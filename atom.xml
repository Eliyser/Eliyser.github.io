<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>never belief any book</title>
  
  <subtitle>love youself,love life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://47.107.237.149/"/>
  <updated>2019-05-03T05:47:10.695Z</updated>
  <id>http://47.107.237.149/</id>
  
  <author>
    <name>Haien</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>array</title>
    <link href="http://47.107.237.149/2019/05/02/%E6%95%B0%E7%BB%84/"/>
    <id>http://47.107.237.149/2019/05/02/数组/</id>
    <published>2019-05-02T10:31:33.753Z</published>
    <updated>2019-05-03T05:47:10.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ul><li><p>int[] a = new int[100];    定义数组</p></li><li><p>a.length；计算数组长度（把这个直接看成数字）</p></li><li>for(int r:a){System.out.println(r);数组遍历</li><li><p>int[] a={2,3,4,5};省长度、省new</p><p>new int[]={2,3,4,5};省长度，省变量名</p></li><li>a=new int[]{6,7,8,9};对a进行重新初始化</li><li><p>new int[0];省变量名，创建长度为0数组；在编写结果为数组的方法时，若碰巧结果为零则可以用上</p><pre><code>int [][]  fun(int[][] a)//数组作为返回结果及形参{对传入的数组a进行操作；return a；//返回数组，实际只是一个引用}//把数组名当作一个指针来看待就好了，指针怎么用数组就怎么用</code></pre></li><li><p>int[] b=a;拷贝数组，a,b只是引用</p></li><li>System.out.println(from,fromIndex,to,toIndex,count);值覆盖</li><li>Array.sort(a);数组排序</li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul><li>double[][] a=new double[2][2];定义二维数组</li><li><p>初始化</p><pre><code>int[][] a={{1,2},{3,4}};省new、省长度</code></pre></li><li><p>遍历</p><pre><code>for(double[] row:a)    for(double b:row){         do something with b;    }</code></pre></li><li><p>for(int n=0;n&lt;=MAX;n++)</p><p>a[n]=new int[n+1];不规则数组</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一维数组&quot;&gt;&lt;a href=&quot;#一维数组&quot; class=&quot;headerlink&quot; title=&quot;一维数组&quot;&gt;&lt;/a&gt;一维数组&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;int[] a = new int[100];    定义数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;a.le
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第五章-编码、加密/</id>
    <published>2019-04-30T08:29:23.108Z</published>
    <updated>2019-04-09T01:58:46.480Z</updated>
    
    <content type="html"><![CDATA[<ul><li>密码存储应加密或生成摘要存储。</li></ul><h3 id="编码、解码"><a href="#编码、解码" class="headerlink" title="编码、解码"></a>编码、解码</h3><ul><li>Shiro提供了base64和16进制对字符串进行编码、解码。其内部的一些数据的存储和表示也都使用了base64和16进制的字符串。</li><li>base64：网络上最常用的用于传输8bit字节码的编码方式之一，可用于在HTTP环境下传递较长的标识信息，起到简单的加密作用。主要是基于64个可打印字符来表示二进制数据，即编码过程是从二进制到字符的过程。</li></ul><pre><code>String str = &quot;hello&quot;;String base64Encoded = Base64.encodeToString(str.getBytes()); //编码：二进制-&gt;字符String str2 = Base64.decodeToString(base64Encoded); //解码Assert.assertEquals(str, str2);</code></pre><ul><li>16进制</li></ul><pre><code>String str = &quot;hello&quot;;String hexEncoded = Hex.encodeToString(str.getBytes()); //编码String str2 = new String(Hex.decode(hexEncoded.getBytes())); //解码Assert.assertEquals(str, str2);</code></pre><ul><li>CodecSupport类：提供toBytes(str,”utf-8”)、toString(bytes,”utf-8”),进行String和byte数组之间的额转换。</li></ul><h3 id="散列算法"><a href="#散列算法" class="headerlink" title="散列算法"></a>散列算法</h3><ul><li>散列算法一般用于生成数据的摘要信息，不可逆。</li><li>常见的有：MD5、SHA等。</li><li>一般进行散列时最好提供一个salt，比如一些只有系统知道的干扰数据，如，用户名和id，这样生成的散列值更难破解。</li><li>因此用户注册和修改密码时，系统应将密码和盐一起保存到数据库。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7565.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code>String str = &quot;hello&quot;;String salt = &quot;123&quot;;String md5 = new Md5Hash(str, salt).toString();//还可以是toBase64()/toHex();String sha1 = new Sha256Hash(str, salt).toString();//还有SHA1、SHA512、SHA256、SHA384...</code></pre><ul><li>还可以指定散列次数</li></ul><pre><code>//散列两次md5(md5(str));//相当于new MD5Hash(str,salt,2).toString();</code></pre><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li>AES算法：下一代加密算法标准，速度快，安全级别高，支持128/192/256/512位秘钥的加密。</li></ul><pre><code>AesCipherService aesCipherService=new AesCipherService();aesCipherService.setKeySize(128); //设置key长度；不影响加密后长度Key key=aesCipherService.generateNewKey(); //生成keyString source=&quot;hello&quot;;String encryptText=aesCipherService.encrypt(source.getBytes(),key.getEncoded())        .toHex(); //加密，参数是两个byte数组String source2=new String(aesCipherService.decrypt(Hex.decode(encryptText),        key.getEncoded()).getBytes()); //解密,参数是两个byte数组</code></pre><ul><li>crypt：C语言加密函数名。</li><li><p>代码实例：shiroHelloWorld/test/AllTest</p></li><li><p>Blowfish算法：布鲁斯·施奈尔发明的区块加密算法。</p></li></ul><pre><code>BlowfishCipherService blowfishCipherService = new BlowfishCipherService();blowfishCipherService.setKeySize(128);//生成keyKey key = blowfishCipherService.generateNewKey();String text = &quot;hello&quot;;//加密String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();//解密String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());Assert.assertEquals(text, text2);</code></pre><ul><li>DefaultBlockCipherService：对称加密通用支持器</li></ul><pre><code>//对称加密，使用Java的JCA（javax.crypto.Cipher）加密API，常见的如 &apos;AES&apos;, &apos;Blowfish&apos;DefaultBlockCipherService cipherService = new DefaultBlockCipherService(&quot;AES&quot;);cipherService.setKeySize(128);//生成keyKey key = cipherService.generateNewKey();String text = &quot;hello&quot;;//加密String encrptText = cipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();//解密String text2 = new String(cipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());Assert.assertEquals(text, text2);</code></pre><h3 id="Shiro的加密接口"><a href="#Shiro的加密接口" class="headerlink" title="Shiro的加密接口"></a>Shiro的加密接口</h3><ul><li>Shiro提供的散列支持</li></ul><pre><code>//内部使用MessageDigestString simpleHash = new SimpleHash(&quot;SHA-1&quot;, str, salt).toString();</code></pre><ul><li>经过加密后变成byte数组，必须toString()/toHex()变换一下比较好看，而存入数据库一般是toHex()。</li><li>为了实现更加完整的加密方案，Shiro提供了HashService，这个也是密码加密最常用的。</li></ul><pre><code>DefaultHashService hashService = new DefaultHashService(); //默认实现//all设置hashService.setHashAlgorithmName(&quot;SHA-512&quot;); //设置算法；默认为SHA-512;被request覆盖hashService.setPrivateSalt(new SimpleByteSource(&quot;123&quot;)); //私盐，散列时自动与用户传入的公盐混合产生一个新盐；默认无hashService.setGeneratePublicSalt(true); //在用户没有传入公盐时是否自动产生公盐；被request覆盖hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator()); //用于生成公盐；SecureRandomNumberGenerator用于生成一个随机数；默认就这个hashService.setHashIterations(1); //散列迭代次数;被request覆盖HashRequest request=new HashRequest.Builder() //all有用配置如下        .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;hello&quot;))        .setSalt(ByteSource.Util.bytes(&quot;123&quot;)).setIterations(2).build();String hex=hashService.computeHash((request)).toHex();</code></pre><ul><li>代码实例：shiroHelloWorld/test/AllTest</li></ul><h3 id="PasswordService、CredentialsMatcher加密和验证密码"><a href="#PasswordService、CredentialsMatcher加密和验证密码" class="headerlink" title="PasswordService、CredentialsMatcher加密和验证密码"></a>PasswordService、CredentialsMatcher加密和验证密码</h3><ul><li>Shiro提供了PasswordService和CredentialsMatcher接口用于加密和验证密码。</li><li>PasswordService默认实现：DefaultPasswordService。</li><li>CredentialsMatcher默认实现：PasswordMatcher、HashedcredentialsMatcher(更强大)。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>自定义Realm</li></ul><pre><code>public class MyRealm4 extends AuthorizingRealm {    public PasswordService passwordService; //等待外部注入    public void setPasswordService(PasswordService passwordService){        this.passwordService=passwordService;    }    /**     * @Author haien     * @Description 被间接父类AuthenticatingRealm调用，获取到AuthenticationInfo后                    调用assertCredentialsMatch(token,info),其中token代表表单信息，                    info代表数据库用户，它使用了credentialsMatcher                    （未指定则使用默认实现类）来验证密码是否匹配，                    否则抛出IncorrectCredentialsException；                    但不验证用户名是否正确     * @Date 2019/2/22     * @Param [token]     * @return org.apache.shiro.authc.AuthenticationInfo     **/    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token)            throws AuthenticationException {        return new SimpleAuthenticationInfo(&quot;wu&quot;,                passwordService.encryptPassword(&quot;123&quot;),getName());    }    /**     * @Author haien     * @Description 不需要授权就直接返回null就好了     * @Date 2019/2/22     * @Param [principalCollection]     * @return org.apache.shiro.authz.AuthorizationInfo     **/    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {        return null;    }}</code></pre><ul><li>如果自定义Realm实现的是Realm接口，而不是继承了AuthenticatingRealm及其以下的类，则用户名和密码验证逻辑都必须在此Realm中实现，否则视返回Info类为验证通过，不再进行验证。</li><li>shiro-passwordservice.ini</li></ul><pre><code>[main]passwordService=org.apache.shiro.authc.credential.DefaultPasswordService //有必要可自定义hashService=org.apache.shiro.crypto.hash.DefaultHashService //定义散列密码使用的HashServicepasswordService.hashService=$hashServicehashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat //对散列出的值格式化，默认使用Shiro1CryptFormat，还有Base64Formath和HexFormat；对于有salt的密码应自定义ParsableHashFormat实现类，然后把salt格式化到散列值中。passwordService.hashFormat=$hashFormathashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory //根据散列值得到散列的密码和saltpasswordService.hashFormatFactory=$hashFormatFactorypasswordMatcher=org.apache.shiro.authc.credential.PasswordMatcher //定义AuthenticatingRealm用到的CredentialsMatcherpasswordMatcher.passwordService=$passwordServicemyRealm=com.haien.shiroHelloWorld.chapter5.realm.MyRealmmyRealm.passwordService=$passwordServicemyRealm.credentialsMatcher=$passwordMatchersecurityManager.realms=$myRealm;</code></pre><ul><li>PasswordTest：测试类</li></ul><pre><code>public class PasswordTest extends BaseTest {    @Test    public void testPasswordServiceWithMyRealm(){        login(&quot;classpath:config/shiro-passwordservice.ini&quot;,                &quot;wu&quot;,&quot;123&quot;);    }}</code></pre><h4 id="使用jdbc的示例"><a href="#使用jdbc的示例" class="headerlink" title="使用jdbc的示例"></a>使用jdbc的示例</h4><ul><li>shiro-jdbc-passwordservice.ini：如果JdbcRealm不指定CredentialsMatcher，则会使用默认实现类SimpleCredentialsMatcher，它不进行加密，只进行明文匹配。</li></ul><pre><code>[main]passwordService=org.apache.shiro.authc.credential.DefaultPasswordServicehashService=org.apache.shiro.crypto.hash.DefaultHashServicepasswordService.hashService=$hashServicehashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormatpasswordService.hashFormat=$hashFormathashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactorypasswordService.hashFormatFactory=$hashFormatFactorypasswordMatcher=org.apache.shiro.authc.credential.PasswordMatcherpasswordMatcher.passwordService=$passwordServicedataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://127.0.0.1:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=truejdbcRealm.credentialsMatcher=$passwordMatcher//不用配置PasswordServicesecurityManager.realms=$jdbcRealm</code></pre><ul><li>PasswordTest:测试类</li></ul><pre><code>public class PasswordTest extends BaseTest {    @Test    public void testPasswordserviceWithJdbcRealm(){        login(&quot;classpath:config/shiro-jdbc-passwordservice.ini&quot;,                &quot;wu&quot;,&quot;123&quot;);    }}</code></pre><h3 id="HashedCredentialsMatcher"><a href="#HashedCredentialsMatcher" class="headerlink" title="HashedCredentialsMatcher"></a>HashedCredentialsMatcher</h3><ul><li>和之前的PasswordMatcher不同，它只用于密码验证，且可以提供自己的盐，而不是随机生成盐，且加密算法可以指定。</li><li>比如使用MD5，“密码+盐（用户名—+随机数”的方式生成散列值。</li></ul><h4 id="自定义Realm示例"><a href="#自定义Realm示例" class="headerlink" title="自定义Realm示例"></a>自定义Realm示例</h4><ul><li>MyRealm2：准备用户</li></ul><pre><code>/** * @Author haien * @Description 用户名+加密后的密码作为盐 * @Date 2019/2/23 **/public class MyRealm2 extends AuthenticatingRealm { //不需要授权，继承AuthenticatingRealm即可    @Override    protected AuthenticationInfo doGetAuthenticationInfo(            AuthenticationToken authenticationToken) throws AuthenticationException {        //用户库        String username=&quot;liu&quot;;        String password=&quot;123&quot;;        //返回后，AuthenticatingRealm只会进行密码比对，不对用户名进行验证，因此用户验证需要在这里实现        if(!username.equals(authenticationToken.getPrincipal())){            throw new UnknownAccountException();        }        //密码加密；则ini配置文件应制定相同的加密方式来对登录用户进行加密后再与realm比对        String algorithmName=&quot;md5&quot;;        String salt2=new SecureRandomNumberGenerator().nextBytes().toHex(); //随机数        int hashIterations=2;        SimpleHash hash=new SimpleHash(algorithmName,password,                username+salt2,hashIterations);        String encodedPassword=hash.toHex(); //加密后的密码        //封装        SimpleAuthenticationInfo ai=                new SimpleAuthenticationInfo(username,encodedPassword,getName());        //HashedCredentialsMatcher会自动识别这个盐，并拿去给登录用户加密        ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); //盐=用户名+随机数        //返回给AuthenticatingRealm后，它调用HashedCredentialsMatcher的方法，        //将login密码加密，并与此身份凭证中的密码比对        return ai;    }}</code></pre><ul><li>shiro-hashedCredentialsMatcher.ini：指定CredentialsMatcher实现类、Realm</li></ul><pre><code>[main];告诉AuthorizingRealm，它获取到的身份凭证是这么来的credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=md5credentialsMatcher.hashIterations=2;加密后的密码是否转为了十六进制，默认是base64credentialsMatcher.storedCredentialsHexEncoded=truemyRealm=com.haien.shiroHelloWorld.chapter5.realm.MyRealm2myRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$myRealm</code></pre><ul><li>测试</li></ul><pre><code>public class PasswordTest extends BaseTest {    @Test    public void testHashedCredentialsMatcherWithMyRealm2() {        login(&quot;classpath:config/shiro-hashedCredentialsMatcher.ini&quot;,                &quot;liu&quot;, &quot;123&quot;);                 //HashedCredentialsMatcher会将密码加密后与Realm提供的用户库进行比对    }}</code></pre><h4 id="JdbcRealm示例"><a href="#JdbcRealm示例" class="headerlink" title="JdbcRealm示例"></a>JdbcRealm示例</h4><ul><li>shiro-jdbc-hashedCredentialsMatcher.ini：Shiro默认不进行Enum类型转换，但saltStyle是枚举类型，因此需要我们自己注册一个Enum转换器对值先进行类型转换再赋给saltStyle。而密码+盐查询语句authenticationQuery原本为：select password, password_salt from users where username = ?，现在我们的盐=username+password_salt，因此要重写sql.</li></ul><pre><code>[main];指定密码加密方式，需要和用户注册、修改密码时使用的加密方式一致credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatchercredentialsMatcher.hashAlgorithmName=md5credentialsMatcher.hashIterations=2credentialsMatcher.storedCredentialsHexEncoded=truedataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://127.0.0.1:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=true;需要被转换为Enum才能赋给saltStyle属性，因此在测试方法中注册了自定义的Enum转换器jdbcRealm.saltStyle=COLUMN;重写sql语句；同时对用户名和密码进行验证jdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ?jdbcRealm.credentialsMatcher=$credentialsMatchersecurityManager.realms=$jdbcRealm</code></pre><ul><li>测试方法</li></ul><pre><code>public class PasswordTest extends BaseTest {    /**     * @Author haien     * @Description 自定义Enum转换器     * @Date 2019/2/23     **/    private class EnumConverter extends AbstractConverter{        @Override        protected String convertToString(final Object value) throws Throwable {            return ((Enum)value).name();        }        @Override        protected Class getDefaultType() {            return null;        }        @Override        protected Object convertToType(final Class type, final Object value)                throws Throwable {            return Enum.valueOf(type,value.toString());        }    }    @Test    public void testHashedCredentialsMatcherWithJdbcRealm(){        //注册自定义的Enum转换器，否则ini文件默认不进行Enum类型转换        BeanUtilsBean.getInstance().getConvertUtils().register(new EnumConverter(),                JdbcRealm.SaltStyle.class);        login(&quot;classpath:config/shiro-jdbc-hashedCredentialsMatcher.ini&quot;,                &quot;liu&quot;, &quot;123&quot;);    }}</code></pre><h3 id="密码重试次数限制"><a href="#密码重试次数限制" class="headerlink" title="密码重试次数限制"></a>密码重试次数限制</h3><ul><li>目的：防止密码被暴力破解。</li><li>方法：继承HashedCredentialsMatcher,且使用Ehcache记录重试次数和超时时间。</li><li>RetryLimitHashedCredentialsMatcher：限制输入次数不超出5次</li></ul><pre><code>/** * @Author haien * @Description 自定义CredentialsMatcher实现类，限制密码重试次数 *              输入正确清除cache中的记录，否则cache中的重试次数+1，如果超出5次那么抛出异常 * @Date 2019/2/24 **/public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher {    //密码重试次数缓存对象集合    private Ehcache passwordRetryCache;    public RetryLimitHashedCredentialsMatcher() {        CacheManager cacheManager=CacheManager.newInstance(                CacheManager.class.getClassLoader().getResource(&quot;ehcache.xml&quot;));        passwordRetryCache=cacheManager.getCache(&quot;passwordRetryCache&quot;);    }    @Override    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {        //获取表单参数        String username=(String)token.getPrincipal();        //获取该用户的缓存对象        Element element=passwordRetryCache.get(username);        //缓存对象不存在说明上一次登录成功或从未登录过        if(element==null){            element=new Element(username,new AtomicInteger(0)); //new一个并置零            passwordRetryCache.put(element);        }        //从缓存对象中获取重试次数        AtomicInteger retryCount=(AtomicInteger)element.getObjectValue();        //第6次起无论输入对错都禁止        if(retryCount.incrementAndGet()&gt;5) //+1            throw new ExcessiveAttemptsException();        boolean matches=super.doCredentialsMatch(token,info);        if(matches)            passwordRetryCache.remove(username);        return matches;    }}</code></pre><ul><li><a href="https://jinnianshilongnian.iteye.com/blog/2021439" target="_blank" rel="noopener">《跟我学Shiro》第五章</a></li><li>代码实例：ideaProjects/shiroHelloWorld/chapter5</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;密码存储应加密或生成摘要存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;编码、解码&quot;&gt;&lt;a href=&quot;#编码、解码&quot; class=&quot;headerlink&quot; title=&quot;编码、解码&quot;&gt;&lt;/a&gt;编码、解码&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shiro提供了base64和1
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%9B%9B%E7%AB%A0-ini%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第四章-ini配置解析/</id>
    <published>2019-04-30T08:29:23.095Z</published>
    <updated>2019-02-22T04:02:30.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="根对象securityManager"><a href="#根对象securityManager" class="headerlink" title="根对象securityManager"></a>根对象securityManager</h3><ul><li>Shiro是从根对象SecurityManager进行身份验证和授权的，所有操作都是自它开始。这个对象是线程安全的且整个应用只需要一个即可。因此shiro提供了SecurityUtils让我们绑定它为全局的。</li></ul><h3 id="Java-Configuration"><a href="#Java-Configuration" class="headerlink" title="Java Configuration"></a>Java Configuration</h3><ul><li><p>用Java代码代替ini配置</p><pre><code>public class NonConfigurationCreateTest {    @Test    public void test(){        DefaultSecurityManager securityManager=new DefaultSecurityManager();        //设置authenticator        ModularRealmAuthenticator authenticator=new ModularRealmAuthenticator();        authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());        securityManager.setAuthenticator(authenticator);        //设置authorizer        ModularRealmAuthorizer authorizer=new ModularRealmAuthorizer();        authorizer.setPermissionResolver(new WildcardPermissionResolver());        securityManager.setAuthorizer(authorizer);        //设置Realm        DruidDataSource ds=new DruidDataSource();        ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        ds.setUrl(&quot;jdbc:mysql://localhosr:3306/shiro&quot;);        ds.setUsername(&quot;root&quot;);        ds.setPassword(&quot;123456&quot;);        JdbcRealm jdbcRealm=new JdbcRealm();        jdbcRealm.setDataSource(ds);        jdbcRealm.setPermissionsLookupEnabled(true);        securityManager.setRealms(Arrays.asList((Realm)jdbcRealm));        //SecurityManager设置到SecurityUtils，方便全局使用        SecurityUtils.setSecurityManager(securityManager);        //测试        Subject subject=SecurityUtils.getSubject();        UsernamePasswordToken token=new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;);        subject.login(token);        Assert.assertTrue(subject.isAuthenticated());    }}</code></pre></li></ul><h3 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><ul><li><p>ini配置下，securityManager的获取如下</p><pre><code>Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =   new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;); SecurityManager securityManager = factory.getInstance();</code></pre></li><li>IniSecurityManagerFactory是创建securityManager的工厂，它需要一个ini配置文件路径，支持“classpath:”（类路径）、“file:”（文件系统）、“url:”（网络）三种路径格式，默认是文件系统。</li><li>默认创建DefaultSecurityManager类型的securityManager，如果想自定义，需要在ini配置文件中指定securityManager=SecurityManager实现类；名字必须为securityManager。</li><li><p>ini配置文件其中几部分</p><pre><code>[main]#提供了对根对象securityManager及其依赖的配置securityManager=org.apache.shiro.mgt.DefaultSecurityManager…………securityManager.realms=$jdbcRealm[urls]#用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器/index.html = anon/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</code></pre></li><li><p>Array/Set/List注入</p><pre><code>//多个之间用,分开即可authenticator.array=1,2,3 authenticator.set=$jdbcRealm,$jdbcRealm&amp;nbsp;</code></pre></li><li><p>Map键值对注入</p><pre><code>authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc //常量都看作字符串，如，1，abc</code></pre></li><li><p>[users]部分</p><pre><code>[users]  #提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2  username=password,role1,role2</code></pre></li><li>其中，密码一般生成其摘要或加密存储。</li><li>[roles]部分：如果只有角色没有对应的权限，可以不配[roles]</li></ul><ul><li>重复注入则后面的覆盖前面的。</li><li>代码实例：ideaProjects/shiroHelloWorld/chapter4</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2020820" target="_blank" rel="noopener">《跟我学Shiro第四章》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;根对象securityManager&quot;&gt;&lt;a href=&quot;#根对象securityManager&quot; class=&quot;headerlink&quot; title=&quot;根对象securityManager&quot;&gt;&lt;/a&gt;根对象securityManager&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E7%AB%A0-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十章-会话管理/</id>
    <published>2019-04-30T08:29:23.092Z</published>
    <updated>2019-03-09T06:48:29.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li>即用户访问应用时保持的连接关系，在多次交互中应用能识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后可以记住用户，且在退出之前都可以识别当前用户是谁。</li><li>获取会话：登陆成功后即可获取会话。</li></ul><pre><code>login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;); //登录成功相当于创建了会话Subject subject = SecurityUtils.getSubject();Session session = subject.getSession();//等价于subject.getSession(true) //没有Session对象会创建一个，若传入false则无Session将返回null</code></pre><ul><li><p>若启用会话存储功能则在创建Subject时会主动创建一个Session。</p></li><li><p>获取属性：</p></li></ul><pre><code>//获取当前会话的唯一标识session.getId();//获取主机地址session.getHost();//获取、设置当前Session的过期时间，默认是会话管理器的全局过期时间session.getTimeout();session.setTimeout();//获取会话的启动时间及最后访问时间；javaSE应用需要自己定期调用session.touch()更新最后访问时间//web应用每次进入ShiroFilter都会自动调用它来更新。session.getStartTimestamp();session.getLastAccessTime();//更新会话最后访问时间及销毁会话；Subject.logout()时会自动调用stop()。//在web中调用javax.servlet.http.HttpSession. invalidate()也会自动调用它来销毁Session会话。session.touch();session.stop();//操作会话属性session.setAttribute(&quot;key&quot;,&quot;123&quot;);session.getattribute(&quot;key&quot;);session.removeAttribute(&quot;key&quot;);</code></pre><h3 id="会话管理器"><a href="#会话管理器" class="headerlink" title="会话管理器"></a>会话管理器</h3><ul><li>管理着应用中所有Subject的会话的创建、维护、删除、失效和验证等工作，是Shiro的核心组件。</li><li>SecurityManager都继承了会话管理器SessionSecurityManager。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/eb4cde34-53c1-3c46-abd5-0eda9de6400d.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>SecurityManager：提供了如下接口：</li></ul><pre><code>Session start(SessionContext context); //启动会话Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话</code></pre><ul><li>WebSessionManager：专用于web应用，又提供了如下接口：</li></ul><pre><code>boolean isServletContainerSessions();//是否使用Servlet容器的会话</code></pre><ul><li>ValidatingSessionManager：用于验证会话是否过期：</li></ul><pre><code>void validateSessions(); //所有会话是否过期</code></pre><ul><li>三个内置实现类<ul><li>DefaultSessionManager：DefaultSecurityManager使用，用于javaSE环境。</li><li>ServletContainerSessionManager：DefaultWebSecurityManager使用，用于web环境，直接使用Servlet容器的会话。</li><li>DefaultWebSessionManager：同上，不过是由自己维护着会话，不用Servlet容器的会话管理。</li></ul></li><li>替换SecurityManager默认的SessionManager可以在ini中配置：</li></ul><pre><code>[main]sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager;web环境下应换为sessionManager=org.apache.shiro.web.session.mgt.ServletContainerSessionManagersecurityManager.sessionManager=$sessionManager</code></pre><ul><li>设置会话的全局过期时间（单位：ms），默认30分钟。将应用给所有Session，不过可以单独设置每个session的timeout属性。</li></ul><pre><code>sessionManager. globalSessionTimeout=1800000</code></pre><ul><li><p>如果使用ServletContainerSessionManager进行会话管理Session的超时依赖于底层Servlet容器的超时时间，可以在web.xml中设置（单位：min）：</p><pre><code>&lt;session-config&gt;  &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt;</code></pre></li><li><p>使用DefaultWebSessionManager维护会话：</p></li></ul><pre><code>//sessionIdCookie：创建会话cookie的模板sessionIdCookie=org.apache.shiro.web.servlet.SimpleCookiesessionManager=org.apache.shiro.web.session.mgt.DefaultWebSessionManager//设置cookie名，默认为JSESSIONIDsessionIdCookie.name=sid//设置cookie域名，默认空，即当前访问的域名#sessionIdCookie.domain=sishuok.com//设置cookie路径，默认空，即存储在域名根下#sessionIdCookie.path=//设置cookie过期时间，单位秒，默认-1，即关闭浏览器时过期sessionIdCookie.maxAge=1800//true表示客户端不会暴露脚本代码，有助于减少某些类型的跨站点脚本攻击，Servlet2.5及以上才支持sessionIdCookie.httpOnly=truesessionManager.sessionIdCookie=$sessionIdCookie是否启用Session Id Cookie，默认启用；禁用将不会设置Session Id Cookie，即默认使用JSESSIONIDsessionManager.sessionIdCookieEnabled=truesecurityManager.sessionManager=$sessionManager</code></pre><ul><li>配置了会话之后，第一次访问项目（任何页面）报错：There is no session with id […]，没事，这是shiro自己的一个bug，无伤大雅。</li></ul><h3 id="会话监听器"><a href="#会话监听器" class="headerlink" title="会话监听器"></a>会话监听器</h3><ul><li>用于监听会话创建、过期及停止事件。</li></ul><pre><code>public class MySessionListener1 implements SessionListener {    @Override    public void onStart(Session session) {//会话创建时触发        System.out.println(&quot;会话创建：&quot; + session.getId());    }    @Override    public void onExpiration(Session session) {//会话过期时触发        System.out.println(&quot;会话过期：&quot; + session.getId());    }    @Override    public void onStop(Session session) {//退出/会话过期时触发        System.out.println(&quot;会话停止：&quot; + session.getId());    }  }</code></pre><ul><li>如果只想监听某一事件，可以继承SessionListenerAdapter实现类。</li></ul><pre><code>public class MySessionListener2 extends SessionListenerAdapter {    @Override    public void onStart(Session session) {        System.out.println(&quot;会话创建：&quot; + session.getId());    }}</code></pre><ul><li>ini配置监听器</li></ul><pre><code>sessionListener1=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener1sessionListener2=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener2sessionManager.sessionListeners=$sessionListener1,$sessionListener2</code></pre><h3 id="会话持久化"><a href="#会话持久化" class="headerlink" title="会话持久化"></a>会话持久化</h3><ul><li>SessionDAO接口：用于会话的CRUD，可以把会话保存到数据库。提供如下基本接口：</li></ul><pre><code>//如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统///NoSQL数据库；即可以实现会话的持久化；返回会话ID，返回的ID.equals(session.getId())；Serializable create(Session session);//根据会话ID获取会话Session readSession(Serializable sessionId) throws UnknownSessionException;//更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用void update(Session session) throws UnknownSessionException;//删除会话；当会话过期/会话停止（如用户退出时）会调用void delete(Session session);//获取当前所有活跃用户，如果用户量多此方法影响性能Collection&lt;Session&gt; getActiveSessions();</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/6dac0cd6-f6ca-3e2d-b3ba-f8c7104e1b2a.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>AbstractSessionDAO: 提供了SessionDAO的基础实现，如生成会话id等。</li><li>CacheSessionDAO：提供了对开发者透明的会话缓存的功能，如查询会话时先到缓存看有没有，没有再查数据库。只需设置相应的CacheManager即可。自定义SessionDAO继承这个即可。</li><li>MemorySessionDAO：直接在内存中进行会话维护。</li><li><p>EnterpriseCacheSessionDAO：Enterprise，事业；提供了缓存功能的会话维护，默认使用MapCache，内部使用ConcurrentHashMap保存缓存的会话，ConCurrent，同时发生的，同时存在的。</p></li><li><p>ini配置SessionDAO</p></li></ul><pre><code>sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAOsessionManager.sessionDAO=$sessionDAO</code></pre><ul><li><p>Shiro使用Ehcache存储会话，可以配合TerraCotta实现容器无关的分布式集群，依赖如下：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>shiro-web.ini</p></li></ul><pre><code>sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO//CachingSessionDAO设置Session缓存名字，默认为此sessionDAO.activeSessionsCacheName=shiro-activeSessionCachesessionManager.sessionDAO=$sessionDAO//cacheManager：缓存管理器，次数使用Ehcache实现cacheManager = org.apache.shiro.cache.ehcache.EhCacheManager//指定Ehcache缓存的配置文件cacheManager.cacheManagerConfigFile=classpath:ehcache.xmlsecurityManager.cacheManager = $cacheManager</code></pre><ul><li><p>ehcache.xml</p><pre><code>&lt;cache name=&quot;shiro-activeSessionCache&quot; //名字与sessionDAO的activeSessionsCacheName属性一致   maxEntriesLocalHeap=&quot;10000&quot;   overflowToDisk=&quot;false&quot;   eternal=&quot;false&quot;   diskPersistent=&quot;false&quot;   timeToLiveSeconds=&quot;0&quot;   timeToIdleSeconds=&quot;0&quot;   statistics=&quot;true&quot;/&gt;</code></pre></li><li><p>另外可以在ini中配置会话id生成器</p></li></ul><pre><code>//默认为此，底层使用UUID生成。sessionIdGenerator=org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGeneratorsessionDAO.sessionIdGenerator=$sessionIdGenerator</code></pre><h3 id="自定义SessionDAO"><a href="#自定义SessionDAO" class="headerlink" title="自定义SessionDAO"></a>自定义SessionDAO</h3><pre><code>public class MySessionDAO extends CachingSessionDAO { //带缓存的SessionDAO，会先从缓存找    private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate();    //保存会话    protected Serializable doCreate(Session session) {        Serializable sessionId = generateSessionId(session);        assignSessionId(session, sessionId);        String sql = &quot;insert into sessions(id, session) values(?,?)&quot;;        //把会话序列化后存储到数据库        jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session));        return session.getId();    }    //更新会话    protected void doUpdate(Session session) {        if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) {            return; //如果会话过期/停止 没必要再更新了        }        String sql = &quot;update sessions set session=? where id=?&quot;;        jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId());    }    //删除会话    protected void doDelete(Session session) {        String sql = &quot;delete from sessions where id=?&quot;;        jdbcTemplate.update(sql, session.getId());    }    //查询会话    protected Session doReadSession(Serializable sessionId) {        String sql = &quot;select session from sessions where id=?&quot;;        List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class,            sessionId);        if(sessionStrList.size() == 0) return null;        return SerializableUtils.deserialize(sessionStrList.get(0));    }}</code></pre><ul><li>接着在shiro-web.ini中配置这个自定义的会话持久化</li></ul><pre><code>sessionDAO=com.github.zhangkaitao.shiro.chapter10.session.dao.MySessionDAO</code></pre><h3 id="会话验证"><a href="#会话验证" class="headerlink" title="会话验证"></a>会话验证</h3><ul><li>SessionValidationScheduler：会话验证调度器，用于定期地验证会话是否已过期，是将停止会话。出于性能考虑，一般都是获取会话时来验证会话是否过期并停止会话的，但是在web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期检测。</li></ul><pre><code>//默认sessionValidationScheduler=org.apache.shiro.session.mgt                                .ExecutorServiceSessionValidationScheduler//调度时间间隔，单位ms，默认1小时sessionValidationScheduler.interval = 3600000//设置进行会话验证时的会话管理器sessionValidationScheduler.sessionManager=$sessionManager//设置全局会话超时时间，默认30min，30min内没有访问会话将过期sessionManager.globalSessionTimeout=1800000//是否开启会话验证器，默认开启sessionManager.sessionValidationSchedulerEnabled=truesessionManager.sessionValidationScheduler=$sessionValidationScheduler</code></pre><h4 id="Quartz会话验证调度器"><a href="#Quartz会话验证调度器" class="headerlink" title="Quartz会话验证调度器"></a>Quartz会话验证调度器</h4><ul><li><p>依赖</p><pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;     &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;     &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!--使用quartz要用到的--&gt;    &lt;groupId&gt;commons-collections&lt;/groupId&gt;    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;    &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>ini配置</p></li></ul><pre><code>sessionValidationScheduler=org.apache.shiro.session.mgt.quartz                                .QuartzSessionValidationSchedulersessionValidationScheduler.sessionValidationInterval = 3600000sessionValidationScheduler.sessionManager=$sessionManager</code></pre><h4 id="分页获取会话并验证"><a href="#分页获取会话并验证" class="headerlink" title="分页获取会话并验证"></a>分页获取会话并验证</h4><ul><li>会话验证调度器实际都是调用AbstractValidatingSessionManager的validateSessions()进行验证，该方法调用SessionDAO的getActiveSessions()获取all会话进行验证，会话较多时会影响性能，可以考虑分页获取会话并进行验证。</li><li>自定义分页获取会话并验证的会话验证调度器，核心代码：</li></ul><pre><code>//分页获取会话String sql = &quot;select session from sessions limit ?,?&quot;;int start = 0; //起始记录int size = 20; //每页大小List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);while(sessionList.size() &gt; 0) {    for(String sessionStr : sessionList) {        try {            Session session = SerializableUtils.deserialize(sessionStr); //反序列化回session对象            //获取验证方法            Method validateMethod =                 ReflectionUtils.findMethod(AbstractValidatingSessionManager.class,                     &quot;validate&quot;, Session.class, SessionKey.class);             validateMethod.setAccessible(true);            //调用验证方法            ReflectionUtils.invokeMethod(validateMethod,                 sessionManager, session, new DefaultSessionKey(session.getId()));        } catch (Exception e) {            //ignore        }    }    start = start + size;    sessionList = jdbcTemplate.queryForList(sql, String.class, start, size);}</code></pre><ul><li><p>ini配置和之前类似。</p></li><li><p>如果在会话过期时不想删除，可以通过如下配置：</p></li></ul><pre><code>//默认开启，在会话过期后会调用SessionDAO的delete()删除会话sessionManager.deleteInvalidSessions=false</code></pre><ul><li><p>若在获取会话时验证了会话已过期，将抛出InvalidSessionException，需要捕获该异常并跳转相应页面提示会话已过期，让用户重新登录。可以在web.xml配置错误页面</p><pre><code>&lt;error-page&gt;    &lt;exception-type&gt;org.apache.shiro.session.InvalidSessionException&lt;/exception-type&gt;    &lt;location&gt;/invalidSession.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre></li></ul><h3 id="SessionFactory"><a href="#SessionFactory" class="headerlink" title="SessionFactory"></a>SessionFactory</h3><ul><li>创建会话的工厂。默认用SimpleSessionFactory来创建SimpleSession会话。</li><li>首先自定义一个Session：保存用户的状态。</li></ul><pre><code>public class OnlineSession extends SimpleSession {    public static enum OnlineStatus {        //创建实例，调用构造器（要求传入字符串，则不能不传）        on_line(&quot;在线&quot;), hidden(&quot;隐身&quot;), force_logout(&quot;强制退出&quot;);        private final String info;        private OnlineStatus(String info) {            this.info = info;        }        public String getInfo() {            return info;        }    }    private String userAgent; //用户浏览器类型    private OnlineStatus status = OnlineStatus.on_line; //在线状态    private String systemHost; //用户登录时系统IP    //省略其他}</code></pre><ul><li>接着自定义SessionFactory</li></ul><pre><code>public class OnlineSessionFactory implements SessionFactory {    /**     * 根据会话上下文创建OnlineSession，保存用户信息进去     */    @Override    public Session createSession(SessionContext initData) {        OnlineSession session = new OnlineSession();        if (initData != null &amp;&amp; initData instanceof WebSessionContext) {            WebSessionContext sessionContext = (WebSessionContext) initData;            HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest();            if (request != null) {                session.setHost(IpUtils.getIpAddr(request));                session.setUserAgent(request.getHeader(&quot;User-Agent&quot;));                session.setSystemHost(request.getLocalAddr() + &quot;:&quot; + request.getLocalPort());            }        }        return session;    }}</code></pre><ul><li>最后在shiro-web.ini配置自定义的SessionFactory</li></ul><pre><code>sessionFactory=org.apache.shiro.session.mgt.OnlineSessionFactorysessionManager.sessionFactory=$sessionFactory</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;会话&quot;&gt;&lt;a href=&quot;#会话&quot; class=&quot;headerlink&quot; title=&quot;会话&quot;&gt;&lt;/a&gt;会话&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;即用户访问应用时保持的连接关系，在多次交互中应用能识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-cache%E7%BC%93%E5%AD%98/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十一章-cache缓存/</id>
    <published>2019-04-30T08:29:23.078Z</published>
    <updated>2019-04-05T02:58:49.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>Shiro提供了类似于Spring的Cache抽象，即它本身不实现cache，但是对cache进行了抽象，方便更换底层cache实现（如，Ehcache,Hazelcast,OSCache,Terracotta,Coherence,GigaSpaces,JBossCache）。</li><li>Cache接口：</li></ul><pre><code>public interface Cache&lt;K, V&gt; {    //根据Key获取缓存中的值    public V get(K key) throws CacheException;    //往缓存中放入key-value，返回缓存中之前的值    public V put(K key, V value) throws CacheException;     //移除缓存中key对应的值，返回该值    public V remove(K key) throws CacheException;    //清空整个缓存    public void clear() throws CacheException;    //返回缓存大小    public int size();    //获取缓存中所有的key    public Set&lt;K&gt; keys();    //获取缓存中所有的value    public Collection&lt;V&gt; values();}</code></pre><ul><li>CacheManager接口：从接口方法来看就是用来获取cache的。</li></ul><pre><code>public interface CacheManager {    //根据缓存名字获取一个Cache实例，不存在则新建一个    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException;}</code></pre><p><img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/722072-20171215174146058-659069124.jpg" alt=""></p><ul><li><p>从上面来看，我们定义缓存要做两件事，一是实现Cache接口（shiro-ehcache.xml），二是实现CacheManager接口（shiro.ini中注册EhCacheManager的bean）。</p></li><li><p>Shiro数据的缓存方式分为两类，一是将数据存储到本地，一是存储到集中式存储中间件，如，redis或Memcached。若使用后者，当页面使用了大量shiro标签时（如，&lt;shiro:hasPermission name=”admin”&gt;），每个标签都会发起一个查询请求，那么访问一个页面将会向缓存发送大量网络请求，这回给集中缓存组件带来一定的瞬时请求压力，而且，网络查询的效率并不高。采用本地缓存则不存在这些问题。所以，如果在项目中使用了大量shiro标签，那还是采用本次缓存更合适。</p></li><li>MemoryConstraintCacheManager: 本地缓存。</li><li><p>EhCacheManager：集中式缓存。</p></li><li><p>CacheManagerAware：用于注入CacheManager</p></li></ul><pre><code>public interface CacheManagerAware {    //注入CacheManager    void setCacheManager(CacheManager cacheManager);}</code></pre><ul><li>Shiro内部的组件DefaultSecurityManager会自动检测相应的对象（如Realm）是否实现了CacheManagerAware，并自动注入相应的CacheManager。</li></ul><h3 id="Realm缓存"><a href="#Realm缓存" class="headerlink" title="Realm缓存"></a>Realm缓存</h3><ul><li>即权限数据的缓存（其实还有用户身份AuthenticationInfo的缓存，不过用的比较少，暂且忽略），需要设置一个CacheManager来管理缓存，设置方式有两种。</li></ul><ol><li>设置在SecurityManager中，最终也会设置给CachingRealm，其实真正使用CacheManager的组件也就realm和SessionDAO。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/722072-20171215174215261-1270582200.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>其中CachingSecurityManager有CacheManager属性，会把它设置给CachingRealm。</li></ul><ol start="2"><li>推荐：直接设置给CachingRealm。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/722072-20171215174236824-980527750.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/722072-20171215174251371-575269375.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code>&lt;bean id=&quot;myRealm&quot; class=&quot;org.chench.test.shiro.spring.dao.ShiroCacheJdbcRealm&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;permissionsLookupEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.MemoryConstrainedCacheManager&quot; /&gt;</code></pre><ul><li>Shiro提供了几个Realm，它们实现了CacheManagerAware接口，能够实现缓存的一些基础功能。</li><li>CachingRealm: 最基础的实现，实现了CacheManagerAware接口，提供了缓存的一些基础实现。</li><li>AuthenticatingRealm、AuthorizingRealm：分别提供了对AuthenticationInfo和AuthorizationInfo的缓存。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>测试用例：仿ideaProjects/shiroHelloWorld/chapter6</li><li>在UserRealm中添加了6个方法用于清除缓存：</li></ul><pre><code>//重写以下方法并改为public，否则测试无法调用这些Protected的方法@Overridepublic void clearCachedAuthenticationInfo(PrincipalCollection principals) {    super.clearCachedAuthenticationInfo(principals);}@Overridepublic void clearCachedAuthorizationInfo(PrincipalCollection principals) {    super.clearCachedAuthorizationInfo(principals);}@Overridepublic void clearCache(PrincipalCollection principals) {    //同时调用以上俩方法，清空两个Info    super.clearCache(principals); }public void clearAllCachedAuthorizationInfo(){    getAuthorizationCache().clear();}public void clearAllCachedAuthenticationInfo() {    getAuthenticationCache().clear();}public void clearAllCache() {    clearAllCachedAuthenticationInfo();    clearAllCachedAuthorizationInfo();}</code></pre><ul><li>shiro.ini</li></ul><pre><code>userRealm=com.github.zhangkaitao.shiro.chapter11.realm.UserRealm//启用缓存，默认false，看源码默认好像是true。userRealm.cachingEnabled=true//启用身份验证缓存，缓存AuthenticationInfo，默认falseuserRealm.authenticationCachingEnabled=true//缓存AuthenticationInfo的缓存名称userRealm.authenticationCacheName=authenticationCache//启用授权缓存，默认trueuserRealm.authorizationCachingEnabled=trueuserRealm.authorizationCacheName=authorizationCachesecurityManager.realms=$userRealm//缓存管理器，此处使用EhCacheManager，即Ehcache实现，需要导入Ehcache的依赖cacheManager=org.apache.shiro.cache.ehcache.EhCacheManagercacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xmlsecurityManager.cacheManager=$cacheManager</code></pre><ul><li><p>这篇<a href="https://www.cnblogs.com/NeverCtrl-C/p/7998992.html" target="_blank" rel="noopener">参考文章</a>又说只要设置了CacheManager就会自动开启缓存，实际测试好像也是这样。</p></li><li><p>Ehcache依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>引入这个就不需要之前的ehcache-core依赖了。</p></li><li><p>ehcache.xml:配置Ehcache缓存，可以将数据存储到磁盘或内存中。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache name = &quot;shirocache&quot;&gt;    &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; //数据缓存地址，如，F:/develop/ehcache    &lt;cache name=&quot;authorizationCache&quot; //缓存名称        maxEntriesLocalHeap=&quot;2000&quot; //缓存最大条目数        eternal=&quot;false&quot; //对象是否永久有效，true则timeout失效        timeToIdleSeconds=&quot;3600&quot; //对象在失效前的闲置时间（单位：s），                                 //仅eternal=false时有效；默认为0，即可闲置时间无穷大。        timeToLiveSeconds=&quot;0&quot; //缓存数据的生成时间（单位：s），                              //介于创建时间和失效时间之间；仅eternal=false有效；                              //默认为0，即对象存活时间无穷大。        overflowToDisk=&quot;false&quot; //内存中对象数量达到maxElementInMemory时，                               //是否将对象写到磁盘        statistics=&quot;true&quot;&gt;    &lt;/cache&gt;    &lt;cache name=&quot;authenticationCache&quot;        maxEntriesLocalHeap=&quot;2000&quot;        eternal=&quot;false&quot;        timeToIdleSeconds=&quot;3600&quot;        timeToLiveSeconds=&quot;0&quot;        overflowToDisk=&quot;false&quot;        statistics=&quot;true&quot;&gt;    &lt;/cache&gt;    &lt;cache name=&quot;shiro-activeSessionCache&quot;         maxEntriesLocalHeap=&quot;2000&quot;         eternal=&quot;false&quot;         timeToIdleSeconds=&quot;3600&quot;         timeToLiveSeconds=&quot;0&quot;         overflowToDisk=&quot;false&quot;         statistics=&quot;true&quot;&gt;    &lt;/cache&gt;&lt;/ehcache&gt;</code></pre></li><li><p>cache标签其他属性：</p><ul><li>diskSpoolBufferSizeMB：设置diskStore磁盘缓存的缓存区大小，默认30MB。每个Cache都应该有自己的一个缓存区。</li><li>maxElementOnDisk：磁盘最大缓存个数。</li><li>diskPersistent：是否缓存虚拟机重启期数据，默认false。</li><li>diskExpiryThreadIntervalSeconds: 磁盘失效线程运行时间间隔，默认120s。</li><li>memoryStoreEvictionPolicy:达到maxElementInMemory时，Ehcache将会根据此策略去清理内存，默认策略是LRU（最近最少使用），可设为FIFO（先进先出）或LFU（较少使用）。</li><li>clearOnFlush: 内存数量最大时是否清除。</li></ul></li><li><p>因为测试用例的关系，需要将Ehcache的CacheManager改为使用VM单例模式(不过本例好像没有在哪里修改)</p></li></ul><pre><code>this.manager = new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream());//改为this.manager = net.sf.ehcache.CacheManager.create(getCacheManagerConfigFileInputStream());</code></pre><ul><li>测试：首先登陆成功，此时会缓存相应的AuthenticationInfo；然后修改密码，此时AuthenticationInfo过期；接着需要调用realm的clearCacheAuthenticationInfo()清空之前的AuthenticationInfo，否则下次登录时还会获取那个修改密码前的AuthenticationInfo。</li></ul><pre><code>@Testpublic void testClearCachedAuthenticationInfo() {    //1、登陆成功即缓存AuthenticationInfo    login(u1.getUsername(), password);    //2、修改了密码则之前保存的AuthenticationInfo变旧    userService.changePassword(u1.getId(), password + &quot;1&quot;);    //3、清除之前缓存的AuthenticationInfo，否则下次登录时还会获取到旧的    //AuthenticationInfo    RealmSecurityManager securityManager =        (RealmSecurityManager) SecurityUtils.getSecurityManager();    //获取Realm    UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next();    userRealm.clearCachedAuthenticationInfo(subject().getPrincipals());    //4、再次登录，检测到AuthenticationInfo已清空，故重新缓存    login(u1.getUsername(), password + &quot;1&quot;);}</code></pre><ul><li>无论用户是否正常退出，缓存都将自动清空。</li><li>如果修改了用户的权限，而用户不退出系统，则修改的权限无法立即生效。需要用户在修改后手动调用clearXxx()清除缓存。</li></ul><h3 id="验证中缓存的使用"><a href="#验证中缓存的使用" class="headerlink" title="验证中缓存的使用"></a>验证中缓存的使用</h3><ul><li>以上测试中，登录后即缓存AuthenticationInfo，实际是AuthenticationRealm类中的getAuthenticationInfo()起作用，首先判断缓存中是否已有该记录，否则调用子类Realm的doGetAuthenticationInfo()查询数据库，并将结果缓存起来，下次就不用查询数据库了。核心代码：</li></ul><pre><code>public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)        throws AuthenticationException {    //首先从缓存中获取记录    AuthenticationInfo info = getCachedAuthenticationInfo(token);    //若缓存中无此数据    if (info == null) {        //则从数据库查找        info = doGetAuthenticationInfo(token);        if (token != null &amp;&amp; info != null) {            //将记录缓存起来            cacheAuthenticationInfoIfPossible(token, info);        }    } else {        //debug级日志记录    }    if (info != null) {        //匹配密码        assertCredentialsMatch(token, info);    } else {        //debug级日志记录    }    return info;} </code></pre><h3 id="授权中缓存的使用"><a href="#授权中缓存的使用" class="headerlink" title="授权中缓存的使用"></a>授权中缓存的使用</h3><ul><li>而AuthorizationInfo的缓存则是AuthorizingRealm中的getAuthorizationInfo()在实现，也是先找缓存，没有再调用doGetAuthorizationInfo()去数据库找。</li></ul><pre><code>protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) {    //如果登录成功的用户身份信息集合为空，则直接返回null    if (principals == null) {        return null;    }    AuthorizationInfo info = null;    Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();    if (cache != null) {        Object key = getAuthorizationCacheKey(principals); //这个集合只有一个key        info = cache.get(key);    }    //如果缓存中找不到AuthorizationInfo    if (info == null) {        //从数据库找        info = doGetAuthorizationInfo(principals);        //并存入缓存        if (info != null &amp;&amp; cache != null) {            Object key = getAuthorizationCacheKey(principals);            cache.put(key, info);        }    }    return info;} </code></pre><ul><li>如果需要实现自己的缓存，可以考虑自己<a href="https://github.com/zhangkaitao/es/tree/master/web/src/main/java/com/sishuok/es/extra/aop" target="_blank" rel="noopener">通过aop机制实现而废弃Shiro的缓存</a></li><li>如果要和Spring集成可以考虑使用<a href="https://github.com/zhangkaitao/es/blob/master/web/src/main/java/org/apache/shiro/cache/spring/SpringCacheManagerWrapper.java" target="_blank" rel="noopener">SpringCacheManagerWrapper</a>,它对Spring Cache进行了包装，转换为Shiro的CacheManager实现类</li></ul><h3 id="Session缓存"><a href="#Session缓存" class="headerlink" title="Session缓存"></a>Session缓存</h3><ul><li>为了使会话能够用上缓存（比如查询会话时先看看缓存中是否有，没有再倒数据库查询），可以先设置SecurityManager的CacheManager属性，再设置SecurityManager的SessionManager属性，那么会自动把配置的CacheManager注入到SessionManager中。</li></ul><pre><code>//设置CacheManagersecurityManager.cacheManager=$cacheManager//设置SessionManagersessionManager=org.apache.shiro.session.mgt.DefaultSessionManagersecurityManager.sessionManager=$sessionManager</code></pre><ul><li>若SecurityManager实现了SessionsSecurityManager接口，则会自动判断SessionManager是否实现了CacheManagerAware接口，是则将CacheManager注入给它。然后SessionManager会判断SessionDAO是否实现了CacheManagerAware接口（如继承自CachingSessionDAO），是则会把CacheManager注入给它。</li><li>对于CachingSessionDAO,可以设置缓存的名称：</li></ul><pre><code>sessionDAO=com.github.zhangkaitao.shiro.chapter11.session.dao.MySessionDAO//默认为此sessionDAO.activeSessionsCacheName=shiro-activeSessionCache</code></pre><ul><li><a href="https://jinnianshilongnian.iteye.com/blog/2029217" target="_blank" rel="noopener">《跟我学Shiro》第十一章</a></li><li><a href="https://www.cnblogs.com/nuccch/p/8044226.html" target="_blank" rel="noopener">参考文章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shiro提供了类似于Spring的Cache抽象，即它本身不实现cache，但是对cache进行了抽象，方便更换底层cache
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十五章-单点登录/</id>
    <published>2019-04-30T08:29:23.074Z</published>
    <updated>2019-03-17T04:29:57.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Shiro 1.2开始支持Jasig CAS单点登录。</li><li>作用：用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无需多次登录。</li></ul><h3 id="服务器下载"><a href="#服务器下载" class="headerlink" title="服务器下载"></a>服务器下载</h3><ul><li>Jasig CAS分为服务器端和客户端，服务器提供用户验证。访问需要登录的页面，自动跳转单点登录服务器：<a href="https://localhost:8443/server/login?service=原url，单点登录采用的是https。" target="_blank" rel="noopener">https://localhost:8443/server/login?service=原url，单点登录采用的是https。</a></li><li>war包下载地址：<a href="http://central.maven.org/maven2/org/jasig/cas/cas-server-webapp/4.0.3、http://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp/4.0.3。" target="_blank" rel="noopener">http://central.maven.org/maven2/org/jasig/cas/cas-server-webapp/4.0.3、http://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp/4.0.3。</a></li><li>我们使用cas 4.0.0版本的服务器，除了以上地址还可以到<a href="https://www.apereo.org/cas/download选择版本下载zip自己构建war包（没试过），也可以到网盘https://pan.baidu.com/s/1snr4Tzv，密码：z45j，下载cas-server-4.0.0-release.rar（已下载到E和网盘/五年高考三年模拟）。" target="_blank" rel="noopener">https://www.apereo.org/cas/download选择版本下载zip自己构建war包（没试过），也可以到网盘https://pan.baidu.com/s/1snr4Tzv，密码：z45j，下载cas-server-4.0.0-release.rar（已下载到E和网盘/五年高考三年模拟）。</a></li><li>解压（网盘版解压外层压缩包后依然有两个压缩包，再接着把俩一起解压了），找到cas-server-4.0.0\modules\cas-server-webapp-4.0.0.war，重命名为cas.war（主要是为了待会访问系统时url短一点）。</li><li>将cas-server.war放入tomcat/webapps，启动tomcat。</li><li>访问<a href="https://localhost:8443/cas/login，默认用户名casuser,密码Mellon登录。" target="_blank" rel="noopener">https://localhost:8443/cas/login，默认用户名casuser,密码Mellon登录。</a></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/20140826121727793.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/20140826121756950.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>注销： <a href="https://localhost:8443/cas/logout" target="_blank" rel="noopener">https://localhost:8443/cas/logout</a></p></li><li><p>以上只是测试cas server的效果，下面正式集成cas，分为server和client两部分。</p></li><li>新建Maven项目：shiro-chapter15。</li></ul><h3 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h3><ul><li>直接将E:\cas-server-4.0.0-release\cas-server-4.0.0\cas-server-webapp拷到shirochapter15下成为其子模块，并重命名为shiro-chapter15-server；idea将自动扫描到更改。</li><li>在idea中修改shiro-chapter15的pom.xml，设置shiro-chapter15-server为其子模块。</li><li>修改shiro-chapter15-server的pom.xml中的一些头信息，增加tomcat插件。</li><li>添加证书：src下建包licensing，把E:\cas导入maven缺少head.txt文件中俩文件复制进去即可。</li><li><p>添加自定义用户：src/main/webapp/WEB-INF/deployerConfigContext.xml，primaryAuthenticationHandler节点下添加代码：</p><pre><code>&lt;entry key=&quot;zhang&quot; value=&quot;123&quot;/&gt;</code></pre></li><li>tomcat7:run运行，出现上面登录界面，输入zhang/123即可登录。cas server配置成功。</li></ul><h3 id="CAS-Client"><a href="#CAS-Client" class="headerlink" title="CAS Client"></a>CAS Client</h3><ul><li>示例采用shirochapter12，web.xml、pom.xml、src、resources下文件基本一致，以下只列出不同的部分。</li><li>导出证书：cas客户端和服务端间交互需要用到证书，因此需要将D:/keys/localhost.keystore导出证书到相同目录下。</li></ul><pre><code>//导出证书keytool -export -alias localhost -file D:\keys\localhost.cer     -keystore D:\keys\localhost.keystore//导入jdkcd D:\jdk\1.8\jre\lib\security //进入jdk（真正的jdk而非本地jdk目录）keytool -import -alias localhost     -file D:\localhost.cer -noprompt -trustcacerts -storetype jks     -keystore cacerts -storepass 123456</code></pre><ul><li><p>导入失败的话可先将security下的cacerts删掉。</p></li><li><p>导入shiro-cas依赖：</p><pre><code>&lt;dependency&gt; &lt;!--集成cas-client--&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>自定义CasRealm：继承CasRealm类，实现权限验证，用户验证则交给cas server做，不用自定义。</p></li></ul><pre><code>public class MyCasRealm extends CasRealm {    private UserService userService;    public void setUserService(UserService userService){        this.userService=userService;    }    /**     * @Author haien     * @Description 根据CAS服务器返回的用户身份获取相应的权限信息     * @Date 2019/3/11     * @Param [principals]     * @return org.apache.shiro.authz.AuthorizationInfo     **/    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        String username=(String)principals.getPrimaryPrincipal();        SimpleAuthorizationInfo authorizationInfo=new SimpleAuthorizationInfo();        authorizationInfo.setRoles(userService.findRoles(username));        authorizationInfo.setStringPermissions(userService.findPermissions(username));        return authorizationInfo;    }}</code></pre><ul><li><p>spring-shiro-web.xml：配置CasRealm和CasFilter，即查找用户权限以支持权限验证和配置cas过滤器使登录时重定向到cas server的登录页面。</p><pre><code>&lt;!--CasRealm--&gt;&lt;bean id=&quot;casRealm&quot; class=&quot;com.haien.chapter15.realm.MyCasRealm&quot;&gt;    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt;    &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt;    &lt;!--CAS Server服务器端地址--&gt;    &lt;property name=&quot;casServerUrlPrefix&quot; value=&quot;https://localhost:8443/chapter15-server&quot;/&gt;    &lt;!--登录成功后跳转的url，即用于接收并处理登录成功后的Ticket的--&gt;    &lt;property name=&quot;casService&quot; value=&quot;https://localhost:8443/chapter15-client/cas&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>如果用户权限信息也由服务端提供的话，可以不用继承而直接使用CasRealm。</p><pre><code>&lt;bean id=&quot;casRealm&quot; class=&quot;org.apache.shiro.cas.CasRealm&quot;&gt;    &lt;!--和上面一样的property--&gt;    &lt;!--默认添加给所有登录成功用户的角色和权限--&gt;    &lt;property name=&quot;defaultRoles&quot; value=&quot;admin,user&quot;/&gt;    &lt;property name=&quot;defaultPermissions&quot; value=&quot;user:create,user:update&quot;/&gt;    &lt;!--角色、权限字段名；若权限信息是从服务端返回的（即返回的CAS Principal中    除了Principal外还有Attributes），可以使用roleAttributeNames、    permissionAttributeNames来获取Attributes中的角色、权限信息；    请自行查询cas如何获取用户更多信息--&gt;    &lt;property name=&quot;roleAttributeNames&quot; value=&quot;roles&quot;/&gt;    &lt;property name=&quot;permissionAttributeNames&quot; value=&quot;permissions&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>CasFilter：</p><pre><code>&lt;!--CasFilter:类似于FormAuthenticationFilter，只不过其验证服务器端返回的是CAS Service Ticket--&gt;&lt;bean id=&quot;casFilter&quot; class=&quot;org.apache.shiro.cas.CasFilter&quot;&gt;    &lt;property name=&quot;failureUrl&quot; value=&quot;/casFailure.jsp&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;!--登录路径;service为登录成功后跳转的url--&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;https://localhost:8443/chapter15-server/login?        service=https://localhost:8443/chapter15-client/cas&quot;/&gt;    &lt;!-- 登录成功后跳转路径 --&gt;    &lt;property name=&quot;successUrl&quot; value=&quot;/&quot; /&gt;    &lt;!--定义自己的过滤器--&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;cas&quot; value-ref=&quot;casFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /casFailure.jsp=anon            /cas=cas //走cas服务器，带着ticket过去再次身份验证            /logout = logout            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li><p>测试：</p></li></ul><ol><li>访问<a href="http://localhost:8080/chapter15-client/,自动跳转登录页面，即在spring-shiro-web.xml" target="_blank" rel="noopener">http://localhost:8080/chapter15-client/,自动跳转登录页面，即在spring-shiro-web.xml</a><br>配置的loginUrl————<a href="https://localhost:8443/server/login?service=" target="_blank" rel="noopener">https://localhost:8443/server/login?service=</a><br><a href="https://localhost:8443/chapter15-client/cas，原url从/变成/cas；" target="_blank" rel="noopener">https://localhost:8443/chapter15-client/cas，原url从/变成/cas；</a></li><li>登录成功后，转回原url：<a href="https://localhost:8443/chapter15-client/cas?ticket=" target="_blank" rel="noopener">https://localhost:8443/chapter15-client/cas?ticket=</a><br>ST-1-eh2cIo92F9syvoMs5DOg-cas01.example.org；</li><li>spring-shiro-web.xml配置了/cas要走cas过滤器，它会先验证ticket是否有效，有效再调用MyCasRealm获取权限信息。</li></ol><ul><li>代码实例：ideaProjects/shirochapter15</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2036730" target="_blank" rel="noopener">《跟我学Shiro》第十五章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shiro 1.2开始支持Jasig CAS单点登录。&lt;/li&gt;
&lt;li&gt;作用：用户只需要到一个中央服务器登录一次即可访问这些系
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-SSL/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十四章-SSL/</id>
    <published>2019-04-30T08:29:23.070Z</published>
    <updated>2019-03-10T04:19:43.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Secure Sockets Layer，安全套接层。在传输层对网络进行加密，为网络通信安全提供安全及数据完整性。</li><li>利用数据加密技术，确保数据在传输过程中不会被截取及窃听。</li><li>广泛应用于web浏览器与服务器之间的身份认证和加密数据传输。</li><li>对于SSL的支持，Shiro只是判断当前url是否需要SSL登录，是则自动重定向到https进行访问。</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li>首先生成数字证书，保存到D:/localhost.keystore。证书生成步骤如下：<ul><li>使用jdk的KeyTool命令，生成证书（包含证书、公钥、私钥）到D:/localhost.keystore</li></ul></li></ul><pre><code>keytool -genkey -keystore &quot;D:\localhost.keystore&quot; -alias localhost -keyalg RSA输入密钥库口令:123456再次输入新口令:123456您的名字与姓氏是什么?  [Unknown]:  localhost //必须是localhost，否则出错您的组织单位名称是什么?  [Unknown]:  sishuok.com您的组织名称是什么?  [Unknown]:  sishuok.com您所在的城市或区域名称是什么?  [Unknown]:  beijing您所在的省/市/自治区名称是什么?  [Unknown]:  beijing该单位的双字母国家/地区代码是什么?  [Unknown]:  cnCN=localhost, OU=sishuok.com, O=sishuok.com, L=beijing, ST=beijing, C=cn是否正确?  [否]:  y输入 &lt;localhost&gt; 的密钥口令        (如果和密钥库口令相同, 按回车):回车再次输入新口令:</code></pre><ul><li><p>可以选择导出cer证书并安装到浏览器内，详见笔记：https、SSL和TLS，使用KeyTool生成自签名证书。不过不安装也没事，只是进行ssl访问时会提示网站不安全而已。</p></li><li><p>然后设置tomcat/config/server.xml</p><pre><code>&lt;!--&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;       maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;       clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;--&gt;&lt;!--将以上代码替换为--&gt;&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;   maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;   clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;    keystoreFile=&quot;D:/localhost.keystore&quot; keystorePass=&quot;123456&quot; /&gt;&lt;!--keystorePass:生成keystore时的口令；    clientAuth:设置是否双向验证，默认false，表示只有客户端验证服务器，    服务器不验证客户端；--&gt;</code></pre></li><li><p>添加SSL到配置文件spring-shiro-web.xml，使用和十三章一样的代码。</p><pre><code>&lt;bean id=&quot;sslFilter&quot; class=&quot;org.apache.shiro.web.filter.authz.SslFilter&quot;&gt;    &lt;property name=&quot;port&quot; value=&quot;8443&quot;/&gt; &lt;!--SslFilter端口默认是443，此处使用了8443--&gt;&lt;/bean&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    ……    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;ssl&quot; value-ref=&quot;sslFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login.jsp = ssl,authc //表示访问登录页面时需要走SSL            /logout = logout            /authenticated.jsp = authc            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li><p>打包并部署到tomcat：否则直接运行是没用的。</p><pre><code>&lt;build&gt;    &lt;finalName&gt;chapter14&lt;/finalName&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2.2&lt;/version&gt;        &lt;configuration&gt;          &lt;path&gt;/${project.build.finalName}&lt;/path&gt;        &lt;/configuration&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre></li><li><p>运行mvn package,把打成的war包复制到tomcat/webapps下，运行tomcat/bin/startup.bat，访问localhost:8080/chapter14/，自动跳转到<a href="https://localhost:8080/chapter14/login.jsp。" target="_blank" rel="noopener">https://localhost:8080/chapter14/login.jsp。</a></p></li><li><p><a href="https://jinnianshilongnian.iteye.com/blog/2036420" target="_blank" rel="noopener">《跟我学Shiro》第十四章</a></p></li><li>代码实例：ideaProjects/shiro-example-chapter14（是从作者github拷下来的代码，但是所有文件都换成了shirochapter12的；和shirochapter12完全一样，包括依赖版本、resources下各xml和web.xml都比对一致；除了pom.xml中顶上url，但经测试无论用哪个url都对，但不知为何14没问题，12在tomcat运行却一直报错如下：</li></ul><pre><code>org.springframework.beans.factory.BeanCreationException:   Error creating bean with name &apos;shiroFilter&apos; defined in class path resource  [spring-shiro-web.xml]: Initialization of bean failed;   nested exception is org.springframework.beans.ConversionNotSupportedException:  Failed to convert property value of type [java.util.LinkedHashMap] to required type  [java.util.Map] for property &apos;filters&apos;;   nested exception is java.lang.IllegalStateException: Cannot convert value of type [java.lang.String] to required type [javax.servlet.Filter] for property  &apos;filters[ssl]&apos;: no matching editors or conversion strategy found</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Secure Sockets Layer，安全套接层。在传输层对网络进行加密，为网络通信安全提供安全及数据完整性。&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-RememberMe%E5%92%8CCookie/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十三章-RememberMe和Cookie/</id>
    <published>2019-04-30T08:29:23.060Z</published>
    <updated>2019-03-07T12:33:55.770Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>首先在登录页面选中remember me然后登录成功；如果是浏览器登录，一般会把remember me的cookie写到客户端保存下来；</li><li>关闭浏览器再次打开，会发现浏览器还是记住你的；</li><li>访问一般的网页服务端还是知道你是谁的，且能正常访问；</li><li>但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，还是需要再进行身份验证，以确定当前用户还是你。</li></ol><h3 id="remember-me配置"><a href="#remember-me配置" class="headerlink" title="remember me配置"></a>remember me配置</h3><ul><li>测试用例：第十二章的示例，ideaProjects/shirochapter12</li><li><p>spring-shiro-web.xml:</p><pre><code>&lt;!-- 会话Cookie模板 --&gt;&lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;    &lt;constructor-arg value=&quot;sid&quot;/&gt;    &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;    &lt;constructor-arg value=&quot;rememberMe&quot;/&gt;    &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;&lt;!-- 30天 --&gt;&lt;/bean&gt;&lt;!-- rememberMe管理器 --&gt;&lt;bean id=&quot;rememberMeManager&quot;   class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;    &lt;property name=&quot;cipherKey&quot;       value=&quot;#{T(org.apache.shiro.codec.Base64).decode(&apos;4AvVhmFLUs0KTA3Kprsdag==&apos;)}&quot;/&gt;    &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt;&lt;/bean&gt;</code></pre></li><li>sessionIdCookie:maxAge=-1表示浏览器关闭时Cookie失效。</li><li>rememberMeCookie:记住我的cookie，保存时长30天。</li><li><p>rememberMeManager：rememberMe管理器，cipherKey(cipher:密码)是加密RememberMe Cookie的密钥，默认AES算法。</p><pre><code>&lt;!-- 安全管理器 --&gt;&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;    ……    &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    ……    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login.jsp = authc            /logout = logout            /authenticated.jsp = authc            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li>rememberMeParam：rememberMe请求参数名，请求参数是Boolean类型，true表示RememberMe。</li><li>/login.jsp = authc：用户必须通过身份验证Subject.login()，则Subject.isAuthenticated()==true；一般用于访问特殊网页，如，我的订单、提交订单页面。</li><li><p>/** = user：身份验证通过或记住我；一般用于普通网页，如，主页之类的。</p></li><li><p>测试：</p></li></ul><ol><li>访问localhost:8080/chapter12/，跳转login页面，登录成功后会设置会话及rememberMeCookie；</li><li>关闭浏览器，会话cookie失效，但rememberMe有效；</li><li>重新打开浏览器访问localhost:8080/chapter12/，可以访问，不再要求登录；</li><li>但是访问/authenticated.jsp，则会跳转登录页面重新进行身份验证。</li></ol><h3 id="自定义RememberMe"><a href="#自定义RememberMe" class="headerlink" title="自定义RememberMe"></a>自定义RememberMe</h3><ul><li>如果要自己做RememberMe，需要在登录之前这样创建Token：UsernamePasswordToken(用户名，密码，是否记住我)，如：</li></ul><pre><code>Subject subject = SecurityUtils.getSubject();UsernamePasswordToken token = new UsernamePasswordToken(username, password);token.setRememberMe(true);subject.login(token);</code></pre><ul><li>subject.isAuthenticated():表示用户是经过身份验证登录的，即Subject.login()。</li><li>subject.isRemembered()：表示用户是通过记住我登录的，此时可能是别人使用你的电脑，或你的cookie被窃取；与以上方法不会同时为true。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>RememberMe需要配合相应的拦截器使用，用错了拦截器可能就不满足你的需求了。</li><li>代码示例：ideaProjects/shirochapter12</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2031823" target="_blank" rel="noopener">《跟我学Shiro》第十三章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先在登录页面选中remember me然后登录成功；如果是浏览器登录，一般会把remember me的cookie写到客户端保
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-OAuth2%E9%9B%86%E6%88%90/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十七章-OAuth2集成/</id>
    <published>2019-04-30T08:29:23.046Z</published>
    <updated>2019-04-01T13:24:42.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>使用Apache Oltu来做对OAuth的实现，因为它比较轻量、简单、灵活。</li><li>按照OAuth的角色分布，可以写三个程序：资源服务器、授权服务器和客户端Client各一个，也可以全部写到一个程序里面。</li><li>本例采用写成两个程序，一个服务器端，一个客户端。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>数据库：shiro-oauth2.所在会话：mysql。</li><li>oauth2_user:用户表，资源拥有者。admin/123456。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7680.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>oauth2_client:客户端表，存储客户端id和客户端密钥，在进行授权时使用。</li></ul><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="oltu源码"><a href="#oltu源码" class="headerlink" title="oltu源码"></a>oltu源码</h4><ul><li>源码分包：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/041748590918173.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>issuer：生成授权码和访问令牌，刷新令牌。</li><li>request：封装授权码请求和令牌请求的逻辑，并提供相应的校验服务。</li><li>response：封装授权流程中的响应逻辑，提供生成不同响应结果的方法。</li><li>validator：为request提供校验服务。</li></ul><h4 id="issuer"><a href="#issuer" class="headerlink" title="issuer"></a>issuer</h4><ul><li>主要是俩接口。</li><li>OAuthIssuer接口：默认实现类OAuthIssuerImpl。</li></ul><pre><code>public interface OAuthIssuer {    public String accessToken() throws OAuthSystemException;    public String authorizationCode() throws OAuthSystemException;    public String refreshToken() throws OAuthSystemException;}</code></pre><ul><li>ValueGenerator接口：默认实现类MD5Generator和UUIDValueGenerator，用于生成code和token的字符串。</li></ul><pre><code>public interface ValueGenerator {    public String generateValue() throws OAuthSystemException;    public String generateValue(String param) throws OAuthSystemException;}</code></pre><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><ul><li>封装请求主要是为了提取其中的参数来验证是否合格，比如client_id是否正确。</li><li>主要是一个父类，其他都是其子类。</li><li>OAuthRequest：父类，提供最基础的逻辑和方法。</li><li>OAuthAuthzRequest：授权码请求。</li><li>AbstractOAuthTokenRequest：抽象类，为下一个类做准备。</li><li>OAuthTokenRequest：令牌请求。</li><li>OAuthUnauthenticatedTokenRequest：刷新令牌的请求。</li><li><a href="https://www.cnblogs.com/jdluojing/p/4201729.html" target="_blank" rel="noopener">validator部分代码分析</a></li><li>封装请求示例：</li></ul><pre><code>OAuthTokenRequest oAuthTokenRequest=new OAuthTokenRequest(request);//比如规定的参数必须要有，至少GrantType、clientId、clientSecret、code、redirectUrl；//否则抛出异常：OAuthProblemException；另有OAuthSystemException，这个较少出现</code></pre><h4 id="validator"><a href="#validator" class="headerlink" title="validator"></a>validator</h4><ul><li>包下all类实现自validators包的OAuthvalidator接口，其包下还有实现了all方法的AbstractValidator类。</li><li>本包下类：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/041748590918173.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><a href="https://www.cnblogs.com/jdluojing/p/4201729.html" target="_blank" rel="noopener">部分代码分析</a></li></ul><h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><ul><li>OAuthResponse：构造响应数据的父类，构造方法protected，不能创建实例，实际用到的是其静态内部类OAuthResponseBuilder，是后面要介绍到的两个Builder类的父类；不知道在不在本包；成员如下：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/041749056842324.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>其中有两个Builder：OAuthResponseBuilder和OAuthErrorResponseBuilder，后者是前者的子类。</p></li><li><p>OAuthASResponse：子类，提供了组装不同请求的方法，成员如下：</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/041749045594768.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>构造方法是protected，因此不能new此类的实例，我们实际需要用的只是它的两个静态内部类OAuthAuthorizationResponseBuilder和OAuthTokenResponseBuilder，通过它们的方法来生成最终的响应数据。</p></li><li><p>构造响应的方法基本也就上面框出来3个了，注意到Builder内的all方法都是返回本类的实例，也就是可以无限链式调用。我们先看一个实际使用中的场景：</p></li></ul><pre><code>// 处理授权码请求返回的响应OAuthResponse oAuthResponse= OAuthASResponse.authorizationResponse(request, 200)        .location(redirectUrl)        .setCode(oauthCode)        .setScope(state)        .buildQueryMessage();String url=oAuthResponse.getLocationUri();response.sendRedirect(url);// 令牌OAuthResponse authASResponse = OAuthASResponse.tokenResponse(200)        .setAccessToken(access_token)        .setExpiresIn(&quot;7200&quot;)        .setRefreshToken(refreshToken)        .setTokenType(TokenType.BEARER.toString())        .setParam(&quot;re_expires_in&quot;, &quot;14400&quot;)        .buildJSONMessage();String json=authASResponse.getBody();// 错误响应OAuthResponse authASResponse = OAuthASResponse        .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)        .setError(OAuthError.ResourceResponse.INVALID_TOKEN)        .setErrorDescription(&quot;invald expired&quot;)        .buildJSONMessage();return new ResponseEntity&lt;String&gt;(authASResponse.getBody(), headers,    HttpStatus.UNAUTHORIZED);</code></pre><ul><li>buildQueryMessage()：发起新请求，url即location()中的参数redirectUrl，响应体自然也送至该url。</li><li>buildJSONMessage()：返回原页面，响应体被解析为json。</li><li>setter实际就是设置响应参数，最后调用一个buildXxxMessage方法生成一个包含所有响应参数的OAuthResponse对象(注意是OAuthResponse这个父类，而不是OAuthASResponse子类，所以最终都是要用OAuthResponse对象来接收)。</li><li>对象返回后就可以调用getBody(),getHeaders()之类的方法获取到其中的响应数据。</li><li><p>对于错误响应中的error，在set时可以直接调用alth提供的OAuthError类的常量，它们是不同场景下通用的错误标识。</p></li><li><p><a href="https://www.cnblogs.com/jdluojing/p/4201729.html" target="_blank" rel="noopener">参考文章</a></p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>目的：执行OAuth授权流程。</li><li>实体: 客户端Client、用户User。</li><li>service：客户端的增删查改、用户的增删查改、OAuthService管理code和token。</li><li><p>controller：分为对内的后台管理控制器和对外的执行OAuth的控制器。后台管理主要负责QQ内部维护的用户和已在此注册的客户端，执行OAuth的控制器负责为客户端授权（给code、给token、给用户信息）。</p></li><li><p>依赖：authzserver授权服务器和resourceserver资源服务器两个依赖。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt;    &lt;artifactId&gt;org.apache.oltu.oauth2.authzserver&lt;/artifactId&gt;    &lt;version&gt;0.31&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt;    &lt;artifactId&gt;org.apache.oltu.oauth2.resourceserver&lt;/artifactId&gt;    &lt;version&gt;0.31&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ul><h5 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h5><ul><li><p>以下两个controller一个负责根据登录表单给code，一个负责根据code给token，合为授权服务器。</p></li><li><p>AuthorizeController：授权控制器，控制客户端访问OAth服务器端的授权登录页面，通过授权验证并获取code授权码。</p></li></ul><ol><li>首先访问该controller第一个方法地址：/authorize?client_id=xxx&amp;response_type=code&amp;redirect_uri=<a href="http://localhost:9080/chapter17-client/oauth2-login，即访问授权页面。" target="_blank" rel="noopener">http://localhost:9080/chapter17-client/oauth2-login，即访问授权页面。</a></li><li>控制器首先检查clientId是否正确，如果错误则返回错误响应；</li><li>如果正确则判断用户是否已登录，否则跳转登录页面；</li><li>已登录则生成相应auth code，并保存到缓存中。</li><li>重定向回redirect_uri:<a href="http://localhost:9080/chapter17-client/oauth2-login?code=xxx,接着客户端凭此code去获取token。" target="_blank" rel="noopener">http://localhost:9080/chapter17-client/oauth2-login?code=xxx,接着客户端凭此code去获取token。</a></li></ol><pre><code>@Controllerpublic class AuthorizeController {    @Resource    private OAuthService oAuthService;    @Resource    private ClientService clientService;    /**     * @Author haien     * @Description 映射授权页面：/authorize?clien_id=xxx &amp; response_type=code &amp;                 redirect_uri=http://localhost:8080/chapter17-client/oauth2-login     * @Date 2019/3/26     * @Param [model, request]     * @return java.lang.Object     **/    @RequestMapping(&quot;/authorize&quot;)    public Object authorize(Model model, HttpServletRequest request)            throws OAuthSystemException,URISyntaxException {        try {            //1. 把当前请求封装成OAth请求            OAuthAuthzRequest oAuthAuthzRequest=new OAuthAuthzRequest(request);            //2. 检查client_id是否正确            if(!oAuthService.checkClientId(oAuthAuthzRequest.getClientId())){                //错误则构造错误响应                OAuthResponse response=OAuthASResponse                        .errorResponse(HttpServletResponse.SC_BAD_REQUEST)                         //设置错误码                        .setError(OAuthError.TokenResponse.INVALID_CLIENT)                        .setErrorDescription(                            Constants.INVALID_CLIENT_DESCRIPTION)                        .buildJSONMessage(); //返回原页面，响应体被前端解析为json                //获取上面构造好的响应数据                return new ResponseEntity(                        response.getBody(),                        HttpStatus.valueOf(response.getResponseStatus())                    ); //response.getBody()：获取响应体，返回string；                       //包含两个键值对：error和error_description            }            //3. 判断用户是否已登录            Subject subject=SecurityUtils.getSubject();            //若用户尚未登录，跳转登录页面            if(!subject.isAuthenticated()){                //如果登录失败则跳转回登录页面                if(!login(subject,request))                    model.addAttribute(&quot;client&quot;,                            clientService.findByClientId(                                oAuthAuthzRequest.getClientId()));                //跳转登录页面                return &quot;oauth2login&quot;;            }            //4. 登录成功或已登录则生成授权码code            String username=(String)subject.getPrincipal();            String authorizationCode=null;            /*获取请求中的response_type参数，            OAUTH_RESPONSE_TYPE值应为response_type；            responseType目前只支持code和token*/            String responseType=oAuthAuthzRequest                .getParam(OAuth.OAUTH_RESPONSE_TYPE);            if(responseType.equals(ResponseType.CODE.toString())){                //生成authCode                OAuthIssuerImpl oauthIssuerImpl=new OAuthIssuerImpl(                    new MD5Generator());                authorizationCode=oauthIssuerImpl.authorizationCode();                //添加缓存条目：key=authCode.value=username                oAuthService.addAuthCode(authorizationCode,username);            }            /*5. 重定向回客户端地址，            http://localhost:8080/chapter17-client/oauth2-login?            code=xxx*/            //获取请求中的重定向地址，OAUTH_REDIRECT_URI应为redirect_uri            String redirectURI=oAuthAuthzRequest                .getParam(OAuth.OAUTH_REDIRECT_URI);            final OAuthResponse response= OAuthASResponse                    .authorizationResponse(request,HttpServletResponse.SC_FOUND)                    .setCode(authorizationCode) //设置授权码                    .location(redirectURI)                    .buildQueryMessage(); //发起新请求，url即redirectURI            //获取response数据            HttpHeaders headers=new HttpHeaders();            //响应报头域中location为重定向的url            headers.setLocation(new URI(response.getLocationUri()));             return new ResponseEntity(headers,                HttpStatus.valueOf(response.getResponseStatus()));        } catch (OAuthProblemException e) { //new OAuthAuthzRequest()抛出的            //异常处理            String redirectUri=e.getRedirectUri();            //如果客户端没有传入redirectUri            if(OAuthUtils.isEmpty(redirectUri)) {                //返回原页面，打印以下字符串                return new ResponseEntity(                        &quot;OAuth callback url needs to be provided by client!&quot;,                        HttpStatus.NOT_FOUND);            }            //否则返回其他错误信息            final OAuthResponse response=OAuthASResponse                    .errorResponse(HttpServletResponse.SC_FOUND)                    .error(e)                    .location(redirectUri)                    .buildQueryMessage();            //获取response数据            HttpHeaders headers=new HttpHeaders();            headers.setLocation(new URI(response.getLocationUri()));            return new ResponseEntity(headers,                HttpStatus.valueOf(response.getResponseStatus()));        }    }    /**     * @Author haien     * @Description shiro的登录方法     * @Date 2019/3/26     * @Param [subject, request]     * @return boolean     **/    private boolean login(Subject subject,HttpServletRequest request){        //不处理get请求        if(&quot;get&quot;.equalsIgnoreCase(request.getMethod()))            return false;        String username=request.getParameter(&quot;username&quot;);        String password=request.getParameter(&quot;password&quot;);        if(StringUtils.isEmpty(username)||StringUtils.isEmpty(password))            return false;        UsernamePasswordToken token=new UsernamePasswordToken(username,password);        try {            subject.login(token);            return true;        } catch(Exception e){            request.setAttribute(&quot;error&quot;,&quot;登录失败：&quot;+e.getClass().getName());            return false;        }    }}</code></pre><ul><li>其中242行catch块无redirectUri时，返回原页面并打印错误信息如下：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7685.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>AccessTokenController：令牌控制器，负责用code获取token的过程。</li></ul><ol><li>首先访问该类方法:/accesstoken，并post数据：client_id=xxx &amp; client_secret=xxx &amp; grant_type=authorization_code &amp; code=xxx &amp; redirect_uri=<a href="http://localhost:9080/chapter17-client/oauth2-login，请求获取token。" target="_blank" rel="noopener">http://localhost:9080/chapter17-client/oauth2-login，请求获取token。</a></li><li>控制器验证client_id、client_secret和code是否正确，否则生成错误响应；</li><li>正确则生成Access Token。</li><li>重定向回去，并带上Access Token。</li></ol><pre><code>@Controllerpublic class AccessTokenController {    @Resource    private OAuthService oAuthService;    @Resource    private UserService userService;    @RequestMapping(&quot;/accessToken&quot;)    public HttpEntity token(HttpServletRequest request)         throws OAuthSystemException {        try {            //1. 把当前请求封装成OAuth的请求            OAuthTokenRequest oAuthTokenRequest=new OAuthTokenRequest(request);            //2. 检查client_id、客户端key(client_secret)、许可证类型是否正确            if(!oAuthService.checkClientId(oAuthTokenRequest.getClientId())){                OAuthResponse response=OAuthASResponse                        .errorResponse(HttpServletResponse.SC_BAD_REQUEST)                        .setError(OAuthError.TokenResponse.INVALID_CLIENT)                        .setErrorDescription(                            Constants.INVALID_CLIENT_DESCRIPTION)                        .buildJSONMessage();                return new ResponseEntity(response.getBody(),                        HttpStatus.valueOf(response.getResponseStatus()));            }            //客户端key            if(!oAuthService.checkClientSecret(                    oAuthTokenRequest.getClientSecret())){                OAuthResponse response=OAuthASResponse                        .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)                        .setError(OAuthError.TokenResponse.UNAUTHORIZED_CLIENT)                        .setErrorDescription(                            Constants.INVALID_CLIENT_DESCRIPTION)                        .buildJSONMessage();                return new ResponseEntity(response.getBody(),                        HttpStatus.valueOf(response.getResponseStatus()));            }            //许可证类型,此处只支持code类型，其他还有password和refresh_token            String authCode=oAuthTokenRequest.getParam(OAuth.OAUTH_CODE);            //从request中获取grant_type参数,判断是不是code类型            if(oAuthTokenRequest.getParam(OAuth.OAUTH_GRANT_TYPE).equals(                    GrantType.AUTHORIZATION_CODE.toString())){                //检查code是否正确                if(!oAuthService.checkAuthCode(authCode)){                    //生成错误响应                    OAuthResponse response=OAuthASResponse                            .errorResponse(HttpServletResponse.SC_BAD_REQUEST)                            .setError(OAuthError.TokenResponse.INVALID_GRANT)                            .setErrorDescription(&quot;错误的授权码&quot;)                            .buildJSONMessage();                    return new ResponseEntity(response.getBody(),                            HttpStatus.valueOf(response.getResponseStatus()));                }            }            //3. 生成Access Token            OAuthIssuer oauthissuer=new OAuthIssuerImpl(new MD5Generator());             final String accessToken=oauthissuer.accessToken(); //生成token            //加入缓存            oAuthService.addAccessToken(accessToken,                    oAuthService.getUsernameByAuthCode(authCode));            //4. 重定向回去（不知道为什么这里没有把请求中的redirect_uri放进去）            //不需要return，自然会作为response带回去            OAuthResponse response=OAuthASResponse                    .tokenResponse(HttpServletResponse.SC_OK)                    .setAccessToken(accessToken)                    //Long转String                    .setExpiresIn(String.valueOf(oAuthService.getExpireIn()))                     .buildJSONMessage();            return new ResponseEntity(response.getBody(),                    HttpStatus.valueOf(response.getResponseStatus()))l        } catch (OAuthProblemException e) {            //生成错误响应            OAuthResponse response=OAuthASResponse                    .errorResponse(HttpServletResponse.SC_BAD_REQUEST)                    .error(e)                    .buildJSONMessage();            return new ResponseEntity(response.getBody(),                    HttpStatus.valueOf(response.getResponseStatus()));        }    }}</code></pre><h5 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h5><ul><li>ResourceController：充当资源服务器，拥有user信息，根据token给客户端提供这些信息。</li></ul><ol><li>首先访问该类方法：/userInfo?access_token=xxx，即用token请求用户信息。</li><li>控制器判断token是否有效（存在并未过期），否则生成错误响应，客户端重新请求授权；</li><li>是则返回用户信息（此处为用户名）。</li></ol><pre><code>@RestControllerpublic class ResourceController {    @Resource    private OAuthService oAuthService;    @RequestMapping(&quot;/userInfo&quot;)    public HttpEntity userInfo(HttpServletRequest request)         throws OAuthSystemException {        try {            //1. 将request包装成OAuth请求            OAuthAccessResourceRequest oAuthAccessResourceRequest=                    new OAuthAccessResourceRequest(request);            //2. 检查Access Token是否正确            String accessToken=oAuthAccessResourceRequest.getAccessToken();            if(!oAuthService.checkAccessToken(accessToken)){ //不存再或已过期                //生成错误响应                OAuthResponse response=OAuthASResponse                        .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)                        .setRealm(Constants.RESOURCE_SERVER_NAME)                        .setError(OAuthError.ResourceResponse.INVALID_TOKEN)                        .buildHeaderMessage();                HttpHeaders headers=new HttpHeaders();                headers.add(OAuth.HeaderType.WWW_AUTHENTICATE,                        response.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE));                return new ResponseEntity(headers,HttpStatus.UNAUTHORIZED);            }            //3. 返回资源（这里是用户名）            String username=oAuthService.getUsernameByAccessToken(accessToken);            return new ResponseEntity(username,HttpStatus.OK);        } catch (OAuthProblemException e) {            //是否设置了错误码            String errorCode=e.getError();            //没有错误码则不加错误码            if(OAuthUtils.isEmpty(errorCode)){                OAuthResponse response=OAuthASResponse                        .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)                        .setRealm(Constants.RESOURCE_SERVER_NAME)                        .buildHeaderMessage();                HttpHeaders headers=new HttpHeaders();                headers.add(OAuth.HeaderType.WWW_AUTHENTICATE,                        response.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE));                return new ResponseEntity(headers,HttpStatus.UNAUTHORIZED);            }            //有就加上            OAuthResponse response=OAuthASResponse                    .errorResponse(HttpServletResponse.SC_UNAUTHORIZED)                    .setRealm(Constants.RESOURCE_SERVER_NAME)                    .setError(e.getError())                    .setErrorDescription(e.getDescription())                    .setErrorUri(e.getUri())                    .buildHeaderMessage();            HttpHeaders headers=new HttpHeaders();            headers.add(OAuth.HeaderType.WWW_AUTHENTICATE,                    response.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE));            return new ResponseEntity(HttpStatus.BAD_REQUEST);        }    }}</code></pre><ul><li><p>配置文件：跟第十六章类似，其中要说的是过滤链的配置：OAuth的几个地址：/authorize、/accesstoken、/userInfo都是匿名可访问的。</p><pre><code>&lt;property name=&quot;filterChainDefinitions&quot;&gt;    &lt;!--OAuth的几个地址：/authorize、/accesstoken、/userInfo都是匿名可访问的--&gt;    &lt;value&gt;        / = anon        /login = authc        /logout = logout        /authorize=anon        /accessToken=anon        /userInfo=anon        /** = user    &lt;/value&gt;&lt;/property&gt;</code></pre></li><li><p>测试：</p></li></ul><ol><li>首先模拟豆瓣向qq发起授权请求：<a href="http://localhost:8080/chapter17-server/authorize" target="_blank" rel="noopener">http://localhost:8080/chapter17-server/authorize</a><br>?client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee &amp; response_type=code &amp; redirect_uri=<a href="http://localhost:9080/chapter17-client/oauth2-login。" target="_blank" rel="noopener">http://localhost:9080/chapter17-client/oauth2-login。</a></li><li>转发至登录页面，url仍是上面那个。</li><li>登录，提交至以上url进入login()验证，验证成功则重定向至redirect_uri（此时访问失败，因为还没有设置该url）并带上code。</li><li>重定向失败了先不管，先拿着code拿token：访问<a href="http://localhost:8080/chapter17-server/accessToken，post带上参数：client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee" target="_blank" rel="noopener">http://localhost:8080/chapter17-server/accessToken，post带上参数：client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee</a> &amp; client_secret=d8346ea2-6017-43ed-ad68-19c0f971738b &amp; code=3569b277920280b33d6d86ded9022df8 &amp; grant_type=authorization_code。返回token（json格式）。</li><li>带上token去请求用户信息：<a href="http://localhost:8080/chapter17-server/authorize" target="_blank" rel="noopener">http://localhost:8080/chapter17-server/authorize</a><br>?client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee &amp; response_type=code &amp; redirect_uri=<a href="http://localhost:9080/chapter17-client/oauth2-login，返回用户名。" target="_blank" rel="noopener">http://localhost:9080/chapter17-client/oauth2-login，返回用户名。</a></li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>流程：豆瓣客户端在登录时选择请求QQ服务器端授权登录，成功后返回code给客户端，客户端使用该code去服务器端换取token。</li><li><p>依赖：</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt;  &lt;artifactId&gt;org.apache.oltu.oauth2.client&lt;/artifactId&gt;  &lt;version&gt;0.31&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>OAuth2Token类：用于存储OAuth2服务端返回的auth code；待会被login方法调用；实现了AuthenticationToken接口，它用于保存用户提交的信息，常用的实现类是UsernamePasswordToken。</p></li></ul><pre><code>public class OAuth2Token implements AuthenticationToken {    private String authCode; //code    private String principal; //username    //构造方法    public OAuth2Token(String authCode) {        this.authCode = authCode;    }    //getter    @Override    public String getPrincipal() {        return principal;    }    @Override    public Object getCredentials() {        return authCode;    }    //setter    ......}</code></pre><ul><li>OAuth2AuthenticationFilter: 过滤器，类似于FormAuthenticationFilter，控制OAuth2客户端的身份验证。</li></ul><ol><li>首先判断响应中是否包含error参数（除非重定向才会有响应），有则直接重定向到失败页面。</li><li>如果用户未身份验证且没有code，（若有code则是服务端授权之后返回的），则重定向到服务端进行授权；</li><li>如果未验证但有code，则调用executeLogin()进行登录（虽然服务端那边已经登录成功并拿到了code，但是客户端这边的Subject仍未登录，按第六章的说法，默认只有同线程的Subject是同一个，这里连应用都不是同一个），用code创建OAuth2Token提交给Subject登录。</li><li>登录成功回调onLoginSuccess()重定向到成功页面；</li><li>失败回调onLoginFailure()重定向到失败页面。</li></ol><pre><code>public class OAuth2AuthenticationFilter extends AuthenticatingFilter {    //auth code参数名    private String authcCodeParam=&quot;code&quot;;    private String clientId;    //服务器端登录成功后重定向地址    private String redirectUrl;    //失败后重定向地址    private String failureUrl;    private String responseType=&quot;code&quot;;    /**     * @Author haien     * @Description 用code创建OAuth2Token     * @Date 2019/3/30     * @Param [request, response]     * @return org.apache.shiro.authc.AuthenticationToken     **/    @Override    protected AuthenticationToken createToken(ServletRequest request,             ServletResponse response) throws Exception{        HttpServletRequest httpRequest=(HttpServletRequest)request;        String code=httpRequest.getParameter(authcCodeParam);        return new OAuth2Token(code);    }    @Override    protected boolean isAccessAllowed(ServletRequest request,         ServletResponse response, Object mappedValue) {        return false;    }    /**     * @Author haien     * @Description 当访问拒绝时是否已经处理了，返回true表示需要继续处理，                    否则直接返回即可。不知道什么情况下会被拒绝？     * @Date 2019/3/30     * @Param [request, response]     * @return boolean     **/    @Override    protected boolean onAccessDenied(ServletRequest request,             ServletResponse response) throws Exception {        String error=request.getParameter(&quot;error&quot;);        String errorDescription=request.getParameter(&quot;error_description&quot;);        //如果服务端返回了错误参数        if(!StringUtils.isEmpty(error)){            //重定向到失败页面            WebUtils.issueRedirect(request,response,              failureUrl+&quot;?error=&quot;+error+&quot;error_description=&quot;+errorDescription);            return false;        }        //判断用户是否已身份验证（记住我不算）        Subject subject=getSubject(request,response);        if(!subject.isAuthenticated()){            //如果用户未身份验证且没有code            if(StringUtils.isEmpty(request.getParameter(authcCodeParam))){                //重定向到服务端授权                saveRequestAndRedirectToLogin(request,response);                return false;            }            /*未身份验证但已经重定向到server端登录页面并成功登录拿到code            （由于拿到code后OAuthresponse.buildQueryMessage()重定向回/oauth2-login            又触发该过滤器，因为server端和client端并不共享一个Subject，所以那边登录后            这边仍未登录），则执行父类的登录逻辑，它会调用createToken()用code创建            OAuth2Token并交给Subject.login()登录，login()将调用OAuth2Realm进行身份            验证；登录成功将回调onLoginSuccess()重定向到成功页面；            失败则onLoginFailure()重定向到失败页面*/            return executeLogin(request,response);        }        return false;    }    /**     * @Author haien     * @Description 登录成功后的回调方法，重定向到成功页面；                    被上面executeLogin()调用     * @Date 2019/3/30     * @Param [token, subject, request, response]     * @return boolean     **/    @Override    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject,                                     ServletRequest request,                                      ServletResponse response) throws Exception {        //把原先的url：/oauth2-login清空，跳转默认成功页面，不然又会触发过滤器，        //而执行onAccessdeny()，这次直接返回false，        //而给前端呈现了一个空白的/oauth2-login页面        WebUtils.getAndClearSavedRequest(request);         issueSuccessRedirect(request,response);        return false;    }    /**     * @Author haien     * @Description 登录失败后的回调；被上面executeLogin()调用     * @Date 2019/3/30     * @Param [token, e, request, response]     * @return boolean     **/    @Override    protected boolean onLoginFailure(AuthenticationToken token,             AuthenticationException ae,ServletRequest request,             ServletResponse response) {        Subject subject=getSubject(request,response);        //如果用户其实已登录过了        if(subject.isAuthenticated()||subject.isRemembered()){            //重定向到成功页面            try {                issueSuccessRedirect(request,response);            } catch (Exception e) {                e.printStackTrace();            }        }        //如果用户未登录且目前登录失败        else {            try {                //重定向到失败页面                WebUtils.issueRedirect(request,response,failureUrl);            } catch (IOException e) {                e.printStackTrace();            }        }        return false;    }}</code></pre><ul><li><p>ShiroFilter：</p><pre><code>&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;  &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;  &lt;property name=&quot;loginUrl&quot;            value=&quot;http://localhost:8080/chapter17-server/authorize?client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee&amp;amp;response_type=code&amp;amp;redirect_uri=http://localhost:9080/chapter17-client/oauth2-login&quot;/&gt;  &lt;property name=&quot;successUrl&quot; value=&quot;/&quot;/&gt;  &lt;property name=&quot;filters&quot;&gt;      &lt;util:map&gt;         &lt;entry key=&quot;oauth2Authc&quot; value-ref=&quot;oAuth2AuthenticationFilter&quot;/&gt;      &lt;/util:map&gt;  &lt;/property&gt;  &lt;property name=&quot;filterChainDefinitions&quot;&gt;      &lt;value&gt;          / = anon          /oauth2Failure.jsp = anon          /oauth2-login = oauth2Authc          /logout = logout          /** = user      &lt;/value&gt;  &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li>loginUrl会自动设置到所有的AccessControllerFilter，包括OAuth2AuthenticationFilter。</li><li><p>/oauth2-login为服务端OAuth2授权起点，指定oauth2Authc过滤器。</p></li><li><p>测试：</p></li></ul><ol><li>访问<a href="http://localhost:9080/chapter17-client/，展示index.jsp登录页面，点击登录按钮，其url为/oauth2-login。" target="_blank" rel="noopener">http://localhost:9080/chapter17-client/，展示index.jsp登录页面，点击登录按钮，其url为/oauth2-login。</a></li><li>第一次触发OAuth2AuthenticationFilter，主要逻辑在onAccessDeny()中，它发现用户未登录，重定向到登录接口，按ShiroFilter设置的loginUrl，为<a href="http://localhost:8080/chapter17-server/authorize?带各参数，其中redirectUrl为/oauth2-login。" target="_blank" rel="noopener">http://localhost:8080/chapter17-server/authorize?带各参数，其中redirectUrl为/oauth2-login。</a></li><li>填写登录信息，提交server端AuthorizeController登录并带着code重定向到以上redirectUrl：/oauth2-login。</li><li>第二次又触发OAuth2AuthenticationFilter，在客户端执行login()登录一遍，其会调用OAuth2Realm中的extractUsername()拿着code去请求token进而请求userInfo获得username，封装进token，构造客户端的Subject；</li><li>登录成功，执行onLoginSuccess()，情况原本要访问的url：/oauth2-login，重定向到默认成功页面。</li></ol><ul><li>代码示例：ideaProjects/shiro-cahpter17</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2038646" target="_blank" rel="noopener">《跟我学shiro第十七章》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用Apache Oltu来做对OAuth的实现，因为它比较轻量、简单、灵活。&lt;/li&gt;
&lt;li&gt;按照OAuth的角色分布，可以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E7%BB%BC%E5%90%88%E5%AE%9E%E4%BE%8B%EF%BC%8C%E7%94%A8%E6%88%B7%E3%80%81%E8%A7%92%E8%89%B2%E3%80%81%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十六章-综合实例，用户、角色、资源模型，配置文件详解/</id>
    <published>2019-04-30T08:29:23.042Z</published>
    <updated>2019-03-28T09:38:20.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统功能"><a href="#系统功能" class="headerlink" title="系统功能"></a>系统功能</h3><ul><li>根据用户权限获取菜单集合，返回前端显示。当前只有admin/123456。</li><li>本系统实体包括用户、公司、资源和角色，在界面上可以对它们进行增删查改等。</li><li>比如，用户可以修改用户所属公司、拥有角色和资源、修改密码；公司可以移动子公司到其他公司旗下；资源可以修改资源所需权限、在父菜单下增删子菜单，角色可以修改用户可访问的资源。</li><li>下图为资源管理</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7674.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>在组织机构管理栏点击“添加子节点”</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7675.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><ul><li>数据库：shiro2。所在会话：mysql。</li><li>用户表：organization_id：所属公司id，roles_ids:拥有角色id，用逗号连接成字符串。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7676.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>角色表：role：英文名称，用于后台交互；description：中文名称，用于前端显示；resource_ids：能访问的资源id，用逗号连接成字符串。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7657.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>资源表：type:资源类型，菜单和按钮，按钮实际为菜单的子菜单，为最低一级，当然菜单与菜单之间也有父子关系；parent_id:父菜单的id号；parent_ids：祖宗菜单链，从最顶级菜单的id开始排到父菜单，中间用/分隔，最后也用/结束；url:该资源对应的url；permission:访问该资源需要的权限；avaiable：是否可用。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7677.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>公司：parent_id：父公司id；parent_ids:祖宗公司id，从顶级公司排到父公司，中间用/分隔，最后也用/结束；avaliable：是否经营中。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7678.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>注意：配置文件的class属性不能断开，否则视为类路径出错</li><li>resources.properties: 常量配置，包括DataSource的jdbc属性、数据连接池属性和shiro的密码加密算法，以备spring-config.xml引入。</li></ul><pre><code>#这里只列出加密算法属性#shiropassword.algorithmName=md5password.hashIterations=2</code></pre><ul><li><p>spring-config-cache.xml：定义cache底层为ehcache，以备spring-config.xml注入。</p><pre><code>&lt;bean id=&quot;springCacheManager&quot;       class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;ehcacheManager&quot;/&gt;&lt;/bean&gt;&lt;!--ehcache--&gt;&lt;bean id=&quot;ehcacheManager&quot;      class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>ehcache.xml：与以前配置相同，不再赘述。</p></li><li><p>spring-mvc-shiro.xml: 定义aop切面，开启@RequriresPermissions注解进行权限控制。</p><pre><code>&lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt;&lt;bean     class=&quot;org.apache.shiro.spring.security.interceptor            .AuthorizationAttributeSourceAdvisor&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>spring-config-shiro.xml: shiro配置，包括缓存、会话、realm、ShiroFilter、SecurityManager，以下只列出重要的。</p></li></ul><pre><code>&lt;!-- Realm实现 --&gt;&lt;bean id=&quot;userRealm&quot; class=&quot;com.haien.chapter16.realm.UserRealm&quot;&gt;    &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;    &lt;property name=&quot;cachingEnabled&quot; value=&quot;false&quot;/&gt;    &lt;!--&lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt;--&gt;    &lt;!--&lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt;--&gt;    &lt;!--&lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt;--&gt;    &lt;!--&lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt;--&gt;&lt;/bean&gt;&lt;bean id=&quot;sysUserFilter&quot;  class=&quot;com.github.zhangkaitao.shiro.chapter16.web.shiro.filter.SysUserFilter&quot;/&gt;&lt;!-- Shiro的Web过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login = authc            /logout = logout            /authenticated = authc            /** = user,sysUser        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><ul><li>UserRealm禁用了shiro自己的缓存，而启用自己的缓存，否则需要在修改用户信息时频繁清理缓存。</li><li><p>SysUserFilter：根据当前用户身份获取User信息放入request，便于后续获取。</p></li><li><p>spring-config.xml: 扫描要注册的bean、注入数据源、配置事务管理器、引入其他配置文件，方便在web.xml只定位这一个配置文件即可发现其他配置文件。</p><pre><code>&lt;context:property-placeholder location=&quot;classpath:resources.properties&quot;/&gt;&lt;!-- 扫描注解Bean --&gt;&lt;context:component-scan base-package=&quot;com.haien.chapter16&quot;&gt;    &lt;!--controller包的扫描交给MVC层的xml--&gt;    &lt;context:exclude-filter type=&quot;annotation&quot;        expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!-- 开启AOP监听 只对当前配置文件有效  expose-proxy=&quot;true&quot;--&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;!-- 数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;      init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;    &lt;property name=&quot;url&quot; value=&quot;${connection.url}&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;${connection.username}&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;${connection.password}&quot;/&gt;    &lt;!-- 配置初始化大小、最小、最大 --&gt;    &lt;property name=&quot;initialSize&quot; value=&quot;${druid.initialSize}&quot;/&gt;    &lt;property name=&quot;minIdle&quot; value=&quot;${druid.minIdle}&quot;/&gt;    &lt;property name=&quot;maxActive&quot; value=&quot;${druid.maxActive}&quot;/&gt;    &lt;!-- 配置获取连接等待超时的时间 --&gt;    &lt;property name=&quot;maxWait&quot; value=&quot;${druid.maxWait}&quot;/&gt;    &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，    单位是毫秒 --&gt;    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot;              value=&quot;${druid.timeBetweenEvictionRunsMillis}&quot; /&gt;    &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;    &lt;property name=&quot;minEvictableIdleTimeMillis&quot;         value=&quot;${druid.minEvictableIdleTimeMillis}&quot; /&gt;    &lt;property name=&quot;validationQuery&quot;         value=&quot;${druid.validationQuery}&quot; /&gt;    &lt;property name=&quot;testWhileIdle&quot; value=&quot;${druid.testWhileIdle}&quot; /&gt;    &lt;property name=&quot;testOnBorrow&quot; value=&quot;${druid.testOnBorrow}&quot; /&gt;    &lt;property name=&quot;testOnReturn&quot; value=&quot;${druid.testOnReturn}&quot; /&gt;    &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小    如果用Oracle，则把poolPreparedStatements配置为true，    mysql可以配置为false。--&gt;    &lt;property name=&quot;poolPreparedStatements&quot;         value=&quot;${druid.poolPreparedStatements}&quot; /&gt;    &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot;      value=&quot;${druid.maxPoolPreparedStatementPerConnectionSize}&quot; /&gt;    &lt;!-- 配置监控统计拦截的filters --&gt;    &lt;property name=&quot;filters&quot; value=&quot;${druid.filters}&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSourceProxy&quot;      class=&quot;org.springframework.jdbc.datasource        .TransactionAwareDataSourceProxy&quot;&gt;    &lt;property name=&quot;targetDataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot;       class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;dataSourceProxy&quot;/&gt;&lt;/bean&gt;&lt;!--事务管理器配置--&gt;&lt;bean id=&quot;transactionManager&quot;      class=&quot;org.springframework.jdbc.datasource.        DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceProxy&quot;/&gt;&lt;/bean&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--expose-proxy=&quot;true&quot;--&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;    &lt;!-- 只对业务逻辑层实施事务 --&gt;    &lt;!--匹配规则详见笔记：Spring基础概念--&gt;    &lt;aop:pointcut id=&quot;txPointcut&quot;        expression=&quot;execution(* com.haien            .chapter16..service..*+.*(..))&quot;/&gt;    &lt;aop:advisor id=&quot;txAdvisor&quot; advice-ref=&quot;txAdvice&quot;         pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt;&lt;bean class=&quot;com.haien.chapter16.spring.SpringUtils&quot;/&gt;&lt;import resource=&quot;classpath:spring-config-cache.xml&quot;/&gt;&lt;import resource=&quot;classpath:spring-config-shiro.xml&quot;/&gt;</code></pre></li><li><p>controller层无权限会抛出UnauthorizationException，被全局异常处理器截获并返回unauthorized.jsp。</p></li><li><p>spring-mvc.xml：扫描controller类、引入spring-mvc-shiro.xml。</p><pre><code>&lt;!--引入常量配置文件--&gt;&lt;context:property-placeholder     location=&quot;classpath:resources.properties&quot;/&gt;&lt;!-- 开启controller注解支持 --&gt;&lt;context:component-scan        base-package=&quot;com.haien.chapter16.web.controller&quot;        use-default-filters=&quot;false&quot;&gt;    &lt;context:include-filter type=&quot;annotation&quot;        expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;!--扫描全局异常处理类，否则改类不起作用--&gt;    &lt;context:include-filter type=&quot;annotation&quot;        expression=&quot;org.springframework.web.bind.annotation.            ControllerAdvice&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--注册@CurrentUser参数解析器，用在IndexController中，从request中获取shiro sysUser拦截器放入的当前登录User对象--&gt;&lt;mvc:annotation-driven&gt;    &lt;mvc:argument-resolvers&gt;        &lt;bean          class=&quot;com.haien.chapter16.web.bind                    .method.CurrentUserMethodArgumentResolver&quot;/&gt;    &lt;/mvc:argument-resolvers&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- 当在web.xml中DispatcherServlet使用 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 映射时，能映射静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 静态资源映射 --&gt;&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/WEB-INF/static/&quot;/&gt;&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;&lt;bean id=&quot;defaultViewResolver&quot;      class=&quot;org.springframework.web.servlet.view.        InternalResourceViewResolver&quot;      p:order=&quot;1&quot;&gt;    &lt;property name=&quot;viewClass&quot;         value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;    &lt;property name=&quot;contentType&quot; value=&quot;text/html&quot;/&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;!-- 控制器异常处理 --&gt;&lt;bean id=&quot;exceptionHandlerExceptionResolver&quot;      class=&quot;org.springframework.web.servlet.mvc.method.annotation                .ExceptionHandlerExceptionResolver&quot;&gt;&lt;/bean&gt;&lt;bean     class=&quot;com.haien.chapter16.web.exception.DefaultExceptionHandler&quot;/&gt;&lt;import resource=&quot;spring-mvc-shiro.xml&quot;/&gt;</code></pre></li><li><a href="mvc:default-servlet-handler/" target="_blank" rel="noopener">mvc:default-servlet-handler/</a>：由于web.xml中DispatcherServlet使用<url-pattern>/</url-pattern>拦截all请求，会将静态资源的请求也拦截，导致找不到对应的controller处理，加上此标签会在SpringMvc上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，检查进入DispatcherServlet的url，发现是对静态资源的请求则将该请求转由web服务器默认的Servlet处理，不是则由DispatcherServlet继续处理。</li><li><p>一般web应用服务器默认的Servlet名为“default”，DefaultServletHttpRequestHandler可以找到它。但如果你所有的web服务器的默认Servlet名不是“default”，则需要通过default-servlet-name属性显式指定：</p><pre><code>&lt;mvc:default-servlet-handler     default-servlet-name=&quot;所使用的Web服务器默认使用的Servlet名称&quot; /&gt;</code></pre></li><li><p>&lt;mvc:resources /&gt;：除此之外，还可以利用此标签明确匹配url和静态资源。</p><pre><code>&lt;mvc:resources location=&quot;/,classpath:/META-INF/publicResources/&quot;     mapping=&quot;/resources/**&quot;/&gt;</code></pre></li><li><p>以上，将Web根路径（webapp）”/“及类路径下/META-INF/publicResources/ 的目录映射为/resources路径。假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。</p></li><li><p><a href="https://www.cnblogs.com/dflmg/p/6393416.html" target="_blank" rel="noopener">参考文章</a></p></li><li><p>web.xml：配置Spring监听器、shiro安全过滤器、Servlet编码过滤器、Dispatcherservlet分发器，以下只列出重要的。</p></li></ul><pre><code>&lt;!--加上这个可以在注册bean时切换bean作用域scope--&gt;&lt;listener&gt;    &lt;listener-class&gt;        org.springframework.web.context.request.RequestContextListener    &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- shiro 安全过滤器 --&gt;&lt;filter&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;        org.springframework.web.filter.DelegatingFilterProxy    &lt;/filter-class&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;init-param&gt;        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt;</code></pre><ul><li><dispatcher>REQUEST</dispatcher>：指定被分发的请求种类，默认request，如果此次请求非request则不会走该过滤器，也就是不会被分发给controller处理。它必须写在filter-mapping的最后。取值：<ul><li>REQUEST：只要发起的请求是一次http请求，如某个url发起了一次get、post请求，或者发起相当于两次请求的重定向，那么就会走该过滤器。</li><li>FORWARD：请求是转发才走过滤器。</li><li>INCLUDE：只要是通过&lt;jsp:include page=”xxx.jsp” /&gt;嵌入进来的页面，每嵌入一个页面，都会走一次该过滤器。</li><li>ERROR：当触发了一次error时，就会走一次该过滤器。什么是触发error？比如我在web.xml中配置了<error-page></error-page>，当后台返回400/404/500时，容器就会将请求转发到一下错误页面，这就触发了一次error。，走进了过滤器。虽然这是转发的过程，但是配置成FORWARD并不会走过滤器。</li></ul></li><li><a href="https://www.cnblogs.com/xrq730/p/4929029.html" target="_blank" rel="noopener">参考文章</a></li></ul><pre><code>&lt;error-page&gt;    &lt;error-code&gt;400&lt;/error-code&gt;    &lt;location&gt;/filter/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;    &lt;error-code&gt;404&lt;/error-code&gt;    &lt;location&gt;/filter/error.jsp&lt;/location&gt;&lt;/error-page&gt;&lt;error-page&gt;    &lt;error-code&gt;500&lt;/error-code&gt;    &lt;location&gt;/filter/error.jsp&lt;/location&gt;&lt;/error-page&gt;</code></pre><h3 id="用户验证链"><a href="#用户验证链" class="headerlink" title="用户验证链"></a>用户验证链</h3><ul><li>使用基于表单的拦截器实现用户验证，自定义了UserRealm，重写其中doGetAuthenticationInfo()验证用户提交的表单信息是否与数据库匹配。</li><li>调用链从高级到低级：</li></ul><ol><li>PathMatchingFilter.preHandle()</li><li>AccessControlFilter.onPreHandle()</li><li>FormAuthenticationFilter.onAccessDenied()</li><li>DelegatingSubject.login()</li><li>ModularRealmAuthenticator.doAuthenticate()</li><li>UserRealm.doGetAuthenticationInfo()</li></ol><ul><li>也就是说FormAuthenticationFilter是会调用login()的，而login()又会调用Realm，所以FormAuthenticationFilter的登录验证是通过Realm实现的。</li></ul><h3 id="自定义注解-注解解析器-使用实例"><a href="#自定义注解-注解解析器-使用实例" class="headerlink" title="自定义注解+注解解析器+使用实例"></a>自定义注解+注解解析器+使用实例</h3><ul><li>@CurrentUser：自定义注解</li></ul><pre><code>/** * @Author haien * @Description 绑定当前登录的用户 * @Date 2019/3/14 **///测试此注解作用@Target({ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CurrentUser {    //Constants类CURRENT_USER常量=&quot;user&quot;，    //因为当前登录用户在request中存为user属性，    //所以将此注解用于方法参数，再定义一个解析器解析此注解：    //获取此注解值并从request中查找属性赋给方法参数，    //即实现了绑定当前用户到方法属性的功能。    String value() default Constants.CURRENT_USER; }</code></pre><ul><li>CurrentUserMethodArgumentResolver：自定义注解解析器</li></ul><pre><code>public class CurrentUserMethodArgumentResolver         implements HandlerMethodArgumentResolver {    public CurrentUserMethodArgumentResolver() {    }    /**     * @Author haien     * @Description 判断参数是否受支持，依据是它是否拥有CurrentUser注解     * @Date 2019/3/14     * @Param [parameter]     * @return boolean     **/    @Override    public boolean supportsParameter(MethodParameter parameter) {        //判断参数是否被注解了        if(parameter.hasParameterAnnotation(CurrentUser.class)){            return true;        }        return false;    }    /**     * @Author haien     * @Description 对被注解参数的解析是：                    获取当前登录对象并返回给此参数     * @Date 2019/3/14     * @Param [parameter, mavContainer, webRequest, binderFactory]     * @return java.lang.Object     **/    @Override    public Object resolveArgument(MethodParameter parameter,            ModelAndViewContainer mavContainer,            NativeWebRequest webRequest,            WebDataBinderFactory binderFactory) throws Exception {        CurrentUser currentUserAnnotation=            parameter.getParameterAnnotation(CurrentUser.class);        //currentUserAnnotation.value()返回“user”，        //从request获取“user”属性        return webRequest.getAttribute(currentUserAnnotation.value(),                NativeWebRequest.SCOPE_REQUEST);    }}</code></pre><ul><li>IndexController：使用注解</li></ul><pre><code>@RequestMapping(&quot;/&quot;)public String index(@CurrentUser User loginUser, Model model) { //@CurrentUser获取当前登录对象并赋给loginUser    //根据用户名查询权限字符串    Set&lt;String&gt; permissions =         userService.findPermissions(loginUser.getUsername());    //查询跟这些权限有关的菜单    List&lt;Resource&gt; menus = resourceService.findMenus(permissions);    model.addAttribute(&quot;menus&quot;, menus);    return &quot;index&quot;;}</code></pre><h3 id="使用Spring的Cache代替Shiro的Cache"><a href="#使用Spring的Cache代替Shiro的Cache" class="headerlink" title="使用Spring的Cache代替Shiro的Cache"></a>使用Spring的Cache代替Shiro的Cache</h3><ul><li>因为shiro自己的cache每次都要手动清除缓存，才能防止修改后有获取到未更新的缓存，所以使用spring提供的cache，并连同shiro cache中一些较好的方法封装起来。</li><li><p>以前的shiro cache：</p><pre><code>&lt;!-- 缓存管理器 使用Ehcache实现 --&gt;&lt;bean id=&quot;cacheManager&quot;       class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;    &lt;property name=&quot;cacheManagerConfigFile&quot;         value=&quot;classpath:ehcache.xml&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>现在：</p><pre><code>//spring-config-cache.xml&lt;!--底层使用ehcache--&gt;&lt;bean id=&quot;ehcacheManager&quot;      class=&quot;org.springframework.cache.ehcache.        EhCacheManagerFactoryBean&quot;&gt;    &lt;property name=&quot;configLocation&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;&lt;/bean&gt;&lt;!--将=引入以上CacheManager--&gt;&lt;bean id=&quot;springCacheManager&quot;         class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;ehcacheManager&quot;/&gt;&lt;/bean&gt;//spring-config-shiro.xml&lt;!-- 缓存管理器 --&gt;&lt;bean id=&quot;cacheManager&quot;     class=&quot;com.haien.spring.SpringCacheManagerWrapper&quot;&gt;    &lt;!--定义在spring-config-cache.xml中--&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;springCacheManager&quot;/&gt;&lt;/bean&gt;/** * @Author haien * @Description 包装Spring Cache，因为spring的cache没有shiro的cache那些功能， *              但又有其优点，所以给它封装一些shiro中比较好的方法进去。 * @Date 2019/3/16 **/public class SpringCacheManagerWrapper implements CacheManager {    private org.springframework.cache.CacheManager cacheManager;    //由xml文件注入一个Spring框架的cache对象    public void setCacheManager(org.springframework.cache.CacheManager cacheManager){        this.cacheManager=cacheManager;    }    /**     * @Author haien     * @Description 获取注入进来的cache对象并封装成SpringCacheWrapper对象，     *              其中就提供了shiro中较好的方法。     * @Date 2019/3/16     * @Param [name]     * @return org.apache.shiro.cache.Cache&lt;K,V&gt;     **/    @Override    public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException {        //获取上面setCacheManager()        org.springframework.cache.Cache springCache=cacheManager.getCache(name);        return new SpringCacheWrapper(springCache);    }    /**     * @Author haien     * @Description 内部类：继承shiro的Cache，重写了它的方法，                    封装给当前类的springcache对象     * @Date 2019/3/16     **/    static class SpringCacheWrapper implements Cache{ //继承shiro的cache        private org.springframework.cache.Cache springCache;        SpringCacheWrapper(org.springframework.cache.Cache springCache) {            this.springCache = springCache;        }        @Override        public Object get(Object key) throws CacheException {            Object value=springCache.get(key);            if(value instanceof SimpleValueWrapper)                 return ((SimpleValueWrapper)value).get();            return value;        }        @Override        public Object put(Object key, Object value) throws CacheException {            springCache.put(key,value);            return value;        }        @Override        public Object remove(Object key) throws CacheException {            springCache.evict(key);            return null;        }        @Override        public void clear() throws CacheException {            springCache.clear();        }        @Override        public int size() {            if(springCache.getNativeCache() instanceof Ehcache){                Ehcache ehcache=(Ehcache)springCache.getNativeCache();                return ehcache.getSize();            }            throw new UnsupportedOperationException(                    &quot;invoke spring cache abstract size method not supported&quot;);        }        @Override        public Set keys() {            if(springCache.getNativeCache() instanceof Ehcache){                Ehcache ehcache=(Ehcache)springCache.getNativeCache();                return new HashSet(ehcache.getKeys());            }            throw new UnsupportedOperationException(                    &quot;invoke spring caceh abstract keys method not supported&quot;);        }        @Override        public Collection values() {            if(springCache.getNativeCache() instanceof Ehcache){                Ehcache ehcache=(Ehcache)springCache.getNativeCache();                List keys=ehcache.getKeys();                if(!CollectionUtils.isEmpty(keys)){                    List values=new ArrayList(keys.size());                    for(Object key:keys){                        Object value=get(key);                        if(value!=null)                            values.add(value);                    }                    return Collections.unmodifiableList(values);                }else{                    return Collections.emptyList();                }            }            throw new UnsupportedOperationException(                    &quot;invoke spring cache abstract values method not supported&quot;);        }    }}</code></pre></li><li><p><a href="https://jinnianshilongnian.iteye.com/blog/2037222" target="_blank" rel="noopener">参考文章</a></p></li><li>代码示例：ideaProjects/shiro-chapter16</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统功能&quot;&gt;&lt;a href=&quot;#系统功能&quot; class=&quot;headerlink&quot; title=&quot;系统功能&quot;&gt;&lt;/a&gt;系统功能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;根据用户权限获取菜单集合，返回前端显示。当前只有admin/123456。&lt;/li&gt;
&lt;li&gt;本系统实体包括用户
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%8A%A8%E6%80%81url%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十九章-动态url权限控制、拦截器自定义/</id>
    <published>2019-04-30T08:29:23.037Z</published>
    <updated>2019-04-28T07:42:48.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>即访问url时进行权限匹配，如果没有权限则直接跳到错误页面。</li><li>在Shiro中，更多的是通过AOP进行方法级别的权限控制，而通过url进行权限控制是一种集中的权限控制。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>拦截器：如authc、anon等字符串为一个拦截器；拦截器链：url=authc为一条拦截器链；拦截器链集合：url1=authc，url2=anon为拦截器链集合。</li><li>仿chapter16的示例，主要功能是用户、公司、角色和资源之间关系的调整，如修改用户所属公司、所有角色，资源所需权限、角色所有资源等。</li><li>数据库：除user、organization、role、resource外，新增一张url-filter表，映射url和角色、权限之间的关系（多个角色、权限之间用逗号分隔），即动态的拦截器链。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7686.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>实体：多一个URLFilter类，封装url和权限、角色间的关系。</li></ul><pre><code>public class UrlFilter implements Serializable {    private Long id;    private String name; //url名称或描述    private String url; //地址    private String roles; //所需角色，可省略，用逗号分隔    private String permissions; //所需权限，可省略，用逗号分隔    //setter/getter}</code></pre><ul><li>dao、service、controller层都增加对UrlFilter的增删查改。</li><li>controller层撤销shiro的权限注解，因为要用数据库中动态的拦截器链来实现。</li><li>因为数据库中的拦截器链都是要合并到shiro中的，所以在service层中，更新数据库拦截器链后，要重置shiro中的拦截器链集合，以同步此更新，否则更新不生效。比如：</li></ul><pre><code>@Overridepublic void deleteUrlFilter(Long urlFilterId) {    urlFilterDao.deleteUrlFilter(urlFilterId);    initFilterChain();}/** * @Author haien * @Description 初始化Shiro的url拦截器，用于在url表改动后，                将数据库发送的改动同步到Shiro中。 * @Date 2019/4/5 * @Param [] * @return void **/@PostConstruct //当DI容器实例化当前bean时，该方法会自动执行public void initFilterChain() {    //将配置文件和数据库的拦截器链合并    shiroFilerChainManager.initFilterChains(findAll()); //先清空集合再去加载}</code></pre><ul><li>ShiroFilterChainManager: 调用了FilterChainManager的方法，先清空拦截器链集合再重新加载。</li></ul><pre><code>@Servicepublic class ShiroFilterChainManager {    //过滤链管理器，管理所有过滤器，包含增删查改等操作    @Resource    private DefaultFilterChainManager filterChainManager; //注入的是                                                    //CustomDefaultFilterChainManager    //默认过滤链，包含在配置文件中提到的所有过滤器    private Map&lt;String,NamedFilterList&gt; defaultFilterChains;    /**     * @Author haien     * @Description 获取配置文件中all过滤器，之后会自动与数据库中包含的过滤器合并     * @Date 2019/4/5     * @Param []     * @return void     **/    @PostConstruct //DI容器实例化该bean时自动执行该方法    public void inti(){        //获取配置文件中all拦截器（静态的，不会变）        defaultFilterChains=new HashMap&lt;&gt;(filterChainManager.getFilterChains());    }    /**     * @Author haien     * @Description 初始化过滤链，默认+数据库     * @Date 2019/4/5     * @Param [urlFilters]     * @return void     **/    public void initFilterChains(List&lt;UrlFilter&gt; urlFilters){        //1. 删除以前老的filter chain并注册默认的        filterChainManager.getFilterChains().clear();        if(defaultFilterChains!=null)            filterChainManager.getFilterChains().putAll(defaultFilterChains);        //2. 注册数据库中的        for(UrlFilter urlFilter:urlFilters){            String url=urlFilter.getUrl();            //注册roles-filter关系的过滤器            if(!StringUtils.isEmpty(urlFilter.getRoles()))                filterChainManager.addToChain(url,&quot;roles&quot;,urlFilter.getRoles());            //注册perms-filter关系的拦截器            if(!StringUtils.isEmpty(urlFilter.getPermissions()))                filterChainManager.addToChain(url,&quot;perms&quot;,urlFilter.getPermissions());        }    }}</code></pre><ul><li>为了实现本例功能，加载数据库中动态的拦截器链，我们需要自定义FilterChainManager；而为了实现一个url匹配多个拦截器链，我们还要自定义FilterChainResolver。下面先介绍一下这俩都是什么。</li></ul><h3 id="PathMatchingFilterChainResolver过滤链解析器"><a href="#PathMatchingFilterChainResolver过滤链解析器" class="headerlink" title="PathMatchingFilterChainResolver过滤链解析器"></a>PathMatchingFilterChainResolver过滤链解析器</h3><ul><li>按照第八章过滤链步骤，第一步是要先根据当前请求的url获取拦截器链。</li><li>PathMatchingFilterChainResolver：遍历配置文件中all拦截器链，如，/<strong>=athc，将其名字/</strong>与当前url/index比对，匹配则执行该拦截器链，如，/**匹配/index。所以，如果要改变url的拦截器匹配方法，则要自定义Resolver。</li></ul><pre><code>public FilterChain getChain(ServletRequest request, ServletResponse response,         FilterChain originalChain) {    //1、首先获取拦截器链管理器    FilterChainManager filterChainManager = getFilterChainManager();    if (!filterChainManager.hasChains()) {        return null;    }    //2、接着获取当前请求的URL（不带上下文）    String requestURI = getPathWithinApplication(request);    //3、遍历配置文件中all拦截器链（拦截器链的名字就是URL，如/**）    for (String pathPattern : filterChainManager.getChainNames()) {        //4、如匹配当前url        if (pathMatches(pathPattern, requestURI)) {            //5、和原始拦截器链进行合并后返回            return filterChainManager.proxy(originalChain, pathPattern);        }    }    return null;}</code></pre><ul><li><p>缺点：最后一步找到即返回，如果后面还有其他拦截器也是匹配当url的呢？后面我们会自定义一个能将all拦截器链合并返回的解析器。</p></li><li><p>第1步中，默认使用DefaultFilterChainManager管理拦截器链，其内部采用Map管理url-拦截器链的关系，因为Map不可重复，所以每个url只能配置一条拦截器链（但可以包含多个拦截器），如果定义了多条则最终采用哪条也说不定。</p></li><li>FilterChainManager接口：主要功能是注册拦截器链、添加拦截器以及对原始拦截器链生成代理之后的拦截器链。如果要实现动态url-拦截器配置，即注册数据库中定义的拦截器链的话，就要自定义Manager。</li></ul><pre><code>public interface FilterChainManager {      Map&lt;String, Filter&gt; getFilters(); //得到注册的拦截器      void addFilter(String name, Filter filter); //注册拦截器      void addFilter(String name, Filter filter, boolean init); //注册拦截器      //根据拦截器链定义创建拦截器链     void createChain(String chainName, String chainDefinition);      void addToChain(String chainName, String filterName); //添加拦截器到指定的拦截器链      //添加拦截器（带配置，指明所需权限或角色）到指定的拦截器链      void addToChain(String chainName, String filterName,         String chainSpecificFilterConfig) throws ConfigurationException;     NamedFilterList getChain(String chainName); //获取拦截器链      boolean hasChains(); //是否有拦截器链      Set&lt;String&gt; getChainNames(); //得到所有拦截器链的名字      //使用指定的拦截器链代理原始拦截器链     FilterChain proxy(FilterChain original, String chainName); }</code></pre><ul><li><p>解析以下配置文件：filters定义了拦截器，filterChainDefinitions定义了拦截器链，/login为拦截器链名字，user,sysUser是拦截器名字。</p><pre><code>&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;      ……      &lt;property name=&quot;filters&quot;&gt;          &lt;util:map&gt;              &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;              &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;          &lt;/util:map&gt;      &lt;/property&gt;      &lt;property name=&quot;filterChainDefinitions&quot;&gt;          &lt;value&gt;              /login = authc              /logout = logout              /authenticated = authc              /** = user,sysUser          &lt;/value&gt;      &lt;/property&gt;  &lt;/bean&gt;   </code></pre></li><li><p>前面说过PathMatchingFilterChainResolver和DefaultFilterChainManager不能满足我们的需求，我们稍微扩展一下。</p></li><li>CustomPathMatchingFilterChainResolver：本例自定义的Resolver;返回匹配当前url的多条拦截器链，默认的只能返回第一条。</li></ul><pre><code>public class CustomPathMatchingFilterChainResolver      extends PathMatchingFilterChainResolver {  //继承自默认解析器      private CustomDefaultFilterChainManager customDefaultFilterChainManager;        //Manager setter      public void setCustomDefaultFilterChainManager(              CustomDefaultFilterChainManager customDefaultFilterChainManager) {            this.customDefaultFilterChainManager = customDefaultFilterChainManager;            setFilterChainManager(customDefaultFilterChainManager);        }        //为当前url匹配拦截器链，匹配多条，而不是遇到一条就返回      @Override      public FilterChain getChain(ServletRequest request, ServletResponse response,             FilterChain originalChain) {            FilterChainManager filterChainManager = getFilterChainManager();            if (!filterChainManager.hasChains()) {                return null;            }            //遍历配置文件all拦截器链          String requestURI = getPathWithinApplication(request);            List&lt;String&gt; chainNames = new ArrayList&lt;String&gt;(); //拦截器链集合          for (String pathPattern : filterChainManager.getChainNames()) {              if (pathMatches(pathPattern, requestURI)) {                  //遇到匹配的不急着返回，而是添加到集合                chainNames.add(pathPattern);               }            }            //集合为空则返回null          if(chainNames.size() == 0) {              return null;            }            return customDefaultFilterChainManager.proxy(originalChain, chainNames);        }      }</code></pre><ul><li>CustomDefaultFilterChainManager：本例自定义的Manager；主要是改变注册拦截器链的方式，比如说吧数据库中的合并进来。</li></ul><pre><code>public class CustomDefaultFilterChainManager extends DefaultFilterChainManager {      //配置文件中all拦截器链，即默认的静态拦截器链，会与数据库中动态的拦截器链合并    private Map&lt;String, String&gt; filterChainDefinitionMap = null;      //登录地址    private String loginUrl;      //登录成功后默认跳转地址    private String successUrl;    //未授权跳转地址    private String unauthorizedUrl;      public CustomDefaultFilterChainManager() {          //调用父类方法，注册默认拦截器        setFilters(new LinkedHashMap&lt;String, Filter&gt;());          //注册默认拦截器链        setFilterChains(new LinkedHashMap&lt;String, NamedFilterList&gt;());          addDefaultFilters(true);      }      //省略setter    //注册我们自定义的拦截器，相当于ShiroFilterFactoryBean的filters属性    //只要是我们在配置文件中声明注册bean的，不管shiro本身提供的还是我们自定义的拦截器，    //都算自定义拦截器    public void setCustomFilters(Map&lt;String, Filter&gt; customFilters) {          for(Map.Entry&lt;String, Filter&gt; entry : customFilters.entrySet()) {              addFilter(entry.getKey(), entry.getValue(), false);          }      }      //解析配置文件中all拦截器链，相当于ShiroFilterFactoryBean的filterChainDefinitions    public void setDefaultFilterChainDefinitions(String definitions) {          Ini ini = new Ini();          ini.load(definitions);          Ini.Section section = ini.getSection(IniFilterChainResolverFactory.URLS);          if (CollectionUtils.isEmpty(section)) {              section = ini.getSection(Ini.DEFAULT_SECTION_NAME);          }          setFilterChainDefinitionMap(section);      }      @PostConstruct //Spring容器启动时自动调用    public void init() {          ////给拦截器配置上属性，这里是三个url        Map&lt;String, Filter&gt; filters = getFilters();          if (!CollectionUtils.isEmpty(filters)) { //判空            //注册拦截器            for (Map.Entry&lt;String, Filter&gt; entry : filters.entrySet()) {                  String name = entry.getKey(); //拦截器名                Filter filter = entry.getValue(); //配置，即角色或权限                applyGlobalPropertiesIfNecessary(filter); //给拦截器设置三个url                 if (filter instanceof Nameable) {                      ((Nameable) filter).setName(name);                  }                addFilter(name, filter, false);              }          }          //将拦截器构建成拦截器链        Map&lt;String, String&gt; chains = getFilterChainDefinitionMap();          if (!CollectionUtils.isEmpty(chains)) { //判空             for (Map.Entry&lt;String, String&gt; entry : chains.entrySet()) {                  String url = entry.getKey(); //如，/**                String chainDefinition = entry.getValue(); //如，authc,user                createChain(url, chainDefinition); //创建过滤器链             }          }      }      protected void initFilter(Filter filter) {          //ignore，因为交给Spring管理了，因此Filter的相关配置会在Spring配置中完成      }      //组合多个拦截器链为一个新的FilterChain代理    public FilterChain proxy(FilterChain original, List&lt;String&gt; chainNames) {        //chainNames中的元素，如，/index、/**        NamedFilterList configured = new SimpleNamedFilterList(chainNames.toString());         //遍历过滤器链名，找到对应的过滤器链，添加到集合        for(String chainName : chainNames) {              configured.addAll(getChain(chainName));          }        //再和原始的过滤器链合并        return configured.proxy(original);      }      private void applyGlobalPropertiesIfNecessary(Filter filter) {          applyLoginUrlIfNecessary(filter);          applySuccessUrlIfNecessary(filter);          applyUnauthorizedUrlIfNecessary(filter);      }      private void applyLoginUrlIfNecessary(Filter filter) {          ...配置loginUrl...    }      private void applySuccessUrlIfNecessary(Filter filter) {          ...配置SuccessUrl...    }      private void applyUnauthorizedUrlIfNecessary(Filter filter) {          ...配置UnauthorizedUrl...    }  }</code></pre><ul><li><p>spring-config-shiro.xml: 其中拦截器链的配置较特别。</p><pre><code>&lt;!-- 基于Form表单的身份验证过滤器 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot;      class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt;    &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt;    &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt;    &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;sysUserFilter&quot;      class=&quot;com.haien.chapter16.web.shiro.filter.SysUserFilter&quot;/&gt;&lt;!--自定义的拦截器链管理器，要添加数据库中动态的拦截器链就必须自定义--&gt;&lt;bean id=&quot;filterChainManager&quot;      class=&quot;com.haien.chapter19.service.impl.CustomDefaultFilterChainManager&quot;&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;    &lt;property name=&quot;successUrl&quot; value=&quot;/&quot;/&gt;    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;    &lt;property name=&quot;customFilters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login = authc            /logout = logout            /authenticated = authc            /** = user,sysUser        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;&lt;!--拦截器链解析器，为当前url匹配多条拦截器链；注入以上管理器--&gt;&lt;bean id=&quot;filterChainResolver&quot;      class=&quot;com.haien.chapter19.service.impl.CustomPathMatchingFilterChainResolver&quot;&gt;    &lt;property name=&quot;customDefaultFilterChainManager&quot; ref=&quot;filterChainManager&quot;/&gt;&lt;/bean&gt;&lt;!-- Shiro的Web过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;!--拦截器链配置已被拦截器链管理器代劳    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login = authc            /logout = logout            /authenticated = authc            /** = user,sysUser        &lt;/value&gt;    &lt;/property&gt;    --&gt;&lt;/bean&gt;&lt;!--最后把filterChainResolver设置给ShiroFilter，其使用它进行动态url动态控制--&gt;&lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;    &lt;property name=&quot;targetObject&quot; ref=&quot;shiroFilter&quot;/&gt;    &lt;property name=&quot;targetMethod&quot; ref=&quot;setFilterChainResolver&quot;/&gt;    &lt;property name=&quot;arguments&quot; ref=&quot;filterChainResolver&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>测试：</p></li></ul><ol><li>访问/urlFilter；</li><li>跳转登录页面，登录后点击新增，增加以下拦截器链：</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/e529ffa2-c6da-392d-af0a-7817716d2870.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不用分配任何权限。</p><ol start="3"><li>再访问/user则要求用户拥有aa角色，因此跳转未授权页面。</li><li>在数据库中将aa角色添加给用户，再访问/user则可以访问了。</li></ol><ul><li>代码实例：ideaProjects/shiro-chapter19</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2040929" target="_blank" rel="noopener">《跟我学Shiro》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;即访问url时进行权限匹配，如果没有权限则直接跳到错误页面。&lt;/li&gt;
&lt;li&gt;在Shiro中，更多的是通过AOP进行方法级别的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E4%B8%8ESpring%E9%9B%86%E6%88%90%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%88%9D%E8%A7%A3/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十二章-与Spring集成、配置文件初解/</id>
    <published>2019-04-30T08:29:23.032Z</published>
    <updated>2019-03-07T07:33:21.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Shiro的组件都是Javabean/pojo式的组件，所以非常容易使用Spring进行组件管理,可以非常方便得从ini配置转为Spring配置（如xml配置文件）。</li></ul><h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><ul><li><p>依赖</p><pre><code>&lt;!--单元测试--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.9&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--集成Spring做测试必备的依赖，比如要注入Spring容器中的bean--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!--用于开启事务，否则测试将无法自动回滚--&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-logging&lt;/groupId&gt;  &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;  &lt;version&gt;1.1.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;  &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;  &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;  &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;  &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!--使用quartz要用到的--&gt;  &lt;groupId&gt;commons-collections&lt;/groupId&gt;  &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;  &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql数据库及druid连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid&lt;/artifactId&gt;  &lt;version&gt;0.2.23&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;!--使用JdbcTemplate，方便数据库操作--&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>spring-shiro.xml：取代ini配置，提供了普通JavaSE应用的Spring配置。</p><pre><code>&lt;!-- 缓存管理器 使用Ehcache实现 --&gt;&lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;    &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot;/&gt;&lt;/bean&gt;&lt;!-- 凭证匹配器 --&gt;&lt;bean id=&quot;credentialsMatcher&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher&quot;&gt;    &lt;constructor-arg ref=&quot;cacheManager&quot;/&gt;    &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt;    &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt;    &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;&lt;!-- Realm实现 --&gt;&lt;bean id=&quot;userRealm&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.realm.UserRealm&quot;&gt;    &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt;    &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt;    &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话ID生成器 --&gt;&lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;/&gt;&lt;!-- 会话DAO --&gt;&lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt;    &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt;    &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话验证调度器 --&gt;&lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt;    &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot;/&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;&lt;/bean&gt;&lt;!-- 会话管理器 --&gt;&lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.session.mgt.DefaultSessionManager&quot;&gt;    &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt;    &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt;   &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt;    &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt;&lt;/bean&gt;&lt;!-- 安全管理器 --&gt;&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.mgt.DefaultSecurityManager&quot;&gt;    &lt;property name=&quot;realms&quot;&gt;        &lt;list&gt;&lt;ref bean=&quot;userRealm&quot;/&gt;&lt;/list&gt;    &lt;/property&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;&lt;/bean&gt;&lt;!-- 相当于调用SecurityUtils.setSecurityManager(securityManager) --&gt;&lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;&lt;property name=&quot;staticMethod&quot; value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;/&gt;    &lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot;/&gt;&lt;/bean&gt;&lt;!-- Shiro生命周期处理器--&gt;&lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt;</code></pre></li><li><p>其中，Realm实现需要注入userService的bean，它不在本配置文件，而在以下spring-beans.xml中，一样可以找到的。</p></li><li><p>spring-beans.xml</p><pre><code>&lt;!-- 数据库连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/shiro&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;!-- Base DAO: abstract=&quot;true&quot;即该类不能被实例化，默认false；抽象bean可以不映射任何类 --&gt;&lt;bean id=&quot;baseDao&quot; abstract=&quot;true&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- DAO --&gt;&lt;bean id=&quot;permissionDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.PermissionDaoImpl&quot; parent=&quot;baseDao&quot;/&gt;&lt;bean id=&quot;roleDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.RoleDaoImpl&quot; parent=&quot;baseDao&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.UserDaoImpl&quot; parent=&quot;baseDao&quot;/&gt;&lt;!-- Service --&gt;&lt;bean id=&quot;permissionService&quot; class=&quot;com.haien.shirochapter12.service.impl.PermissionServiceImpl&quot;&gt;    &lt;property name=&quot;permissionDao&quot; ref=&quot;permissionDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;roleService&quot; class=&quot;com.haien.shirochapter12.service.impl.RoleServiceImpl&quot;&gt;    &lt;property name=&quot;roleDao&quot; ref=&quot;roleDao&quot;/&gt;&lt;/bean&gt;&lt;!--帮助加密密码--&gt;&lt;bean id=&quot;passwordHelper&quot; class=&quot;com.haien.shirochapter12.service.impl.PasswordHelper&quot;&gt;    &lt;property name=&quot;algorithmName&quot; value=&quot;md5&quot;/&gt;    &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.haien.shirochapter12.service.impl.UserServiceImpl&quot;&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;    &lt;property name=&quot;passwordHelper&quot; ref=&quot;passwordHelper&quot;/&gt;&lt;/bean&gt;&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=&quot;transactionManager&quot;      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;&lt;!--开启事务--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre></li><li>分别写User,Role,Permission的entity,dao,service层、实现身份验证和授权的UserRealm。</li><li>ShiroTest：测试类，测试前删除各表数据，重新插入，分配角色和用户给用户；主要测试方法则是以某个用户登录，判断是否拥有权限。</li></ul><pre><code>@Testpublic void test() {    Subject subject = SecurityUtils.getSubject();    UsernamePasswordToken token = new UsernamePasswordToken(u1.getUsername(), password);    subject.login(token);    Assert.assertTrue(subject.isAuthenticated());    subject.checkRole(&quot;admin&quot;);    subject.checkPermission(&quot;user:create&quot;);    userService.changePassword(u1.getId(), password + &quot;1&quot;);    userRealm.clearCache(subject.getPrincipals());    token = new UsernamePasswordToken(u1.getUsername(), password + &quot;1&quot;);    subject.login(token);}</code></pre><h3 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h3><ul><li><p>spring-shiro-web.xml:web应用和JavaSE应用的shiro配置是类似的，此处提供一些不一样的配置.</p><pre><code>&lt;!-- web:会话Cookie模板 --&gt;&lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;    &lt;!--设置cookie名，默认为JSESSIONID--&gt;    &lt;constructor-arg value=&quot;sid&quot;/&gt;    &lt;!--设置cookie过期时间，单位秒，默认-1，即关闭浏览器时过期--&gt;    &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt;    &lt;!--true表示客户端不会暴露脚本代码，有助于减少某些类型的跨站点脚本攻击，    Servlet2.5及以上才支持--&gt;    &lt;property name=&quot;maxAge&quot; value=&quot;180000&quot;/&gt;&lt;/bean&gt;&lt;!-- web:会话管理器，使用用于web环境的DefaultWebSessionManager --&gt;&lt;bean id=&quot;sessionManager&quot;      class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!--自己管理--&gt;    &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt;    &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt;    &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt;    &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot;/&gt;    &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt;&lt;/bean&gt;&lt;!-- web:安全管理器，使用用于web环境的DefaultWebSecurityManager --&gt;&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;    &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;&lt;/bean&gt;&lt;!-- web:基于Form表单的身份验证过滤器 --&gt;&lt;bean id=&quot;formAuthenticationFilter&quot;      class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt;    &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt;    &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;&lt;/bean&gt;&lt;!-- web:Shiro的Web过滤器，使用ShiroFilterFactoryBean创建ShiroFilter过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt;    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;    &lt;!--定义自己的过滤器--&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /index.jsp = anon            /unauthorized.jsp = anon            /login.jsp = authc            /logout = logout            /** = user        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li>会话管理器和安全管理器都要换成web环境下的，还要加个过滤器。</li><li>过滤器使用ShiroFilterFactoryBean来创建ShiroFilter过滤器，filters属性用于定义自己的过滤器，即ini配置中的[filters]，filterChianDefinitions用于声明url和filter的关系，即ini配置中的[urls]。</li><li><p>web.xml:</p><pre><code>&lt;!-- Spring配置文件开始  --&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;      classpath:spring-beans.xml,      classpath:spring-shiro-web.xml    &lt;/param-value&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!-- Spring配置文件结束 --&gt;  &lt;!-- shiro 安全过滤器 --&gt;  &lt;!-- The filter-name matches name of a &apos;shiroFilter&apos; bean inside applicationContext.xml --&gt;  &lt;filter&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;    &lt;init-param&gt;      &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;spring&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;async-supported&gt;true&lt;/async-supported&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;spring&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;</code></pre></li><li><p>DelegatingFilterProxy:自动到Spring容器中查找名为shiroFilter的bean（它就定义在spring-shiro-web.xml中），并把filter请求交给它处理。</p></li><li><p>spring-mvc.xml:</p><pre><code>&lt;!--use-default-filters：使用默认过滤器，它会扫描包含@Service、@Component、@Repository、@Controller注解的类；不使用则需用include-filter指定扫描哪些类--&gt;&lt;context:component-scan base-package=&quot;com.haien.shirochapter12.web&quot;     use-default-filters=&quot;false&quot;&gt;    &lt;!--指定只扫描base-package下有@Controller的类--&gt;    &lt;context:include-filter type=&quot;annotation&quot;                            expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;!--指定只扫描base-package下有@ControllerAdvice的类--&gt;    &lt;context:include-filter type=&quot;annotation&quot;             expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--添加shiro spring aop权限注解的支持，即使用注解式授权--&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt; &lt;!--表示使用代理类--&gt;&lt;bean class=&quot;org.apache.shiro.spring.security.interceptor                    .AuthorizationAttributeSourceAdvisor&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;&lt;/bean&gt;&lt;!--启动SpringMvc注解功能，完成请求和注解controller类的映射--&gt;&lt;mvc:annotation-driven/&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; &lt;!--url映射视图，无需通过控制器--&gt;&lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt;&lt;bean id=&quot;defaultViewResolver&quot;      class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;    &lt;property name=&quot;contentType&quot; value=&quot;text/html&quot;/&gt;    &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt;    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt;&lt;!-- 控制器异常处理（好像不写也可以） --&gt;&lt;bean id=&quot;exceptionHandlerExceptionResolver&quot; class=&quot;org.springframework.web.servlet                    .mvc.method.annotation.ExceptionHandlerExceptionResolver&quot;&gt;&lt;/bean&gt;&lt;bean class=&quot;com.haien.shirochapter12.web.exception.DefaultExceptionHandler&quot;/&gt;</code></pre></li><li><p>AnnotationController：上面开启了Shiro注解式访问控制，那么接下来就可以在Controller中使用注解</p></li></ul><pre><code>@Controllerpublic class AnnotationController {    @RequestMapping(&quot;/hello1&quot;)    public String hello1() {        SecurityUtils.getSubject().checkRole(&quot;admin&quot;);        return &quot;success&quot;;    }    @RequiresRoles(&quot;admin&quot;)    @RequestMapping(&quot;/hello2&quot;)    public String hello2() {        return &quot;success&quot;;    }}</code></pre><ul><li>DefaultExceptionHandler：全局异常处理，无权限则返回unauthorized.jsp页面，提示用户无权限。目前数据库只有zhang/123拥有权限，其他如li/123都没有权限。</li></ul><pre><code>@ControllerAdvicepublic class DefaultExceptionHandler {    @ExceptionHandler({UnauthorizedException.class}) //处理controller抛出的该类异常及其子类    @ResponseStatus(HttpStatus.UNAUTHORIZED)    public ModelAndView processUnauthenticatedException(NativeWebRequest request            ,UnauthorizedException e){        ModelAndView mv=new ModelAndView();        mv.addObject(&quot;exception&quot;,e);        mv.setViewName(&quot;unauthorized&quot;);        return mv;    }}</code></pre><ul><li>代码示例：ideaProjects/shirochapter12</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2029717" target="_blank" rel="noopener">《跟我学shiro第十二章》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shiro的组件都是Javabean/pojo式的组件，所以非常容易使用Spring进行组件管理,可以非常方便得从ini配置转为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%99%BB%E5%BD%95%E4%BA%BA%E6%95%B0%E6%8E%A7%E5%88%B6/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第十八章-并发登录人数控制/</id>
    <published>2019-04-30T08:29:23.029Z</published>
    <updated>2019-04-05T06:38:08.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>在某些项目中，一个账户可能只允许一人登录或几个人同时登录，当超过人数时，要么进制后者登录，要么踢出前者登录。</li><li>Spring Security直接提供了相应的功能。</li><li>Shiro没有提供默认实现，但自己添加也是很容易的。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>采用第十六章的示例，主要功能是用户、公司、角色和资源之间关系的调整，如修改用户所属公司、所有角色，资源所需权限、角色所有资源等。</li><li>目的：添加登录人数限制功能。</li><li>KickoutSessionControlFilter：控制登录人数的过滤器。</li></ul><pre><code>public class KickoutSessionControllerFilter extends AccessControlFilter {    //踢出后重定向的地址    private String kickoutUrl;    //是否踢出之后登录的用户，默认false，即踢出之前登录的而用户    private boolean kickoutAfter=false;    //同一账号最大会话数，默认1    private int maxSession=1;    //根据会话id，获取会话进行踢出操作    private SessionManager sessionManager;    //使用cacheManager获取相应cache来缓存用户登录的会话，用于保存用户-会话之间的关系    private Cache&lt;String,Deque&lt;Serializable&gt;&gt; cache;    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response,                                      Object mappedValue) throws Exception {        return false;    }    public void setCacheManager(CacheManager cacheManager) {        //根据name获取cache实例，没有则新建一个        this.cache = cacheManager.getCache(&quot;shiro-kickout-session&quot;);    }    //其他setter    @Override    protected boolean onAccessDenied(ServletRequest request, ServletResponse response)            throws Exception {        Subject subject=getSubject(request,response);        //如果未登录，则直接进行之后的流程        if(!subject.isAuthenticated()&amp;&amp;!subject.isRemembered())            return true; //打断点，看到底和false什么区别！！！        Session session=subject.getSession();        Serializable sessionId=session.getId();        String username=(String)subject.getPrincipal();        //获取之前登录者队列        Deque&lt;Serializable&gt; deque=cache.get(username); //若有多人登录，            //则查询key为username的一条目，其value为包含多个会话的队列        if(deque==null){            deque=new LinkedList&lt;&gt;();            //第一次暂时存储了一个空队列进去，但下一个if将放入会话，            //所以第一次存储了一个包含自身会话的队列            cache.put(username,deque); //存储时键为username，值为之前登录者会话队列        }        //如果队列里没有此sessionId，且用户没有被踢出，则放入队列        if(!deque.contains(sessionId) &amp;&amp; session.getAttribute(&quot;kickout&quot;)==null)            deque.push(sessionId); //插入队头，而队列的引用放在cache中，相当于缓存会话        //如果队列里的会话数超出最大值，则开始踢人        while (deque.size()&gt;maxSession){ //用if应该就可以，顶多加入当前用户即超出限制            //要被踢的sessionId            Serializable kickoutSessionId=null;            //如果规定踢出后者            if(kickoutAfter)                kickoutSessionId=deque.removeFirst(); //弹出首元素，此处为最后进去的元素            //否则踢出前者            else                kickoutSessionId=deque.removeLast(); //弹出尾元素            try {                //根据session id获取session                Session kickoutSession = sessionManager                        .getSession(new DefaultSessionKey(kickoutSessionId));                if (kickoutSession != null)                    //设置会话的kickout属性表示被踢出                    kickoutSession.setAttribute(&quot;kickout&quot;, true);            } catch (Exception e){                //ignore            }        }        //如果当前会话不幸在上面while中被踢出了，则注销并重定向到踢出后的地址；        //但如果踢出的是其他会话，那么需要刷新，它才会被强制登出        if(session.getAttribute(&quot;kickout&quot;)!=null){            try {                subject.logout();            } catch (Exception e){                //ignore            }            saveRequest(request); //保存当前请求            WebUtils.issueRedirect(request,response,kickoutUrl); //返回login页面            return false;        }        return true;    }}</code></pre><ul><li><p>ehcache.xml：设置用于存放会话的缓存shiro-kickout-session。</p><pre><code>&lt;cache name=&quot;shiro-kickout-session&quot;   maxEntriesLocalHeap=&quot;2000&quot;   eternal=&quot;false&quot;   timeToIdleSeconds=&quot;3600&quot;   timeToLiveSeconds=&quot;0&quot;   overflowToDisk=&quot;false&quot;   statistics=&quot;true&quot;&gt;&lt;/cache&gt;</code></pre></li><li><p>spring-config-shiro.xml: 注册过滤器。</p><pre><code>&lt;!--控制并发登录人数的过滤器--&gt;&lt;bean id=&quot;kickoutSessionControllerFilter&quot;      class=&quot;com.haien.chapter18.web.shiro.filter.KickoutSessionControllerFilter&quot;&gt;    &lt;!--使用cacheManager获取相应cache来缓存用户登录的会话，    用于保存用户-会话之间的关系--&gt;    &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt;    &lt;!--用于根据会话id，获取会话进行踢出操作--&gt;    &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt;    &lt;!--是否踢出后来登录的，默认false--&gt;    &lt;property name=&quot;kickoutAfter&quot; value=&quot;false&quot;/&gt;    &lt;!--同一个用户最大会话数，默认1，即只能一人登录--&gt;    &lt;property name=&quot;maxSession&quot; value=&quot;2&quot;/&gt;    &lt;!--被踢出后重定向到的地址--&gt;    &lt;property name=&quot;kickoutUrl&quot; value=&quot;/login?kickout=1&quot;/&gt;&lt;/bean&gt;&lt;!-- Shiro的Web过滤器 --&gt;&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;    &lt;property name=&quot;filters&quot;&gt;        &lt;util:map&gt;            &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt;            &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt;            &lt;entry key=&quot;kickout&quot; value-ref=&quot;kickoutSessionControllerFilter&quot;/&gt;        &lt;/util:map&gt;    &lt;/property&gt;    &lt;property name=&quot;filterChainDefinitions&quot;&gt;        &lt;value&gt;            /login = authc            /logout = logout            /authenticated = authc            /** = kickout,user,sysUser        &lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li><p>测试：本例设置maxSession=2，所以需要打开3个浏览器，分别访问localhost:8080/chapter18进行登录，然后刷新第一次登录的浏览器，将会被强制退出返回登录页面。</p></li><li><p><a href="https://jinnianshilongnian.iteye.com/blog/2039760" target="_blank" rel="noopener">《跟我学Shiro》第十八章</a></p></li><li>代码示例：ideaProjects/shiro-chapter18</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在某些项目中，一个账户可能只允许一人登录或几个人同时登录，当超过人数时，要么进制后者登录，要么踢出前者登录。&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%80-%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第三章一-授权流程/</id>
    <published>2019-04-30T08:29:23.026Z</published>
    <updated>2019-03-14T08:09:57.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>授权，也叫控制访问。关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。</li><li>角色：权限的集合，一般情况下我们会赋予用户角色而不是权限。</li><li>Shiro支持粗粒度（角色级别访问控制）和细粒度（权限级别）权限。</li><li>隐式角色：直接通过角色来验证用户有没有操作权限，粒度较粗，是以角色为单位进行访问控制的。如果有一天不允许总监这一角色使用打印机了，需要在逻辑代码中将总监去掉，不允许他做的事越多，代码修改量越大。（基于角色的控制访问）</li><li>显式角色：通过权限来验证用户有没有操作权限，假设哪个角色不能访问某个资源，只需要从角色的权限集合中移除某个权限即可，无需多处修改代码。（基于资源的控制访问）</li></ul><h3 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h3><ul><li>Shiro支持三种方式的授权：编程式、注解式和JSP/GSP标签。</li></ul><ol><li>编程式：写if/esle代码块；常用</li></ol><pre><code>Subject subject=SecurityUtils.getSubject();if(subject.hasRole(&quot;admin&quot;)){    //有权限}else{    //无权限}</code></pre><ol start="2"><li>注解式：在方法上加注解（一般在controller上），没有权限将抛UnauthorizedException异常</li></ol><pre><code>@RequiresRoles({&quot;admin&quot;,&quot;user&quot;},logical=logical.AND)public void hello() {    //有权限}@RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR)@RequiresAuthentication //必须通过login登录@RequiresUser //必须已登录（身份验证或记住我）@RequiresGuest //未登录，游客</code></pre><ol start="3"><li><p>JSP/GSP标签：在JSP/GSP页面加标签</p><pre><code>&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt;</code></pre></li></ol><h3 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h3><ul><li>shiro-role.ini：配置用户拥有的角色</li></ul><pre><code>[users]zhang=123,role1,role2wang=123,role1</code></pre><ul><li>BaseTest：抽象化一些常用测试方法</li></ul><pre><code>public abstract class BaseTest {    /**     * @Author haien     * @Description protected:只能被本类及其子类、本包的方法访问     * @Date 2019/2/18     * @Param [configFile, username, password]     * @return void     **/    protected void login(String configFile,String username,String password){        //1、获取SecurityManager工厂        Factory&lt;SecurityManager&gt; factory=new IniSecurityManagerFactory(configFile);        //2、得到SecurityManager实例，并绑定给SecurityUtils        SecurityManager securityManager=factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        //3、得到Subject及创建用户名、密码身份凭证Token        Subject subject=SecurityUtils.getSubject();        UsernamePasswordToken token=new UsernamePasswordToken(username,password);        subject.login(token);    }    public Subject subject(){        return SecurityUtils.getSubject();    }    @After    public void tearDown() throws Exception{        ThreadContext.unbindSubject(); //退出时解除绑定Subject到线程，否则对下次测试造成影响    }}</code></pre><ul><li>RoleTest：测试Subject判断用户角色方法</li></ul><pre><code>public class RoleTest extends BaseTest{    @Test    public void testHasRole(){        //zhang拥有role1、role2        login(&quot;classpath:config/shiro-role.ini&quot;,&quot;zhang&quot;,&quot;123&quot;);        //判断是否拥有角色：role1        Assert.assertTrue(subject().hasRole(&quot;role1&quot;));        //role1、role2        Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;,&quot;role2&quot;)));        //role1、role2和!role3        boolean[] result=subject().hasRoles(Arrays.asList(&quot;role1&quot;,&quot;role2&quot;,&quot;role3&quot;));        Assert.assertEquals(true,result[0]);        Assert.assertEquals(true,result[1]);        Assert.assertEquals(false,result[2]);    }    @Test(expected = UnauthorizedException.class)    public void testCheckRole(){        login(&quot;classpath:config/shiro-role.ini&quot;,&quot;zhang&quot;,&quot;123&quot;);        //断言拥有角色role1        subject().checkRole(&quot;role1&quot;);        //断言拥有角色role1.role3，失败抛异常        subject().checkRoles(&quot;role1&quot;,&quot;role3&quot;);    }}</code></pre><ul><li>Subject并没有提供hasAnyRole()</li><li>checkRole()和hasRole()的区别是它在判断为假的情况下会抛UnauthorizedException异常<h3 id="基于资源的访问控制（显式角色）"><a href="#基于资源的访问控制（显式角色）" class="headerlink" title="基于资源的访问控制（显式角色）"></a>基于资源的访问控制（显式角色）</h3></li><li>shiro-permission.ini</li></ul><pre><code>;首先根据用户名找到角色[users]zhang=123,role1,role2wang=123,role1;再根据角色找到权限[roles];角色=权限1，权限2role1=user:create,user:updaterole2=user:create,user:delete</code></pre><ul><li>PermissionTest:测试细粒度的授权</li></ul><pre><code>public class PermissionTest extends BaseTest{    @Test    public void testIsPermitted(){        login(&quot;classpath:config/shiro-permission.ini&quot;,&quot;zhang&quot;,&quot;123&quot;);        //判断拥有权限user:create        Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;));        //user:update and user:delete        Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;,&quot;user:delete&quot;));        //!user:view        Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));    }    @Test(expected = UnauthorizedException.class)    public void testCheckPermission(){        login(&quot;classpath:config/shiro-permission.ini&quot;,&quot;zhang&quot;,&quot;123&quot;);        //user:create        subject().checkPermission(&quot;user:create&quot;);        //user:create and user:update        subject().checkPermissions(&quot;user:create&quot;,&quot;user:update&quot;);        //!user:view,失败抛异常        subject().checkPermissions(&quot;user:view&quot;);    }}</code></pre><ul><li>没有isPermittedAny()</li></ul><h3 id="权限书写规范"><a href="#权限书写规范" class="headerlink" title="权限书写规范"></a>权限书写规范</h3><ul><li>规则————资源标识符:操作:对象实例id，即对哪个资源的哪个实例可以进行什么操作。</li><li>支持通配符：“:”表示资源、操作和实例之间的分隔，“,”表示操作之间的分隔，“*”表示任意资源、操作或实例。</li><li>单个资源单个权限</li></ul><pre><code>//用户拥有system:user资源的update权限subject().checkPermissions(&quot;system:user:update&quot;);  </code></pre><ul><li>单个资源多个权限</li></ul><pre><code>role4=system:user:update,system:user:delete//orrole4=&quot;system:user:update,delete&quot;//然后通过如下代码判断subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);//orsubject().checkPermissions(&quot;system:user:update,delete&quot;);</code></pre><ul><li>以上四行代码随意搭配都可</li><li>单个资源全部权限</li></ul><pre><code>//推荐role52=system:user:*//orrole53=system:user//然后通过以下代码判断subject().checkPermissions(&quot;system:user:*&quot;);subject().checkPermissions(&quot;system:user&quot;);</code></pre><ul><li>所有资源某一权限</li></ul><pre><code>//用户拥有所有资源的view权限role61=*:viewsubject().checkPermissions(&quot;user:view&quot;);//假设权限是system:user:view,则写法为role5=*:*:view</code></pre><ul><li>前缀匹配：前缀对了就能匹配任意特例</li><li>user等价于user:*、user:*:*</li><li>user:view等价于user:view:*</li><li>没有后缀匹配</li><li>*:view不能匹配system:user:view</li><li>*:*:view才能匹配system:user:view</li><li>性能问题：通配符陪陪方式比字符串相等匹配方式更复杂，需要花费更多时间。<h3 id="WildcardPermission"><a href="#WildcardPermission" class="headerlink" title="WildcardPermission"></a>WildcardPermission</h3></li><li>wildcard:通配符</li><li>以下两种方式是等价的</li></ul><pre><code>subject().checkPermission(&quot;menu:view:1&quot;);subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;));</code></pre><ul><li>因此没什么必要的话使用字符串更方便。</li></ul><h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><ol><li>首先调用Subject.isPermitted<em>/hasRole</em>接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer；</li><li>Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例；</li><li>在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限；</li><li>Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配则isPermitted<em>/hasRole</em>会返回true，否则返回false表示授权失败。</li></ol><ul><li>ModularRealmAuthorizer进行多Realm授权流程</li></ul><ol><li>首先检查相应的Realm是否实现了Authorizer；</li><li>是则调用相应的isPermitted<em>/hasRole</em>方法判断权限；</li><li>若有一个Realm匹配那么返回true，否则返回false。</li></ol><ul><li><p>用Realm进行授权应继承AuthorizingRealm，授权流程：<br>1.1. 如果调用hasRole*(role)，则直接AuthorizationInfo.getRoles()获取用户角色与要求角色role对比即可；<br>2.1.1. 如果调用isPermitted(String),首先通过AuthorizationInfo.getStringPermissions()获得字符串集合，再通过PermissionResolver将权限字符串解析为Permission实例，默认使用WildcardPermissionResolver。<br>2.1.2. 如果通过isPermitted(WildcardPermission),则直接通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合即可；<br>2.2. 然后获取用户角色，通过RolePermissionResolver解析角色对应权限集合（无默认实现，可自己定义）；<br>2.3. 调用Permission.implies(Permission p)逐个与传入的用户权限比较，若有匹配的则返回true，否则返回false。</p></li><li><p>总结：Authorizer的职责是授权，提供了角色、权限判断接口。其子接口为SecurityManager，它的默认实现类为ModularRealmAuthorizer用于多Realm的授权匹配。PermissionResolver用于解析要求的权限字符串到Permission实例，RolePermissionResolver用于根据角色解析相应的权限集合。</p></li><li><p>指定Authorizer实现</p></li></ul><pre><code>//这里是默认实现，可以改为自定义的Authorizer实现类authorizer=org.apache.shiro.authz.ModularRealmAuthorizersecurityManager.authorizer=$authorizer</code></pre><ul><li>PS:自定义Authorizer可参考ModularRealmAuthorizer</li><li>指定Authorizer的permissionResolver（PermissionResolverAware接口实现类）</li></ul><pre><code>permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverauthorizer.permissionResolver=$permissionResolver</code></pre><ul><li>指定Authorizer的rolePermissionResolver（RolePermissionResolverAware接口实现类）</li></ul><pre><code>rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3                            .permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolver</code></pre><ul><li>代码实例：ideaProjects/shiroHelloWorld</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2020017" target="_blank" rel="noopener">《跟我学shiro第三章》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;授权，也叫控制访问。关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%BA%8C-%E6%8E%88%E6%9D%83%E7%A4%BA%E4%BE%8B/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第三章二-授权示例/</id>
    <published>2019-04-30T08:29:23.012Z</published>
    <updated>2019-03-13T12:35:09.916Z</updated>
    
    <content type="html"><![CDATA[<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>调用链：开始用户验证login()-&gt;AbstractAuthenticaticator.authenticate()-&gt;子类ModularRealmAuthenticator.doAuthenticate()判断有几个Realm，然后一个个执行-&gt;getAuthenticationInfo()-&gt;AuthenticatingRealm.getAuthenticationInfo()-&gt;MyRealm.doGetAuthenticationInfo()到此完成用户验证-&gt;</li><li>开始授权BitAndWildPermissionResolver.resolvePermission()解析所需权限-&gt;MyRealm.doGetAuthorizationInfo()获取用户权限-&gt;BitAndWildPermissionResolver.resolvePermission()解析用户权限中存在的字符串权限+user2+10、user2:*-&gt;MyRolePermissionResolver.resolvePermissionInRole()解析用户角色role1、role2的权限，返回menu:*</li><li>根据调用链从外到内</li><li><p>AuthorizerTest：测试类</p><pre><code>public class AuthorizerTest extends BaseTest {    /**     * @Author haien     * @Description 测试MyRealm自己设置角色权限的授权方式     * @Date 2019/2/19     * @Param []     * @return void     **/    @Test    public void testIsPermitted(){        login(&quot;classpath:config/shiro-jdbc-authorizer.ini&quot;,&quot;zhang&quot;,&quot;123&quot;);        Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));        Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;));        Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;)); //新增        Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;)); //查看        Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;)); //新增与查看        Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;)); //没有删除权限        //MyRolePermissionResolver解析得到的权限        Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));    }}</code></pre></li><li><p>MyRealm：doGetAuthenticationInfo()被login()调用，完成用户验证</p><pre><code>public class MyRealm extends AuthorizingRealm { //继承AuthorizingRealm实现Realm接口    /**     * @Author haien     * @Description 获取身份验证信息（和MyRealm1一样）     * @Date 2019/2/19     * @Param [authenticationToken]     * @return org.apache.shiro.authc.AuthenticationInfo     **/    @Override    protected AuthenticationInfo doGetAuthenticationInfo(            AuthenticationToken authenticationToken) throws AuthenticationException {        String username=(String)authenticationToken.getPrincipal(); //得到用户名        String password=new String((char[])authenticationToken.getCredentials()); //得到密码        //String password=(String)authenticationToken.getCredentials();        //若用户名错误        if(!&quot;zhang&quot;.equals(username)){            throw new UnknownAccountException();        }        //若密码错误        if(!&quot;123&quot;.equals(password)){            throw new IncorrectCredentialsException();        }        //身份验证成功，返回一个AuthenticationInfo实现        return new SimpleAuthenticationInfo(username,password,getName());    }}</code></pre></li><li><p>如果想用数据库而不是自己准备用户和权限的话，可以配置shiro-jdbc-authorizer.ini，替换shiro-authorizer.ini和MyRealm类</p><pre><code>[main];自定义Authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer;自定义permissionResolverpermissionResolver=com.haien.shiroHelloWorld.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver;自定义rolePermissionResolverrolePermissionResolver=com.haien.shiroHelloWorld.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer;以上都和shiro-authorizer.ini一样;自定义JdbcRealm；    ;一定要放在SecurityManager。authorizer，因为调用setRealms()会将realms设置给Authorizer，    ;并将前面给Authorizer设置的属性permissionResolver和RolePermissionResolver设置给realmsjdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=true //开启权限从数据库查找功能securityManager.realms=$jdbcRealm</code></pre></li><li><p>BitAndWildPermissionResolver：解析权限字符串（用户拥有的权限和要求的权限）</p><pre><code>/** * @Author haien * @Description 解析权限字符串：根据字符串是否以+开头解析为BitPermission或WildcardPermission * @Date 2019/2/19 **/public class BitAndWildPermissionResolver implements PermissionResolver {    /**     * @Author haien     * @Description 根据字符串是否以+开头解析为BitPermission或WildcardPermission     * @Date 2019/2/19     * @Param [s]     * @return org.apache.shiro.authz.Permission     **/    @Override    public Permission resolvePermission(String permissionString) {        if(permissionString.startsWith(&quot;+&quot;)){            return new BitPermission(permissionString);        }        return new WildcardPermission(permissionString);    }}</code></pre></li><li><p>其中BitPermission实现了Permission接口</p><ul><li>Permission接口</li></ul></li></ul><pre><code>public interface Permission {    //权限匹配    boolean implies(Permission var1);}</code></pre><ul><li><p>this是用户拥有的权限，var1是所需权限，当this是user:*或user，var1是user:create或两者完全相同时，返回true。</p></li><li><p>BitPermission</p><pre><code>/** * @Author haien * @Description 实现位移方式的权限定义，解析要求的权限。被BitAndWildPermissionResolver调用。 *              规则：+资源+权限位。以+开头，中间通过+分隔； *              权限位：0-all权限（二进制0000），1-新增（0001），2-修改（0010）， *              4-删除（0100）、8-查看（1000）；如，+user+10，由于10二进制为1010, *              1位置与2、8相同，按位与返回二进制数非0，所以表示拥有修改、查看权限 * @Date 2019/2/18 **/public class BitPermission implements Permission {    //资源    private String resourceIdentify;    //权限位    private int permissionBit;    //实例id    private String instanceId;    public BitPermission(String permissionString) {        //解析要求的权限字符串        String[] array=permissionString.split(&quot;\\+&quot;); //加//防止+被解析        if(array.length&gt;1){            resourceIdentify=array[1]; //第0个为空        }        if(StringUtils.isEmpty(resourceIdentify)){ //开头两个+相连，或者length&lt;=1,即根本没定义权限            resourceIdentify=&quot;*&quot;;        }        if(array.length&gt;2){            permissionBit=Integer.valueOf(array[2]);        }//peimissionBit为空的话即默认值0，不用赋*给它，后面用0来判断即可        if(array.length&gt;3){            instanceId=array[3];        }        if(StringUtils.isEmpty(instanceId)){            instanceId=&quot;*&quot;;        }    }    /**     * @Author haien     * @Description 判断用户是否拥有权限     * @Date 2019/2/18     * @Param [p所需权限](this为用户权限)     * @return boolean     **/    @Override    public boolean implies(Permission p) {        if(!(p instanceof BitPermission)) {            return false;        }        BitPermission other=(BitPermission)p;        if(!(&quot;*&quot;.equals(this.resourceIdentify) //this：用户拥有的权限，other：所需权限             ||this.resourceIdentify.equals(other.resourceIdentify))){            return false;        }        if(!(this.permissionBit==0||(this.permissionBit&amp;other.permissionBit)!=0)){            return false;        }        if(!(&quot;*&quot;.equals(this.instanceId)||this.instanceId.equals(other.instanceId))){            return false;        }        return true;    }}</code></pre></li><li><p>MyRealm：doGetAuthorizationInfo()获取用户权限。</p><pre><code>public class MyRealm extends AuthorizingRealm { //继承AuthorizingRealm实现Realm接口    /**     * @Author haien     * @Description 根据用户身份获取授权信息     * @Date 2019/2/19     * @Param [principalCollection]     * @return org.apache.shiro.authz.AuthorizationInfo     **/    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {        SimpleAuthorizationInfo authorizationInfo=new SimpleAuthorizationInfo();        /*不从数据库查找，自己设置权限进去*/        //用户拥有两个角色        authorizationInfo.addRole(&quot;role1&quot;); //添加角色后调用MyRolePermissionResolver解析出权限        authorizationInfo.addRole(&quot;role2&quot;); //解析出来后应该是添加回authorizationInfo的权限集合        //四个权限        authorizationInfo.addObjectPermission(new BitPermission(&quot;+user1+10&quot;));        authorizationInfo.addObjectPermission(new WildcardPermission(&quot;user1:*&quot;));        authorizationInfo.addStringPermission(&quot;+user2+10&quot;); //10代表2新增与8查看        authorizationInfo.addStringPermission(&quot;user2:*&quot;); //字符串权限，等下会调用BitAndWildPermissionResolver解析        return authorizationInfo;    }}</code></pre></li><li><p>其中，Principle原本是AuthenticationToken的属性之一，表示用户名。</p></li><li><p>MyRolePermissionResolver：解析角色字符串到用户权限集合</p><pre><code>public class MyRolePermissionResolver implements RolePermissionResolver {    /**     * @Author haien     * @Description 如果用户拥有role1，则返回menu:*权限，添加到用户权限集合中     * @Date 2019/2/19     * @Param [roleString]     * @return java.util.Collection&lt;org.apache.shiro.authz.Permission&gt;     **/    @Override    public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) {        if(&quot;role1&quot;.equals(roleString)){            //role1的权限（在MyRealm中添加也一样）            /*            return Arrays.asList(new WildcardPermission(&quot;menu:*&quot;),                    new BitPermission(&quot;+user1+10&quot;),                    new WildcardPermission(&quot;user1:*&quot;),                    new BitPermission(&quot;+user2+10&quot;),                    new WildcardPermission(&quot;user2:*&quot;));            */            return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;));        }        return null;    }}</code></pre></li><li>代码实例：ideaProjects/shiroHelloWorld</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2020017" target="_blank" rel="noopener">《跟我学shiro第三章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;调用链：开始用户验证login()-&amp;gt;AbstractAuthenticaticator.authenticate()-&amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%B8%8Eweb%E9%9B%86%E6%88%90%E3%80%81ShiroFilter%E3%80%81%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第七章-与web集成、ShiroFilter、基于表单的拦截器/</id>
    <published>2019-04-30T08:29:23.009Z</published>
    <updated>2019-03-31T06:00:14.345Z</updated>
    
    <content type="html"><![CDATA[<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li><p>shiro-web</p><pre><code>&lt;!--shiro项目至少的jar--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;    &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>Servlet3:编译与测试时的web环境</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.0.1&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre></li><li><p>tomcat7-maven-plugin插件: 运行时的web环境</p><pre><code>&lt;build&gt;    &lt;finalName&gt;shiroHelloWorld-chapter7&lt;/finalName&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;              &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;              &lt;version&gt;2.2&lt;/version&gt;              &lt;configuration&gt;                  &lt;path&gt;/${project.build.finalName}&lt;/path&gt;              &lt;/configuration&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;&lt;/build&gt;</code></pre></li></ul><h3 id="web-xml配置、ShiroFilter"><a href="#web-xml配置、ShiroFilter" class="headerlink" title="web.xml配置、ShiroFilter"></a>web.xml配置、ShiroFilter</h3><ul><li>Shiro提供了与web的集成，通过一个ShiroFilter入口来拦截需要安全控制的url，默认实现类是IniShiroFilter。</li><li><p>shiro 1.1版本的ShiroFilter：</p><pre><code>&lt;filter&gt;    &lt;filter-name&gt;iniShiroFilter&lt;/filter-name&gt; &lt;!--使用IniShiroFilter作为shiro安全控制入口点--&gt;    &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;configPath&lt;/param-name&gt; &lt;!--configPath：指定ini配置文件位置；固定--&gt;        &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt; &lt;!--默认先从/WEB-INF/shiro.ini加载，            没有再classpath：shiro.ini--&gt;    &lt;/init-param&gt;    &lt;!-- 或不指定ini位置，直接按下面这样    &lt;init-param&gt;        &lt;param-name&gt;config&lt;/param-name&gt;        &lt;param-value&gt;            [main]            authc.loginUrl=/login            [users]            zhang=123,admin            [roles]            admin=user:*,menu:*            [urls]            /login=anon            /static/**=anon            /authenticated=authc            /role=authc,roles[admin]            /permission=authc,perms[&quot;user:create&quot;]        &lt;/param-value&gt;    &lt;/init-param&gt;    --&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;iniShiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--指定需要拦截的url--&gt;&lt;/filter-mapping&gt;</code></pre></li><li>使用IniShiroFilter作为Shiro安全控制的入口点。</li><li>可以使用configPath指定ini配置文件路径，默认先从/WEB-INF/shiro.ini加载（/表示根目录，为webapp），没有再是classpath:shiro.ini。也可以直接内嵌配置文件内容。</li><li><p>shiro 1.2版本开始引入Environment/WebEnvironment，由它们的实现类提供相应的SecurityManager及其相应的依赖。ShiroFilter会自动找到Environment然后获取相应依赖。</p><pre><code>&lt;listener&gt;    &lt;!--通过EnvironmentLoaderListener创建相应的WebEnvironment，并自动绑定到ServletContext，    默认使用IniWebEnvironment实现类。--&gt;    &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--可通过如下配置修改默认配置--&gt;&lt;context-param&gt;    &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt;    &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt;    &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt;    &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt; &lt;!--默认先/WEB-INF/shiro，没有再classpath:shiro.ini--&gt;&lt;/context-param&gt;</code></pre></li><li>以上俩版本的配置相当于以下代码：</li></ul><pre><code>//1、获取SecurityManager工厂，并使用ini配置文件初始化SecurityManagerFactory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory=          new IniSecurityManagerFactory(&quot;classpath:config/shiro.ini&quot;);//2、得到SecurityManager实例，并绑定SecurityUtilsSecurityManager securityManager=factory.getInstance();SecurityUtils.setSecurityManager(securityManager);</code></pre><ul><li><p>那么以后登录直接从第3步：Subject subject=SecurityUtils.getSubject();写起。</p></li><li><p>与Spring集成：使用DelegatingFilterProxy，作用是自动到Spring容器查找名为filter-name的bean，并把所有Filter的操作委托给它，所以需要将shiroFilter注册到Spring。</p><pre><code>&lt;filter&gt;    &lt;!--DelegatingFilterProxy作用是自动到Spring容器查找名为filter-name的bean，并把所有    Filter的操作委托给它，所以需要将shiroFilter注册到Spring。--&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;    &lt;!--可以不写--&gt;    &lt;init-param&gt;        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;        &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre></li><li><p>ShiroFilter的bean：主要是绑定SecurityManager。需要使用org.springframework.web.context.ContextLoaderListener加载所在配置文件。</p><pre><code>&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;    &lt;!—忽略其他，详见与Spring集成部分 --&gt;&lt;/bean&gt;</code></pre></li><li><p>如果不与Spring集成，则直接声明ShiroFilter即可：</p><pre><code>&lt;!--绑定SecurityManager--&gt;&lt;filter&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;</code></pre></li></ul><h3 id="常用的身份验证"><a href="#常用的身份验证" class="headerlink" title="常用的身份验证"></a>常用的身份验证</h3><ul><li>shiro.ini配置文件</li></ul><pre><code>[main]#默认是/login.jspauthc.loginUrl=/login #未登录会自动跳转登录页面roles.unauthorizedUrl=/unauthorizedperms.unauthorizedUrl=/unauthorized[users]zhang=123,adminwang=123[roles]admin=user:*,menu:*[urls];格式：url=拦截器[参数]。anon拦截器表示匿名访问，无需登录；authc则需要登录；;roles[admin]需要admin角色；perms[&quot;user:create&quot;]需要有user:create权限/login=anon/unauthorized=anon/static/**=anon/authenticated=authc/role=authc,roles[admin]/permission=authc,perms[&quot;user:create&quot;]</code></pre><ul><li>urls格式：url=拦截器[参数]。anon拦截器表示匿名访问，无需登录，相当于不需拦截的资源；authc则需要登录;roles[admin]需要admin角色；perms[“user:create”]需要有user:create权限.</li><li><p>按照顺序进行匹配，只采用第一个匹配的进行拦截。</p></li><li><p>使用Ant风格模式</p><ul><li>?：匹配一个字符，如”/admin?”将匹配/admin1，但不匹配/admin或/admin2；</li><li><em>：匹配零个或多个字符串，如/admin</em>将匹配/admin、/admin123，但不匹配/admin/1；</li><li><strong>：匹配路径中的零个或多个路径，如/admin/</strong>将匹配/admin/a或/admin/a/b。</li></ul></li><li><p>接收到请求后，先到ini查看是否需要拦截，不需要则查找url匹配的servlet类，需要则在ini中查找登录的url，再查找匹配的servlet类。</p></li><li><p>LoginServlet：登录Servlet。get请求时展示登录页面；post请求进行登录验证。</p></li></ul><pre><code>//相当于web.xml配置&lt;servlet&gt;@WebServlet(name=&quot;loginServlet&quot;,urlPatterns = &quot;/login&quot;) //url：http://localhost:8080/shiroHelloWorld-chapter7/loginpublic class LoginServlet extends HttpServlet {    /**     * @Author haien     * @Description get请求时展示登录页面     * @Date 2019/2/28     * @Param [req, resp]     * @return void     **/    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {        req.getRequestDispatcher(&quot;/jsp/login.jsp&quot;).forward(req,resp);    }    /**     * @Author haien     * @Description post请求进行登录验证     * @Date 2019/2/28     * @Param [req, resp]     * @return void     **/    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {        String error = null;        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        Subject subject = SecurityUtils.getSubject();        UsernamePasswordToken token = new UsernamePasswordToken(username, password);        try {            subject.login(token);        } catch (UnknownAccountException e) {            error = &quot;用户名/密码错误&quot;;        } catch (IncorrectCredentialsException e) {            error = &quot;用户名/密码错误&quot;;        } catch (AuthenticationException e) {            //其他错误，比如锁定，如果想单独处理请单独catch处理            error = &quot;其他错误：&quot; + e.getMessage();        }        if(error != null) {//出错了，返回登录页面            req.setAttribute(&quot;error&quot;, error);            req.getRequestDispatcher(&quot;/jsp/login.jsp&quot;).forward(req, resp);        } else {//登录成功            req.getRequestDispatcher(&quot;/jsp/loginSuccess.jsp&quot;).forward(req, resp);        }    }}</code></pre><ul><li>登录成功不能老是跳到成功页面，而是要跳到之前请求的页面，可以在登录时把当前请求保存下来，登录成功再重定向到该请求即可。</li></ul><h3 id="基于Basic的拦截器身份验证"><a href="#基于Basic的拦截器身份验证" class="headerlink" title="基于Basic的拦截器身份验证"></a>基于Basic的拦截器身份验证</h3><ul><li>同样是做安全控制的拦截器，但是它要求登录的方式不是跳转登录页面，而是弹出登录窗口。</li><li>shiro-basicfilterlogin.ini：</li></ul><pre><code>[main];authBasic是org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter类的实例，;用于实现基于Basic的身份验证;applicationName属性显示在弹出的登录框authcBasic.applicationName=please loginperms.unauthorizedUrl=/unauthorizedroles.unauthorizedUrl=/unauthorized[users]zhang=123,adminwang=123[roles]admin=user:*,menu:*[urls];/role需要走authcBasic拦截器，即如果访问/role时未登录则弹出对话框进行登录/role=authcBasic,roles[admin]</code></pre><ul><li>需要将web.xml中配置文件更改为shiro-basicfilterlogin.ini。</li><li>未登录访问/role将弹出窗口。再次测试未登录却没弹窗可能是因为Chrome记住了登录信息。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/00e16ed3-afea-3614-926c-bdc2b09d5d8e.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="基于表单的拦截器身份验证"><a href="#基于表单的拦截器身份验证" class="headerlink" title="基于表单的拦截器身份验证"></a>基于表单的拦截器身份验证</h3><ul><li>和第一种类似，但是更简单，因为已经实现了登录信息与用户库的匹配，我们只需要写登录页面的映射、登录失败处理即可。</li><li>原理大致如下，详情参见笔记：Shiro第八章二-自定义拦截器</li></ul><pre><code>public class FormLoginFilter extends PathMatchingFilter {    private String loginUrl = &quot;/login.jsp&quot;;    private String successUrl = &quot;/&quot;;    /**    * 总方法    */    @Override    protected boolean onPreHandle(ServletRequest request, ServletResponse response,       Object mappedValue) throws Exception {        //1、判断是否已登录，是则直接进入过滤链下一步        if(SecurityUtils.getSubject().isAuthenticated()) {            return true;//已经登录过        }        //2、未登录则判断是否为登录请求，是，则若是get请求，继续过滤链（跳转登录        //页面），若是post请求，认为是表单验证请求，进行表单验证，执行subject.login()；        //否，若是get方法的其他页面请求则保存当前请求并重定向到登录页面，非get请求可能报错吧        HttpServletRequest req = (HttpServletRequest) request;        HttpServletResponse resp = (HttpServletResponse) response;        if(isLoginRequest(req)) { //是登录请求            if(&quot;post&quot;.equalsIgnoreCase(req.getMethod())) { //form表单提交                boolean loginSuccess = login(req); //登录                if(loginSuccess) { //登录成功                    return redirectToSuccessUrl(req, resp);                }            }            //是get请求|登录失败，继续过滤器链，可能是被分配到controller处理/login            return true;        }         else { //不是登录请求，保存当前地址并重定向到登录界面            saveRequestAndRedirectToLogin(req, resp);            return false;        }    }    /**    * 登录成功后调用，若有之前的请求则重定向到它，否则到默认成功页面    */    private boolean redirectToSuccessUrl(HttpServletRequest req,         HttpServletResponse resp) throws IOException {        WebUtils.redirectToSavedRequest(req, resp, successUrl);        return false;    }    /**    * 保存当前请求并跳转登录页面    */    private void saveRequestAndRedirectToLogin(HttpServletRequest req,      HttpServletResponse resp) throws IOException {        WebUtils.saveRequest(req);        WebUtils.issueRedirect(req, resp, loginUrl);    }    /**    * 表单验证，执行登录方法    */    private boolean login(HttpServletRequest req) {        String username = req.getParameter(&quot;username&quot;);        String password = req.getParameter(&quot;password&quot;);        try {            SecurityUtils.getSubject().login(new UsernamePasswordToken(username, password));        } catch (Exception e) {            req.setAttribute(&quot;shiroLoginFailure&quot;, e.getClass());            return false;        }        return true;    }    /**    * 判断是否登录请求    */    private boolean isLoginRequest(HttpServletRequest req) {        return pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req));    }}</code></pre><ul><li>shiro-formfilterlogin.ini：</li></ul><pre><code>[main];authc是org.apache.shiro.web.filter.authc.FormAuthenticationFilter类的实例；;loginUrl:指定登录地址、表单提交地址；successUrl：默认是/，          如果有上一个地址会自动重定向到该地址；;failureKeyAttribute：登录失败信息的在request中的key，默认为shiroLoginFailure，                      内容为异常类型名。authc.loginUrl=/formfilterlogin //get请求即为请求登录页面，由controller映射页面；    post为表单验证请求，FormAuthenticationFilter处理authc.usernameParam=usernameauthc.passwordParam=passwordauthc.successUrl=/authc.failureKeyAttribute=shiroLoginFailureperms.unauthorizedUrl=/unauthorizedroles.unauthorizedUrl=/unauthorized[users]zhang=123,adminwang=123[roles]admin=user:*,menu:*[urls]/static/**=anon/formfilterlogin=authc/role=authc,roles[admin]/permission=authc,perms[&quot;user:create&quot;]</code></pre><ul><li><p>然后web.xml改为shiro-formfilterlogin.ini。</p></li><li><p>formfilterlogin.jsp：登录页面。</p><pre><code>&lt;body&gt;    &lt;div class=&quot;error&quot;&gt;${error}&lt;/div&gt;    &lt;form action=&quot;${pageContext.request.contextPath}/formfilterlogin&quot; method=&quot;post&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;        密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre></li><li><p>FormFilterLoginServlet：登录失败处理</p></li></ul><pre><code>@WebServlet(name = &quot;formFilterLoginServlet&quot;, urlPatterns = &quot;/formfilterlogin&quot;)public class FormFilterLoginServlet extends HttpServlet {    /**     * @Author haien     * @Description get请求的话FormAuthenticationFilter不做任何处理     直接结束当前过滤链，进入下一过滤链，应该是Spring自己的过滤链了，     应该就是分发给controller处理，所以这里应该是映射登录页面才对，不过交给doPost做     也获取不到shiroLoginFailure，也是直接返回登录页面了     *      * @Date 2019/3/15     * @Param [req, resp]     * @return void     **/    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {        doPost(req, resp);    }    /**     * @Author haien     * @Description 身份验证和成功跳转已被处理，如果失败FormAuthenticationFilter     * 并不会返回登录页面或做任何处理，只是结束当前过滤链而进入下一过滤链，     * 而下一过滤链应该就是Spring自己的过滤链，也就是将原请求分发到controller，     * 所以要准备一个处理登录失败情况的跳转这里只处理失败情况     *      * @Date 2019/2/28     * @Param [req, resp]     * @return void     **/    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {        String errorClassName = (String)req.getAttribute(&quot;shiroLoginFailure&quot;); //异常类型名        if(UnknownAccountException.class.getName().equals(errorClassName)) {            req.setAttribute(&quot;error&quot;, &quot;用户名/密码错误&quot;);        } else if(IncorrectCredentialsException.class.getName().equals(errorClassName)) {            req.setAttribute(&quot;error&quot;, &quot;用户名/密码错误&quot;);        } else if(errorClassName != null) {            req.setAttribute(&quot;error&quot;, &quot;未知错误：&quot; + errorClassName);        }        req.getRequestDispatcher(&quot;/jsp/formfilterlogin.jsp&quot;).forward(req, resp); //返回登录页面    }}</code></pre><ul><li>测试：登录/role，会跳转/formfilterlogin登录页面，登陆成功会跳转/role而不是默认登录成功页面。</li></ul><h3 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h3><ul><li>shiro.ini</li></ul><pre><code>[main]roles.unauthorizedUrl=/unauthorizedperms.unauthorizedUrl=/unauthorized [urls]/role=authc,roles[admin]/permission=authc,perms[&quot;user:create&quot;]</code></pre><ul><li>unauthorizedUrl: 验证失败重定向到的地址。</li><li>roles: org.apache.shiro.web.filter.authz.RolesAuthorizationFilter类的实例，通过[参数]指定访问时需要的权限，如有多个使用”,”分隔，验证需要都通过。</li><li><p>perms：org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter类实例，验证权限字符串。</p></li><li><p>PermissionServlet类：只处理权限验证成功情况，失败情况ini已处理。</p></li></ul><pre><code>@WebServlet(name = &quot;permissionServlet&quot;, urlPatterns = &quot;/permission&quot;)public class PermissionServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp)      throws ServletException, IOException {        Subject subject = SecurityUtils.getSubject();        subject.checkPermission(&quot;user:create&quot;);        req.getRequestDispatcher(&quot;/WEB-INF/jsp/hasPermission.jsp&quot;).forward(req, resp);    }}</code></pre><ul><li>RoleServlet类：角色单位的权限验证，也是只处理成功情况，主要逻辑如下：</li></ul><pre><code>subject.checkRole(&quot;admin&quot;);</code></pre><ul><li><p>测试：访问/login，使用zhang/123登录后访问/role或/permission，跳转授权成功页面；使用wang/123登录则跳转/unauthorized无授权页面。</p></li><li><p>Shiro也提供了logout拦截器用于退出，它是org.apache.shiro.web.filter.authc.LogoutFilter类的实例</p></li></ul><pre><code>[main];logout是org.apache.shiro.web.filter.authc.LogoutFilter类实例，Shiro内置logout拦截器logout.redirectUrl=/login[urls];指定退出url是/logout2；使用Shiro内置的logout拦截器退出，logout配置在上面main中/logout2=logout</code></pre><ul><li><p>则无需写Servlet类处理退出请求，只要把退出链接的url改成/logout2即可</p><pre><code>&lt;a href=&quot;${pageContext.request.contextPath}/logout2&quot;&gt;退出&lt;/a&gt;</code></pre><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3></li><li>ideaProjects/shiroHelloWorldchapter7</li><li><a href="https://jinnianshilongnian.iteye.com/blog/2024723" target="_blank" rel="noopener">参考文章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;依赖&quot;&gt;&lt;a href=&quot;#依赖&quot; class=&quot;headerlink&quot; title=&quot;依赖&quot;&gt;&lt;/a&gt;依赖&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shiro-web&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--shiro项目至少的jar--&amp;gt;
&amp;lt;depen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%90%84%E7%A7%8D%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3-%E5%AE%8C%E6%95%B4%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83%E7%A4%BA%E4%BE%8B/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第六章-各种对象详解-完整用户登录认证与授权示例/</id>
    <published>2019-04-30T08:29:22.998Z</published>
    <updated>2019-03-14T08:10:57.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul><li>doGetAuthenticationInfo()和getAuthenticationInfo()一样，都是做用户验证和返回身份凭证的。</li><li>从调用链上，getAuthorizationInfo()会调用doGetAuthorizationInfo()，所以大部分时候是重写后者。</li></ul><h3 id="AuthenticationToken"><a href="#AuthenticationToken" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h3><ul><li><p>收集用户提交的身份信息（如用户名和凭据（如密码））的接口。</p><pre><code>public interface AuthenticationToken extends Serializable {    Object getPrincipal(); //身份    Object getCredentials(); //凭据};</code></pre></li><li>扩展接口RememberMeAuthenticationToken:提供boolean isRememberMe()实现记住我功能。</li><li>扩展接口HostAuthenticationToken：提供String getHost()获取用户主机。</li><li>内置实现类UsernamePasswordToken：仅保存用户名、密码，并实现了以上两个接口，可以实现记住我和主机验证的支持。</li></ul><h3 id="AuthenticationInfo"><a href="#AuthenticationInfo" class="headerlink" title="AuthenticationInfo"></a>AuthenticationInfo</h3><ul><li>封装验证通过的身份信息，主要包括Object属性principal(一般存储用户名)和credentials（密码）。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/0be597af-cd61-34ce-b1f0-8ebd15dbdeb9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>MergableAuthenticationInfo子接口：在多Realm时合并AuthenticationInfo，主要合并Principal，如果是其他信息如credentialsSalt，则会后合并进来的AuthenticationInfo覆盖。</li><li>SaltedAuthenticationInfo子接口：比如HashedCredentialsMatcher，在验证时会判断AuthenticationInfo是否是SaltedAuthenticationInfo的子类，是则获取其盐。</li><li>Account子接口：相当于我们之前的[users],SimpleAccount是其实现。在IniRealm、PropertiesRealm这种静态创建账号的场景中使用，它们继承了SimpleAccountRealm，其中就有API用于增删查改SimpleAccount。适用于账号不是特别多的情况。</li><li>SimpleAuthenticationInfo：一般都是返回这个类型。</li></ul><h3 id="PincipalCollection"><a href="#PincipalCollection" class="headerlink" title="PincipalCollection"></a>PincipalCollection</h3><ul><li>Principal前缀：应该是上面AuthenticationInfo的属性principal。</li><li>PincipalCollection:是一个身份集合，保存登录成功的用户的身份信息。因为我们可以在Shiro中同时配置多个Realm，所以身份信息就有多个。可以传给doGetAuthorizationInfo()方法为登录成功的用户授权。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/772c988b-e930-31d1-ad14-c9ae8f476f66.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code>public interface PrincipalCollection extends Iterable, Serializable {    Object getPrimaryPrincipal(); //得到主要的身份    &lt;T&gt; T oneByType(Class&lt;T&gt; type); //根据身份类型获取第一个    &lt;T&gt; Collection&lt;T&gt; byType(Class&lt;T&gt; type); //根据身份类型获取一组    List asList(); //转换为List    Set asSet(); //转换为Set    Collection fromRealm(String realmName); //根据Realm名字获取    Set&lt;String&gt; getRealmNames(); //获取所有身份验证通过的Realm名字    boolean isEmpty(); //判断是否为空};</code></pre><ul><li>其中，getPrimaryPrincipal()时，如果只有一个Principal，那么直接返回即可，但若有多个则返回第一个，由于其底层由Map存储，所以第一个也就是任意一个。</li><li>oneByType() 、 byType()：根据凭据的类型返回对应的Principal。</li><li>fromRealm()：根据Realm名字返回对应的Principal。</li><li>因为此例中就一个Realm，所以直接调用getPrimaryPrincipal得到之前传入的用户名即可。</li></ul><pre><code>@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(        PrincipalCollection principals) {    //PrincipalCollection是一个身份集合，因为我们现在就一个Realm，    //所以直接调用getPrimaryPrincipal得到之前传入的用户名即可    String username=(String)principals.getPrimaryPrincipal();    ...}</code></pre><ul><li>MutablePrincipalCollection：可变的PrincipalCollection接口，提供了如下可变方法</li></ul><pre><code>public interface MutablePrincipalCollection extends PrincipalCollection {    void add(Object principal, String realmName); //添加Realm-Principal的关联    void addAll(Collection principals, String realmName); //添加一组Realm-Principal的关联    void addAll(PrincipalCollection principals);//添加PrincipalCollection    void clear();//清空}</code></pre><ul><li>SimplePrincipalCollection：MutablePrincipalCollection唯一实现类。在继承了AbstractAuthenticationStrategy的验证策略中，afterAttemp()会调用SimplePrincipalCollection的merge()将多个Principal合并到一个PrincipalCollection中。</li></ul><h3 id="PrincipalCollection示例"><a href="#PrincipalCollection示例" class="headerlink" title="PrincipalCollection示例"></a>PrincipalCollection示例</h3><ul><li>准备三个Realm，命名分别为a,b,c，身份凭证只有细微差别。</li></ul><pre><code>public class MyRealm1 implements Realm {    @Override    public String getName() {        return &quot;a&quot;; //realm name 为 “a”    }    @Override    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)            throws AuthenticationException {        return new SimpleAuthenticationInfo(                &quot;zhang&quot;, //身份 字符串类型                &quot;123&quot;,   //凭据                getName() //Realm Name        );    }}//和1完全一样，只是命名为bpublic class MyRealm2 implements Realm {    @Override    public String getName() {        return &quot;b&quot;; //realm name 为 “b”    }    @Override    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)            throws AuthenticationException {        return new SimpleAuthenticationInfo(                &quot;zhang&quot;, //身份 字符串类型                &quot;123&quot;,   //凭据                getName() //Realm Name        );    }}//除了命名不同，只是Principal类型为User，而不是简单的Stringpublic class MyRealm3 implements Realm {    @Override    public String getName() {        return &quot;c&quot;; //realm name 为 “c”    }    @Override    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)            throws AuthenticationException {        User user=new User(&quot;zhang&quot;,&quot;123&quot;);        return new SimpleAuthenticationInfo(                user, //身份 User类型                &quot;123&quot;,   //凭据                getName() //Realm Name        );    }}</code></pre><ul><li>shiro-multirealm.ini</li></ul><pre><code>[main]realm1=com.haien.shiroHelloWorld.principalTest.realm.MyRealm1realm2=com.haien.shiroHelloWorld.principalTest.realm.MyRealm2realm3=com.haien.shiroHelloWorld.principalTest.realm.MyRealm3securityManager.realms=$realm1,$realm2,$realm3</code></pre><ul><li>PrincipalCollectionTest：测试方法</li></ul><pre><code>public class PrincipalCollectionTest extends BaseTest {    @Test    public void testPrincipalCollection(){        login(&quot;classpath:config/shiro-multirealm.ini&quot;,                &quot;zhang&quot;,&quot;123&quot;);        Subject subject=subject();        //获取Map中第一个Principal，即PrimaryPrincipal        Object primaryPrincipal1=subject.getPrincipal();        //获取PrincipalCollection        PrincipalCollection principalCollection=subject.getPrincipals();        //也是获取PrimaryPrincipal        Object primaryPrincipal2=principalCollection.getPrimaryPrincipal();        //获取所有身份验证成功的Realm名字        Set&lt;String&gt; realmNames=principalCollection.getRealmNames();        for(String realmName:realmNames)            System.out.println(realmName);        //将身份信息转换为Set/List（实际转换为List也是先转为Set）        List&lt;Object&gt; principals=principalCollection.asList();        /*返回集合包含两个String类、一个User类，但由于两个String类都是&quot;zhang&quot;，        所以只只剩下一个,转为List结果也是一样*/        for(Object principal:principals)            System.out.println(&quot;set:&quot;+principal);        //根据realm名字获取身份，因为realm名字可以重复，        //所以可能有多个身份，建议尽量不要重复        Collection&lt;User&gt; users=principalCollection.fromRealm(&quot;c&quot;);        for(User user:users)            System.out.println(&quot;c:user=&quot;+user.getUsername()+user.getPassword());        Collection&lt;String&gt; usernames=principalCollection.fromRealm(&quot;b&quot;);        for(String username:usernames)            System.out.println(&quot;b:username=&quot;+username);    }}</code></pre><ul><li>代码实例：ideaProjects/shiroHelloWorld/PrincipalTest</li></ul><h3 id="AuthorizationInfo"><a href="#AuthorizationInfo" class="headerlink" title="AuthorizationInfo"></a>AuthorizationInfo</h3><ul><li>封装权限信息，主要是doGetAuthorizationInfo()时封装授权信息然后返回的。</li></ul><pre><code>public interface AuthorizationInfo extends Serializable {    Collection&lt;String&gt; getRoles(); //获取角色字符串信息    Collection&lt;String&gt; getStringPermissions(); //获取权限字符串信息    Collection&lt;Permission&gt; getObjectPermissions(); //获取Permission对象信息}</code></pre><ul><li>SimpleAuthorizationInfo：实现类，大多数时候使用这个。主要增加了以下方法：</li></ul><pre><code>authorizationInfo.addRole(&quot;role1&quot;); //添加角色到内部维护的role集合；    添加角色后调用MyRolePermissionResolver解析出权限authorizationInfo.setRoles(Set&lt;String&gt; roles); //将内部维护的role集合设置为入参authorizationInfo.addObjectPermission(new BitPermission(&quot;+user1+10&quot;)); //添加对象型权限authorizationInfo.addObjectPermission(new WildcardPermission(&quot;user1:*&quot;));authorizationInfo.addStringPermission(&quot;+user2+10&quot;); //字符串型权限authorizationInfo.addStringPermission(&quot;user2:*&quot;);authorizationInfo.setStringPermissions(Set&lt;String&gt; permissions);</code></pre><h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><ul><li>Shiro核心对象，基本所有身份验证、授权都是通过Subject完成的。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/131b0c95-9aed-36b0-9c09-0a6f9c6b3605.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><pre><code>//获取身份信息Object getPrincipal(); //Primary PrincipalPrincipalCollection getPrincipals(); // PrincipalCollection//身份验证void login(AuthenticationToken token) throws AuthenticationException; //调用各种方法；    登录失败抛AuthenticationException，成功则调用isAuthenticated()返回trueboolean isAuthenticated(); //与isRemembered()一个为true一个为falseboolean isRemembered(); //返回true表示是通过记住我登录到额而不是调用login方法//角色验证boolean hasRole(String roleIdentifier); //返回true或false表示成功与否boolean[] hasRoles(List&lt;String&gt; roleIdentifiers);boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers);void checkRole(String roleIdentifier) throws AuthorizationException; //失败抛异常void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;void checkRoles(String... roleIdentifiers) throws AuthorizationException;//权限验证boolean isPermitted(String permission);boolean isPermitted(Permission permission);boolean[] isPermitted(String... permissions);boolean[] isPermitted(List&lt;Permission&gt; permissions);boolean isPermittedAll(String... permissions);boolean isPermittedAll(Collection&lt;Permission&gt; permissions);void checkPermission(String permission) throws AuthorizationException;void checkPermission(Permission permission) throws AuthorizationException;void checkPermissions(String... permissions) throws AuthorizationException;void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException;//会话（登录成功相当于建立了会话，然后调用getSession获取Session getSession(); //相当于getSession(true)Session getSession(boolean create); //当create=false，如果没有会话将返回null，    当create=true，没有也会强制创建一个//退出void logout();//RunAsvoid runAs(PrincipalCollection principals)     throws NullPointerException, IllegalStateException; //实现允许A作为B进行访问，    调用runAs(b)即可boolean isRunAs(); //此时此方法返回truePrincipalCollection getPreviousPrincipals(); //得到a的身份信息，    而getPrincipals()得到b的身份信息PrincipalCollection releaseRunAs(); //不需要了RunAs则调用这个//多线程&lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException;void execute(Runnable runnable);&lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable);Runnable associateWith(Runnable runnable);</code></pre><ul><li>Subject的获取：一般不需要我们创建，直接通过SecurityUtils获取即可</li></ul><pre><code>public static Subject getSubject() {    Subject subject = ThreadContext.getSubject();    if (subject == null) {        subject = (new Subject.Builder()).buildSubject();        ThreadContext.bind(subject);    }    return subject;}</code></pre><ul><li>首先查看当前线程是否绑定了Subject，没有则通过Subject.BUilder构建一个并绑定到线程返回。</li><li>如果想自定义Subject实例的创建，代码如下：</li></ul><pre><code>new Subject.Builder().principals(身份).authenticated(true/false).buildSubject()</code></pre><ul><li>然后自己绑定到线程即可。在new Subject.Builder()时如果没有传入SecurityManager，则自动调用SecurityUtils.getsecurityManager()获取一个默认实现类的对象。</li><li>Subject一般用法</li></ul><ol><li>身份验证login()</li><li>授权hasRole*()/isPermitted*/checkRole*()/checkPermission*()</li><li>将相应的数据存储到会话Session</li><li>切换身份RunAs/多线程身份传播</li><li>退出</li></ol><ul><li>完整用户登录认证与授权示例：ideaProjects/shiroHelloWorld/chapter6、src/test/UserRealmTest为主测试</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Realm&quot;&gt;&lt;a href=&quot;#Realm&quot; class=&quot;headerlink&quot; title=&quot;Realm&quot;&gt;&lt;/a&gt;Realm&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;doGetAuthenticationInfo()和getAuthenticationInfo()一样，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%B9%9D%E7%AB%A0-jsp%E6%A0%87%E7%AD%BE/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第九章-jsp标签/</id>
    <published>2019-04-30T08:29:22.983Z</published>
    <updated>2019-03-01T12:33:56.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jstl标签库"><a href="#jstl标签库" class="headerlink" title="jstl标签库"></a>jstl标签库</h3><ul><li>Shiro提供了jstl标签用于在jsp页面、gsp页面进行权限控制，如根据登录页面显示相应的菜单。</li><li>导入标签库</li></ul><pre><code>&lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</code></pre><ul><li><p>guest标签：用户未登录时作为游客处理。</p><pre><code>&lt;shiro:guest&gt;    欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt;&lt;/shiro:guest&gt;</code></pre></li><li><p>user标签：用户已登录（身份验证或记住我）。</p><pre><code>&lt;shiro:user&gt;    欢迎[&lt;shiro:principal/&gt;]登录&lt;/a&gt;&lt;/shiro:user&gt;</code></pre></li><li><p>authenticated标签：用户已身份验证，不是记住我登录的。</p><pre><code>&lt;shiro:authenticated&gt;    用户[&lt;shiro:principal/&gt;]已身份验证通过&lt;/shiro:authenticated&gt;</code></pre></li><li><p>notAuthenticated标签：用户通过非身份验证方式登录。</p><pre><code>&lt;shiro:notAuthenticated&gt;    未身份验证（包括记住我）&lt;/shiro:notAuthenticated&gt;</code></pre></li><li><p>principal标签：显示用户身份信息，默认调用Subject.getPrincipal()。</p></li></ul><pre><code>//相当于Subject.getPrincipals().oneByType(String.class)&lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;//((User)Subject.getPrincipals()).getUsername()&lt;shiro:principal property=&quot;username&quot;/&gt;</code></pre><ul><li><p>hasRole标签：拥有指定角色将显示body体内容。</p><pre><code>&lt;shiro:hasRole name=&quot;admin&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt;&lt;/shiro:hasRole&gt;</code></pre></li><li><p>hasAnyRoles标签</p><pre><code>&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;&lt;/shiro:hasAnyRoles&gt;</code></pre></li><li><p>lacksRole：没有该角色将显示该内容。</p><pre><code>&lt;shiro:lacksRole name=&quot;abc&quot;&gt;    用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt;&lt;/shiro:lacksRole&gt;</code></pre></li><li><p>hasPermission</p><pre><code>&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;&lt;/shiro:hasPermission&gt;</code></pre></li><li><p>lacksPermission</p><pre><code>&lt;shiro:lacksPermission name=&quot;org:create&quot;&gt;    用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt;&lt;/shiro:lacksPermission&gt;</code></pre></li></ul><h3 id="自定义标签库"><a href="#自定义标签库" class="headerlink" title="自定义标签库"></a>自定义标签库</h3><pre><code>//导入自定义标签库&lt;%@taglib prefix=&quot;zhang&quot; tagdir=&quot;/WEB-INF/tags&quot; %&gt;//使用定义标签库&lt;zhang:hasAllRoles name=&quot;admin,user&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有角色admin和user&lt;br/&gt;&lt;/zhang:hasAllRoles&gt;&lt;zhang:hasAllPermissions name=&quot;user:create,user:update&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有权限user:create和user:update&lt;br/&gt;&lt;/zhang:hasAllPermissions&gt;&lt;zhang:hasAnyPermissions name=&quot;user:create,abc:update&quot;&gt;    用户[&lt;shiro:principal/&gt;]拥有权限user:create或abc:update&lt;br/&gt;&lt;/zhang:hasAnyPermissions&gt;</code></pre><ul><li>tags包下分别写了三个脚本：hasAllPermissions.tag、hasAllRoles.tag、hasAnyPermissions.tag，但是逻辑看不懂。</li><li><a href="https://github.com/zhangkaitao/shiro-example/tree/master/shiro-example-chapter9/src/main/webapp/WEB-INF/tags" target="_blank" rel="noopener">脚本地址</a></li><li><a href="https://jinnianshilongnian.iteye.com/blog/2026398" target="_blank" rel="noopener">参考文章</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jstl标签库&quot;&gt;&lt;a href=&quot;#jstl标签库&quot; class=&quot;headerlink&quot; title=&quot;jstl标签库&quot;&gt;&lt;/a&gt;jstl标签库&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shiro提供了jstl标签用于在jsp页面、gsp页面进行权限控制，如根据登录页面显示
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%B8%80-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第二章一-用户认证/</id>
    <published>2019-04-30T08:29:22.976Z</published>
    <updated>2019-04-03T05:50:33.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Java安全框架</li><li>Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。</li><li>三个核心组件：Subject、SecurityManager和Realms。</li><li>Subject:当前操作用户，代表了当前用户的安全操作。所有Subject都绑定到SEcurityManager，与Subject的所有交互都会委托给SecurityManager，可以把Subject认为是一个门面，SecurityManager才是实际的执行者。</li><li>SecurityManager：安全管理器，Shiro框架核心，管理所有用户的安全操作。即所有与安全有关的操作都会与SecurityManager交互；它管理着所有Subject，负责与其他组件进行交互，相当于SpringMvc的DispatcherServlet前端控制器。</li><li>Realm：Shiro从Realm（领域）获取安全数据（用户、角色、权限），就是说SecurityManager要验证用户身份，需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从REalm得到用户相应的权限进行验证；可以把Realm看成DataSource，即安全数据源。<h3 id="Shiro和Spring-Security比较"><a href="#Shiro和Spring-Security比较" class="headerlink" title="Shiro和Spring Security比较"></a>Shiro和Spring Security比较</h3></li><li><p>Shiro比Spring更容易使用，实现和最重要的理解</p></li><li><p>Spring Security更加知名的唯一原因是因为品牌名称</p></li><li><p>“Spring”以简单而闻名，但讽刺的是很多人发现安装Spring Security很难</p></li><li><p>然而，Spring Security却有更好的社区支持</p></li><li><p>Apache Shiro在Spring Security处理密码学方面有一个额外的模块</p></li><li><p>Spring-security 对spring 结合较好，如果项目用的springmvc ，使用起来很方便。但是如果项目中没有用到spring，那就不要考虑它了。</p></li><li><p>Shiro 功能强大、且 简单、灵活。是Apache下的项目，比较可靠，且不跟任何的框架或者容器绑定，可以独立运行</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ul><li><p>依赖</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;      &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;      &lt;version&gt;1.2.2&lt;/version&gt;  &lt;/dependency&gt;</code></pre></li><li>包含SecurityManager等最基础的对象。        </li><li><p>shiro.ini：准备用户库</p><pre><code>[users]zhang=123wang=123</code></pre></li><li><p>测试</p><pre><code>import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.subject.Subject;import org.apache.shiro.util.Factory;import org.apache.shiro.mgt.SecurityManager;import org.junit.Assert;import org.junit.Test;/** * @Author haien * @Description 运用shiro测试登录登出 * @Date 2019/2/15 **/public class LoginLogoutTest {    @Test    public void testHelloWorld(){        //1、获取SecurityManager工厂，并使用ini配置文件初始化SecurityManager        Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory=                new IniSecurityManagerFactory(&quot;classpath:config/shiro.ini&quot;);        //2、得到SecurityManager实例，并绑定SecurityUtils        SecurityManager securityManager=factory.getInstance();        SecurityUtils.setSecurityManager(securityManager);        //3、得到Subject，创建用户名、密码身份验证Token（即用户身份凭证）        Subject subject=SecurityUtils.getSubject();        UsernamePasswordToken token=new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;); //可能不止用户名、密码，如登录时允许用户名、邮箱、手机选一登录        try {            //4、登录，即身份验证            subject.login(token);        }catch (AuthenticationException e){            //5、身份验证失败        }        Assert.assertEquals(true,subject.isAuthenticated()); //断言用户是否已登录        //6、退出        subject.logout();    }}</code></pre></li><li>其中，验证失败抛出AuthenticationException或其子类，如，DisabledAccountException（禁用的账号）、LockedAccountException（锁定的账号）、UnknownAccountException（错误的账号）、、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等。</li><li>对于页面错误消息的显示，最好使用用户名/密码错误，而不是用户名错误、密码错误，防止一些恶意用户没法扫描账号库。</li></ul><h3 id="身份验证流程"><a href="#身份验证流程" class="headerlink" title="身份验证流程"></a>身份验证流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/8d639160-cd3e-3b9c-8dd6-c7f9221827a5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/722072-20171215174215261-1270582200.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</li><li>SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；</li><li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；</li><li>Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</li><li>Authenticator会把相应的表单参数封装类AuthenticationToken传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了，如果返回一个身份信息封装类AuthenticationInfo则身份验证成功。</li></ol><p>PS：此处可以配置多个Realm（上面的ini配置方式就是使用org.apache.shiro.realm.text.IniRealm），将按照相应的顺序及策略进行访问。</p><ul><li><p>Realm：获取用户库</p><pre><code>public interface Realm {    //返回一个唯一的Realm名字    String getName();     //判断此Realm是否支持此Token    boolean supports(AuthenticationToken var1);    //根据Token获取认证信息    AuthenticationInfo getAuthenticationInfo(AuthenticationToken var1)         throws AuthenticationException;}</code></pre></li><li><p>单Realm配置：自定义Realm实现类</p><pre><code>public class MyRealm1 implements Realm {    /**     * @Author haien     * @Description 获得唯一的Realm名字     * @Date 2019/2/15     * @Param []     * @return java.lang.String     **/    @Override    public String getName() {        return &quot;myrealm1&quot;;    }    /**     * @Author haien     * @Description 判断此Realm是否支持此Token     * @Date 2019/2/15     * @Param [authenticationToken]     * @return boolean     **/    @Override    public boolean supports(AuthenticationToken token) {        //仅支持UsernamePasswordToken        return token instanceof UsernamePasswordToken;    }    /**     * @Author haien     * @Description 根据Token获得Token信息     * @Date 2019/2/15     * @Param [authenticationToken表单参数封装类]     * @return org.apache.shiro.authc.AuthenticationInfo身份信息封装类     **/    @Override    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken)            throws AuthenticationException {        //表单参数，来自login方法        String username=(String)authenticationToken.getPrincipal();        String password=new String((char[])authenticationToken.getCredentials());        //String password=(String)authenticationToken.getCredentials();        //若用户名错误        if(!&quot;zhang&quot;.equals(username)){ //zhang来自用户库            throw new UnknownAccountException();        }        //若密码错误        if(!&quot;123&quot;.equals(password)){ //123来自用户库            throw new IncorrectCredentialsException();        }        //身份验证成功，返回一个AuthenticationInfo实现        return new SimpleAuthenticationInfo(username,password,getName());    }}</code></pre></li><li><p>配置ini文件指定自定义Realm实现</p><pre><code>;第三方用户库：指定自定义Realm（可以在这个Realm里面定义用户库位置）myRealm1=com.haien.shiroHelloWorld.realm.MyRealm1 //相当于调用public无参构造创建对象;指定securityManage的realms实现(通过￥name来引入上面的Realm定义)securityManager.realms=$myRealm1 //相当于调用setter方法设置对象引用</code></pre></li><li><p>多Realm配置。此处我们使用显式指示顺序的方式指定Realm的顺序，若删去第4行，SecurityManager则会按照Realm声明的顺序进行验证（即无需设置realms属性，会自动发现）；而显式指定后，没有被指定到的Realm将会被忽略。</p><pre><code>1 myRealm1=com.haien.shiroHelloWorld.realm.MyRealm12 myRealm2=com.haien.shiroHelloWorld.realm.MyRealm23 ;多Realm配置4 securityManager.realms=$myRealm1,$myRealm2</code></pre><h3 id="Shiro默认提供的Realm"><a href="#Shiro默认提供的Realm" class="headerlink" title="Shiro默认提供的Realm"></a>Shiro默认提供的Realm</h3></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/34062d4e-8ac5-378a-a9e2-4845f0828292.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>一般继承AuthorizingRealm即可，本身有权限验证doGetAuthorizationInfo()，又继承了用户验证doGetAuthenticationInfo，也继承了缓存功能。其中主要默认实现如下：<ul><li>org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息；</li><li>org.apache.shiro.realm.text.PropertiesRealm： user.username=password,role1,role2指定用户名/密码及其角色；role.role1=permission1,permission2指定角色及权限信息；</li><li>org.apache.shiro.realm.jdbc.JdbcRealm：通过sql查询相应的信息，如“select password from users where username = ?”获取用户密码，“select password, password_salt from users where username = ?”获取用户密码及盐；“select role_name from user_roles where username = ?”获取用户角色；“select permission from roles_permissions where role_name = ?”获取角色对应的权限信息；也可以调用相应的api进行自定义sql；</li></ul></li><li>特别地，值需要用户验证而不需要授权，则继承AuthenticatingRealm即可。</li><li>而若实现Realm的话，一般是重写getAuthenticationInfo()实现用户验证，没有授权给功能。</li></ul><h3 id="JDBC-Realm"><a href="#JDBC-Realm" class="headerlink" title="JDBC Realm"></a>JDBC Realm</h3><ul><li>先到数据库shiro下建表：users,user_roles,roles_permissions，并添加一个用户：username-zhang,password-123.</li><li><p>ini配置</p><pre><code>;jdbc用户库jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm //实例名=全限定类名，创建一个实例dataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.Driver //实例名.属性=值，自动调用setter进行赋值dataSource.url=jdbc:mysql://127.0.0.1:3306/shirodataSource.username=rootdataSource.password=123456jdbcRealm.dataSource=$dataSourcesecurityManager.realms=$jdbcRealm</code></pre></li></ul><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><ul><li>ideaProjects/shiroHelloWorld<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3></li><li><a href="https://jinnianshilongnian.iteye.com/blog/2019547" target="_blank" rel="noopener">张开涛跟我学shiro</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java安全框架&lt;/li&gt;
&lt;li&gt;Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://47.107.237.149/2019/04/30/Shiro%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BA%8C-%E9%AA%8C%E8%AF%81%E8%80%85Authenticator%E3%80%81%E9%AA%8C%E8%AF%81%E7%AD%96%E7%95%A5AuthenticationStrategy/"/>
    <id>http://47.107.237.149/2019/04/30/Shiro第二章二-验证者Authenticator、验证策略AuthenticationStrategy/</id>
    <published>2019-04-30T08:29:22.971Z</published>
    <updated>2019-02-23T08:02:12.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Authenticator及AuthenticationStrategy"><a href="#Authenticator及AuthenticationStrategy" class="headerlink" title="Authenticator及AuthenticationStrategy"></a>Authenticator及AuthenticationStrategy</h3><ul><li><p>Authenticator的职责是验证用户，被subject的login()调用。</p><pre><code>public AuthenticationInfo authenticate(AuthenticationToken authenticationToken)    throws AuthenticationException {    //调用了Realm的getAuthenticationInfo()}</code></pre></li><li>Authenticator：SecurityManager是其子接口，默认实现类为ModularRealmAuthenticator，其委托给多个Realm进行验证。</li><li>AuthenticatorStrategy：制定多个Realm的验证规则。默认提供的实现：<ul><li>FirstSuccessfulStrategy：只要有一个Realm验证成功即可，值返回第一个验证成功的Realm的认证信息。</li><li>AtLeastSuccessfulStrategy：只要有一个Realm验证成功即可，返回所有验证成功的Realm的认证信息。</li><li>AllSuccessfulstrategy：默认使用；所有Realm都验证成功才行，返回所有认证信息。</li></ul></li><li>假设我们有三个Realm：<ul><li>myRealm1： 用户名/密码为zhang/123时成功，且返回身份/凭据为zhang/123；</li><li>myRealm2： 用户名/密码为wang/123时成功，且返回身份/凭据为wang/123；</li><li>myRealm3： 用户名/密码为zhang/123时成功，且返回身份/凭据为<a href="mailto:zhang@163.com" target="_blank" rel="noopener">zhang@163.com</a>/123。</li></ul></li><li>现在测试一下AllSuccessfulStrategy验证策略</li><li><p>首先是ini配置文件</p><pre><code>;指定securityManager的authentication实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator;指定securityManager.authenticator的authenticationStragegyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.haien.shiroHelloWorld.realm.MyRealm1myRealm2=com.haien.shiroHelloWorld.realm.MyRealm2myRealm3=com.haien.shiroHelloWorld.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3</code></pre></li><li><p>测试</p><pre><code>/** * @Author haien * @Description 测试AllSuccessfulStrategy成功 * @Date 2019/2/16 * @Param [] * @return void **/@Testpublic void testAllSuccessfulStrategyWithSuccess(){    //登录成功（因为ini配置文件中没有使用身份必须为wang的myRealm2）    login(&quot;classpath:config/shiro-authenticator-all-success.ini&quot;); //登录逻辑代码先通用化了    Subject subject=SecurityUtils.getSubject();    //得到一个身份集合，其包含了Realm验证成功的身份信息    PrincipalCollection principalCollection=subject.getPrincipals();    //包含了zhang和zhang@163.com的身份凭证    Assert.assertEquals(2,principalCollection.asList().size());}/** * @Author haien * @Description 测试AllSuccessfulStrategy失败 * @Date 2019/2/17 * @Param [] * @return void **/@Test(expected = UnknownAccountException.class) //括号里表明当方法抛出此异常时测试成功public void testAllSuccessfulAccountWithFail(){    //但实际登录失败（配置文件改为使用myRealm1和myRealm2）    login(&quot;classpath:config/shiro-authenticator-all-fail.ini&quot;);    Subject subject=SecurityUtils.getSubject();}</code></pre></li><li>以上测试失败方法如果捕获异常的话可获得以下调用链</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://zhuzhuzai.oss-cn-shenzhen.aliyuncs.com/%E6%8D%95%E8%8E%B7606.PNG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="自定义AuthenticationStrategy"><a href="#自定义AuthenticationStrategy" class="headerlink" title="自定义AuthenticationStrategy"></a>自定义AuthenticationStrategy</h3><ul><li><p>AuthenticationStrategy接口类</p><pre><code>//在所有Realm验证之前调用AuthenticationInfo beforeAllAttempts(Collection&lt;? extends Realm&gt; realms,    AuthenticationToken token) throws AuthenticationException;//在每个Realm之前调用AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token,     AuthenticationInfo aggregate) throws AuthenticationException;//在每个Realm之后调用AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token,     AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)    throws AuthenticationException;//在所有Realm之后调用AuthenticationInfo afterAllAttempts(AuthenticationToken token,     AuthenticationInfo aggregate)throws AuthenticationException;//将所有验证成功的身份信息集合起来，便于最后一起返回；FirstSuccessfulStrategy类重写了该方法AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate)</code></pre></li><li><p>自定义AuthenticationStrategy实现类一般继承AbstractAuthenticationStrategy即可。</p></li><li><p>AtLeastTwoAuthenticatorStrategy：至少两个通过才行，返回所有验证信息</p><pre><code>public class AtLeastTwoAuthenticatorStrategy extends AbstractAuthenticationStrategy {    /**     * @Author haien     * @Description 在所有Realm验证之前调用     * @Date 2019/2/17     * @Param [realms, token]     * @return org.apache.shiro.authc.AuthenticationInfo     **/    @Override    public AuthenticationInfo beforeAllAttempts(Collection&lt;? extends Realm&gt; realms,           AuthenticationToken token) throws AuthenticationException {        //和父类方法一样，返回一个空的身份凭证        return new SimpleAuthenticationInfo();    }    /**     * @Author haien     * @Description 在每个Realm验证之前调用     * @Date 2019/2/17     * @Param [realm, token, aggregate]     * @return org.apache.shiro.authc.AuthenticationInfo     **/    @Override    public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token,           AuthenticationInfo aggregate) throws AuthenticationException {        //和父类方法一样，返回之前合并的        return aggregate;    }    @Override    public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token,      AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)      throws AuthenticationException {        //也是和父类方法一样        AuthenticationInfo info;        if(singleRealmInfo==null){            info=aggregateInfo;        }else {            if(aggregateInfo==null){                info=singleRealmInfo;            }else{                //调用父类merge()将所有身份凭证集合起来，最后一起返回                info=merge(singleRealmInfo,aggregateInfo);            }        }        return info;    }    /**     * @Author haien     * @Description 真正重写的方法：判断是否至少两个Realm通过     * @Date 2019/2/17     * @Param [token, aggregate]     * @return org.apache.shiro.authc.AuthenticationInfo     **/    @Override    public AuthenticationInfo afterAllAttempts(AuthenticationToken token,           AuthenticationInfo aggregate) throws AuthenticationException {        if(aggregate==null||CollectionUtils.isEmpty(aggregate.getPrincipals())                ||aggregate.getPrincipals().getRealmNames().size()&lt;2){ //是否至少两个通过            throw new AuthenticationException(&quot;Authentication token of type [&quot;                    +token.getClass()+&quot;]&quot;+&quot;could not be authenticated by any                     configured realms.Please ensure that at least two realm                     can authenticate these tokens.&quot;);        }        //这一步即父类方法体        return aggregate;    }}</code></pre></li><li><p>OnlyOneAuthenticatorStrategy：至少一个通过，重写的是afterAttempt()</p><pre><code>@Overridepublic AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token,       AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)        throws AuthenticationException {    AuthenticationInfo info;    if(singleRealmInfo == null){ //若当前身份凭证为空，说明未通过认证        info=aggregateInfo; //返回之前的身份凭证集合    }else{ //否则需要加入集合        if(aggregateInfo==null){ //若集合为空，则返回当前的身份凭证            info=singleRealmInfo;        }else{ //两个都不为空才需要加入集合            info=merge(singleRealmInfo,aggregateInfo);            if(info.getPrincipals().getRealmNames().size()&gt;1){                System.out.println(info.getPrincipals().getRealmNames()); //打印集合                throw new AuthenticationException(&quot;Authentication token of type [&quot;                  +token.getClass()+&quot;]&quot;+&quot;could not be authenticated by any configured &quot; +                        &quot;realms. Please ensure that only one realm can authenticated &quot; +                        &quot;these tokens&quot;);            }        }    }    return info;}</code></pre></li><li>代码实例：ideaProjects/shiroHelloWord/authenticationstrategy</li><li><a href="https://github.com/zhangkaitao/shiro-example/blob/master/shiro-example-chapter2/src/test/java/com/github/zhangkaitao/shiro/chapter2/authenticator/strategy/OnlyOneAuthenticatorStrategy.java" target="_blank" rel="noopener">张开涛跟我学shiro第二章源码</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Authenticator及AuthenticationStrategy&quot;&gt;&lt;a href=&quot;#Authenticator及AuthenticationStrategy&quot; class=&quot;headerlink&quot; title=&quot;Authenticator及Authen
      
    
    </summary>
    
    
  </entry>
  
</feed>

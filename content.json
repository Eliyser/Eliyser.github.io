{"meta":{"title":"never belief any book","subtitle":"love youself,love life","description":"love youself,love life","author":"Haien","url":"http://47.107.237.149"},"pages":[{"title":"categories","date":"2018-06-03T09:56:30.000Z","updated":"2018-06-03T11:50:01.753Z","comments":true,"path":"categories/index.html","permalink":"http://47.107.237.149/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-03T09:54:24.000Z","updated":"2018-06-03T11:49:23.640Z","comments":false,"path":"tags/index.html","permalink":"http://47.107.237.149/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"classpath根目录","date":"2019-04-30T08:25:44.644Z","updated":"2019-04-28T05:40:38.096Z","comments":true,"path":"2019/04/30/classpath根目录/","link":"","permalink":"http://47.107.237.149/2019/04/30/classpath根目录/","excerpt":"","text":"在编程的时候，就是放在src下面，和你自己创建的包同一级 在eclipse编译并发布到服务器端后，src路径对应WEB-INF路径，包中的.java文件对应 WEB-INF下的classes文件夹下即calsses/com/javaweb/environment/test/.class。 classPath即class类文件的根路径，所以发布前根路径是src,对应发布后的WEB-INF/classes/ 用maven构建项目的时候，classpath即src/main/下的resources、java和webapp。若在main下新建一个properties文件，则classpath也指该文件。 项目中文件加载pojo对象、其他文件的默认路径都是classpath，不需要加前缀，直接写包名即可，如： //加载pojo对象 &lt;context: component-scan base-package=&quot;com.taotao.controller&quot; /&gt; //加载其他文件 &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;context:property-placeholder location=&quot;classpath:resource/db.properties&quot; /&gt; 参考文章 编译后，classpath是指WEB-INF文件夹下的classes目录 解释classes含义： 存放各种资源配置文件，eg. init.properties,log4j.properties.struts.xml 存放模板文件，eg. actionerror.ftl 存放class文件，对应的是项目开发时的src目录的编译文件 总结：这是一个定位资源的入口 //加载classpath下以applicationContext开头的配置文件 &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt; //加载其子目录下的文件 &lt;param-value&gt;classpath:context/conf/controller.xml&lt;/param-value&gt; **/：表示任意目录 **/applicationContext-.xml表示任意目录下以applicationContext开头的xml文件。 classpath和classpath*的区别","categories":[],"tags":[]},{"title":"","slug":"Cannot add or update a child row-a foreign key constraint fails","date":"2019-04-30T08:25:44.639Z","updated":"2018-05-19T14:56:55.891Z","comments":true,"path":"2019/04/30/Cannot add or update a child row-a foreign key constraint fails/","link":"","permalink":"http://47.107.237.149/2019/04/30/Cannot add or update a child row-a foreign key constraint fails/","excerpt":"","text":"可能插入了一个主表中并不存在的外键，这时候要检查这个外键在主表中是否存在","categories":[],"tags":[]},{"title":"","slug":"CallableStatement接口","date":"2019-04-30T08:25:44.637Z","updated":"2018-06-15T06:57:00.718Z","comments":true,"path":"2019/04/30/CallableStatement接口/","link":"","permalink":"http://47.107.237.149/2019/04/30/CallableStatement接口/","excerpt":"","text":"CallableStatement是prepareStatement的子接口 如何用程序调用存储过程呢？ 设置输入参数 设置返回参数 获取返回参数 代码实例：ideaProject-&gt;src.main.java.com.haien.MyCallableStatement","categories":[],"tags":[]},{"title":"","slug":"Cache和Buffer的区别","date":"2019-04-30T08:25:44.630Z","updated":"2019-03-20T13:55:52.104Z","comments":true,"path":"2019/04/30/Cache和Buffer的区别/","link":"","permalink":"http://47.107.237.149/2019/04/30/Cache和Buffer的区别/","excerpt":"","text":"Cache 高速缓存。 我们知道各种硬件存在制作工艺上的差别，所以当两种硬件需要交互时，肯定会存在速度上的差异，而且只有交互双方都完成了这一步才能同时解放去处理其他书屋。 假如现在有A、B两个设备，A用来交互的接口速度是1000M/s，B是500M/s，那么以下两种情况： A从B取一个1000M的文件原本需要1s，实际却需要2s，额外的1s是等待B把剩余的500M找出来，而这1s的空闲时间除了等待干不了其他事情。 A给B1000M文件也需要2s，本来也只需要1s,但B 1s内只能拿500M，剩下的500M还得等下一个1sB来取，等待的这1s也是不能干别的事。 解决的办法就是在A和B之间加一层区域ab，它提供了两个接口，a接口的速率接近A，b接口则接近B，然后我们把ab的a和A相连，b和B相连，让A、B把文件通过ab传给对方： A要从B中取1000M文件，它把需求告诉了ab，接下来ab通过b和B进行文件传送，对于第一次传送ab并没起什么作用，但第一次之后ab就背着B偷偷缓存了一个一模一样的文件，而且只要从B取东西，ab都会缓存一个副本下来，下次谁来取都直接把该副本通过a接口给它，由于a的速率相对接近A，所以A觉得节省了时间。说白了ab就是提供了缓存能力，即cache。ab会定期清cache以保证提供的东西是最新的。例如，CPU读取内存数据时，一般都是经过内存的一部分作为缓存来增加系统的读取性能。 A要给B发个1000M的文件，它通过a接口给了ab。站在A的角度上好像它认为已经交到B手上了，但其实ab并不先交给B，而是先缓存下来，等到系统空闲或buffer满了再通过b接口慢慢给B，这样A就不用等了。此时，ab提供的就是缓冲的能力，即Buffer。它存在的目的就是适用于速度快的往速度慢的输出东西，例如，内存的数据要写到磁盘，CPU寄存器里的数据写到内存。","categories":[],"tags":[]},{"title":"","slug":"Cache高速缓冲存储","date":"2019-04-30T08:25:44.622Z","updated":"2019-03-21T12:00:30.911Z","comments":true,"path":"2019/04/30/Cache高速缓冲存储/","link":"","permalink":"http://47.107.237.149/2019/04/30/Cache高速缓冲存储/","excerpt":"","text":"计算机中的缓存 存储器是计算机五大组成部分之一（控制器、运算器、存储器、输入和输出），分为主存储器和辅助存储器。 主存储器又称内存Memory，辅助存储器又称外存。 我们平时使用的程序，如Windows操作系统、打字软件、游戏软件，一般都是安装在硬盘等外存上的，使用时才将其调入内存运行。我们平时输入一段文字，或玩一个游戏，都是在内存中进行的。 就好比在一个书房里，外存相当于存放书籍的书架，内存则是我们工作的书桌。 内存是计算机程序与CPU进行沟通的桥梁，计算机中所有程序的运行都是在内存中进行的，其作用是战术存放CPU中的运算数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中。为了配合CPU的高速，内存和CPU之间还加了一层高速缓存。 通常我们把要永久保存的、大量的数据存储在外存，而把一些临时或少量的数据和程序放在内存。 程序中的缓存 当程序的并发量较高、对实时性的要求较高时，我们的程序就必须使用缓存了，否则，可能显示一个公司的报表、在搜索引擎上搜索资料都要花几分钟的时间。 使用缓存，就是在取出数据结果后，暂时将数据存储在某些可以快速存取的位置，如Nosql、MemoryCache，让这些耗时的数据重复地利用，不必每次重复请求相同的数据，读取时先从缓存中找，节省CPU和io。 缓存的终点在于更新，如果数据没有及时更新和删除，就会成为脏数据。 缓存策略 也就是用一些算法决定什么时候清缓存、清哪一部分。 缓存控制 在Java中，我们一般对方法进行缓存控制。当调用findUserById(long id)时，先从缓存查找有没有结果。没有再调用该方法从数据库加载用户，并添加到缓存中。下次调用前将会从缓存中获取数据。","categories":[],"tags":[]},{"title":"","slug":"c forEach","date":"2019-04-30T08:25:44.619Z","updated":"2018-05-03T12:01:12.494Z","comments":true,"path":"2019/04/30/c forEach/","link":"","permalink":"http://47.107.237.149/2019/04/30/c forEach/","excerpt":"","text":"-&lt;c:forEach var=”pow” items=”${power }”&gt; ${pow } &lt;/c:forEach&gt;在作用域比如request、session里面存了power这个集合，然后这边${power }取一下就可以遍历了","categories":[],"tags":[]},{"title":"","slug":"byte数组本质、0xff、String转byte[]原理","date":"2019-04-30T08:25:44.609Z","updated":"2019-02-23T05:49:46.416Z","comments":true,"path":"2019/04/30/byte数组本质、0xff、String转byte[]原理/","link":"","permalink":"http://47.107.237.149/2019/04/30/byte数组本质、0xff、String转byte[]原理/","excerpt":"","text":"0x（零叉）前缀表示后面的数为十六进制数，0（零）前缀表示八进制。 把number转换为二进制，只取最低的8位，也就是一个字节。而0xff二进制最后8位就是1111 1111，前面全是0。将number &amp; 0xff，只有最后8位被显示出来，前面无论是0是1最后都是0，被遮蔽。 byte的本质就是一个8位的二进制数字，即表示从0~255的一个数字，所以byte数组中存的是数字。比如，byte[] byteArrary = { 0x01, 0x02, 0x03, 34 };其中，int型常量不能超过255，若将34改为340则报错，而int型变量不允许存入，原因是变量是不确定的，它可能超过了255。 String转byte[]，就是先转ASCII码，然后再转成二进制，如，A-&gt;65-&gt;65的二进制表示.","categories":[],"tags":[]},{"title":"","slug":"BufferedImage类、Image类、Graphics类","date":"2019-04-30T08:25:44.600Z","updated":"2019-02-10T02:35:03.455Z","comments":true,"path":"2019/04/30/BufferedImage类、Image类、Graphics类/","link":"","permalink":"http://47.107.237.149/2019/04/30/BufferedImage类、Image类、Graphics类/","excerpt":"","text":"BufferedImage Image是一个抽象类，BufferedImage是其实现类，是一个带缓冲区图像类，主要作用是将一幅图片加载到内存中（BufferedImage生成的图片在内存里有一个图像缓冲区，利用这个缓冲区我们可以很方便地操作这个图片），提供获得绘图对象、图像缩放、选择图像平滑度等功能，通常用来做图片大小变换、图片变灰、设置透明不透明等。 public abstract Graphics getGraphics()； //获得在图像上绘图的Graphics对象 Java将一幅图片加载到内存的方法是： String imgPath = &quot;C://demo.jpg&quot;; BufferedImage image = ImageIO.read(new FileInputStream(imgPath)); 继而可以对图片进行操作,比如，获得图片的宽度：image.getWidth() 图片只有加载到内存中才能进行进一步的处理。 RGB:R（红）G（绿）B（蓝）色彩模式是工业界的一种颜色标准。在Java中每个RGB像素所占的位数为8. 创建： 直接调用构造函数 //指定宽高、图像字节灰度 BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY) //创建一个不带透明色的对象 BufferedImage bimage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //创建一个带透明色的对象 new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); - 根据已经存在的BufferedImage对象创建一个copy体 public BufferedImage createBufferedImage(BufferedImage src) - 通过创建ColorModel（颜色转换为Java中的像素表示）和Raster（光栅，描述像素的）对象创建BufferedImage对象 public BufferedImage createBufferedImage（int width , int height, byte[] pixels）{ //pixel像素 ColorModel cm = getColorModel(); SampleModel sm = getIndexSampleModel((IndexColorModel)cm, width,height); DataBuffer db = new DataBufferByte(pixels, width*height,0); WritableRaster raster = Raster.creatWritableRaster(sm, db,null); BufferedImage image = new BufferedImage (cm, raster,false, null); return image; } - 读取一个图片文件来转换. BufferedImage image = ImageIo.read(new FileInputStream(filePath)); 保存：找个位置写出去 File outputfile = new File(&quot;save.png&quot;); ImageIO.write(bi,&quot;png&quot;,outputfile); Raster和ColorModel对象、BufferedImage的创建与保存ImageIO 提供read()和write()静态方法，读写图片，比以往的InputStream读写更方便。BufferedImage与byte数组的转换 在传输中，图片是不能直接传的，需要先转为字节数组再传输较为方便；而字节数组再转回BufferedImage则还原图片。 BufferedImage–&gt;byte[] ImageIO.write(BufferedImage image,String format,OutputStream out); //format:图片格式，“gif&quot;等； //out:目标；特别的，如果目标为byte数组，则将其预设为ByteArrayOutputStream即可传入此方法，执行完后，只要toByteArray()即可获得byte[]. byte[]–&gt;bufferedImage ByteArrayInputStream in = new ByteArrayInputStream(byte[]b); //将b作为输入流； BufferedImage image = ImageIO.read(InputStream in); //将in作为输入流，读取图片存入image中，而这里in可以为ByteArrayInputStream(); 参考文章应用 缓存网络图片 //获得图片地址 Url img = new URL(url); //获得图片输入流 InputStream in = img.openStream(); //把输入流转为BufferedImage JPEGImageDecoder decoderFile = JPEGCodec.createJPEGDecoder(in); BufferedImage image = decoderFile.decodeAsBufferedImage(); //获得其byte数组 ImageIO.write(image, &quot;jpg&quot;, bos); //写出 InputStream is = new ByteArrayInputStream(os.toByteArray()); 具体测试与改动 URL url = new URL(&quot;http://www.google.com/intl/en_ALL/images/logo.gif&quot;); BufferedImage image = ImageIO.read(url); ByteArrayOutputStream os = new ByteArrayOutputStream(); ImageIO.write(image, &quot;gif&quot;, os); InputStream is = new ByteArrayInputStream(os.toByteArray()); Graphics 提供基本绘图和显示格式化文字的方法，画图用的坐标系原点在左上角，纵轴向下。主要有画线段、矩形、圆、椭圆、圆弧、多边形等各种颜色的图形、线条。 Graphics2D类提供更强大的绘图能力。 在窗口画一条直线：drawLine(int x1,int y1,int x2,int y2) g.drawLine(3,3,50,50);//在(3,3)与(50,50)之间画一条线段 g.drawLine(100,100,100,100);//画一个点 画折线：drawPolyline(int[],int[],int)，各点的x、y坐标，折线数。 画字符串：drawString(String str,int x,int y)，x、y是开始显示的位置，使用默认字体、大小、黑色。再写下一行要写在什么位置就很难精确定位了。若要精确定位，则需要知道字符串显示的长度和字高，可以通过FontMetrics类来实现。 FontMetrics fm = g.getFontMetrics(font); //从Graphics对象获取FontMetrics对象 int height = fm.getHeight(); //调用其getHeight()获得字高 int width = fm.stringWidth(s1); //获得字符串宽度 应用FontMetrics精确定位 String s1 = &quot;Hello, Java World!&quot;; g.setColor(Color.red); setBackground(new Color(0,255,0)); Font font = new Font(&quot;Arial&quot;, Font.BOLD, 18); g.setFont(font); FontMetrics fm = g.getFontMetrics(font); int height = fm.getHeight(); int width = fm.stringWidth(s1); int posx =50; int posy = 50; g.drawString(s1 ,posx, posy); g.drawString(&quot;I will come in.&quot; ,posx +width, posy+height); 显示效果 设置画笔字体：setFont(Font font)；Java有一个类叫GraphicsEnvironment提供绘图环境，其中getAvailableFontFamilyNames()方法可获取程序所在操作系统的所有字体名（是String不是Font）。 GraphicsEnvironment gv = GraphicsEnvironment.getLocalGraphicsEnvironment(); String[] ftNames = gv.getAvailableFontFamilyNames(); for (int i=0; i&lt;ftNames.length; i++) Font ft = new Font(ftNames[i], Font.BOLD, 14); 设置前景色（画笔颜色）：setColor(Color color)，选择颜色有两种方法，一是直接用颜色值RGB创建Color对象：Color color=new Color(int R,int G,int B),由于是8位，所以不能超过255;二是用颜色常量如Color.red,Color.green等，Color类提供了13中颜色常量。 设置背景色：setBackground(new Color(int,int,int)) 来个写不同字体的小例子 public void paint (Graphics g){ String s1 = &quot;This Font is &quot;; Font font = new Font(&quot;Arial&quot;, Font.BOLD, 18); g.setColor(Color.red); setBackground(new Color(0,255,0)); g.setFont(font); g.drawString(s1 + font.getName() ,20, 60); g.setFont(new Font(&quot;隶书&quot;, Font.BOLD, 28)); g.drawString(&quot;现在是隶书&quot; ,20, 120); g.setColor(new Color(0,0,0)); } 显示效果 画矩形：drawRect(int x,int y,int width,int height),画矩形线框，x,y指定了左上角位置，后两个为矩形宽高；fillRect(iny x.int y,int width,int height),指定填充颜色。 g.drawRect(80,100,40,25);//画线框 g.setColor(Color.yellow);g.fillRect(20,70,20,30);//画着色块 画圆角矩形：drawRoundRect(int x,int y,int width,int height,int arcWidth,int arcHeight),线框，最后两个宽高是圆角弧的横向直径和纵向直径；fillRoundRect(int x,int y,int width,int height,int arcWidth,int arcHeight),颜色填充。 g.drawRoundRect(10,10,150,70,40,25);//画一个圆角矩形 g.setColor(Color.blue); g.fillRoundRect(80,100,100,100,60,40);//涂一个圆角矩形块 g.drawRoundRect(10,150,40,40,40,40);//画圆 g.setColor(Color.red); g.fillRoundRect(80,100,100,100,100,100);//画圆块 画三维矩形: draw3DRect(int x,int y,int width,int height,boolean raised),画一个突出显示的矩形（即3D矩形），raise是突出与否；fill3DRect(int x,int y,int width,int height,boolean raised)，颜色填充。 g.draw3DRect(80,100,40,25,true);//画一个线框 g.setColor(Color.yellow); g.fill3DRect(20,70,20,30,true);//画一个着色块 画椭圆：drawOval(int x,int y,int width,int height),x、y是中心坐标，长轴、短轴；fillOval(int x,int y,int width,int height),填充。 画圆弧：drawArc(int x,int y,int width,int height,int startAngle,int arcAngle),画椭圆一部分的圆弧线，椭圆中心时它的外接矩形的中心，外接矩形左上角坐标为(x,y)，宽width，高height，startAngle单位是度，其实角度0度是指3点钟方向，startAngle和arcAngle表示从startAngle角度开始，逆时针方向画arcAngle度的弧，约定，正值度数是逆时针方向，负数为顺时针，例如-90°是6点钟方向；fillArc(int x,int y,int width, int height, int startAngle, int arcAngle)，着色。 g.drawArc(10,40,90,50,0,180);//画圆弧线 g.drawArc(100,40,90,50,180,180);//画圆弧线 g.setColor(Color.yellow); g.fillArc(10,100,40,40,0,-270);//填充缺右上角的四分之三的椭圆 g.setColor(Color.green); g.fillArc(60,110,110,60,-90,-270);//填充缺左下角的四分之三的椭圆 画多边形：drawPolygon(int xPoints[],int yPoints[],int nPoints),多边形是多条线段首尾连接而成的封笔平面图，多边形线段端点的x,y坐标存储在两个数组中，画多边形就是按给定的坐标点顺序用直线段将它们连起来，nPoints是坐标点个数；fillPolygon(int xPoints[],int yPoints[],int nPoints)，着色。 int px1[]={50,90,10,50};//首末点相重,才能画多边形 int py1[]={10,50,50,10}; int px2[]={140,180,170,180,140,100,110,140}; int py2[]={5,25,35,45,65,35,25,5}; g.setColor(Color.blue); g.fillPolygon(px1,py1,4); g.setColor(Color.red); g.drawPolygon(px2,py2,9); 也可以用多边形对象Polygon画多边形 Polygon()：创建多边形对象，暂时没有坐标点。 Polygon(int xPoints[],int yPoints[],int nPoints)：用指定的坐标点创建多边形对象。 addPoint()：将一个坐标点加入到Polygon对象中。 drawPolygon(Polygon p)：绘制多边形。 fillPolygon(Polygon p)：和指定的颜色填充多边形。 画一个三角形 int x[]={140,180,170,180,140,100,110,100}; //用多边形对象不要求首末点重合 int y[]={5,25,35,45,65,45,35,25}; Polygon ponlygon1=new Polygon(); polygon1.addPoint(50,10); polygon1.addPoint(90,50); polygon1.addPoint(10,50); g.drawPolygon(polygon1); g.setColor(Color.yellow); Polygon polygon2 = new Polygon(x,y,8); g.fillPolygon(polygon2); 画图片：drawImage(Image image,int x,int y) 擦除矩形块：clearREct(int x,int y,int width,int height),当需要在一个着色图形中有一个空缺的矩形时，可用背景色填充一矩形块实现，相当于在该图形上使用了橡皮擦。以下代码实现了在一个圆中擦除了一个矩形块 g.setColor(Color.blue); g.fillOval(50,50,100,100);g.clearRect(70,70,40,55); 限定作图显示区域：clipRect(int x,int y,int width,int height),用一个矩形表示图形的显示区域，超出部分不显示，多个限制区有覆盖时，得到交集区域 g.clipRect(0,0,100,50);g.clipRect(50,25,100,50); 复制图形：copyArea(int x,int y,int width,int height,int dx,int dy),dx和dy表示将图形复制到原位置偏移的像素点数，正值为往右或往下偏移，负值为往左或往上偏移，x、y是要复制矩形区域的左上角坐标。以下代码将一个矩形的部分、另一个矩形的全部分别平移 g.drawRect(10,10,60,90); g.fillRect(90,10,60,90); g.copyArea(40,50,60,70,-20,80); g.copyArea(110,50,60,60,10,80); 对Point、Rectangle类的应用 Point p = new Point(cx / 2, cy / 2); //定义一个点 Rectangle rect = new Rectangle((p.x - 40), (p.y - 40), 80, 40); //定义一个矩形 int[] xP = {(p.x - 40), (p.x + 90), p.x+200, (p.x - 40)}; int[] yP = {(p.y - 40), (p.y +140), (p.y + 60), (p.y-40)}; g.drawArc(rect.x, rect.y, rect.width, rect.height * 2, 270, 90); //画弧 g.drawPolygon(xP, yP,3); //画多边形 g.setColor(Color.red); 画图形方法代码实例 github/image_verifyCode分支/thz-parent/thz-manager-web/WebPageController、thz-common/tool/RandomValidateCodeUtil、RandomValidateCodeUtilTest","categories":[],"tags":[]},{"title":"","slug":"Boot","date":"2019-04-30T08:25:44.597Z","updated":"2019-03-18T09:21:41.585Z","comments":true,"path":"2019/04/30/Boot/","link":"","permalink":"http://47.107.237.149/2019/04/30/Boot/","excerpt":"","text":"boot是系统引导文件。 也解作Build Own Operate Transfer,即创建、拥有、运营和移交。","categories":[],"tags":[]},{"title":"","slug":"BCrypt加密算法","date":"2019-04-30T08:25:44.593Z","updated":"2019-02-06T01:30:40.963Z","comments":true,"path":"2019/04/30/BCrypt加密算法/","link":"","permalink":"http://47.107.237.149/2019/04/30/BCrypt加密算法/","excerpt":"","text":"BCrypt算法与md5、sha算法主要区别为，每次生成的密文（hash）都是不同的，这样暴力猜解起来要更困难一点，而且密文长度较长，为60位。 使用方法： BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String hashedPassword = passwordEncoder.encode(password); //hashedPassword即为密文 参考文章","categories":[],"tags":[]},{"title":"","slug":"a标签添加onclick事件","date":"2019-04-30T08:25:44.589Z","updated":"2018-05-10T10:48:32.279Z","comments":true,"path":"2019/04/30/a标签添加onclick事件/","link":"","permalink":"http://47.107.237.149/2019/04/30/a标签添加onclick事件/","excerpt":"","text":"a href=”javascript:void(0);” onclick=”js_method()” a href=”javascript:;” onclick=”js_method()” a href=”#” onclick=”js_method();return false;” 参考地址","categories":[],"tags":[]},{"title":"","slug":"assert","date":"2019-04-30T08:25:44.586Z","updated":"2018-06-03T01:29:08.013Z","comments":true,"path":"2019/04/30/assert/","link":"","permalink":"http://47.107.237.149/2019/04/30/assert/","excerpt":"","text":"assert()宏是用于保证满足某个特定条件，用法是： assert(表达式); 如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句。 使用这个宏前需要包含头文件assert.h 注意： 每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败 不能使用改变环境的语言，因为assert只在debug时生效，如果这么做，会使程序在真正运行时遇到问题。如，assert（i++&lt;100）","categories":[],"tags":[]},{"title":"","slug":"ArrayList.this类名.this何意","date":"2019-04-30T08:25:44.570Z","updated":"2018-10-23T14:04:58.451Z","comments":true,"path":"2019/04/30/ArrayList.this类名.this何意/","link":"","permalink":"http://47.107.237.149/2019/04/30/ArrayList.this类名.this何意/","excerpt":"","text":"ArrayList的源码中，有一个实现了Iterator接口的内部类Itr，其中有两个elementData变量，一个是内部类的属性，一个是外部类的，那么外部类的就必须标识为ArrayList.this.elemtData 注意，不是this.elementData，因为外部类的对象是不能调用内部类的，所以只能用类名.this来区别内部类和外部类的属性。 //内部类 private class Itr implements Iterator&lt;E&gt; { transient Object[] elementData; @SuppressWarnings(&quot;unchecked&quot;) public E next() { //同名变量 Object[] elementData = ArrayList.this.elementData; } }","categories":[],"tags":[]},{"title":"","slug":"Apache POI","date":"2019-04-30T08:25:44.556Z","updated":"2018-09-08T08:30:26.970Z","comments":true,"path":"2019/04/30/Apache POI/","link":"","permalink":"http://47.107.237.149/2019/04/30/Apache POI/","excerpt":"","text":"简介 一种用java代码读写文档（Excel、word、PPT）的方式读写Excel方面 针对不同的Excel版本，要采用不同的工具类。 HSSFWorkbook：操作Excel2003以前的版本，扩展名为.xls XSSFWorkbook：操作2007的版本，扩展名是.xlsx 如果版本匹配错了，会抛出异常： org.apache.poi.openxml4j.exceptions.InvalidOperationException org.apache.poi.poifs.filesystem.OfficeXmlFileException 从POI 3.8版本开始，提供了一种基于XSSF的低内存占用的API—-SXSSF 当数据量超出65536条后，在使用HSSFWorkbook或XSSFWorkbook，程序会报OutOfMemoryError：Javaheap space;内存溢出错误。这时应该用SXSSFworkbook。参考文章读取各种文档的类 HSSF–读写.xls格式文档 XSSF–读写.xlsx格式文档 HWPF–读写.doc格式文档 HSLF–读写PPT工作簿概念 打个比方，工作簿就像一本书或者一本账册，工作表就像其中的一张或一篇。工作簿中包含一个或多个工作表，工作表依托于工作簿存在。 新建Excel文档（.xls)其实就是新建工作簿,然后在里面可以有sheet1、sheet2等等。代码实例 一个较为复杂的例子 public void excel() throws Exception{ String excelName = year+&quot;泛珠赛全国总决赛终评评委打分审核表(&quot;+model+&quot;)&quot;; //工作簿名称 Workbook wb = new HSSFWorkbook(); Map&lt;String, CellStyle&gt; styles = createStyles(wb); //设置各种单元格对应的样式 for (int i = 0; i &lt; pingweiList.size(); i++) { //创建Excel表格 CreatePingweiScore(wb, styles, headers,pingweiList.get(i), model,year); } // 写出 String file = excelName+&quot;.xls&quot;; //文件命名 FileOutputStream out = new FileOutputStream(file); wb.write(out); out.close(); } /* * 设置各种单元格对应的样式 * （基本上样式都是应用于单元格的，没见过应用在行上的顶多设置下行高这样） */ private static Map&lt;String, CellStyle&gt; createStyles(Workbook wb){ Map&lt;String, CellStyle&gt; styles = new HashMap&lt;&gt;(); CellStyle style; /*设置标题格式*/ Font titleFont = wb.createFont(); //字号 titleFont.setFontHeightInPoints((short)18); //加粗 titleFont.setBold(true); //设置单元格样式 style = wb.createCellStyle(); //水平居中 style.setAlignment(HorizontalAlignment.CENTER); //垂直居中 style.setVerticalAlignment(VerticalAlignment.CENTER); //将字体样式加入到样式当中 style.setFont(titleFont); //将样式应用到标题当中 styles.put(&quot;title&quot;, style); /*设置表头格式*/ Font monthFont = wb.createFont(); monthFont.setFontHeightInPoints((short)11); monthFont.setBold(true); //字体颜色 monthFont.setColor(IndexedColors.BLACK.getIndex()); style = wb.createCellStyle(); style.setAlignment(HorizontalAlignment.CENTER); style.setVerticalAlignment(VerticalAlignment.CENTER); style.setFont(monthFont); //自动换行 style.setWrapText(true); //应用到表头 styles.put(&quot;header&quot;, style); /*设置单元格*/ CellStyle cellStyle = wb.createCellStyle(); cellStyle.setAlignment(HorizontalAlignment.CENTER); cellStyle.setWrapText(true); //右边框 cellStyle.setBorderRight(BorderStyle.THIN); //右边框颜色 cellStyle.setRightBorderColor(IndexedColors.BLACK.getIndex()); cellStyle.setBorderLeft(BorderStyle.THIN); cellStyle.setLeftBorderColor(IndexedColors.BLACK.getIndex()); cellStyle.setBorderTop(BorderStyle.THIN); cellStyle.setTopBorderColor(IndexedColors.BLACK.getIndex()); cellStyle.setBorderBottom(BorderStyle.THIN); cellStyle.setBottomBorderColor(IndexedColors.BLACK.getIndex()); //应用到单元格 styles.put(&quot;cell&quot;, cellStyle); return styles;//styles：应用单元-单元属性的Map集合 } /* * 设置Excel表格 */ private int CreatePingweiScore(Workbook wb, Map&lt;String, CellStyle&gt; styles, String[] headers,String pid, String model,int year){ //所有作品的分 List&lt;PingweiScore&gt; pingweiScoreList = pingweiScoreService.selectByPidAndModelAndYear(pid,model,year); String titleName = year+&quot;泛珠赛全国总决赛终评评委打分审核表(&quot;+model+&quot;)&quot;; String pingweiName = &quot;评委&quot;+pid; //打印设置 Sheet sheet = wb.createSheet(pingweiName); //pingweiName为表名 PrintSetup printSetup = sheet.getPrintSetup(); printSetup.setLandscape(true); //true表示页面方向为横向，false为纵向 sheet.setFitToPage(true); sheet.setHorizontallyCenter(true); //title row Row titleRow = sheet.createRow(0); titleRow.setHeightInPoints(45); Cell titleCell = titleRow.createCell(0); titleCell.setCellValue(titleName); titleCell.setCellStyle(styles.get(&quot;title&quot;)); sheet.addMergedRegion(CellRangeAddress.valueOf(&quot;$A$1:$J$1&quot;)); //从A1到J1单元格合并；可以直接CellRangeAddress（起始行，终止行，起始列，终止列） //Second row Row secondRow = sheet.createRow(1); secondRow.setHeightInPoints(40); //行高 Cell secondCell = secondRow.createCell(0); secondCell.setCellValue(&quot;评委编号：&quot;+pid+&quot; 评委签名：&quot;); secondCell.setCellStyle(styles.get(&quot;header&quot;)); //设置单元格样式 sheet.addMergedRegion(CellRangeAddress.valueOf(&quot;$A$2:$J$2&quot;)); //合并单元格，前面设置的样式都应用到了这些单元格上了 //header row Row headerRow = sheet.createRow(2); headerRow.setHeightInPoints(40); Cell headerCell; for (int i = 0; i &lt; headers.length; i++) { headerCell = headerRow.createCell(i); headerCell.setCellValue(headers[i]); headerCell.setCellStyle(styles.get(&quot;header&quot;)); } //评委分数 int rownum = 3; //前三列为固定值先不管 for (int i = 0; i &lt; pingweiScoreList.size(); i++) { Row row = sheet.createRow(rownum++); for (int j = 0; j &lt; headers.length; j++) { Cell cell = row.createCell(j); //逐项分数写入 switch (j){ case 0: cell.setCellValue(pingweiScoreList.get(i).getProId());break; case 1: cell.setCellValue(pingweiScoreList.get(i).getBianHao());break; case 2: cell.setCellValue(pingweiScoreList.get(i).getProName());break; case 3: cell.setCellValue(pingweiScoreList.get(i).getOption1());break; case 4: cell.setCellValue(pingweiScoreList.get(i).getOption2());break; case 5: cell.setCellValue(pingweiScoreList.get(i).getOption3());break; case 6: cell.setCellValue(pingweiScoreList.get(i).getOption4());break; case 7: cell.setCellValue(pingweiScoreList.get(i).getOption5());break; case 8: cell.setCellValue(pingweiScoreList.get(i).getOption6());break; case 9: cell.setCellValue(pingweiScoreList.get(i).getTotalScore());break; } } } //所有行第1~3列的宽度，分别用来填写序号、作品编号和作品名称 sheet.setColumnWidth(0, 10*256); //10 characters wide sheet.setColumnWidth(1, 10*256); //10 characters wide sheet.setColumnWidth(2, 30*256); //30 characters wide //后面列的宽度 for (int i = 3; i &lt; headers.length; i++) { sheet.setColumnWidth(i, 9*256); //9 characters wide } return 0; } 其中write(Outputstream)为HSSFWork唯一写出方法 一些样式设置参考解析Excel保存到数据库public class ResolveExcelServiceImpl implements ResolveExcelService { private static final String SUFFIX_2003=&quot;.xls&quot;; private static final String SUFFIX_2007=&quot;.xlsx&quot;; @Override public List&lt;Works&gt; resolveExcel(MultipartFile file) throws BusinessException { List&lt;Works&gt; list=new ArrayList&lt;Works&gt;(); if(file==null){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;文件不存在！&quot;); } //获取文件名 String originalFilename=file.getOriginalFilename(); Workbook workbook=null; //判断格式 try{ if(originalFilename.endsWith(SUFFIX_2003)){ /* getInputStream()返回InputStream 经测试，全部文件都返回ByteArrayInputStream */ workbook=new HSSFWorkbook(file.getInputStream()); }else if(originalFilename.endsWith(SUFFIX_2007)){ //不知道为什么这种格式会抛异常 workbook=new XSSFWorkbook(file.getInputStream()); } }catch (Exception e){ e.printStackTrace(); throw new BusinessException(ReturnCode.CODE_FAIL,&quot;格式错误！&quot;); } if(null==workbook){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;格式错误！&quot;); }else{ //获取所有工作表的数量 int numOfSheet=workbook.getNumberOfSheets(); //遍历这些表 for(int i=0;i&lt;numOfSheet;i++){ //获取一个sheet Sheet sheet=workbook.getSheetAt(i); int lastRowNum=sheet.getLastRowNum(); //从第三行开始，第1行一般是标题，第二行是表头 for(int j=2;j&lt;=lastRowNum;j++){ Row row=sheet.getRow(j); Works works=new Works(); //获取序号单元格 if(row.getCell(0)!=null){ row.getCell(0).setCellType(Cell.CELL_TYPE_STRING); //获取单元格内容（将内容当做字符串处理） String code=row.getCell(0).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^\\\\d{1,2}$&quot;,code); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;序号错误！&quot;); } works.setCode(code); } //编号 if(row.getCell(1)!=null){ row.getCell(1).setCellType(Cell.CELL_TYPE_STRING); String bianHao=row.getCell(1).getStringCellValue(); //校验编号长度 boolean matche=Pattern.matches(&quot;^\\\\d{6}$&quot;,bianHao); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;序号错误！&quot;); } works.setBianHao(bianHao); } //名称 if(row.getCell(2)!=null){ row.getCell(2).setCellType(Cell.CELL_TYPE_STRING); String name=row.getCell(2).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5\\\\w\\\\-\\\\——]{1,}$&quot;,name); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;作品名称错误！&quot;); } works.setName(name); } //分赛区 if(row.getCell(3)!=null){ row.getCell(3).setCellType(Cell.CELL_TYPE_STRING); String district=row.getCell(3).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5]{1,}$&quot;,district); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;分赛区名称错误！&quot;); } works.setPartName(district); } //学校 if(row.getCell(4)!=null){ row.getCell(4).setCellType(Cell.CELL_TYPE_STRING); String school=row.getCell(4).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5]{1,}$&quot;,school); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;学校名称错误！&quot;); } works.setSchool(school); } //指导老师 if(row.getCell(5)!=null){ row.getCell(5).setCellType(Cell.CELL_TYPE_STRING); String teachers=row.getCell(5).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5\\\\s,，、]{1,}$&quot;,teachers); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;老师姓名格式错误！&quot;); } works.setTeachers(teachers); } //学生 if(row.getCell(6)!=null){ row.getCell(6).setCellType(Cell.CELL_TYPE_STRING); String students=row.getCell(6).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5\\\\s,，、]{1,}$&quot;,students); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;学生姓名格式错误！&quot;); } works.setStudents(students); } //组别 if(row.getCell(7)!=null){ row.getCell(7).setCellType(Cell.CELL_TYPE_STRING); String model=row.getCell(7).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5]{1,}$&quot;,model); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;组别格式错误！&quot;); } works.setModel(model); } list.add(works); } } } return list; }","categories":[],"tags":[]},{"title":"","slug":"Ant风格","date":"2019-04-30T08:25:44.553Z","updated":"2019-02-28T06:23:03.321Z","comments":true,"path":"2019/04/30/Ant风格/","link":"","permalink":"http://47.107.237.149/2019/04/30/Ant风格/","excerpt":"","text":"Ant风格，为请求路径的一种匹配方式。 Ant通配符 参考文章 支持Ant风格： Spring资源加载————classpath：com/t?st.xml SpringMvc的url映射————@RequestMapping(“/teach”) Spring注释扫描 &lt;context:component-scan base-package=&quot;org.xxx.**.dao, org.xxx.**.service.impl, org.xx.**.webservice&quot;/&gt;","categories":[],"tags":[]},{"title":"","slug":"alibabaJava开发手册之异常处理","date":"2019-04-30T08:25:44.544Z","updated":"2018-09-26T09:45:28.353Z","comments":true,"path":"2019/04/30/alibabaJava开发手册之异常处理/","link":"","permalink":"http://47.107.237.149/2019/04/30/alibabaJava开发手册之异常处理/","excerpt":"","text":"异常不要用来做流程控制、条件控制，因为异常的处理效率比条件分支低。 //正例 if(obj!=null){ ... } //反例 try{ obj.method() }catch(NullPointException e){ ... } 对大段代码进行try/catch,这是不负责任的表现。请分清稳定代码和非稳定代码。 捕获代码是为了处理它，如果不想处理它，请把该异常抛给它的调用者。最外层的业务处理者，必须处理异常，并将其转化为用户可以理解的内容。 避免直接抛出new RuntimeException(),更不允许抛出Exception或者Throwable，应该用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException、ServiceException等。 避免出现重复的代码（Don’t Repeat Youself),即DRY原则。必要时抽取公共方法，或者抽象公共类，甚至是组件化。","categories":[],"tags":[]},{"title":"","slug":"Ajax","date":"2019-04-30T08:25:44.537Z","updated":"2018-10-13T08:36:16.852Z","comments":true,"path":"2019/04/30/Ajax/","link":"","permalink":"http://47.107.237.149/2019/04/30/Ajax/","excerpt":"","text":"创建一个XMLHttpRequest 对象，用于在后台与服务器交换数据。这意味着可以在不重载的整个网页的 情况下，对网页的某部分进行更新。然后使用该对象的open方法来打开一个Http请求。 open(method,url,async): 规定请求的类型（get或post）、URL与是否异步（一般为true） send(String): 发送请求，String仅用于post请求。 function loadName(){ var xmlHttp; if(window.XMLHttpRequest){ //检查浏览器是否存在XMLHttpRequest对象，它用于在后台与服务器交换数据 xmlHttp=new XMLHttpRequest(); }else{ //IE5|IE6不支持 xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //get，请求方式，中间是URL，文件在服务器上的位置，在web.xml中找到URL为getAjaxName的servlet来处理请求；true，启用异步 xmlHttp.open(&quot;get&quot;, &quot;getAjaxName?name=jack&amp;age=11&quot;, true);//直接加参数 //xmlHttp.open(&quot;post&quot;, &quot;getAjaxName&quot;, true);//不带参数 //xmlHttp.open(&quot;post&quot;, &quot;getAjaxName?name=jack&amp;age=11&quot;, true); xmlHttp.send();//记得要加个send才能把数据发送到后台 } 代码实例：HeadFirstAjaxJsonChap02-&gt;ajax.jsp、onreadystatechange.jsp 注意要使用到json.lib的话就要引入很多个jar包 xmlHttp.open:url栏写法：xmlHttp.open(“get”, “login?action=view&amp;userName=”+userName, true);//带action回去，userName不是一个字符串而是一个字符串对象就不要放引号里面了","categories":[],"tags":[]},{"title":"","slug":"@JoinColumn表关联和级联","date":"2019-04-30T08:25:44.432Z","updated":"2018-08-30T11:55:58.819Z","comments":true,"path":"2019/04/30/@JoinColumn表关联和级联/","link":"","permalink":"http://47.107.237.149/2019/04/30/@JoinColumn表关联和级联/","excerpt":"","text":"@JoinColumn简介 注释本表或另一张关联表中指向对方表的外键一对一外键关联 假设Person中有一个外键addressID关联Address表，是一对一关系。我们一般认为主控方是Person,所以@JoinColumn写在Person中。 @OneToOne(cascade=CascadeType.ALL,optional=true) @JoinColumn(name=&quot;addressID&quot;) //注释本表中指向另一张表的外键 public Address getAddress() { } 我们也可以不写@JoinColumn,hibernate会自动在Person表生成关联字段，名称是被控方类名_被控方主键，如address_id主键关联 如果两张表是以主键关联的，比如person表的主键是id，address表的主键是addressId,则运用以下注释 @OneToOne(cascade=CascadeTtype.ALL) @PrimaryKeyJoinColumn(name=&quot;id&quot;,referencedColumnNmae=&quot;addressId&quot;) public Address getAddress() { } 一对多 加入现在有person（多）表和country（一）表，那么一定是person表中有country_id外键 由于我们是一对多的关系，所以站在一的角度，也就是country的角度，在Country的角度，在该类中加入@JoinColumn @OneToMany(cascade=CascadeType.ALL) @JoinColumn(name=&quot;country_id&quot;) //注释另一张表指向本表的外键 public List&lt;Person&gt; getPerson() { } 在一对多单向关系表中，多的一方没有注解，一的一方有注解。最终外键会被加到哪一张表完全由@JoinColumn根据几对几注解来适当分配。如果一的一方不加@JoinColumn指定外键字段的话，hibernate会自动生成一张中间表Country_Person来对Person和Country进行绑定。 自定义中间表的注解（应该是写在哪个类都可以,比如下面写在Person类） @JoinTable(name=&quot;Person_Country&quot;, joinColumns={@JoinColumn(name=&quot;person_id&quot;))}, //指定关联本表id的字段 inverseJoinColumns={@JoinColumn(name=&quot;country_id&quot;)}) //指定关联对方表id的字段 多对一 还是沿用一对多的例子，只是反过来要把注释加到Person类里 @ManyToOne @JoinColumn(name=&quot;country_id&quot;) public Country getCountry() { } 此时如果不用@JoinColumn指定外键的话，会在person表中生成一个指向country的外键而不是中间表。双向关联 前面一对多和多对一的例子一般都是同时配置，因为只配置一或多的一方会导致另一方无法获取对方信息多对多 多对多关系一般都是用中间表维护的，只需要在一个类中注释一张中间表即可，比如现在有person、project表，在Person类中建立person_project表 @ManyToMany(cascade = CascadeType.ALL) @JoinTable(name = &quot;Person_Project&quot;, joinColumns = {@JoinColumn(name = &quot;person_id&quot;)}, inverseJoinColumns = {@JoinColumn(name = &quot;project_id&quot;)}) //关联另一张表 public List&lt;Project&gt; getProjects() { return project; } 级联 举例：学生与学校的一对多关系 //学生类 @Entity @Table(name = &quot;student&quot;) public class Student { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; //在表中建立外键 &quot;school_fk&quot; @ManyToOne @JoinColumn(name=&quot;school_fk&quot;) private School school; } //学校类 @Entity @Table(name = &quot;school&quot;) public class School { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @OneToMany(mappedBy=&quot;shcool&quot;) /* * 设置 ：级联保存/新建操作。 * 那么新建学校和学生的时候，保存新建的学校新建的学生也同时被保存 @Column(cascade={CascadeType.PERSIST}) private List&lt;Student&gt; students; } //级联保存，测试方法 public void testPersistCreateSchool(){ School school = new School(); school.setName(&quot;学校&quot;); Student st1 = new Student(); st1.setName(&quot;学弟&quot;); st1.setSchool(school); //不需要显示保存学生st1 //studnetDAO.save(st1); Student st2 = new Student(); st2.setName(&quot;学长&quot;); st2.setSchool(school); //不需要显示保存学生st2 //studnetDAO.save(st2); //添加学生 school.addStudent(st1); school.addStudent(st2); schoolDAO.save(school);//保存学校，学校内新建的学生也[st1、st2]被保存了 }","categories":[],"tags":[]}]}
{"meta":{"title":"never belief any book","subtitle":"love youself,love life","description":"love youself,love life","author":"Haien","url":"http://47.107.237.149"},"pages":[{"title":"categories","date":"2018-06-03T09:56:30.000Z","updated":"2018-06-03T11:50:01.753Z","comments":true,"path":"categories/index.html","permalink":"http://47.107.237.149/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-03T09:54:24.000Z","updated":"2018-06-03T11:49:23.640Z","comments":false,"path":"tags/index.html","permalink":"http://47.107.237.149/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"array","slug":"数组","date":"2019-05-02T10:31:33.753Z","updated":"2019-05-03T05:47:10.695Z","comments":true,"path":"2019/05/02/数组/","link":"","permalink":"http://47.107.237.149/2019/05/02/数组/","excerpt":"","text":"一维数组 int[] a = new int[100]; 定义数组 a.length；计算数组长度（把这个直接看成数字） for(int r:a){System.out.println(r);数组遍历 int[] a={2,3,4,5};省长度、省new new int[]={2,3,4,5};省长度，省变量名 a=new int[]{6,7,8,9};对a进行重新初始化 new int[0];省变量名，创建长度为0数组；在编写结果为数组的方法时，若碰巧结果为零则可以用上 int [][] fun(int[][] a)//数组作为返回结果及形参 {对传入的数组a进行操作； return a；//返回数组，实际只是一个引用} //把数组名当作一个指针来看待就好了，指针怎么用数组就怎么用 int[] b=a;拷贝数组，a,b只是引用 System.out.println(from,fromIndex,to,toIndex,count);值覆盖 Array.sort(a);数组排序 二维数组 double[][] a=new double[2][2];定义二维数组 初始化 int[][] a={{1,2},{3,4}};省new、省长度 遍历 for(double[] row:a) for(double b:row){ do something with b; } for(int n=0;n&lt;=MAX;n++) a[n]=new int[n+1];不规则数组","categories":[],"tags":[]},{"title":"","slug":"Shiro第五章-编码、加密","date":"2019-04-30T08:29:23.108Z","updated":"2019-04-09T01:58:46.480Z","comments":true,"path":"2019/04/30/Shiro第五章-编码、加密/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第五章-编码、加密/","excerpt":"","text":"密码存储应加密或生成摘要存储。 编码、解码 Shiro提供了base64和16进制对字符串进行编码、解码。其内部的一些数据的存储和表示也都使用了base64和16进制的字符串。 base64：网络上最常用的用于传输8bit字节码的编码方式之一，可用于在HTTP环境下传递较长的标识信息，起到简单的加密作用。主要是基于64个可打印字符来表示二进制数据，即编码过程是从二进制到字符的过程。 String str = &quot;hello&quot;; String base64Encoded = Base64.encodeToString(str.getBytes()); //编码：二进制-&gt;字符 String str2 = Base64.decodeToString(base64Encoded); //解码 Assert.assertEquals(str, str2); 16进制 String str = &quot;hello&quot;; String hexEncoded = Hex.encodeToString(str.getBytes()); //编码 String str2 = new String(Hex.decode(hexEncoded.getBytes())); //解码 Assert.assertEquals(str, str2); CodecSupport类：提供toBytes(str,”utf-8”)、toString(bytes,”utf-8”),进行String和byte数组之间的额转换。 散列算法 散列算法一般用于生成数据的摘要信息，不可逆。 常见的有：MD5、SHA等。 一般进行散列时最好提供一个salt，比如一些只有系统知道的干扰数据，如，用户名和id，这样生成的散列值更难破解。 因此用户注册和修改密码时，系统应将密码和盐一起保存到数据库。 String str = &quot;hello&quot;; String salt = &quot;123&quot;; String md5 = new Md5Hash(str, salt).toString();//还可以是toBase64()/toHex(); String sha1 = new Sha256Hash(str, salt).toString();//还有SHA1、SHA512、SHA256、SHA384... 还可以指定散列次数 //散列两次 md5(md5(str)); //相当于 new MD5Hash(str,salt,2).toString(); 对称加密 AES算法：下一代加密算法标准，速度快，安全级别高，支持128/192/256/512位秘钥的加密。 AesCipherService aesCipherService=new AesCipherService(); aesCipherService.setKeySize(128); //设置key长度；不影响加密后长度 Key key=aesCipherService.generateNewKey(); //生成key String source=&quot;hello&quot;; String encryptText=aesCipherService.encrypt(source.getBytes(),key.getEncoded()) .toHex(); //加密，参数是两个byte数组 String source2=new String(aesCipherService.decrypt(Hex.decode(encryptText), key.getEncoded()).getBytes()); //解密,参数是两个byte数组 crypt：C语言加密函数名。 代码实例：shiroHelloWorld/test/AllTest Blowfish算法：布鲁斯·施奈尔发明的区块加密算法。 BlowfishCipherService blowfishCipherService = new BlowfishCipherService(); blowfishCipherService.setKeySize(128); //生成key Key key = blowfishCipherService.generateNewKey(); String text = &quot;hello&quot;; //加密 String encrptText = blowfishCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex(); //解密 String text2 = new String(blowfishCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); Assert.assertEquals(text, text2); DefaultBlockCipherService：对称加密通用支持器 //对称加密，使用Java的JCA（javax.crypto.Cipher）加密API，常见的如 &apos;AES&apos;, &apos;Blowfish&apos; DefaultBlockCipherService cipherService = new DefaultBlockCipherService(&quot;AES&quot;); cipherService.setKeySize(128); //生成key Key key = cipherService.generateNewKey(); String text = &quot;hello&quot;; //加密 String encrptText = cipherService.encrypt(text.getBytes(), key.getEncoded()).toHex(); //解密 String text2 = new String(cipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); Assert.assertEquals(text, text2); Shiro的加密接口 Shiro提供的散列支持 //内部使用MessageDigest String simpleHash = new SimpleHash(&quot;SHA-1&quot;, str, salt).toString(); 经过加密后变成byte数组，必须toString()/toHex()变换一下比较好看，而存入数据库一般是toHex()。 为了实现更加完整的加密方案，Shiro提供了HashService，这个也是密码加密最常用的。 DefaultHashService hashService = new DefaultHashService(); //默认实现 //all设置 hashService.setHashAlgorithmName(&quot;SHA-512&quot;); //设置算法；默认为SHA-512;被request覆盖 hashService.setPrivateSalt(new SimpleByteSource(&quot;123&quot;)); //私盐，散列时自动与用户传入 的公盐混合产生一个新盐；默认无 hashService.setGeneratePublicSalt(true); //在用户没有传入公盐时是否自动产生公盐； 被request覆盖 hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator()); //用于生成公盐； SecureRandomNumberGenerator用于生成一个随机数；默认就这个 hashService.setHashIterations(1); //散列迭代次数;被request覆盖 HashRequest request=new HashRequest.Builder() //all有用配置如下 .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;hello&quot;)) .setSalt(ByteSource.Util.bytes(&quot;123&quot;)).setIterations(2).build(); String hex=hashService.computeHash((request)).toHex(); 代码实例：shiroHelloWorld/test/AllTest PasswordService、CredentialsMatcher加密和验证密码 Shiro提供了PasswordService和CredentialsMatcher接口用于加密和验证密码。 PasswordService默认实现：DefaultPasswordService。 CredentialsMatcher默认实现：PasswordMatcher、HashedcredentialsMatcher(更强大)。 示例 自定义Realm public class MyRealm4 extends AuthorizingRealm { public PasswordService passwordService; //等待外部注入 public void setPasswordService(PasswordService passwordService){ this.passwordService=passwordService; } /** * @Author haien * @Description 被间接父类AuthenticatingRealm调用，获取到AuthenticationInfo后 调用assertCredentialsMatch(token,info),其中token代表表单信息， info代表数据库用户，它使用了credentialsMatcher （未指定则使用默认实现类）来验证密码是否匹配， 否则抛出IncorrectCredentialsException； 但不验证用户名是否正确 * @Date 2019/2/22 * @Param [token] * @return org.apache.shiro.authc.AuthenticationInfo **/ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { return new SimpleAuthenticationInfo(&quot;wu&quot;, passwordService.encryptPassword(&quot;123&quot;),getName()); } /** * @Author haien * @Description 不需要授权就直接返回null就好了 * @Date 2019/2/22 * @Param [principalCollection] * @return org.apache.shiro.authz.AuthorizationInfo **/ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return null; } } 如果自定义Realm实现的是Realm接口，而不是继承了AuthenticatingRealm及其以下的类，则用户名和密码验证逻辑都必须在此Realm中实现，否则视返回Info类为验证通过，不再进行验证。 shiro-passwordservice.ini [main] passwordService=org.apache.shiro.authc.credential.DefaultPasswordService //有必要可自定义 hashService=org.apache.shiro.crypto.hash.DefaultHashService //定义散列密码使用的HashService passwordService.hashService=$hashService hashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat //对散列出的值格式化，默认使用Shiro1CryptFormat，还有Base64Formath和HexFormat； 对于有salt的密码应自定义ParsableHashFormat实现类，然后把salt格式化到散列值中。 passwordService.hashFormat=$hashFormat hashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory //根据散列值得到散列的密码和salt passwordService.hashFormatFactory=$hashFormatFactory passwordMatcher=org.apache.shiro.authc.credential.PasswordMatcher //定义AuthenticatingRealm 用到的CredentialsMatcher passwordMatcher.passwordService=$passwordService myRealm=com.haien.shiroHelloWorld.chapter5.realm.MyRealm myRealm.passwordService=$passwordService myRealm.credentialsMatcher=$passwordMatcher securityManager.realms=$myRealm; PasswordTest：测试类 public class PasswordTest extends BaseTest { @Test public void testPasswordServiceWithMyRealm(){ login(&quot;classpath:config/shiro-passwordservice.ini&quot;, &quot;wu&quot;,&quot;123&quot;); } } 使用jdbc的示例 shiro-jdbc-passwordservice.ini：如果JdbcRealm不指定CredentialsMatcher，则会使用默认实现类SimpleCredentialsMatcher，它不进行加密，只进行明文匹配。 [main] passwordService=org.apache.shiro.authc.credential.DefaultPasswordService hashService=org.apache.shiro.crypto.hash.DefaultHashService passwordService.hashService=$hashService hashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat passwordService.hashFormat=$hashFormat hashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory passwordService.hashFormatFactory=$hashFormatFactory passwordMatcher=org.apache.shiro.authc.credential.PasswordMatcher passwordMatcher.passwordService=$passwordService dataSource=com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql://127.0.0.1:3306/shiro dataSource.username=root dataSource.password=123456 jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm jdbcRealm.dataSource=$dataSource jdbcRealm.permissionsLookupEnabled=true jdbcRealm.credentialsMatcher=$passwordMatcher //不用配置PasswordService securityManager.realms=$jdbcRealm PasswordTest:测试类 public class PasswordTest extends BaseTest { @Test public void testPasswordserviceWithJdbcRealm(){ login(&quot;classpath:config/shiro-jdbc-passwordservice.ini&quot;, &quot;wu&quot;,&quot;123&quot;); } } HashedCredentialsMatcher 和之前的PasswordMatcher不同，它只用于密码验证，且可以提供自己的盐，而不是随机生成盐，且加密算法可以指定。 比如使用MD5，“密码+盐（用户名—+随机数”的方式生成散列值。 自定义Realm示例 MyRealm2：准备用户 /** * @Author haien * @Description 用户名+加密后的密码作为盐 * @Date 2019/2/23 **/ public class MyRealm2 extends AuthenticatingRealm { //不需要授权，继承AuthenticatingRealm即可 @Override protected AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken authenticationToken) throws AuthenticationException { //用户库 String username=&quot;liu&quot;; String password=&quot;123&quot;; //返回后，AuthenticatingRealm只会进行密码比对，不对用户名进行验证，因此用户验证需要在这里实现 if(!username.equals(authenticationToken.getPrincipal())){ throw new UnknownAccountException(); } //密码加密；则ini配置文件应制定相同的加密方式来对登录用户进行加密后再与realm比对 String algorithmName=&quot;md5&quot;; String salt2=new SecureRandomNumberGenerator().nextBytes().toHex(); //随机数 int hashIterations=2; SimpleHash hash=new SimpleHash(algorithmName,password, username+salt2,hashIterations); String encodedPassword=hash.toHex(); //加密后的密码 //封装 SimpleAuthenticationInfo ai= new SimpleAuthenticationInfo(username,encodedPassword,getName()); //HashedCredentialsMatcher会自动识别这个盐，并拿去给登录用户加密 ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); //盐=用户名+随机数 //返回给AuthenticatingRealm后，它调用HashedCredentialsMatcher的方法， //将login密码加密，并与此身份凭证中的密码比对 return ai; } } shiro-hashedCredentialsMatcher.ini：指定CredentialsMatcher实现类、Realm [main] ;告诉AuthorizingRealm，它获取到的身份凭证是这么来的 credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher credentialsMatcher.hashAlgorithmName=md5 credentialsMatcher.hashIterations=2 ;加密后的密码是否转为了十六进制，默认是base64 credentialsMatcher.storedCredentialsHexEncoded=true myRealm=com.haien.shiroHelloWorld.chapter5.realm.MyRealm2 myRealm.credentialsMatcher=$credentialsMatcher securityManager.realms=$myRealm 测试 public class PasswordTest extends BaseTest { @Test public void testHashedCredentialsMatcherWithMyRealm2() { login(&quot;classpath:config/shiro-hashedCredentialsMatcher.ini&quot;, &quot;liu&quot;, &quot;123&quot;); //HashedCredentialsMatcher会将密码加密后与Realm提供的用户库进行比对 } } JdbcRealm示例 shiro-jdbc-hashedCredentialsMatcher.ini：Shiro默认不进行Enum类型转换，但saltStyle是枚举类型，因此需要我们自己注册一个Enum转换器对值先进行类型转换再赋给saltStyle。而密码+盐查询语句authenticationQuery原本为：select password, password_salt from users where username = ?，现在我们的盐=username+password_salt，因此要重写sql. [main] ;指定密码加密方式，需要和用户注册、修改密码时使用的加密方式一致 credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher credentialsMatcher.hashAlgorithmName=md5 credentialsMatcher.hashIterations=2 credentialsMatcher.storedCredentialsHexEncoded=true dataSource=com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql://127.0.0.1:3306/shiro dataSource.username=root dataSource.password=123456 jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm jdbcRealm.dataSource=$dataSource jdbcRealm.permissionsLookupEnabled=true ;需要被转换为Enum才能赋给saltStyle属性，因此在测试方法中注册了自定义的Enum转换器 jdbcRealm.saltStyle=COLUMN ;重写sql语句；同时对用户名和密码进行验证 jdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ? jdbcRealm.credentialsMatcher=$credentialsMatcher securityManager.realms=$jdbcRealm 测试方法 public class PasswordTest extends BaseTest { /** * @Author haien * @Description 自定义Enum转换器 * @Date 2019/2/23 **/ private class EnumConverter extends AbstractConverter{ @Override protected String convertToString(final Object value) throws Throwable { return ((Enum)value).name(); } @Override protected Class getDefaultType() { return null; } @Override protected Object convertToType(final Class type, final Object value) throws Throwable { return Enum.valueOf(type,value.toString()); } } @Test public void testHashedCredentialsMatcherWithJdbcRealm(){ //注册自定义的Enum转换器，否则ini文件默认不进行Enum类型转换 BeanUtilsBean.getInstance().getConvertUtils().register(new EnumConverter(), JdbcRealm.SaltStyle.class); login(&quot;classpath:config/shiro-jdbc-hashedCredentialsMatcher.ini&quot;, &quot;liu&quot;, &quot;123&quot;); } } 密码重试次数限制 目的：防止密码被暴力破解。 方法：继承HashedCredentialsMatcher,且使用Ehcache记录重试次数和超时时间。 RetryLimitHashedCredentialsMatcher：限制输入次数不超出5次 /** * @Author haien * @Description 自定义CredentialsMatcher实现类，限制密码重试次数 * 输入正确清除cache中的记录，否则cache中的重试次数+1，如果超出5次那么抛出异常 * @Date 2019/2/24 **/ public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher { //密码重试次数缓存对象集合 private Ehcache passwordRetryCache; public RetryLimitHashedCredentialsMatcher() { CacheManager cacheManager=CacheManager.newInstance( CacheManager.class.getClassLoader().getResource(&quot;ehcache.xml&quot;)); passwordRetryCache=cacheManager.getCache(&quot;passwordRetryCache&quot;); } @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) { //获取表单参数 String username=(String)token.getPrincipal(); //获取该用户的缓存对象 Element element=passwordRetryCache.get(username); //缓存对象不存在说明上一次登录成功或从未登录过 if(element==null){ element=new Element(username,new AtomicInteger(0)); //new一个并置零 passwordRetryCache.put(element); } //从缓存对象中获取重试次数 AtomicInteger retryCount=(AtomicInteger)element.getObjectValue(); //第6次起无论输入对错都禁止 if(retryCount.incrementAndGet()&gt;5) //+1 throw new ExcessiveAttemptsException(); boolean matches=super.doCredentialsMatch(token,info); if(matches) passwordRetryCache.remove(username); return matches; } } 《跟我学Shiro》第五章 代码实例：ideaProjects/shiroHelloWorld/chapter5","categories":[],"tags":[]},{"title":"","slug":"Shiro第四章-ini配置解析","date":"2019-04-30T08:29:23.095Z","updated":"2019-02-22T04:02:30.574Z","comments":true,"path":"2019/04/30/Shiro第四章-ini配置解析/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第四章-ini配置解析/","excerpt":"","text":"根对象securityManager Shiro是从根对象SecurityManager进行身份验证和授权的，所有操作都是自它开始。这个对象是线程安全的且整个应用只需要一个即可。因此shiro提供了SecurityUtils让我们绑定它为全局的。 Java Configuration 用Java代码代替ini配置 public class NonConfigurationCreateTest { @Test public void test(){ DefaultSecurityManager securityManager=new DefaultSecurityManager(); //设置authenticator ModularRealmAuthenticator authenticator=new ModularRealmAuthenticator(); authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy()); securityManager.setAuthenticator(authenticator); //设置authorizer ModularRealmAuthorizer authorizer=new ModularRealmAuthorizer(); authorizer.setPermissionResolver(new WildcardPermissionResolver()); securityManager.setAuthorizer(authorizer); //设置Realm DruidDataSource ds=new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://localhosr:3306/shiro&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); JdbcRealm jdbcRealm=new JdbcRealm(); jdbcRealm.setDataSource(ds); jdbcRealm.setPermissionsLookupEnabled(true); securityManager.setRealms(Arrays.asList((Realm)jdbcRealm)); //SecurityManager设置到SecurityUtils，方便全局使用 SecurityUtils.setSecurityManager(securityManager); //测试 Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken token=new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;); subject.login(token); Assert.assertTrue(subject.isAuthenticated()); } } ini配置文件 ini配置下，securityManager的获取如下 Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;); SecurityManager securityManager = factory.getInstance(); IniSecurityManagerFactory是创建securityManager的工厂，它需要一个ini配置文件路径，支持“classpath:”（类路径）、“file:”（文件系统）、“url:”（网络）三种路径格式，默认是文件系统。 默认创建DefaultSecurityManager类型的securityManager，如果想自定义，需要在ini配置文件中指定securityManager=SecurityManager实现类；名字必须为securityManager。 ini配置文件其中几部分 [main] #提供了对根对象securityManager及其依赖的配置 securityManager=org.apache.shiro.mgt.DefaultSecurityManager ………… securityManager.realms=$jdbcRealm [urls] #用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器 /index.html = anon /admin/** = authc, roles[admin], perms[&quot;permission1&quot;] Array/Set/List注入 //多个之间用,分开即可 authenticator.array=1,2,3 authenticator.set=$jdbcRealm,$jdbcRealm&amp;nbsp; Map键值对注入 authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc //常量都看作字符串，如，1，abc [users]部分 [users] #提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2 username=password,role1,role2 其中，密码一般生成其摘要或加密存储。 [roles]部分：如果只有角色没有对应的权限，可以不配[roles] 重复注入则后面的覆盖前面的。 代码实例：ideaProjects/shiroHelloWorld/chapter4 《跟我学Shiro第四章》","categories":[],"tags":[]},{"title":"","slug":"Shiro第十章-会话管理","date":"2019-04-30T08:29:23.092Z","updated":"2019-03-09T06:48:29.038Z","comments":true,"path":"2019/04/30/Shiro第十章-会话管理/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十章-会话管理/","excerpt":"","text":"会话 即用户访问应用时保持的连接关系，在多次交互中应用能识别出当前访问的用户是谁，且可以在多次交互中保存一些数据。如访问一些网站时登录成功后可以记住用户，且在退出之前都可以识别当前用户是谁。 获取会话：登陆成功后即可获取会话。 login(&quot;classpath:shiro.ini&quot;, &quot;zhang&quot;, &quot;123&quot;); //登录成功相当于创建了会话 Subject subject = SecurityUtils.getSubject(); Session session = subject.getSession(); //等价于 subject.getSession(true) //没有Session对象会创建一个，若传入false则无Session将返回null 若启用会话存储功能则在创建Subject时会主动创建一个Session。 获取属性： //获取当前会话的唯一标识 session.getId(); //获取主机地址 session.getHost(); //获取、设置当前Session的过期时间，默认是会话管理器的全局过期时间 session.getTimeout(); session.setTimeout(); //获取会话的启动时间及最后访问时间；javaSE应用需要自己定期调用session.touch()更新最后访问时间 //web应用每次进入ShiroFilter都会自动调用它来更新。 session.getStartTimestamp(); session.getLastAccessTime(); //更新会话最后访问时间及销毁会话；Subject.logout()时会自动调用stop()。 //在web中调用javax.servlet.http.HttpSession. invalidate()也会自动调用它来销毁Session会话。 session.touch(); session.stop(); //操作会话属性 session.setAttribute(&quot;key&quot;,&quot;123&quot;); session.getattribute(&quot;key&quot;); session.removeAttribute(&quot;key&quot;); 会话管理器 管理着应用中所有Subject的会话的创建、维护、删除、失效和验证等工作，是Shiro的核心组件。 SecurityManager都继承了会话管理器SessionSecurityManager。 SecurityManager：提供了如下接口： Session start(SessionContext context); //启动会话 Session getSession(SessionKey key) throws SessionException; //根据会话Key获取会话 WebSessionManager：专用于web应用，又提供了如下接口： boolean isServletContainerSessions();//是否使用Servlet容器的会话 ValidatingSessionManager：用于验证会话是否过期： void validateSessions(); //所有会话是否过期 三个内置实现类 DefaultSessionManager：DefaultSecurityManager使用，用于javaSE环境。 ServletContainerSessionManager：DefaultWebSecurityManager使用，用于web环境，直接使用Servlet容器的会话。 DefaultWebSessionManager：同上，不过是由自己维护着会话，不用Servlet容器的会话管理。 替换SecurityManager默认的SessionManager可以在ini中配置： [main] sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager ;web环境下应换为 sessionManager=org.apache.shiro.web.session.mgt.ServletContainerSessionManager securityManager.sessionManager=$sessionManager 设置会话的全局过期时间（单位：ms），默认30分钟。将应用给所有Session，不过可以单独设置每个session的timeout属性。 sessionManager. globalSessionTimeout=1800000 如果使用ServletContainerSessionManager进行会话管理Session的超时依赖于底层Servlet容器的超时时间，可以在web.xml中设置（单位：min）： &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 使用DefaultWebSessionManager维护会话： //sessionIdCookie：创建会话cookie的模板 sessionIdCookie=org.apache.shiro.web.servlet.SimpleCookie sessionManager=org.apache.shiro.web.session.mgt.DefaultWebSessionManager //设置cookie名，默认为JSESSIONID sessionIdCookie.name=sid //设置cookie域名，默认空，即当前访问的域名 #sessionIdCookie.domain=sishuok.com //设置cookie路径，默认空，即存储在域名根下 #sessionIdCookie.path= //设置cookie过期时间，单位秒，默认-1，即关闭浏览器时过期 sessionIdCookie.maxAge=1800 //true表示客户端不会暴露脚本代码，有助于减少某些类型的跨站点脚本攻击，Servlet2.5及以上才支持 sessionIdCookie.httpOnly=true sessionManager.sessionIdCookie=$sessionIdCookie 是否启用Session Id Cookie，默认启用；禁用将不会设置Session Id Cookie，即默认使用JSESSIONID sessionManager.sessionIdCookieEnabled=true securityManager.sessionManager=$sessionManager 配置了会话之后，第一次访问项目（任何页面）报错：There is no session with id […]，没事，这是shiro自己的一个bug，无伤大雅。 会话监听器 用于监听会话创建、过期及停止事件。 public class MySessionListener1 implements SessionListener { @Override public void onStart(Session session) {//会话创建时触发 System.out.println(&quot;会话创建：&quot; + session.getId()); } @Override public void onExpiration(Session session) {//会话过期时触发 System.out.println(&quot;会话过期：&quot; + session.getId()); } @Override public void onStop(Session session) {//退出/会话过期时触发 System.out.println(&quot;会话停止：&quot; + session.getId()); } } 如果只想监听某一事件，可以继承SessionListenerAdapter实现类。 public class MySessionListener2 extends SessionListenerAdapter { @Override public void onStart(Session session) { System.out.println(&quot;会话创建：&quot; + session.getId()); } } ini配置监听器 sessionListener1=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener1 sessionListener2=com.github.zhangkaitao.shiro.chapter10.web.listener.MySessionListener2 sessionManager.sessionListeners=$sessionListener1,$sessionListener2 会话持久化 SessionDAO接口：用于会话的CRUD，可以把会话保存到数据库。提供如下基本接口： //如DefaultSessionManager在创建完session后会调用该方法；如保存到关系数据库/文件系统/ //NoSQL数据库；即可以实现会话的持久化；返回会话ID，返回的ID.equals(session.getId())； Serializable create(Session session); //根据会话ID获取会话 Session readSession(Serializable sessionId) throws UnknownSessionException; //更新会话；如更新会话最后访问时间/停止会话/设置超时时间/设置移除属性等会调用 void update(Session session) throws UnknownSessionException; //删除会话；当会话过期/会话停止（如用户退出时）会调用 void delete(Session session); //获取当前所有活跃用户，如果用户量多此方法影响性能 Collection&lt;Session&gt; getActiveSessions(); AbstractSessionDAO: 提供了SessionDAO的基础实现，如生成会话id等。 CacheSessionDAO：提供了对开发者透明的会话缓存的功能，如查询会话时先到缓存看有没有，没有再查数据库。只需设置相应的CacheManager即可。自定义SessionDAO继承这个即可。 MemorySessionDAO：直接在内存中进行会话维护。 EnterpriseCacheSessionDAO：Enterprise，事业；提供了缓存功能的会话维护，默认使用MapCache，内部使用ConcurrentHashMap保存缓存的会话，ConCurrent，同时发生的，同时存在的。 ini配置SessionDAO sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO sessionManager.sessionDAO=$sessionDAO Shiro使用Ehcache存储会话，可以配合TerraCotta实现容器无关的分布式集群，依赖如下： &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; shiro-web.ini sessionDAO=org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO //CachingSessionDAO设置Session缓存名字，默认为此 sessionDAO.activeSessionsCacheName=shiro-activeSessionCache sessionManager.sessionDAO=$sessionDAO //cacheManager：缓存管理器，次数使用Ehcache实现 cacheManager = org.apache.shiro.cache.ehcache.EhCacheManager //指定Ehcache缓存的配置文件 cacheManager.cacheManagerConfigFile=classpath:ehcache.xml securityManager.cacheManager = $cacheManager ehcache.xml &lt;cache name=&quot;shiro-activeSessionCache&quot; //名字与sessionDAO的activeSessionsCacheName属性一致 maxEntriesLocalHeap=&quot;10000&quot; overflowToDisk=&quot;false&quot; eternal=&quot;false&quot; diskPersistent=&quot;false&quot; timeToLiveSeconds=&quot;0&quot; timeToIdleSeconds=&quot;0&quot; statistics=&quot;true&quot;/&gt; 另外可以在ini中配置会话id生成器 //默认为此，底层使用UUID生成。 sessionIdGenerator=org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator sessionDAO.sessionIdGenerator=$sessionIdGenerator 自定义SessionDAOpublic class MySessionDAO extends CachingSessionDAO { //带缓存的SessionDAO，会先从缓存找 private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate(); //保存会话 protected Serializable doCreate(Session session) { Serializable sessionId = generateSessionId(session); assignSessionId(session, sessionId); String sql = &quot;insert into sessions(id, session) values(?,?)&quot;; //把会话序列化后存储到数据库 jdbcTemplate.update(sql, sessionId, SerializableUtils.serialize(session)); return session.getId(); } //更新会话 protected void doUpdate(Session session) { if(session instanceof ValidatingSession &amp;&amp; !((ValidatingSession)session).isValid()) { return; //如果会话过期/停止 没必要再更新了 } String sql = &quot;update sessions set session=? where id=?&quot;; jdbcTemplate.update(sql, SerializableUtils.serialize(session), session.getId()); } //删除会话 protected void doDelete(Session session) { String sql = &quot;delete from sessions where id=?&quot;; jdbcTemplate.update(sql, session.getId()); } //查询会话 protected Session doReadSession(Serializable sessionId) { String sql = &quot;select session from sessions where id=?&quot;; List&lt;String&gt; sessionStrList = jdbcTemplate.queryForList(sql, String.class, sessionId); if(sessionStrList.size() == 0) return null; return SerializableUtils.deserialize(sessionStrList.get(0)); } } 接着在shiro-web.ini中配置这个自定义的会话持久化 sessionDAO=com.github.zhangkaitao.shiro.chapter10.session.dao.MySessionDAO 会话验证 SessionValidationScheduler：会话验证调度器，用于定期地验证会话是否已过期，是将停止会话。出于性能考虑，一般都是获取会话时来验证会话是否过期并停止会话的，但是在web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期检测。 //默认 sessionValidationScheduler=org.apache.shiro.session.mgt .ExecutorServiceSessionValidationScheduler //调度时间间隔，单位ms，默认1小时 sessionValidationScheduler.interval = 3600000 //设置进行会话验证时的会话管理器 sessionValidationScheduler.sessionManager=$sessionManager //设置全局会话超时时间，默认30min，30min内没有访问会话将过期 sessionManager.globalSessionTimeout=1800000 //是否开启会话验证器，默认开启 sessionManager.sessionValidationSchedulerEnabled=true sessionManager.sessionValidationScheduler=$sessionValidationScheduler Quartz会话验证调度器 依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--使用quartz要用到的--&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; ini配置 sessionValidationScheduler=org.apache.shiro.session.mgt.quartz .QuartzSessionValidationScheduler sessionValidationScheduler.sessionValidationInterval = 3600000 sessionValidationScheduler.sessionManager=$sessionManager 分页获取会话并验证 会话验证调度器实际都是调用AbstractValidatingSessionManager的validateSessions()进行验证，该方法调用SessionDAO的getActiveSessions()获取all会话进行验证，会话较多时会影响性能，可以考虑分页获取会话并进行验证。 自定义分页获取会话并验证的会话验证调度器，核心代码： //分页获取会话 String sql = &quot;select session from sessions limit ?,?&quot;; int start = 0; //起始记录 int size = 20; //每页大小 List&lt;String&gt; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size); while(sessionList.size() &gt; 0) { for(String sessionStr : sessionList) { try { Session session = SerializableUtils.deserialize(sessionStr); //反序列化回session对象 //获取验证方法 Method validateMethod = ReflectionUtils.findMethod(AbstractValidatingSessionManager.class, &quot;validate&quot;, Session.class, SessionKey.class); validateMethod.setAccessible(true); //调用验证方法 ReflectionUtils.invokeMethod(validateMethod, sessionManager, session, new DefaultSessionKey(session.getId())); } catch (Exception e) { //ignore } } start = start + size; sessionList = jdbcTemplate.queryForList(sql, String.class, start, size); } ini配置和之前类似。 如果在会话过期时不想删除，可以通过如下配置： //默认开启，在会话过期后会调用SessionDAO的delete()删除会话 sessionManager.deleteInvalidSessions=false 若在获取会话时验证了会话已过期，将抛出InvalidSessionException，需要捕获该异常并跳转相应页面提示会话已过期，让用户重新登录。可以在web.xml配置错误页面 &lt;error-page&gt; &lt;exception-type&gt;org.apache.shiro.session.InvalidSessionException&lt;/exception-type&gt; &lt;location&gt;/invalidSession.jsp&lt;/location&gt; &lt;/error-page&gt; SessionFactory 创建会话的工厂。默认用SimpleSessionFactory来创建SimpleSession会话。 首先自定义一个Session：保存用户的状态。 public class OnlineSession extends SimpleSession { public static enum OnlineStatus { //创建实例，调用构造器（要求传入字符串，则不能不传） on_line(&quot;在线&quot;), hidden(&quot;隐身&quot;), force_logout(&quot;强制退出&quot;); private final String info; private OnlineStatus(String info) { this.info = info; } public String getInfo() { return info; } } private String userAgent; //用户浏览器类型 private OnlineStatus status = OnlineStatus.on_line; //在线状态 private String systemHost; //用户登录时系统IP //省略其他 } 接着自定义SessionFactory public class OnlineSessionFactory implements SessionFactory { /** * 根据会话上下文创建OnlineSession，保存用户信息进去 */ @Override public Session createSession(SessionContext initData) { OnlineSession session = new OnlineSession(); if (initData != null &amp;&amp; initData instanceof WebSessionContext) { WebSessionContext sessionContext = (WebSessionContext) initData; HttpServletRequest request = (HttpServletRequest) sessionContext.getServletRequest(); if (request != null) { session.setHost(IpUtils.getIpAddr(request)); session.setUserAgent(request.getHeader(&quot;User-Agent&quot;)); session.setSystemHost(request.getLocalAddr() + &quot;:&quot; + request.getLocalPort()); } } return session; } } 最后在shiro-web.ini配置自定义的SessionFactory sessionFactory=org.apache.shiro.session.mgt.OnlineSessionFactory sessionManager.sessionFactory=$sessionFactory","categories":[],"tags":[]},{"title":"","slug":"Shiro第十一章-cache缓存","date":"2019-04-30T08:29:23.078Z","updated":"2019-04-05T02:58:49.099Z","comments":true,"path":"2019/04/30/Shiro第十一章-cache缓存/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十一章-cache缓存/","excerpt":"","text":"缓存 Shiro提供了类似于Spring的Cache抽象，即它本身不实现cache，但是对cache进行了抽象，方便更换底层cache实现（如，Ehcache,Hazelcast,OSCache,Terracotta,Coherence,GigaSpaces,JBossCache）。 Cache接口： public interface Cache&lt;K, V&gt; { //根据Key获取缓存中的值 public V get(K key) throws CacheException; //往缓存中放入key-value，返回缓存中之前的值 public V put(K key, V value) throws CacheException; //移除缓存中key对应的值，返回该值 public V remove(K key) throws CacheException; //清空整个缓存 public void clear() throws CacheException; //返回缓存大小 public int size(); //获取缓存中所有的key public Set&lt;K&gt; keys(); //获取缓存中所有的value public Collection&lt;V&gt; values(); } CacheManager接口：从接口方法来看就是用来获取cache的。 public interface CacheManager { //根据缓存名字获取一个Cache实例，不存在则新建一个 public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException; } 从上面来看，我们定义缓存要做两件事，一是实现Cache接口（shiro-ehcache.xml），二是实现CacheManager接口（shiro.ini中注册EhCacheManager的bean）。 Shiro数据的缓存方式分为两类，一是将数据存储到本地，一是存储到集中式存储中间件，如，redis或Memcached。若使用后者，当页面使用了大量shiro标签时（如，&lt;shiro:hasPermission name=”admin”&gt;），每个标签都会发起一个查询请求，那么访问一个页面将会向缓存发送大量网络请求，这回给集中缓存组件带来一定的瞬时请求压力，而且，网络查询的效率并不高。采用本地缓存则不存在这些问题。所以，如果在项目中使用了大量shiro标签，那还是采用本次缓存更合适。 MemoryConstraintCacheManager: 本地缓存。 EhCacheManager：集中式缓存。 CacheManagerAware：用于注入CacheManager public interface CacheManagerAware { //注入CacheManager void setCacheManager(CacheManager cacheManager); } Shiro内部的组件DefaultSecurityManager会自动检测相应的对象（如Realm）是否实现了CacheManagerAware，并自动注入相应的CacheManager。 Realm缓存 即权限数据的缓存（其实还有用户身份AuthenticationInfo的缓存，不过用的比较少，暂且忽略），需要设置一个CacheManager来管理缓存，设置方式有两种。 设置在SecurityManager中，最终也会设置给CachingRealm，其实真正使用CacheManager的组件也就realm和SessionDAO。 其中CachingSecurityManager有CacheManager属性，会把它设置给CachingRealm。 推荐：直接设置给CachingRealm。 &lt;bean id=&quot;myRealm&quot; class=&quot;org.chench.test.shiro.spring.dao.ShiroCacheJdbcRealm&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;permissionsLookupEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.MemoryConstrainedCacheManager&quot; /&gt; Shiro提供了几个Realm，它们实现了CacheManagerAware接口，能够实现缓存的一些基础功能。 CachingRealm: 最基础的实现，实现了CacheManagerAware接口，提供了缓存的一些基础实现。 AuthenticatingRealm、AuthorizingRealm：分别提供了对AuthenticationInfo和AuthorizationInfo的缓存。 示例 测试用例：仿ideaProjects/shiroHelloWorld/chapter6 在UserRealm中添加了6个方法用于清除缓存： //重写以下方法并改为public，否则测试无法调用这些Protected的方法 @Override public void clearCachedAuthenticationInfo(PrincipalCollection principals) { super.clearCachedAuthenticationInfo(principals); } @Override public void clearCachedAuthorizationInfo(PrincipalCollection principals) { super.clearCachedAuthorizationInfo(principals); } @Override public void clearCache(PrincipalCollection principals) { //同时调用以上俩方法，清空两个Info super.clearCache(principals); } public void clearAllCachedAuthorizationInfo(){ getAuthorizationCache().clear(); } public void clearAllCachedAuthenticationInfo() { getAuthenticationCache().clear(); } public void clearAllCache() { clearAllCachedAuthenticationInfo(); clearAllCachedAuthorizationInfo(); } shiro.ini userRealm=com.github.zhangkaitao.shiro.chapter11.realm.UserRealm //启用缓存，默认false，看源码默认好像是true。 userRealm.cachingEnabled=true //启用身份验证缓存，缓存AuthenticationInfo，默认false userRealm.authenticationCachingEnabled=true //缓存AuthenticationInfo的缓存名称 userRealm.authenticationCacheName=authenticationCache //启用授权缓存，默认true userRealm.authorizationCachingEnabled=true userRealm.authorizationCacheName=authorizationCache securityManager.realms=$userRealm //缓存管理器，此处使用EhCacheManager，即Ehcache实现，需要导入Ehcache的依赖 cacheManager=org.apache.shiro.cache.ehcache.EhCacheManager cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache.xml securityManager.cacheManager=$cacheManager 这篇参考文章又说只要设置了CacheManager就会自动开启缓存，实际测试好像也是这样。 Ehcache依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; 引入这个就不需要之前的ehcache-core依赖了。 ehcache.xml:配置Ehcache缓存，可以将数据存储到磁盘或内存中。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache name = &quot;shirocache&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; //数据缓存地址，如，F:/develop/ehcache &lt;cache name=&quot;authorizationCache&quot; //缓存名称 maxEntriesLocalHeap=&quot;2000&quot; //缓存最大条目数 eternal=&quot;false&quot; //对象是否永久有效，true则timeout失效 timeToIdleSeconds=&quot;3600&quot; //对象在失效前的闲置时间（单位：s）， //仅eternal=false时有效；默认为0，即可闲置时间无穷大。 timeToLiveSeconds=&quot;0&quot; //缓存数据的生成时间（单位：s）， //介于创建时间和失效时间之间；仅eternal=false有效； //默认为0，即对象存活时间无穷大。 overflowToDisk=&quot;false&quot; //内存中对象数量达到maxElementInMemory时， //是否将对象写到磁盘 statistics=&quot;true&quot;&gt; &lt;/cache&gt; &lt;cache name=&quot;authenticationCache&quot; maxEntriesLocalHeap=&quot;2000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;3600&quot; timeToLiveSeconds=&quot;0&quot; overflowToDisk=&quot;false&quot; statistics=&quot;true&quot;&gt; &lt;/cache&gt; &lt;cache name=&quot;shiro-activeSessionCache&quot; maxEntriesLocalHeap=&quot;2000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;3600&quot; timeToLiveSeconds=&quot;0&quot; overflowToDisk=&quot;false&quot; statistics=&quot;true&quot;&gt; &lt;/cache&gt; &lt;/ehcache&gt; cache标签其他属性： diskSpoolBufferSizeMB：设置diskStore磁盘缓存的缓存区大小，默认30MB。每个Cache都应该有自己的一个缓存区。 maxElementOnDisk：磁盘最大缓存个数。 diskPersistent：是否缓存虚拟机重启期数据，默认false。 diskExpiryThreadIntervalSeconds: 磁盘失效线程运行时间间隔，默认120s。 memoryStoreEvictionPolicy:达到maxElementInMemory时，Ehcache将会根据此策略去清理内存，默认策略是LRU（最近最少使用），可设为FIFO（先进先出）或LFU（较少使用）。 clearOnFlush: 内存数量最大时是否清除。 因为测试用例的关系，需要将Ehcache的CacheManager改为使用VM单例模式(不过本例好像没有在哪里修改) this.manager = new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream()); //改为 this.manager = net.sf.ehcache.CacheManager.create(getCacheManagerConfigFileInputStream()); 测试：首先登陆成功，此时会缓存相应的AuthenticationInfo；然后修改密码，此时AuthenticationInfo过期；接着需要调用realm的clearCacheAuthenticationInfo()清空之前的AuthenticationInfo，否则下次登录时还会获取那个修改密码前的AuthenticationInfo。 @Test public void testClearCachedAuthenticationInfo() { //1、登陆成功即缓存AuthenticationInfo login(u1.getUsername(), password); //2、修改了密码则之前保存的AuthenticationInfo变旧 userService.changePassword(u1.getId(), password + &quot;1&quot;); //3、清除之前缓存的AuthenticationInfo，否则下次登录时还会获取到旧的 //AuthenticationInfo RealmSecurityManager securityManager = (RealmSecurityManager) SecurityUtils.getSecurityManager(); //获取Realm UserRealm userRealm = (UserRealm) securityManager.getRealms().iterator().next(); userRealm.clearCachedAuthenticationInfo(subject().getPrincipals()); //4、再次登录，检测到AuthenticationInfo已清空，故重新缓存 login(u1.getUsername(), password + &quot;1&quot;); } 无论用户是否正常退出，缓存都将自动清空。 如果修改了用户的权限，而用户不退出系统，则修改的权限无法立即生效。需要用户在修改后手动调用clearXxx()清除缓存。 验证中缓存的使用 以上测试中，登录后即缓存AuthenticationInfo，实际是AuthenticationRealm类中的getAuthenticationInfo()起作用，首先判断缓存中是否已有该记录，否则调用子类Realm的doGetAuthenticationInfo()查询数据库，并将结果缓存起来，下次就不用查询数据库了。核心代码： public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { //首先从缓存中获取记录 AuthenticationInfo info = getCachedAuthenticationInfo(token); //若缓存中无此数据 if (info == null) { //则从数据库查找 info = doGetAuthenticationInfo(token); if (token != null &amp;&amp; info != null) { //将记录缓存起来 cacheAuthenticationInfoIfPossible(token, info); } } else { //debug级日志记录 } if (info != null) { //匹配密码 assertCredentialsMatch(token, info); } else { //debug级日志记录 } return info; } 授权中缓存的使用 而AuthorizationInfo的缓存则是AuthorizingRealm中的getAuthorizationInfo()在实现，也是先找缓存，没有再调用doGetAuthorizationInfo()去数据库找。 protected AuthorizationInfo getAuthorizationInfo(PrincipalCollection principals) { //如果登录成功的用户身份信息集合为空，则直接返回null if (principals == null) { return null; } AuthorizationInfo info = null; Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache(); if (cache != null) { Object key = getAuthorizationCacheKey(principals); //这个集合只有一个key info = cache.get(key); } //如果缓存中找不到AuthorizationInfo if (info == null) { //从数据库找 info = doGetAuthorizationInfo(principals); //并存入缓存 if (info != null &amp;&amp; cache != null) { Object key = getAuthorizationCacheKey(principals); cache.put(key, info); } } return info; } 如果需要实现自己的缓存，可以考虑自己通过aop机制实现而废弃Shiro的缓存 如果要和Spring集成可以考虑使用SpringCacheManagerWrapper,它对Spring Cache进行了包装，转换为Shiro的CacheManager实现类 Session缓存 为了使会话能够用上缓存（比如查询会话时先看看缓存中是否有，没有再倒数据库查询），可以先设置SecurityManager的CacheManager属性，再设置SecurityManager的SessionManager属性，那么会自动把配置的CacheManager注入到SessionManager中。 //设置CacheManager securityManager.cacheManager=$cacheManager //设置SessionManager sessionManager=org.apache.shiro.session.mgt.DefaultSessionManager securityManager.sessionManager=$sessionManager 若SecurityManager实现了SessionsSecurityManager接口，则会自动判断SessionManager是否实现了CacheManagerAware接口，是则将CacheManager注入给它。然后SessionManager会判断SessionDAO是否实现了CacheManagerAware接口（如继承自CachingSessionDAO），是则会把CacheManager注入给它。 对于CachingSessionDAO,可以设置缓存的名称： sessionDAO=com.github.zhangkaitao.shiro.chapter11.session.dao.MySessionDAO //默认为此 sessionDAO.activeSessionsCacheName=shiro-activeSessionCache 《跟我学Shiro》第十一章 参考文章","categories":[],"tags":[]},{"title":"","slug":"Shiro第十五章-单点登录","date":"2019-04-30T08:29:23.074Z","updated":"2019-03-17T04:29:57.356Z","comments":true,"path":"2019/04/30/Shiro第十五章-单点登录/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十五章-单点登录/","excerpt":"","text":"简介 Shiro 1.2开始支持Jasig CAS单点登录。 作用：用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无需多次登录。 服务器下载 Jasig CAS分为服务器端和客户端，服务器提供用户验证。访问需要登录的页面，自动跳转单点登录服务器：https://localhost:8443/server/login?service=原url，单点登录采用的是https。 war包下载地址：http://central.maven.org/maven2/org/jasig/cas/cas-server-webapp/4.0.3、http://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp/4.0.3。 我们使用cas 4.0.0版本的服务器，除了以上地址还可以到https://www.apereo.org/cas/download选择版本下载zip自己构建war包（没试过），也可以到网盘https://pan.baidu.com/s/1snr4Tzv，密码：z45j，下载cas-server-4.0.0-release.rar（已下载到E和网盘/五年高考三年模拟）。 解压（网盘版解压外层压缩包后依然有两个压缩包，再接着把俩一起解压了），找到cas-server-4.0.0\\modules\\cas-server-webapp-4.0.0.war，重命名为cas.war（主要是为了待会访问系统时url短一点）。 将cas-server.war放入tomcat/webapps，启动tomcat。 访问https://localhost:8443/cas/login，默认用户名casuser,密码Mellon登录。 注销： https://localhost:8443/cas/logout 以上只是测试cas server的效果，下面正式集成cas，分为server和client两部分。 新建Maven项目：shiro-chapter15。 CAS Server 直接将E:\\cas-server-4.0.0-release\\cas-server-4.0.0\\cas-server-webapp拷到shirochapter15下成为其子模块，并重命名为shiro-chapter15-server；idea将自动扫描到更改。 在idea中修改shiro-chapter15的pom.xml，设置shiro-chapter15-server为其子模块。 修改shiro-chapter15-server的pom.xml中的一些头信息，增加tomcat插件。 添加证书：src下建包licensing，把E:\\cas导入maven缺少head.txt文件中俩文件复制进去即可。 添加自定义用户：src/main/webapp/WEB-INF/deployerConfigContext.xml，primaryAuthenticationHandler节点下添加代码： &lt;entry key=&quot;zhang&quot; value=&quot;123&quot;/&gt; tomcat7:run运行，出现上面登录界面，输入zhang/123即可登录。cas server配置成功。 CAS Client 示例采用shirochapter12，web.xml、pom.xml、src、resources下文件基本一致，以下只列出不同的部分。 导出证书：cas客户端和服务端间交互需要用到证书，因此需要将D:/keys/localhost.keystore导出证书到相同目录下。 //导出证书 keytool -export -alias localhost -file D:\\keys\\localhost.cer -keystore D:\\keys\\localhost.keystore //导入jdk cd D:\\jdk\\1.8\\jre\\lib\\security //进入jdk（真正的jdk而非本地jdk目录） keytool -import -alias localhost -file D:\\localhost.cer -noprompt -trustcacerts -storetype jks -keystore cacerts -storepass 123456 导入失败的话可先将security下的cacerts删掉。 导入shiro-cas依赖： &lt;dependency&gt; &lt;!--集成cas-client--&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; 自定义CasRealm：继承CasRealm类，实现权限验证，用户验证则交给cas server做，不用自定义。 public class MyCasRealm extends CasRealm { private UserService userService; public void setUserService(UserService userService){ this.userService=userService; } /** * @Author haien * @Description 根据CAS服务器返回的用户身份获取相应的权限信息 * @Date 2019/3/11 * @Param [principals] * @return org.apache.shiro.authz.AuthorizationInfo **/ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { String username=(String)principals.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo=new SimpleAuthorizationInfo(); authorizationInfo.setRoles(userService.findRoles(username)); authorizationInfo.setStringPermissions(userService.findPermissions(username)); return authorizationInfo; } } spring-shiro-web.xml：配置CasRealm和CasFilter，即查找用户权限以支持权限验证和配置cas过滤器使登录时重定向到cas server的登录页面。 &lt;!--CasRealm--&gt; &lt;bean id=&quot;casRealm&quot; class=&quot;com.haien.chapter15.realm.MyCasRealm&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt; &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt; &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt; &lt;!--CAS Server服务器端地址--&gt; &lt;property name=&quot;casServerUrlPrefix&quot; value=&quot;https://localhost:8443/chapter15-server&quot;/&gt; &lt;!--登录成功后跳转的url，即用于接收并处理登录成功后的Ticket的--&gt; &lt;property name=&quot;casService&quot; value=&quot;https://localhost:8443/chapter15-client/cas&quot;/&gt; &lt;/bean&gt; 如果用户权限信息也由服务端提供的话，可以不用继承而直接使用CasRealm。 &lt;bean id=&quot;casRealm&quot; class=&quot;org.apache.shiro.cas.CasRealm&quot;&gt; &lt;!--和上面一样的property--&gt; &lt;!--默认添加给所有登录成功用户的角色和权限--&gt; &lt;property name=&quot;defaultRoles&quot; value=&quot;admin,user&quot;/&gt; &lt;property name=&quot;defaultPermissions&quot; value=&quot;user:create,user:update&quot;/&gt; &lt;!--角色、权限字段名；若权限信息是从服务端返回的（即返回的CAS Principal中 除了Principal外还有Attributes），可以使用roleAttributeNames、 permissionAttributeNames来获取Attributes中的角色、权限信息； 请自行查询cas如何获取用户更多信息--&gt; &lt;property name=&quot;roleAttributeNames&quot; value=&quot;roles&quot;/&gt; &lt;property name=&quot;permissionAttributeNames&quot; value=&quot;permissions&quot;/&gt; &lt;/bean&gt; CasFilter： &lt;!--CasFilter:类似于FormAuthenticationFilter，只不过其验证服务器端返回的是 CAS Service Ticket--&gt; &lt;bean id=&quot;casFilter&quot; class=&quot;org.apache.shiro.cas.CasFilter&quot;&gt; &lt;property name=&quot;failureUrl&quot; value=&quot;/casFailure.jsp&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!--登录路径;service为登录成功后跳转的url--&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;https://localhost:8443/chapter15-server/login? service=https://localhost:8443/chapter15-client/cas&quot;/&gt; &lt;!-- 登录成功后跳转路径 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/&quot; /&gt; &lt;!--定义自己的过滤器--&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;cas&quot; value-ref=&quot;casFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /casFailure.jsp=anon /cas=cas //走cas服务器，带着ticket过去再次身份验证 /logout = logout /** = user &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 测试： 访问http://localhost:8080/chapter15-client/,自动跳转登录页面，即在spring-shiro-web.xml配置的loginUrl————https://localhost:8443/server/login?service=https://localhost:8443/chapter15-client/cas，原url从/变成/cas； 登录成功后，转回原url：https://localhost:8443/chapter15-client/cas?ticket=ST-1-eh2cIo92F9syvoMs5DOg-cas01.example.org； spring-shiro-web.xml配置了/cas要走cas过滤器，它会先验证ticket是否有效，有效再调用MyCasRealm获取权限信息。 代码实例：ideaProjects/shirochapter15 《跟我学Shiro》第十五章","categories":[],"tags":[]},{"title":"","slug":"Shiro第十四章-SSL","date":"2019-04-30T08:29:23.070Z","updated":"2019-03-10T04:19:43.165Z","comments":true,"path":"2019/04/30/Shiro第十四章-SSL/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十四章-SSL/","excerpt":"","text":"简介 Secure Sockets Layer，安全套接层。在传输层对网络进行加密，为网络通信安全提供安全及数据完整性。 利用数据加密技术，确保数据在传输过程中不会被截取及窃听。 广泛应用于web浏览器与服务器之间的身份认证和加密数据传输。 对于SSL的支持，Shiro只是判断当前url是否需要SSL登录，是则自动重定向到https进行访问。 流程 首先生成数字证书，保存到D:/localhost.keystore。证书生成步骤如下： 使用jdk的KeyTool命令，生成证书（包含证书、公钥、私钥）到D:/localhost.keystore keytool -genkey -keystore &quot;D:\\localhost.keystore&quot; -alias localhost -keyalg RSA 输入密钥库口令:123456 再次输入新口令:123456 您的名字与姓氏是什么? [Unknown]: localhost //必须是localhost，否则出错 您的组织单位名称是什么? [Unknown]: sishuok.com 您的组织名称是什么? [Unknown]: sishuok.com 您所在的城市或区域名称是什么? [Unknown]: beijing 您所在的省/市/自治区名称是什么? [Unknown]: beijing 该单位的双字母国家/地区代码是什么? [Unknown]: cn CN=localhost, OU=sishuok.com, O=sishuok.com, L=beijing, ST=beijing, C=cn是否正确? [否]: y 输入 &lt;localhost&gt; 的密钥口令 (如果和密钥库口令相同, 按回车):回车 再次输入新口令: 可以选择导出cer证书并安装到浏览器内，详见笔记：https、SSL和TLS，使用KeyTool生成自签名证书。不过不安装也没事，只是进行ssl访问时会提示网站不安全而已。 然后设置tomcat/config/server.xml &lt;!-- &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt; --&gt; &lt;!--将以上代码替换为--&gt; &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot; maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;D:/localhost.keystore&quot; keystorePass=&quot;123456&quot; /&gt; &lt;!--keystorePass:生成keystore时的口令； clientAuth:设置是否双向验证，默认false，表示只有客户端验证服务器， 服务器不验证客户端；--&gt; 添加SSL到配置文件spring-shiro-web.xml，使用和十三章一样的代码。 &lt;bean id=&quot;sslFilter&quot; class=&quot;org.apache.shiro.web.filter.authz.SslFilter&quot;&gt; &lt;property name=&quot;port&quot; value=&quot;8443&quot;/&gt; &lt;!--SslFilter端口默认是443，此处使用了8443--&gt; &lt;/bean&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; …… &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;entry key=&quot;ssl&quot; value-ref=&quot;sslFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login.jsp = ssl,authc //表示访问登录页面时需要走SSL /logout = logout /authenticated.jsp = authc /** = user &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 打包并部署到tomcat：否则直接运行是没用的。 &lt;build&gt; &lt;finalName&gt;chapter14&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/${project.build.finalName}&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 运行mvn package,把打成的war包复制到tomcat/webapps下，运行tomcat/bin/startup.bat，访问localhost:8080/chapter14/，自动跳转到https://localhost:8080/chapter14/login.jsp。 《跟我学Shiro》第十四章 代码实例：ideaProjects/shiro-example-chapter14（是从作者github拷下来的代码，但是所有文件都换成了shirochapter12的；和shirochapter12完全一样，包括依赖版本、resources下各xml和web.xml都比对一致；除了pom.xml中顶上url，但经测试无论用哪个url都对，但不知为何14没问题，12在tomcat运行却一直报错如下： org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;shiroFilter&apos; defined in class path resource [spring-shiro-web.xml]: Initialization of bean failed; nested exception is org.springframework.beans.ConversionNotSupportedException: Failed to convert property value of type [java.util.LinkedHashMap] to required type [java.util.Map] for property &apos;filters&apos;; nested exception is java.lang.IllegalStateException: Cannot convert value of type [java.lang.String] to required type [javax.servlet.Filter] for property &apos;filters[ssl]&apos;: no matching editors or conversion strategy found","categories":[],"tags":[]},{"title":"","slug":"Shiro第十三章-RememberMe和Cookie","date":"2019-04-30T08:29:23.060Z","updated":"2019-03-07T12:33:55.770Z","comments":true,"path":"2019/04/30/Shiro第十三章-RememberMe和Cookie/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十三章-RememberMe和Cookie/","excerpt":"","text":"简介 首先在登录页面选中remember me然后登录成功；如果是浏览器登录，一般会把remember me的cookie写到客户端保存下来； 关闭浏览器再次打开，会发现浏览器还是记住你的； 访问一般的网页服务端还是知道你是谁的，且能正常访问； 但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，还是需要再进行身份验证，以确定当前用户还是你。 remember me配置 测试用例：第十二章的示例，ideaProjects/shirochapter12 spring-shiro-web.xml: &lt;!-- 会话Cookie模板 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;constructor-arg value=&quot;sid&quot;/&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;maxAge&quot; value=&quot;-1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;constructor-arg value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;&lt;!-- 30天 --&gt; &lt;/bean&gt; &lt;!-- rememberMe管理器 --&gt; &lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt; &lt;property name=&quot;cipherKey&quot; value=&quot;#{T(org.apache.shiro.codec.Base64).decode(&apos;4AvVhmFLUs0KTA3Kprsdag==&apos;)}&quot;/&gt; &lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot;/&gt; &lt;/bean&gt; sessionIdCookie:maxAge=-1表示浏览器关闭时Cookie失效。 rememberMeCookie:记住我的cookie，保存时长30天。 rememberMeManager：rememberMe管理器，cipherKey(cipher:密码)是加密RememberMe Cookie的密钥，默认AES算法。 &lt;!-- 安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; …… &lt;property name=&quot;rememberMeManager&quot; ref=&quot;rememberMeManager&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; …… &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login.jsp = authc /logout = logout /authenticated.jsp = authc /** = user &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; rememberMeParam：rememberMe请求参数名，请求参数是Boolean类型，true表示RememberMe。 /login.jsp = authc：用户必须通过身份验证Subject.login()，则Subject.isAuthenticated()==true；一般用于访问特殊网页，如，我的订单、提交订单页面。 /** = user：身份验证通过或记住我；一般用于普通网页，如，主页之类的。 测试： 访问localhost:8080/chapter12/，跳转login页面，登录成功后会设置会话及rememberMeCookie； 关闭浏览器，会话cookie失效，但rememberMe有效； 重新打开浏览器访问localhost:8080/chapter12/，可以访问，不再要求登录； 但是访问/authenticated.jsp，则会跳转登录页面重新进行身份验证。 自定义RememberMe 如果要自己做RememberMe，需要在登录之前这样创建Token：UsernamePasswordToken(用户名，密码，是否记住我)，如： Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); token.setRememberMe(true); subject.login(token); subject.isAuthenticated():表示用户是经过身份验证登录的，即Subject.login()。 subject.isRemembered()：表示用户是通过记住我登录的，此时可能是别人使用你的电脑，或你的cookie被窃取；与以上方法不会同时为true。 总结 RememberMe需要配合相应的拦截器使用，用错了拦截器可能就不满足你的需求了。 代码示例：ideaProjects/shirochapter12 《跟我学Shiro》第十三章","categories":[],"tags":[]},{"title":"","slug":"Shiro第十七章-OAuth2集成","date":"2019-04-30T08:29:23.046Z","updated":"2019-04-01T13:24:42.773Z","comments":true,"path":"2019/04/30/Shiro第十七章-OAuth2集成/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十七章-OAuth2集成/","excerpt":"","text":"简介 使用Apache Oltu来做对OAuth的实现，因为它比较轻量、简单、灵活。 按照OAuth的角色分布，可以写三个程序：资源服务器、授权服务器和客户端Client各一个，也可以全部写到一个程序里面。 本例采用写成两个程序，一个服务器端，一个客户端。 数据库 数据库：shiro-oauth2.所在会话：mysql。 oauth2_user:用户表，资源拥有者。admin/123456。 oauth2_client:客户端表，存储客户端id和客户端密钥，在进行授权时使用。 服务器端oltu源码 源码分包： issuer：生成授权码和访问令牌，刷新令牌。 request：封装授权码请求和令牌请求的逻辑，并提供相应的校验服务。 response：封装授权流程中的响应逻辑，提供生成不同响应结果的方法。 validator：为request提供校验服务。 issuer 主要是俩接口。 OAuthIssuer接口：默认实现类OAuthIssuerImpl。 public interface OAuthIssuer { public String accessToken() throws OAuthSystemException; public String authorizationCode() throws OAuthSystemException; public String refreshToken() throws OAuthSystemException; } ValueGenerator接口：默认实现类MD5Generator和UUIDValueGenerator，用于生成code和token的字符串。 public interface ValueGenerator { public String generateValue() throws OAuthSystemException; public String generateValue(String param) throws OAuthSystemException; } request 封装请求主要是为了提取其中的参数来验证是否合格，比如client_id是否正确。 主要是一个父类，其他都是其子类。 OAuthRequest：父类，提供最基础的逻辑和方法。 OAuthAuthzRequest：授权码请求。 AbstractOAuthTokenRequest：抽象类，为下一个类做准备。 OAuthTokenRequest：令牌请求。 OAuthUnauthenticatedTokenRequest：刷新令牌的请求。 validator部分代码分析 封装请求示例： OAuthTokenRequest oAuthTokenRequest=new OAuthTokenRequest(request); //比如规定的参数必须要有，至少GrantType、clientId、clientSecret、code、redirectUrl； //否则抛出异常：OAuthProblemException；另有OAuthSystemException，这个较少出现 validator 包下all类实现自validators包的OAuthvalidator接口，其包下还有实现了all方法的AbstractValidator类。 本包下类： 部分代码分析 response OAuthResponse：构造响应数据的父类，构造方法protected，不能创建实例，实际用到的是其静态内部类OAuthResponseBuilder，是后面要介绍到的两个Builder类的父类；不知道在不在本包；成员如下： 其中有两个Builder：OAuthResponseBuilder和OAuthErrorResponseBuilder，后者是前者的子类。 OAuthASResponse：子类，提供了组装不同请求的方法，成员如下： 构造方法是protected，因此不能new此类的实例，我们实际需要用的只是它的两个静态内部类OAuthAuthorizationResponseBuilder和OAuthTokenResponseBuilder，通过它们的方法来生成最终的响应数据。 构造响应的方法基本也就上面框出来3个了，注意到Builder内的all方法都是返回本类的实例，也就是可以无限链式调用。我们先看一个实际使用中的场景： // 处理授权码请求返回的响应 OAuthResponse oAuthResponse= OAuthASResponse.authorizationResponse(request, 200) .location(redirectUrl) .setCode(oauthCode) .setScope(state) .buildQueryMessage(); String url=oAuthResponse.getLocationUri(); response.sendRedirect(url); // 令牌 OAuthResponse authASResponse = OAuthASResponse.tokenResponse(200) .setAccessToken(access_token) .setExpiresIn(&quot;7200&quot;) .setRefreshToken(refreshToken) .setTokenType(TokenType.BEARER.toString()) .setParam(&quot;re_expires_in&quot;, &quot;14400&quot;) .buildJSONMessage(); String json=authASResponse.getBody(); // 错误响应 OAuthResponse authASResponse = OAuthASResponse .errorResponse(HttpServletResponse.SC_UNAUTHORIZED) .setError(OAuthError.ResourceResponse.INVALID_TOKEN) .setErrorDescription(&quot;invald expired&quot;) .buildJSONMessage(); return new ResponseEntity&lt;String&gt;(authASResponse.getBody(), headers, HttpStatus.UNAUTHORIZED); buildQueryMessage()：发起新请求，url即location()中的参数redirectUrl，响应体自然也送至该url。 buildJSONMessage()：返回原页面，响应体被解析为json。 setter实际就是设置响应参数，最后调用一个buildXxxMessage方法生成一个包含所有响应参数的OAuthResponse对象(注意是OAuthResponse这个父类，而不是OAuthASResponse子类，所以最终都是要用OAuthResponse对象来接收)。 对象返回后就可以调用getBody(),getHeaders()之类的方法获取到其中的响应数据。 对于错误响应中的error，在set时可以直接调用alth提供的OAuthError类的常量，它们是不同场景下通用的错误标识。 参考文章 示例 目的：执行OAuth授权流程。 实体: 客户端Client、用户User。 service：客户端的增删查改、用户的增删查改、OAuthService管理code和token。 controller：分为对内的后台管理控制器和对外的执行OAuth的控制器。后台管理主要负责QQ内部维护的用户和已在此注册的客户端，执行OAuth的控制器负责为客户端授权（给code、给token、给用户信息）。 依赖：authzserver授权服务器和resourceserver资源服务器两个依赖。 &lt;dependency&gt; &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt; &lt;artifactId&gt;org.apache.oltu.oauth2.authzserver&lt;/artifactId&gt; &lt;version&gt;0.31&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt; &lt;artifactId&gt;org.apache.oltu.oauth2.resourceserver&lt;/artifactId&gt; &lt;version&gt;0.31&lt;/version&gt; &lt;/dependency&gt; 授权服务器 以下两个controller一个负责根据登录表单给code，一个负责根据code给token，合为授权服务器。 AuthorizeController：授权控制器，控制客户端访问OAth服务器端的授权登录页面，通过授权验证并获取code授权码。 首先访问该controller第一个方法地址：/authorize?client_id=xxx&amp;response_type=code&amp;redirect_uri=http://localhost:9080/chapter17-client/oauth2-login，即访问授权页面。 控制器首先检查clientId是否正确，如果错误则返回错误响应； 如果正确则判断用户是否已登录，否则跳转登录页面； 已登录则生成相应auth code，并保存到缓存中。 重定向回redirect_uri:http://localhost:9080/chapter17-client/oauth2-login?code=xxx,接着客户端凭此code去获取token。 @Controller public class AuthorizeController { @Resource private OAuthService oAuthService; @Resource private ClientService clientService; /** * @Author haien * @Description 映射授权页面：/authorize?clien_id=xxx &amp; response_type=code &amp; redirect_uri=http://localhost:8080/chapter17-client/oauth2-login * @Date 2019/3/26 * @Param [model, request] * @return java.lang.Object **/ @RequestMapping(&quot;/authorize&quot;) public Object authorize(Model model, HttpServletRequest request) throws OAuthSystemException,URISyntaxException { try { //1. 把当前请求封装成OAth请求 OAuthAuthzRequest oAuthAuthzRequest=new OAuthAuthzRequest(request); //2. 检查client_id是否正确 if(!oAuthService.checkClientId(oAuthAuthzRequest.getClientId())){ //错误则构造错误响应 OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_BAD_REQUEST) //设置错误码 .setError(OAuthError.TokenResponse.INVALID_CLIENT) .setErrorDescription( Constants.INVALID_CLIENT_DESCRIPTION) .buildJSONMessage(); //返回原页面，响应体被前端解析为json //获取上面构造好的响应数据 return new ResponseEntity( response.getBody(), HttpStatus.valueOf(response.getResponseStatus()) ); //response.getBody()：获取响应体，返回string； //包含两个键值对：error和error_description } //3. 判断用户是否已登录 Subject subject=SecurityUtils.getSubject(); //若用户尚未登录，跳转登录页面 if(!subject.isAuthenticated()){ //如果登录失败则跳转回登录页面 if(!login(subject,request)) model.addAttribute(&quot;client&quot;, clientService.findByClientId( oAuthAuthzRequest.getClientId())); //跳转登录页面 return &quot;oauth2login&quot;; } //4. 登录成功或已登录则生成授权码code String username=(String)subject.getPrincipal(); String authorizationCode=null; /*获取请求中的response_type参数， OAUTH_RESPONSE_TYPE值应为response_type； responseType目前只支持code和token*/ String responseType=oAuthAuthzRequest .getParam(OAuth.OAUTH_RESPONSE_TYPE); if(responseType.equals(ResponseType.CODE.toString())){ //生成authCode OAuthIssuerImpl oauthIssuerImpl=new OAuthIssuerImpl( new MD5Generator()); authorizationCode=oauthIssuerImpl.authorizationCode(); //添加缓存条目：key=authCode.value=username oAuthService.addAuthCode(authorizationCode,username); } /*5. 重定向回客户端地址， http://localhost:8080/chapter17-client/oauth2-login? code=xxx*/ //获取请求中的重定向地址，OAUTH_REDIRECT_URI应为redirect_uri String redirectURI=oAuthAuthzRequest .getParam(OAuth.OAUTH_REDIRECT_URI); final OAuthResponse response= OAuthASResponse .authorizationResponse(request,HttpServletResponse.SC_FOUND) .setCode(authorizationCode) //设置授权码 .location(redirectURI) .buildQueryMessage(); //发起新请求，url即redirectURI //获取response数据 HttpHeaders headers=new HttpHeaders(); //响应报头域中location为重定向的url headers.setLocation(new URI(response.getLocationUri())); return new ResponseEntity(headers, HttpStatus.valueOf(response.getResponseStatus())); } catch (OAuthProblemException e) { //new OAuthAuthzRequest()抛出的 //异常处理 String redirectUri=e.getRedirectUri(); //如果客户端没有传入redirectUri if(OAuthUtils.isEmpty(redirectUri)) { //返回原页面，打印以下字符串 return new ResponseEntity( &quot;OAuth callback url needs to be provided by client!&quot;, HttpStatus.NOT_FOUND); } //否则返回其他错误信息 final OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_FOUND) .error(e) .location(redirectUri) .buildQueryMessage(); //获取response数据 HttpHeaders headers=new HttpHeaders(); headers.setLocation(new URI(response.getLocationUri())); return new ResponseEntity(headers, HttpStatus.valueOf(response.getResponseStatus())); } } /** * @Author haien * @Description shiro的登录方法 * @Date 2019/3/26 * @Param [subject, request] * @return boolean **/ private boolean login(Subject subject,HttpServletRequest request){ //不处理get请求 if(&quot;get&quot;.equalsIgnoreCase(request.getMethod())) return false; String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); if(StringUtils.isEmpty(username)||StringUtils.isEmpty(password)) return false; UsernamePasswordToken token=new UsernamePasswordToken(username,password); try { subject.login(token); return true; } catch(Exception e){ request.setAttribute(&quot;error&quot;,&quot;登录失败：&quot;+e.getClass().getName()); return false; } } } 其中242行catch块无redirectUri时，返回原页面并打印错误信息如下： AccessTokenController：令牌控制器，负责用code获取token的过程。 首先访问该类方法:/accesstoken，并post数据：client_id=xxx &amp; client_secret=xxx &amp; grant_type=authorization_code &amp; code=xxx &amp; redirect_uri=http://localhost:9080/chapter17-client/oauth2-login，请求获取token。 控制器验证client_id、client_secret和code是否正确，否则生成错误响应； 正确则生成Access Token。 重定向回去，并带上Access Token。 @Controller public class AccessTokenController { @Resource private OAuthService oAuthService; @Resource private UserService userService; @RequestMapping(&quot;/accessToken&quot;) public HttpEntity token(HttpServletRequest request) throws OAuthSystemException { try { //1. 把当前请求封装成OAuth的请求 OAuthTokenRequest oAuthTokenRequest=new OAuthTokenRequest(request); //2. 检查client_id、客户端key(client_secret)、许可证类型是否正确 if(!oAuthService.checkClientId(oAuthTokenRequest.getClientId())){ OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_BAD_REQUEST) .setError(OAuthError.TokenResponse.INVALID_CLIENT) .setErrorDescription( Constants.INVALID_CLIENT_DESCRIPTION) .buildJSONMessage(); return new ResponseEntity(response.getBody(), HttpStatus.valueOf(response.getResponseStatus())); } //客户端key if(!oAuthService.checkClientSecret( oAuthTokenRequest.getClientSecret())){ OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_UNAUTHORIZED) .setError(OAuthError.TokenResponse.UNAUTHORIZED_CLIENT) .setErrorDescription( Constants.INVALID_CLIENT_DESCRIPTION) .buildJSONMessage(); return new ResponseEntity(response.getBody(), HttpStatus.valueOf(response.getResponseStatus())); } //许可证类型,此处只支持code类型，其他还有password和refresh_token String authCode=oAuthTokenRequest.getParam(OAuth.OAUTH_CODE); //从request中获取grant_type参数,判断是不是code类型 if(oAuthTokenRequest.getParam(OAuth.OAUTH_GRANT_TYPE).equals( GrantType.AUTHORIZATION_CODE.toString())){ //检查code是否正确 if(!oAuthService.checkAuthCode(authCode)){ //生成错误响应 OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_BAD_REQUEST) .setError(OAuthError.TokenResponse.INVALID_GRANT) .setErrorDescription(&quot;错误的授权码&quot;) .buildJSONMessage(); return new ResponseEntity(response.getBody(), HttpStatus.valueOf(response.getResponseStatus())); } } //3. 生成Access Token OAuthIssuer oauthissuer=new OAuthIssuerImpl(new MD5Generator()); final String accessToken=oauthissuer.accessToken(); //生成token //加入缓存 oAuthService.addAccessToken(accessToken, oAuthService.getUsernameByAuthCode(authCode)); //4. 重定向回去（不知道为什么这里没有把请求中的redirect_uri放进去） //不需要return，自然会作为response带回去 OAuthResponse response=OAuthASResponse .tokenResponse(HttpServletResponse.SC_OK) .setAccessToken(accessToken) //Long转String .setExpiresIn(String.valueOf(oAuthService.getExpireIn())) .buildJSONMessage(); return new ResponseEntity(response.getBody(), HttpStatus.valueOf(response.getResponseStatus()))l } catch (OAuthProblemException e) { //生成错误响应 OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_BAD_REQUEST) .error(e) .buildJSONMessage(); return new ResponseEntity(response.getBody(), HttpStatus.valueOf(response.getResponseStatus())); } } } 资源服务器 ResourceController：充当资源服务器，拥有user信息，根据token给客户端提供这些信息。 首先访问该类方法：/userInfo?access_token=xxx，即用token请求用户信息。 控制器判断token是否有效（存在并未过期），否则生成错误响应，客户端重新请求授权； 是则返回用户信息（此处为用户名）。 @RestController public class ResourceController { @Resource private OAuthService oAuthService; @RequestMapping(&quot;/userInfo&quot;) public HttpEntity userInfo(HttpServletRequest request) throws OAuthSystemException { try { //1. 将request包装成OAuth请求 OAuthAccessResourceRequest oAuthAccessResourceRequest= new OAuthAccessResourceRequest(request); //2. 检查Access Token是否正确 String accessToken=oAuthAccessResourceRequest.getAccessToken(); if(!oAuthService.checkAccessToken(accessToken)){ //不存再或已过期 //生成错误响应 OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_UNAUTHORIZED) .setRealm(Constants.RESOURCE_SERVER_NAME) .setError(OAuthError.ResourceResponse.INVALID_TOKEN) .buildHeaderMessage(); HttpHeaders headers=new HttpHeaders(); headers.add(OAuth.HeaderType.WWW_AUTHENTICATE, response.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE)); return new ResponseEntity(headers,HttpStatus.UNAUTHORIZED); } //3. 返回资源（这里是用户名） String username=oAuthService.getUsernameByAccessToken(accessToken); return new ResponseEntity(username,HttpStatus.OK); } catch (OAuthProblemException e) { //是否设置了错误码 String errorCode=e.getError(); //没有错误码则不加错误码 if(OAuthUtils.isEmpty(errorCode)){ OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_UNAUTHORIZED) .setRealm(Constants.RESOURCE_SERVER_NAME) .buildHeaderMessage(); HttpHeaders headers=new HttpHeaders(); headers.add(OAuth.HeaderType.WWW_AUTHENTICATE, response.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE)); return new ResponseEntity(headers,HttpStatus.UNAUTHORIZED); } //有就加上 OAuthResponse response=OAuthASResponse .errorResponse(HttpServletResponse.SC_UNAUTHORIZED) .setRealm(Constants.RESOURCE_SERVER_NAME) .setError(e.getError()) .setErrorDescription(e.getDescription()) .setErrorUri(e.getUri()) .buildHeaderMessage(); HttpHeaders headers=new HttpHeaders(); headers.add(OAuth.HeaderType.WWW_AUTHENTICATE, response.getHeader(OAuth.HeaderType.WWW_AUTHENTICATE)); return new ResponseEntity(HttpStatus.BAD_REQUEST); } } } 配置文件：跟第十六章类似，其中要说的是过滤链的配置：OAuth的几个地址：/authorize、/accesstoken、/userInfo都是匿名可访问的。 &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;!--OAuth的几个地址：/authorize、/accesstoken、/userInfo都是匿名可访问的--&gt; &lt;value&gt; / = anon /login = authc /logout = logout /authorize=anon /accessToken=anon /userInfo=anon /** = user &lt;/value&gt; &lt;/property&gt; 测试： 首先模拟豆瓣向qq发起授权请求：http://localhost:8080/chapter17-server/authorize?client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee &amp; response_type=code &amp; redirect_uri=http://localhost:9080/chapter17-client/oauth2-login。 转发至登录页面，url仍是上面那个。 登录，提交至以上url进入login()验证，验证成功则重定向至redirect_uri（此时访问失败，因为还没有设置该url）并带上code。 重定向失败了先不管，先拿着code拿token：访问http://localhost:8080/chapter17-server/accessToken，post带上参数：client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee &amp; client_secret=d8346ea2-6017-43ed-ad68-19c0f971738b &amp; code=3569b277920280b33d6d86ded9022df8 &amp; grant_type=authorization_code。返回token（json格式）。 带上token去请求用户信息：http://localhost:8080/chapter17-server/authorize?client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee &amp; response_type=code &amp; redirect_uri=http://localhost:9080/chapter17-client/oauth2-login，返回用户名。 客户端 流程：豆瓣客户端在登录时选择请求QQ服务器端授权登录，成功后返回code给客户端，客户端使用该code去服务器端换取token。 依赖： &lt;dependency&gt; &lt;groupId&gt;org.apache.oltu.oauth2&lt;/groupId&gt; &lt;artifactId&gt;org.apache.oltu.oauth2.client&lt;/artifactId&gt; &lt;version&gt;0.31&lt;/version&gt; &lt;/dependency&gt; OAuth2Token类：用于存储OAuth2服务端返回的auth code；待会被login方法调用；实现了AuthenticationToken接口，它用于保存用户提交的信息，常用的实现类是UsernamePasswordToken。 public class OAuth2Token implements AuthenticationToken { private String authCode; //code private String principal; //username //构造方法 public OAuth2Token(String authCode) { this.authCode = authCode; } //getter @Override public String getPrincipal() { return principal; } @Override public Object getCredentials() { return authCode; } //setter ...... } OAuth2AuthenticationFilter: 过滤器，类似于FormAuthenticationFilter，控制OAuth2客户端的身份验证。 首先判断响应中是否包含error参数（除非重定向才会有响应），有则直接重定向到失败页面。 如果用户未身份验证且没有code，（若有code则是服务端授权之后返回的），则重定向到服务端进行授权； 如果未验证但有code，则调用executeLogin()进行登录（虽然服务端那边已经登录成功并拿到了code，但是客户端这边的Subject仍未登录，按第六章的说法，默认只有同线程的Subject是同一个，这里连应用都不是同一个），用code创建OAuth2Token提交给Subject登录。 登录成功回调onLoginSuccess()重定向到成功页面； 失败回调onLoginFailure()重定向到失败页面。 public class OAuth2AuthenticationFilter extends AuthenticatingFilter { //auth code参数名 private String authcCodeParam=&quot;code&quot;; private String clientId; //服务器端登录成功后重定向地址 private String redirectUrl; //失败后重定向地址 private String failureUrl; private String responseType=&quot;code&quot;; /** * @Author haien * @Description 用code创建OAuth2Token * @Date 2019/3/30 * @Param [request, response] * @return org.apache.shiro.authc.AuthenticationToken **/ @Override protected AuthenticationToken createToken(ServletRequest request, ServletResponse response) throws Exception{ HttpServletRequest httpRequest=(HttpServletRequest)request; String code=httpRequest.getParameter(authcCodeParam); return new OAuth2Token(code); } @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { return false; } /** * @Author haien * @Description 当访问拒绝时是否已经处理了，返回true表示需要继续处理， 否则直接返回即可。不知道什么情况下会被拒绝？ * @Date 2019/3/30 * @Param [request, response] * @return boolean **/ @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { String error=request.getParameter(&quot;error&quot;); String errorDescription=request.getParameter(&quot;error_description&quot;); //如果服务端返回了错误参数 if(!StringUtils.isEmpty(error)){ //重定向到失败页面 WebUtils.issueRedirect(request,response, failureUrl+&quot;?error=&quot;+error+&quot;error_description=&quot;+errorDescription); return false; } //判断用户是否已身份验证（记住我不算） Subject subject=getSubject(request,response); if(!subject.isAuthenticated()){ //如果用户未身份验证且没有code if(StringUtils.isEmpty(request.getParameter(authcCodeParam))){ //重定向到服务端授权 saveRequestAndRedirectToLogin(request,response); return false; } /*未身份验证但已经重定向到server端登录页面并成功登录拿到code （由于拿到code后OAuthresponse.buildQueryMessage()重定向回/oauth2-login 又触发该过滤器，因为server端和client端并不共享一个Subject，所以那边登录后 这边仍未登录），则执行父类的登录逻辑，它会调用createToken()用code创建 OAuth2Token并交给Subject.login()登录，login()将调用OAuth2Realm进行身份 验证；登录成功将回调onLoginSuccess()重定向到成功页面； 失败则onLoginFailure()重定向到失败页面*/ return executeLogin(request,response); } return false; } /** * @Author haien * @Description 登录成功后的回调方法，重定向到成功页面； 被上面executeLogin()调用 * @Date 2019/3/30 * @Param [token, subject, request, response] * @return boolean **/ @Override protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception { //把原先的url：/oauth2-login清空，跳转默认成功页面，不然又会触发过滤器， //而执行onAccessdeny()，这次直接返回false， //而给前端呈现了一个空白的/oauth2-login页面 WebUtils.getAndClearSavedRequest(request); issueSuccessRedirect(request,response); return false; } /** * @Author haien * @Description 登录失败后的回调；被上面executeLogin()调用 * @Date 2019/3/30 * @Param [token, e, request, response] * @return boolean **/ @Override protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException ae,ServletRequest request, ServletResponse response) { Subject subject=getSubject(request,response); //如果用户其实已登录过了 if(subject.isAuthenticated()||subject.isRemembered()){ //重定向到成功页面 try { issueSuccessRedirect(request,response); } catch (Exception e) { e.printStackTrace(); } } //如果用户未登录且目前登录失败 else { try { //重定向到失败页面 WebUtils.issueRedirect(request,response,failureUrl); } catch (IOException e) { e.printStackTrace(); } } return false; } } ShiroFilter： &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;http://localhost:8080/chapter17-server/authorize?client_id=c1ebe466-1cdc-4bd3-ab69-77c3561b9dee&amp;amp;response_type=code&amp;amp;redirect_uri=http://localhost:9080/chapter17-client/oauth2-login&quot;/&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;oauth2Authc&quot; value-ref=&quot;oAuth2AuthenticationFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; / = anon /oauth2Failure.jsp = anon /oauth2-login = oauth2Authc /logout = logout /** = user &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; loginUrl会自动设置到所有的AccessControllerFilter，包括OAuth2AuthenticationFilter。 /oauth2-login为服务端OAuth2授权起点，指定oauth2Authc过滤器。 测试： 访问http://localhost:9080/chapter17-client/，展示index.jsp登录页面，点击登录按钮，其url为/oauth2-login。 第一次触发OAuth2AuthenticationFilter，主要逻辑在onAccessDeny()中，它发现用户未登录，重定向到登录接口，按ShiroFilter设置的loginUrl，为http://localhost:8080/chapter17-server/authorize?带各参数，其中redirectUrl为/oauth2-login。 填写登录信息，提交server端AuthorizeController登录并带着code重定向到以上redirectUrl：/oauth2-login。 第二次又触发OAuth2AuthenticationFilter，在客户端执行login()登录一遍，其会调用OAuth2Realm中的extractUsername()拿着code去请求token进而请求userInfo获得username，封装进token，构造客户端的Subject； 登录成功，执行onLoginSuccess()，情况原本要访问的url：/oauth2-login，重定向到默认成功页面。 代码示例：ideaProjects/shiro-cahpter17 《跟我学shiro第十七章》","categories":[],"tags":[]},{"title":"","slug":"Shiro第十六章-综合实例，用户、角色、资源模型，配置文件详解","date":"2019-04-30T08:29:23.042Z","updated":"2019-03-28T09:38:20.633Z","comments":true,"path":"2019/04/30/Shiro第十六章-综合实例，用户、角色、资源模型，配置文件详解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十六章-综合实例，用户、角色、资源模型，配置文件详解/","excerpt":"","text":"系统功能 根据用户权限获取菜单集合，返回前端显示。当前只有admin/123456。 本系统实体包括用户、公司、资源和角色，在界面上可以对它们进行增删查改等。 比如，用户可以修改用户所属公司、拥有角色和资源、修改密码；公司可以移动子公司到其他公司旗下；资源可以修改资源所需权限、在父菜单下增删子菜单，角色可以修改用户可访问的资源。 下图为资源管理 在组织机构管理栏点击“添加子节点” 数据库设计 数据库：shiro2。所在会话：mysql。 用户表：organization_id：所属公司id，roles_ids:拥有角色id，用逗号连接成字符串。 角色表：role：英文名称，用于后台交互；description：中文名称，用于前端显示；resource_ids：能访问的资源id，用逗号连接成字符串。 资源表：type:资源类型，菜单和按钮，按钮实际为菜单的子菜单，为最低一级，当然菜单与菜单之间也有父子关系；parent_id:父菜单的id号；parent_ids：祖宗菜单链，从最顶级菜单的id开始排到父菜单，中间用/分隔，最后也用/结束；url:该资源对应的url；permission:访问该资源需要的权限；avaiable：是否可用。 公司：parent_id：父公司id；parent_ids:祖宗公司id，从顶级公司排到父公司，中间用/分隔，最后也用/结束；avaliable：是否经营中。 配置文件 注意：配置文件的class属性不能断开，否则视为类路径出错 resources.properties: 常量配置，包括DataSource的jdbc属性、数据连接池属性和shiro的密码加密算法，以备spring-config.xml引入。 #这里只列出加密算法属性 #shiro password.algorithmName=md5 password.hashIterations=2 spring-config-cache.xml：定义cache底层为ehcache，以备spring-config.xml注入。 &lt;bean id=&quot;springCacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehcacheManager&quot;/&gt; &lt;/bean&gt; &lt;!--ehcache--&gt; &lt;bean id=&quot;ehcacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;/bean&gt; ehcache.xml：与以前配置相同，不再赘述。 spring-mvc-shiro.xml: 定义aop切面，开启@RequriresPermissions注解进行权限控制。 &lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor .AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; spring-config-shiro.xml: shiro配置，包括缓存、会话、realm、ShiroFilter、SecurityManager，以下只列出重要的。 &lt;!-- Realm实现 --&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;com.haien.chapter16.realm.UserRealm&quot;&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt; &lt;property name=&quot;cachingEnabled&quot; value=&quot;false&quot;/&gt; &lt;!--&lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt;--&gt; &lt;!--&lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt;--&gt; &lt;!--&lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt;--&gt; &lt;!--&lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;sysUserFilter&quot; class=&quot;com.github.zhangkaitao.shiro.chapter16.web.shiro.filter.SysUserFilter&quot;/&gt; &lt;!-- Shiro的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login = authc /logout = logout /authenticated = authc /** = user,sysUser &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; UserRealm禁用了shiro自己的缓存，而启用自己的缓存，否则需要在修改用户信息时频繁清理缓存。 SysUserFilter：根据当前用户身份获取User信息放入request，便于后续获取。 spring-config.xml: 扫描要注册的bean、注入数据源、配置事务管理器、引入其他配置文件，方便在web.xml只定位这一个配置文件即可发现其他配置文件。 &lt;context:property-placeholder location=&quot;classpath:resources.properties&quot;/&gt; &lt;!-- 扫描注解Bean --&gt; &lt;context:component-scan base-package=&quot;com.haien.chapter16&quot;&gt; &lt;!--controller包的扫描交给MVC层的xml--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 开启AOP监听 只对当前配置文件有效 expose-proxy=&quot;true&quot;--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!-- 数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;${connection.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${connection.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${connection.password}&quot;/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${druid.initialSize}&quot;/&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${druid.minIdle}&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${druid.maxActive}&quot;/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${druid.maxWait}&quot;/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接， 单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;${druid.timeBetweenEvictionRunsMillis}&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;${druid.minEvictableIdleTimeMillis}&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;${druid.validationQuery}&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;${druid.testWhileIdle}&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;${druid.testOnBorrow}&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;${druid.testOnReturn}&quot; /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 如果用Oracle，则把poolPreparedStatements配置为true， mysql可以配置为false。--&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;${druid.poolPreparedStatements}&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;${druid.maxPoolPreparedStatementPerConnectionSize}&quot; /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=&quot;filters&quot; value=&quot;${druid.filters}&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;dataSourceProxy&quot; class=&quot;org.springframework.jdbc.datasource .TransactionAwareDataSourceProxy&quot;&gt; &lt;property name=&quot;targetDataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;constructor-arg ref=&quot;dataSourceProxy&quot;/&gt; &lt;/bean&gt; &lt;!--事务管理器配置--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource. DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceProxy&quot;/&gt; &lt;/bean&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--expose-proxy=&quot;true&quot;--&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;!-- 只对业务逻辑层实施事务 --&gt; &lt;!--匹配规则详见笔记：Spring基础概念--&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.haien .chapter16..service..*+.*(..))&quot;/&gt; &lt;aop:advisor id=&quot;txAdvisor&quot; advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt; &lt;/aop:config&gt; &lt;bean class=&quot;com.haien.chapter16.spring.SpringUtils&quot;/&gt; &lt;import resource=&quot;classpath:spring-config-cache.xml&quot;/&gt; &lt;import resource=&quot;classpath:spring-config-shiro.xml&quot;/&gt; controller层无权限会抛出UnauthorizationException，被全局异常处理器截获并返回unauthorized.jsp。 spring-mvc.xml：扫描controller类、引入spring-mvc-shiro.xml。 &lt;!--引入常量配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:resources.properties&quot;/&gt; &lt;!-- 开启controller注解支持 --&gt; &lt;context:component-scan base-package=&quot;com.haien.chapter16.web.controller&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--扫描全局异常处理类，否则改类不起作用--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation. ControllerAdvice&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--注册@CurrentUser参数解析器，用在IndexController中，从request中 获取shiro sysUser拦截器放入的当前登录User对象--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:argument-resolvers&gt; &lt;bean class=&quot;com.haien.chapter16.web.bind .method.CurrentUserMethodArgumentResolver&quot;/&gt; &lt;/mvc:argument-resolvers&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 当在web.xml中DispatcherServlet使用 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 映射时，能映射静态资源 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 静态资源映射 --&gt; &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/WEB-INF/static/&quot;/&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id=&quot;defaultViewResolver&quot; class=&quot;org.springframework.web.servlet.view. InternalResourceViewResolver&quot; p:order=&quot;1&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- 控制器异常处理 --&gt; &lt;bean id=&quot;exceptionHandlerExceptionResolver&quot; class=&quot;org.springframework.web.servlet.mvc.method.annotation .ExceptionHandlerExceptionResolver&quot;&gt; &lt;/bean&gt; &lt;bean class=&quot;com.haien.chapter16.web.exception.DefaultExceptionHandler&quot;/&gt; &lt;import resource=&quot;spring-mvc-shiro.xml&quot;/&gt; mvc:default-servlet-handler/：由于web.xml中DispatcherServlet使用/拦截all请求，会将静态资源的请求也拦截，导致找不到对应的controller处理，加上此标签会在SpringMvc上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，检查进入DispatcherServlet的url，发现是对静态资源的请求则将该请求转由web服务器默认的Servlet处理，不是则由DispatcherServlet继续处理。 一般web应用服务器默认的Servlet名为“default”，DefaultServletHttpRequestHandler可以找到它。但如果你所有的web服务器的默认Servlet名不是“default”，则需要通过default-servlet-name属性显式指定： &lt;mvc:default-servlet-handler default-servlet-name=&quot;所使用的Web服务器默认使用的Servlet名称&quot; /&gt; &lt;mvc:resources /&gt;：除此之外，还可以利用此标签明确匹配url和静态资源。 &lt;mvc:resources location=&quot;/,classpath:/META-INF/publicResources/&quot; mapping=&quot;/resources/**&quot;/&gt; 以上，将Web根路径（webapp）”/“及类路径下/META-INF/publicResources/ 的目录映射为/resources路径。假设Web根路径下拥有images、js这两个资源目录,在images下面有bg.gif图片，在js下面有test.js文件，则可以通过 /resources/images/bg.gif 和 /resources/js/test.js 访问这二个静态资源。 参考文章 web.xml：配置Spring监听器、shiro安全过滤器、Servlet编码过滤器、Dispatcherservlet分发器，以下只列出重要的。 &lt;!--加上这个可以在注册bean时切换bean作用域scope--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.request.RequestContextListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- shiro 安全过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;/filter-mapping&gt; REQUEST：指定被分发的请求种类，默认request，如果此次请求非request则不会走该过滤器，也就是不会被分发给controller处理。它必须写在filter-mapping的最后。取值： REQUEST：只要发起的请求是一次http请求，如某个url发起了一次get、post请求，或者发起相当于两次请求的重定向，那么就会走该过滤器。 FORWARD：请求是转发才走过滤器。 INCLUDE：只要是通过&lt;jsp:include page=”xxx.jsp” /&gt;嵌入进来的页面，每嵌入一个页面，都会走一次该过滤器。 ERROR：当触发了一次error时，就会走一次该过滤器。什么是触发error？比如我在web.xml中配置了，当后台返回400/404/500时，容器就会将请求转发到一下错误页面，这就触发了一次error。，走进了过滤器。虽然这是转发的过程，但是配置成FORWARD并不会走过滤器。 参考文章 &lt;error-page&gt; &lt;error-code&gt;400&lt;/error-code&gt; &lt;location&gt;/filter/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/filter/error.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/filter/error.jsp&lt;/location&gt; &lt;/error-page&gt; 用户验证链 使用基于表单的拦截器实现用户验证，自定义了UserRealm，重写其中doGetAuthenticationInfo()验证用户提交的表单信息是否与数据库匹配。 调用链从高级到低级： PathMatchingFilter.preHandle() AccessControlFilter.onPreHandle() FormAuthenticationFilter.onAccessDenied() DelegatingSubject.login() ModularRealmAuthenticator.doAuthenticate() UserRealm.doGetAuthenticationInfo() 也就是说FormAuthenticationFilter是会调用login()的，而login()又会调用Realm，所以FormAuthenticationFilter的登录验证是通过Realm实现的。 自定义注解+注解解析器+使用实例 @CurrentUser：自定义注解 /** * @Author haien * @Description 绑定当前登录的用户 * @Date 2019/3/14 **/ //测试此注解作用 @Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface CurrentUser { //Constants类CURRENT_USER常量=&quot;user&quot;， //因为当前登录用户在request中存为user属性， //所以将此注解用于方法参数，再定义一个解析器解析此注解： //获取此注解值并从request中查找属性赋给方法参数， //即实现了绑定当前用户到方法属性的功能。 String value() default Constants.CURRENT_USER; } CurrentUserMethodArgumentResolver：自定义注解解析器 public class CurrentUserMethodArgumentResolver implements HandlerMethodArgumentResolver { public CurrentUserMethodArgumentResolver() { } /** * @Author haien * @Description 判断参数是否受支持，依据是它是否拥有CurrentUser注解 * @Date 2019/3/14 * @Param [parameter] * @return boolean **/ @Override public boolean supportsParameter(MethodParameter parameter) { //判断参数是否被注解了 if(parameter.hasParameterAnnotation(CurrentUser.class)){ return true; } return false; } /** * @Author haien * @Description 对被注解参数的解析是： 获取当前登录对象并返回给此参数 * @Date 2019/3/14 * @Param [parameter, mavContainer, webRequest, binderFactory] * @return java.lang.Object **/ @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { CurrentUser currentUserAnnotation= parameter.getParameterAnnotation(CurrentUser.class); //currentUserAnnotation.value()返回“user”， //从request获取“user”属性 return webRequest.getAttribute(currentUserAnnotation.value(), NativeWebRequest.SCOPE_REQUEST); } } IndexController：使用注解 @RequestMapping(&quot;/&quot;) public String index(@CurrentUser User loginUser, Model model) { //@CurrentUser获取当前登录对象并赋给loginUser //根据用户名查询权限字符串 Set&lt;String&gt; permissions = userService.findPermissions(loginUser.getUsername()); //查询跟这些权限有关的菜单 List&lt;Resource&gt; menus = resourceService.findMenus(permissions); model.addAttribute(&quot;menus&quot;, menus); return &quot;index&quot;; } 使用Spring的Cache代替Shiro的Cache 因为shiro自己的cache每次都要手动清除缓存，才能防止修改后有获取到未更新的缓存，所以使用spring提供的cache，并连同shiro cache中一些较好的方法封装起来。 以前的shiro cache： &lt;!-- 缓存管理器 使用Ehcache实现 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;/bean&gt; 现在： //spring-config-cache.xml &lt;!--底层使用ehcache--&gt; &lt;bean id=&quot;ehcacheManager&quot; class=&quot;org.springframework.cache.ehcache. EhCacheManagerFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;/bean&gt; &lt;!--将=引入以上CacheManager--&gt; &lt;bean id=&quot;springCacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehcacheManager&quot;/&gt; &lt;/bean&gt; //spring-config-shiro.xml &lt;!-- 缓存管理器 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;com.haien.spring.SpringCacheManagerWrapper&quot;&gt; &lt;!--定义在spring-config-cache.xml中--&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;springCacheManager&quot;/&gt; &lt;/bean&gt; /** * @Author haien * @Description 包装Spring Cache，因为spring的cache没有shiro的cache那些功能， * 但又有其优点，所以给它封装一些shiro中比较好的方法进去。 * @Date 2019/3/16 **/ public class SpringCacheManagerWrapper implements CacheManager { private org.springframework.cache.CacheManager cacheManager; //由xml文件注入一个Spring框架的cache对象 public void setCacheManager(org.springframework.cache.CacheManager cacheManager){ this.cacheManager=cacheManager; } /** * @Author haien * @Description 获取注入进来的cache对象并封装成SpringCacheWrapper对象， * 其中就提供了shiro中较好的方法。 * @Date 2019/3/16 * @Param [name] * @return org.apache.shiro.cache.Cache&lt;K,V&gt; **/ @Override public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String name) throws CacheException { //获取上面setCacheManager() org.springframework.cache.Cache springCache=cacheManager.getCache(name); return new SpringCacheWrapper(springCache); } /** * @Author haien * @Description 内部类：继承shiro的Cache，重写了它的方法， 封装给当前类的springcache对象 * @Date 2019/3/16 **/ static class SpringCacheWrapper implements Cache{ //继承shiro的cache private org.springframework.cache.Cache springCache; SpringCacheWrapper(org.springframework.cache.Cache springCache) { this.springCache = springCache; } @Override public Object get(Object key) throws CacheException { Object value=springCache.get(key); if(value instanceof SimpleValueWrapper) return ((SimpleValueWrapper)value).get(); return value; } @Override public Object put(Object key, Object value) throws CacheException { springCache.put(key,value); return value; } @Override public Object remove(Object key) throws CacheException { springCache.evict(key); return null; } @Override public void clear() throws CacheException { springCache.clear(); } @Override public int size() { if(springCache.getNativeCache() instanceof Ehcache){ Ehcache ehcache=(Ehcache)springCache.getNativeCache(); return ehcache.getSize(); } throw new UnsupportedOperationException( &quot;invoke spring cache abstract size method not supported&quot;); } @Override public Set keys() { if(springCache.getNativeCache() instanceof Ehcache){ Ehcache ehcache=(Ehcache)springCache.getNativeCache(); return new HashSet(ehcache.getKeys()); } throw new UnsupportedOperationException( &quot;invoke spring caceh abstract keys method not supported&quot;); } @Override public Collection values() { if(springCache.getNativeCache() instanceof Ehcache){ Ehcache ehcache=(Ehcache)springCache.getNativeCache(); List keys=ehcache.getKeys(); if(!CollectionUtils.isEmpty(keys)){ List values=new ArrayList(keys.size()); for(Object key:keys){ Object value=get(key); if(value!=null) values.add(value); } return Collections.unmodifiableList(values); }else{ return Collections.emptyList(); } } throw new UnsupportedOperationException( &quot;invoke spring cache abstract values method not supported&quot;); } } } 参考文章 代码示例：ideaProjects/shiro-chapter16","categories":[],"tags":[]},{"title":"","slug":"Shiro第十九章-动态url权限控制、拦截器自定义","date":"2019-04-30T08:29:23.037Z","updated":"2019-04-28T07:42:48.466Z","comments":true,"path":"2019/04/30/Shiro第十九章-动态url权限控制、拦截器自定义/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十九章-动态url权限控制、拦截器自定义/","excerpt":"","text":"简介 即访问url时进行权限匹配，如果没有权限则直接跳到错误页面。 在Shiro中，更多的是通过AOP进行方法级别的权限控制，而通过url进行权限控制是一种集中的权限控制。 示例 拦截器：如authc、anon等字符串为一个拦截器；拦截器链：url=authc为一条拦截器链；拦截器链集合：url1=authc，url2=anon为拦截器链集合。 仿chapter16的示例，主要功能是用户、公司、角色和资源之间关系的调整，如修改用户所属公司、所有角色，资源所需权限、角色所有资源等。 数据库：除user、organization、role、resource外，新增一张url-filter表，映射url和角色、权限之间的关系（多个角色、权限之间用逗号分隔），即动态的拦截器链。 实体：多一个URLFilter类，封装url和权限、角色间的关系。 public class UrlFilter implements Serializable { private Long id; private String name; //url名称或描述 private String url; //地址 private String roles; //所需角色，可省略，用逗号分隔 private String permissions; //所需权限，可省略，用逗号分隔 //setter/getter } dao、service、controller层都增加对UrlFilter的增删查改。 controller层撤销shiro的权限注解，因为要用数据库中动态的拦截器链来实现。 因为数据库中的拦截器链都是要合并到shiro中的，所以在service层中，更新数据库拦截器链后，要重置shiro中的拦截器链集合，以同步此更新，否则更新不生效。比如： @Override public void deleteUrlFilter(Long urlFilterId) { urlFilterDao.deleteUrlFilter(urlFilterId); initFilterChain(); } /** * @Author haien * @Description 初始化Shiro的url拦截器，用于在url表改动后， 将数据库发送的改动同步到Shiro中。 * @Date 2019/4/5 * @Param [] * @return void **/ @PostConstruct //当DI容器实例化当前bean时，该方法会自动执行 public void initFilterChain() { //将配置文件和数据库的拦截器链合并 shiroFilerChainManager.initFilterChains(findAll()); //先清空集合再去加载 } ShiroFilterChainManager: 调用了FilterChainManager的方法，先清空拦截器链集合再重新加载。 @Service public class ShiroFilterChainManager { //过滤链管理器，管理所有过滤器，包含增删查改等操作 @Resource private DefaultFilterChainManager filterChainManager; //注入的是 //CustomDefaultFilterChainManager //默认过滤链，包含在配置文件中提到的所有过滤器 private Map&lt;String,NamedFilterList&gt; defaultFilterChains; /** * @Author haien * @Description 获取配置文件中all过滤器，之后会自动与数据库中包含的过滤器合并 * @Date 2019/4/5 * @Param [] * @return void **/ @PostConstruct //DI容器实例化该bean时自动执行该方法 public void inti(){ //获取配置文件中all拦截器（静态的，不会变） defaultFilterChains=new HashMap&lt;&gt;(filterChainManager.getFilterChains()); } /** * @Author haien * @Description 初始化过滤链，默认+数据库 * @Date 2019/4/5 * @Param [urlFilters] * @return void **/ public void initFilterChains(List&lt;UrlFilter&gt; urlFilters){ //1. 删除以前老的filter chain并注册默认的 filterChainManager.getFilterChains().clear(); if(defaultFilterChains!=null) filterChainManager.getFilterChains().putAll(defaultFilterChains); //2. 注册数据库中的 for(UrlFilter urlFilter:urlFilters){ String url=urlFilter.getUrl(); //注册roles-filter关系的过滤器 if(!StringUtils.isEmpty(urlFilter.getRoles())) filterChainManager.addToChain(url,&quot;roles&quot;,urlFilter.getRoles()); //注册perms-filter关系的拦截器 if(!StringUtils.isEmpty(urlFilter.getPermissions())) filterChainManager.addToChain(url,&quot;perms&quot;,urlFilter.getPermissions()); } } } 为了实现本例功能，加载数据库中动态的拦截器链，我们需要自定义FilterChainManager；而为了实现一个url匹配多个拦截器链，我们还要自定义FilterChainResolver。下面先介绍一下这俩都是什么。 PathMatchingFilterChainResolver过滤链解析器 按照第八章过滤链步骤，第一步是要先根据当前请求的url获取拦截器链。 PathMatchingFilterChainResolver：遍历配置文件中all拦截器链，如，/=athc，将其名字/与当前url/index比对，匹配则执行该拦截器链，如，/**匹配/index。所以，如果要改变url的拦截器匹配方法，则要自定义Resolver。 public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) { //1、首先获取拦截器链管理器 FilterChainManager filterChainManager = getFilterChainManager(); if (!filterChainManager.hasChains()) { return null; } //2、接着获取当前请求的URL（不带上下文） String requestURI = getPathWithinApplication(request); //3、遍历配置文件中all拦截器链（拦截器链的名字就是URL，如/**） for (String pathPattern : filterChainManager.getChainNames()) { //4、如匹配当前url if (pathMatches(pathPattern, requestURI)) { //5、和原始拦截器链进行合并后返回 return filterChainManager.proxy(originalChain, pathPattern); } } return null; } 缺点：最后一步找到即返回，如果后面还有其他拦截器也是匹配当url的呢？后面我们会自定义一个能将all拦截器链合并返回的解析器。 第1步中，默认使用DefaultFilterChainManager管理拦截器链，其内部采用Map管理url-拦截器链的关系，因为Map不可重复，所以每个url只能配置一条拦截器链（但可以包含多个拦截器），如果定义了多条则最终采用哪条也说不定。 FilterChainManager接口：主要功能是注册拦截器链、添加拦截器以及对原始拦截器链生成代理之后的拦截器链。如果要实现动态url-拦截器配置，即注册数据库中定义的拦截器链的话，就要自定义Manager。 public interface FilterChainManager { Map&lt;String, Filter&gt; getFilters(); //得到注册的拦截器 void addFilter(String name, Filter filter); //注册拦截器 void addFilter(String name, Filter filter, boolean init); //注册拦截器 //根据拦截器链定义创建拦截器链 void createChain(String chainName, String chainDefinition); void addToChain(String chainName, String filterName); //添加拦截器到指定的拦截器链 //添加拦截器（带配置，指明所需权限或角色）到指定的拦截器链 void addToChain(String chainName, String filterName, String chainSpecificFilterConfig) throws ConfigurationException; NamedFilterList getChain(String chainName); //获取拦截器链 boolean hasChains(); //是否有拦截器链 Set&lt;String&gt; getChainNames(); //得到所有拦截器链的名字 //使用指定的拦截器链代理原始拦截器链 FilterChain proxy(FilterChain original, String chainName); } 解析以下配置文件：filters定义了拦截器，filterChainDefinitions定义了拦截器链，/login为拦截器链名字，user,sysUser是拦截器名字。 &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; …… &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login = authc /logout = logout /authenticated = authc /** = user,sysUser &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 前面说过PathMatchingFilterChainResolver和DefaultFilterChainManager不能满足我们的需求，我们稍微扩展一下。 CustomPathMatchingFilterChainResolver：本例自定义的Resolver;返回匹配当前url的多条拦截器链，默认的只能返回第一条。 public class CustomPathMatchingFilterChainResolver extends PathMatchingFilterChainResolver { //继承自默认解析器 private CustomDefaultFilterChainManager customDefaultFilterChainManager; //Manager setter public void setCustomDefaultFilterChainManager( CustomDefaultFilterChainManager customDefaultFilterChainManager) { this.customDefaultFilterChainManager = customDefaultFilterChainManager; setFilterChainManager(customDefaultFilterChainManager); } //为当前url匹配拦截器链，匹配多条，而不是遇到一条就返回 @Override public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) { FilterChainManager filterChainManager = getFilterChainManager(); if (!filterChainManager.hasChains()) { return null; } //遍历配置文件all拦截器链 String requestURI = getPathWithinApplication(request); List&lt;String&gt; chainNames = new ArrayList&lt;String&gt;(); //拦截器链集合 for (String pathPattern : filterChainManager.getChainNames()) { if (pathMatches(pathPattern, requestURI)) { //遇到匹配的不急着返回，而是添加到集合 chainNames.add(pathPattern); } } //集合为空则返回null if(chainNames.size() == 0) { return null; } return customDefaultFilterChainManager.proxy(originalChain, chainNames); } } CustomDefaultFilterChainManager：本例自定义的Manager；主要是改变注册拦截器链的方式，比如说吧数据库中的合并进来。 public class CustomDefaultFilterChainManager extends DefaultFilterChainManager { //配置文件中all拦截器链，即默认的静态拦截器链，会与数据库中动态的拦截器链合并 private Map&lt;String, String&gt; filterChainDefinitionMap = null; //登录地址 private String loginUrl; //登录成功后默认跳转地址 private String successUrl; //未授权跳转地址 private String unauthorizedUrl; public CustomDefaultFilterChainManager() { //调用父类方法，注册默认拦截器 setFilters(new LinkedHashMap&lt;String, Filter&gt;()); //注册默认拦截器链 setFilterChains(new LinkedHashMap&lt;String, NamedFilterList&gt;()); addDefaultFilters(true); } //省略setter //注册我们自定义的拦截器，相当于ShiroFilterFactoryBean的filters属性 //只要是我们在配置文件中声明注册bean的，不管shiro本身提供的还是我们自定义的拦截器， //都算自定义拦截器 public void setCustomFilters(Map&lt;String, Filter&gt; customFilters) { for(Map.Entry&lt;String, Filter&gt; entry : customFilters.entrySet()) { addFilter(entry.getKey(), entry.getValue(), false); } } //解析配置文件中all拦截器链，相当于ShiroFilterFactoryBean的filterChainDefinitions public void setDefaultFilterChainDefinitions(String definitions) { Ini ini = new Ini(); ini.load(definitions); Ini.Section section = ini.getSection(IniFilterChainResolverFactory.URLS); if (CollectionUtils.isEmpty(section)) { section = ini.getSection(Ini.DEFAULT_SECTION_NAME); } setFilterChainDefinitionMap(section); } @PostConstruct //Spring容器启动时自动调用 public void init() { ////给拦截器配置上属性，这里是三个url Map&lt;String, Filter&gt; filters = getFilters(); if (!CollectionUtils.isEmpty(filters)) { //判空 //注册拦截器 for (Map.Entry&lt;String, Filter&gt; entry : filters.entrySet()) { String name = entry.getKey(); //拦截器名 Filter filter = entry.getValue(); //配置，即角色或权限 applyGlobalPropertiesIfNecessary(filter); //给拦截器设置三个url if (filter instanceof Nameable) { ((Nameable) filter).setName(name); } addFilter(name, filter, false); } } //将拦截器构建成拦截器链 Map&lt;String, String&gt; chains = getFilterChainDefinitionMap(); if (!CollectionUtils.isEmpty(chains)) { //判空 for (Map.Entry&lt;String, String&gt; entry : chains.entrySet()) { String url = entry.getKey(); //如，/** String chainDefinition = entry.getValue(); //如，authc,user createChain(url, chainDefinition); //创建过滤器链 } } } protected void initFilter(Filter filter) { //ignore，因为交给Spring管理了，因此Filter的相关配置会在Spring配置中完成 } //组合多个拦截器链为一个新的FilterChain代理 public FilterChain proxy(FilterChain original, List&lt;String&gt; chainNames) { //chainNames中的元素，如，/index、/** NamedFilterList configured = new SimpleNamedFilterList(chainNames.toString()); //遍历过滤器链名，找到对应的过滤器链，添加到集合 for(String chainName : chainNames) { configured.addAll(getChain(chainName)); } //再和原始的过滤器链合并 return configured.proxy(original); } private void applyGlobalPropertiesIfNecessary(Filter filter) { applyLoginUrlIfNecessary(filter); applySuccessUrlIfNecessary(filter); applyUnauthorizedUrlIfNecessary(filter); } private void applyLoginUrlIfNecessary(Filter filter) { ...配置loginUrl... } private void applySuccessUrlIfNecessary(Filter filter) { ...配置SuccessUrl... } private void applyUnauthorizedUrlIfNecessary(Filter filter) { ...配置UnauthorizedUrl... } } spring-config-shiro.xml: 其中拦截器链的配置较特别。 &lt;!-- 基于Form表单的身份验证过滤器 --&gt; &lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sysUserFilter&quot; class=&quot;com.haien.chapter16.web.shiro.filter.SysUserFilter&quot;/&gt; &lt;!--自定义的拦截器链管理器，要添加数据库中动态的拦截器链就必须自定义--&gt; &lt;bean id=&quot;filterChainManager&quot; class=&quot;com.haien.chapter19.service.impl.CustomDefaultFilterChainManager&quot;&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt; &lt;property name=&quot;customFilters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login = authc /logout = logout /authenticated = authc /** = user,sysUser &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--拦截器链解析器，为当前url匹配多条拦截器链；注入以上管理器--&gt; &lt;bean id=&quot;filterChainResolver&quot; class=&quot;com.haien.chapter19.service.impl.CustomPathMatchingFilterChainResolver&quot;&gt; &lt;property name=&quot;customDefaultFilterChainManager&quot; ref=&quot;filterChainManager&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!--拦截器链配置已被拦截器链管理器代劳 &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login = authc /logout = logout /authenticated = authc /** = user,sysUser &lt;/value&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; &lt;!--最后把filterChainResolver设置给ShiroFilter，其使用它进行动态url动态控制--&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt; &lt;property name=&quot;targetObject&quot; ref=&quot;shiroFilter&quot;/&gt; &lt;property name=&quot;targetMethod&quot; ref=&quot;setFilterChainResolver&quot;/&gt; &lt;property name=&quot;arguments&quot; ref=&quot;filterChainResolver&quot;/&gt; &lt;/bean&gt; 测试： 访问/urlFilter； 跳转登录页面，登录后点击新增，增加以下拦截器链： 不用分配任何权限。 再访问/user则要求用户拥有aa角色，因此跳转未授权页面。 在数据库中将aa角色添加给用户，再访问/user则可以访问了。 代码实例：ideaProjects/shiro-chapter19 《跟我学Shiro》","categories":[],"tags":[]},{"title":"","slug":"Shiro第十二章-与Spring集成、配置文件初解","date":"2019-04-30T08:29:23.032Z","updated":"2019-03-07T07:33:21.731Z","comments":true,"path":"2019/04/30/Shiro第十二章-与Spring集成、配置文件初解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十二章-与Spring集成、配置文件初解/","excerpt":"","text":"简介 Shiro的组件都是Javabean/pojo式的组件，所以非常容易使用Spring进行组件管理,可以非常方便得从ini配置转为Spring配置（如xml配置文件）。 JavaSE 依赖 &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--集成Spring做测试必备的依赖，比如要注入Spring容器中的bean--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--用于开启事务，否则测试将无法自动回滚--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--使用quartz要用到的--&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql数据库及druid连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;0.2.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--使用JdbcTemplate，方便数据库操作--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; spring-shiro.xml：取代ini配置，提供了普通JavaSE应用的Spring配置。 &lt;!-- 缓存管理器 使用Ehcache实现 --&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 凭证匹配器 --&gt; &lt;bean id=&quot;credentialsMatcher&quot; class=&quot; com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher&quot;&gt; &lt;constructor-arg ref=&quot;cacheManager&quot;/&gt; &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot;/&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- Realm实现 --&gt; &lt;bean id=&quot;userRealm&quot; class=&quot;com.github.zhangkaitao.shiro.chapter12.realm.UserRealm&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;/&gt; &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;/&gt; &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;/&gt; &lt;/bean&gt; &lt;!-- 会话ID生成器 --&gt; &lt;bean id=&quot;sessionIdGenerator&quot; class=&quot;org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator&quot;/&gt; &lt;!-- 会话DAO --&gt; &lt;bean id=&quot;sessionDAO&quot; class=&quot;org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO&quot;&gt; &lt;property name=&quot;activeSessionsCacheName&quot; value=&quot;shiro-activeSessionCache&quot;/&gt; &lt;property name=&quot;sessionIdGenerator&quot; ref=&quot;sessionIdGenerator&quot;/&gt; &lt;/bean&gt; &lt;!-- 会话验证调度器 --&gt; &lt;bean id=&quot;sessionValidationScheduler&quot; class=&quot;org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler&quot;&gt; &lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 会话管理器 --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.session.mgt.DefaultSessionManager&quot;&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt; &lt;/bean&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.mgt.DefaultSecurityManager&quot;&gt; &lt;property name=&quot;realms&quot;&gt; &lt;list&gt;&lt;ref bean=&quot;userRealm&quot;/&gt;&lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 相当于调用SecurityUtils.setSecurityManager(securityManager) --&gt; &lt;bean class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt; &lt;property name=&quot;staticMethod&quot; value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;/&gt; &lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro生命周期处理器--&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; 其中，Realm实现需要注入userService的bean，它不在本配置文件，而在以下spring-beans.xml中，一样可以找到的。 spring-beans.xml &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/shiro&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;!-- Base DAO: abstract=&quot;true&quot;即该类不能被实例化，默认false；抽象bean可以不映射任何类 --&gt; &lt;bean id=&quot;baseDao&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- DAO --&gt; &lt;bean id=&quot;permissionDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.PermissionDaoImpl&quot; parent=&quot;baseDao&quot;/&gt; &lt;bean id=&quot;roleDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.RoleDaoImpl&quot; parent=&quot;baseDao&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.UserDaoImpl&quot; parent=&quot;baseDao&quot;/&gt; &lt;!-- Service --&gt; &lt;bean id=&quot;permissionService&quot; class=&quot;com.haien.shirochapter12.service.impl.PermissionServiceImpl&quot;&gt; &lt;property name=&quot;permissionDao&quot; ref=&quot;permissionDao&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;roleService&quot; class=&quot;com.haien.shirochapter12.service.impl.RoleServiceImpl&quot;&gt; &lt;property name=&quot;roleDao&quot; ref=&quot;roleDao&quot;/&gt; &lt;/bean&gt; &lt;!--帮助加密密码--&gt; &lt;bean id=&quot;passwordHelper&quot; class=&quot;com.haien.shirochapter12.service.impl.PasswordHelper&quot;&gt; &lt;property name=&quot;algorithmName&quot; value=&quot;md5&quot;/&gt; &lt;property name=&quot;hashIterations&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.haien.shirochapter12.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;property name=&quot;passwordHelper&quot; ref=&quot;passwordHelper&quot;/&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!--开启事务--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 分别写User,Role,Permission的entity,dao,service层、实现身份验证和授权的UserRealm。 ShiroTest：测试类，测试前删除各表数据，重新插入，分配角色和用户给用户；主要测试方法则是以某个用户登录，判断是否拥有权限。 @Test public void test() { Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(u1.getUsername(), password); subject.login(token); Assert.assertTrue(subject.isAuthenticated()); subject.checkRole(&quot;admin&quot;); subject.checkPermission(&quot;user:create&quot;); userService.changePassword(u1.getId(), password + &quot;1&quot;); userRealm.clearCache(subject.getPrincipals()); token = new UsernamePasswordToken(u1.getUsername(), password + &quot;1&quot;); subject.login(token); } web应用 spring-shiro-web.xml:web应用和JavaSE应用的shiro配置是类似的，此处提供一些不一样的配置. &lt;!-- web:会话Cookie模板 --&gt; &lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt; &lt;!--设置cookie名，默认为JSESSIONID--&gt; &lt;constructor-arg value=&quot;sid&quot;/&gt; &lt;!--设置cookie过期时间，单位秒，默认-1，即关闭浏览器时过期--&gt; &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;/&gt; &lt;!--true表示客户端不会暴露脚本代码，有助于减少某些类型的跨站点脚本攻击， Servlet2.5及以上才支持--&gt; &lt;property name=&quot;maxAge&quot; value=&quot;180000&quot;/&gt; &lt;/bean&gt; &lt;!-- web:会话管理器，使用用于web环境的DefaultWebSessionManager --&gt; &lt;bean id=&quot;sessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt; &lt;!--自己管理--&gt; &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot;/&gt; &lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionValidationScheduler&quot; ref=&quot;sessionValidationScheduler&quot;/&gt; &lt;property name=&quot;sessionDAO&quot; ref=&quot;sessionDAO&quot;/&gt; &lt;property name=&quot;sessionIdCookieEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot;/&gt; &lt;/bean&gt; &lt;!-- web:安全管理器，使用用于web环境的DefaultWebSecurityManager --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;userRealm&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;/bean&gt; &lt;!-- web:基于Form表单的身份验证过滤器 --&gt; &lt;bean id=&quot;formAuthenticationFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot;&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- web:Shiro的Web过滤器，使用ShiroFilterFactoryBean创建ShiroFilter过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;/&gt; &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt; &lt;!--定义自己的过滤器--&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /index.jsp = anon /unauthorized.jsp = anon /login.jsp = authc /logout = logout /** = user &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 会话管理器和安全管理器都要换成web环境下的，还要加个过滤器。 过滤器使用ShiroFilterFactoryBean来创建ShiroFilter过滤器，filters属性用于定义自己的过滤器，即ini配置中的[filters]，filterChianDefinitions用于声明url和filter的关系，即ini配置中的[urls]。 web.xml: &lt;!-- Spring配置文件开始 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:spring-beans.xml, classpath:spring-shiro-web.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring配置文件结束 --&gt; &lt;!-- shiro 安全过滤器 --&gt; &lt;!-- The filter-name matches name of a &apos;shiroFilter&apos; bean inside applicationContext.xml --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; DelegatingFilterProxy:自动到Spring容器中查找名为shiroFilter的bean（它就定义在spring-shiro-web.xml中），并把filter请求交给它处理。 spring-mvc.xml: &lt;!--use-default-filters：使用默认过滤器，它会扫描包含@Service、@Component、 @Repository、@Controller注解的类；不使用则需用include-filter指定扫描哪些类--&gt; &lt;context:component-scan base-package=&quot;com.haien.shirochapter12.web&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--指定只扫描base-package下有@Controller的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--指定只扫描base-package下有@ControllerAdvice的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--添加shiro spring aop权限注解的支持，即使用注解式授权--&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt;&lt;/aop:config&gt; &lt;!--表示使用代理类--&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor .AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; &lt;!--启动SpringMvc注解功能，完成请求和注解controller类的映射--&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; &lt;!--url映射视图，无需通过控制器--&gt; &lt;!-- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id=&quot;defaultViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!-- 控制器异常处理（好像不写也可以） --&gt; &lt;bean id=&quot;exceptionHandlerExceptionResolver&quot; class=&quot;org.springframework.web.servlet .mvc.method.annotation.ExceptionHandlerExceptionResolver&quot;&gt; &lt;/bean&gt; &lt;bean class=&quot;com.haien.shirochapter12.web.exception.DefaultExceptionHandler&quot;/&gt; AnnotationController：上面开启了Shiro注解式访问控制，那么接下来就可以在Controller中使用注解 @Controller public class AnnotationController { @RequestMapping(&quot;/hello1&quot;) public String hello1() { SecurityUtils.getSubject().checkRole(&quot;admin&quot;); return &quot;success&quot;; } @RequiresRoles(&quot;admin&quot;) @RequestMapping(&quot;/hello2&quot;) public String hello2() { return &quot;success&quot;; } } DefaultExceptionHandler：全局异常处理，无权限则返回unauthorized.jsp页面，提示用户无权限。目前数据库只有zhang/123拥有权限，其他如li/123都没有权限。 @ControllerAdvice public class DefaultExceptionHandler { @ExceptionHandler({UnauthorizedException.class}) //处理controller抛出的该类异常及其子类 @ResponseStatus(HttpStatus.UNAUTHORIZED) public ModelAndView processUnauthenticatedException(NativeWebRequest request ,UnauthorizedException e){ ModelAndView mv=new ModelAndView(); mv.addObject(&quot;exception&quot;,e); mv.setViewName(&quot;unauthorized&quot;); return mv; } } 代码示例：ideaProjects/shirochapter12 《跟我学shiro第十二章》","categories":[],"tags":[]},{"title":"","slug":"Shiro第十八章-并发登录人数控制","date":"2019-04-30T08:29:23.029Z","updated":"2019-04-05T06:38:08.833Z","comments":true,"path":"2019/04/30/Shiro第十八章-并发登录人数控制/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第十八章-并发登录人数控制/","excerpt":"","text":"简介 在某些项目中，一个账户可能只允许一人登录或几个人同时登录，当超过人数时，要么进制后者登录，要么踢出前者登录。 Spring Security直接提供了相应的功能。 Shiro没有提供默认实现，但自己添加也是很容易的。 示例 采用第十六章的示例，主要功能是用户、公司、角色和资源之间关系的调整，如修改用户所属公司、所有角色，资源所需权限、角色所有资源等。 目的：添加登录人数限制功能。 KickoutSessionControlFilter：控制登录人数的过滤器。 public class KickoutSessionControllerFilter extends AccessControlFilter { //踢出后重定向的地址 private String kickoutUrl; //是否踢出之后登录的用户，默认false，即踢出之前登录的而用户 private boolean kickoutAfter=false; //同一账号最大会话数，默认1 private int maxSession=1; //根据会话id，获取会话进行踢出操作 private SessionManager sessionManager; //使用cacheManager获取相应cache来缓存用户登录的会话，用于保存用户-会话之间的关系 private Cache&lt;String,Deque&lt;Serializable&gt;&gt; cache; @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return false; } public void setCacheManager(CacheManager cacheManager) { //根据name获取cache实例，没有则新建一个 this.cache = cacheManager.getCache(&quot;shiro-kickout-session&quot;); } //其他setter @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { Subject subject=getSubject(request,response); //如果未登录，则直接进行之后的流程 if(!subject.isAuthenticated()&amp;&amp;!subject.isRemembered()) return true; //打断点，看到底和false什么区别！！！ Session session=subject.getSession(); Serializable sessionId=session.getId(); String username=(String)subject.getPrincipal(); //获取之前登录者队列 Deque&lt;Serializable&gt; deque=cache.get(username); //若有多人登录， //则查询key为username的一条目，其value为包含多个会话的队列 if(deque==null){ deque=new LinkedList&lt;&gt;(); //第一次暂时存储了一个空队列进去，但下一个if将放入会话， //所以第一次存储了一个包含自身会话的队列 cache.put(username,deque); //存储时键为username，值为之前登录者会话队列 } //如果队列里没有此sessionId，且用户没有被踢出，则放入队列 if(!deque.contains(sessionId) &amp;&amp; session.getAttribute(&quot;kickout&quot;)==null) deque.push(sessionId); //插入队头，而队列的引用放在cache中，相当于缓存会话 //如果队列里的会话数超出最大值，则开始踢人 while (deque.size()&gt;maxSession){ //用if应该就可以，顶多加入当前用户即超出限制 //要被踢的sessionId Serializable kickoutSessionId=null; //如果规定踢出后者 if(kickoutAfter) kickoutSessionId=deque.removeFirst(); //弹出首元素，此处为最后进去的元素 //否则踢出前者 else kickoutSessionId=deque.removeLast(); //弹出尾元素 try { //根据session id获取session Session kickoutSession = sessionManager .getSession(new DefaultSessionKey(kickoutSessionId)); if (kickoutSession != null) //设置会话的kickout属性表示被踢出 kickoutSession.setAttribute(&quot;kickout&quot;, true); } catch (Exception e){ //ignore } } //如果当前会话不幸在上面while中被踢出了，则注销并重定向到踢出后的地址； //但如果踢出的是其他会话，那么需要刷新，它才会被强制登出 if(session.getAttribute(&quot;kickout&quot;)!=null){ try { subject.logout(); } catch (Exception e){ //ignore } saveRequest(request); //保存当前请求 WebUtils.issueRedirect(request,response,kickoutUrl); //返回login页面 return false; } return true; } } ehcache.xml：设置用于存放会话的缓存shiro-kickout-session。 &lt;cache name=&quot;shiro-kickout-session&quot; maxEntriesLocalHeap=&quot;2000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;3600&quot; timeToLiveSeconds=&quot;0&quot; overflowToDisk=&quot;false&quot; statistics=&quot;true&quot;&gt; &lt;/cache&gt; spring-config-shiro.xml: 注册过滤器。 &lt;!--控制并发登录人数的过滤器--&gt; &lt;bean id=&quot;kickoutSessionControllerFilter&quot; class=&quot;com.haien.chapter18.web.shiro.filter.KickoutSessionControllerFilter&quot;&gt; &lt;!--使用cacheManager获取相应cache来缓存用户登录的会话， 用于保存用户-会话之间的关系--&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;!--用于根据会话id，获取会话进行踢出操作--&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;!--是否踢出后来登录的，默认false--&gt; &lt;property name=&quot;kickoutAfter&quot; value=&quot;false&quot;/&gt; &lt;!--同一个用户最大会话数，默认1，即只能一人登录--&gt; &lt;property name=&quot;maxSession&quot; value=&quot;2&quot;/&gt; &lt;!--被踢出后重定向到的地址--&gt; &lt;property name=&quot;kickoutUrl&quot; value=&quot;/login?kickout=1&quot;/&gt; &lt;/bean&gt; &lt;!-- Shiro的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;formAuthenticationFilter&quot;/&gt; &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt; &lt;entry key=&quot;kickout&quot; value-ref=&quot;kickoutSessionControllerFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login = authc /logout = logout /authenticated = authc /** = kickout,user,sysUser &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 测试：本例设置maxSession=2，所以需要打开3个浏览器，分别访问localhost:8080/chapter18进行登录，然后刷新第一次登录的浏览器，将会被强制退出返回登录页面。 《跟我学Shiro》第十八章 代码示例：ideaProjects/shiro-chapter18","categories":[],"tags":[]},{"title":"","slug":"Shiro第三章一-授权流程","date":"2019-04-30T08:29:23.026Z","updated":"2019-03-14T08:09:57.313Z","comments":true,"path":"2019/04/30/Shiro第三章一-授权流程/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第三章一-授权流程/","excerpt":"","text":"简介 授权，也叫控制访问。关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。 角色：权限的集合，一般情况下我们会赋予用户角色而不是权限。 Shiro支持粗粒度（角色级别访问控制）和细粒度（权限级别）权限。 隐式角色：直接通过角色来验证用户有没有操作权限，粒度较粗，是以角色为单位进行访问控制的。如果有一天不允许总监这一角色使用打印机了，需要在逻辑代码中将总监去掉，不允许他做的事越多，代码修改量越大。（基于角色的控制访问） 显式角色：通过权限来验证用户有没有操作权限，假设哪个角色不能访问某个资源，只需要从角色的权限集合中移除某个权限即可，无需多处修改代码。（基于资源的控制访问） 授权方式 Shiro支持三种方式的授权：编程式、注解式和JSP/GSP标签。 编程式：写if/esle代码块；常用 Subject subject=SecurityUtils.getSubject(); if(subject.hasRole(&quot;admin&quot;)){ //有权限 }else{ //无权限 } 注解式：在方法上加注解（一般在controller上），没有权限将抛UnauthorizedException异常 @RequiresRoles({&quot;admin&quot;,&quot;user&quot;},logical=logical.AND) public void hello() { //有权限 } @RequiresPermissions (value={“user:a”, “user:b”}, logical= Logical.OR) @RequiresAuthentication //必须通过login登录 @RequiresUser //必须已登录（身份验证或记住我） @RequiresGuest //未登录，游客 JSP/GSP标签：在JSP/GSP页面加标签 &lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;!— 有权限 —&gt; &lt;/shiro:hasRole&gt; 基于角色的访问控制（隐式角色） shiro-role.ini：配置用户拥有的角色 [users] zhang=123,role1,role2 wang=123,role1 BaseTest：抽象化一些常用测试方法 public abstract class BaseTest { /** * @Author haien * @Description protected:只能被本类及其子类、本包的方法访问 * @Date 2019/2/18 * @Param [configFile, username, password] * @return void **/ protected void login(String configFile,String username,String password){ //1、获取SecurityManager工厂 Factory&lt;SecurityManager&gt; factory=new IniSecurityManagerFactory(configFile); //2、得到SecurityManager实例，并绑定给SecurityUtils SecurityManager securityManager=factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名、密码身份凭证Token Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken token=new UsernamePasswordToken(username,password); subject.login(token); } public Subject subject(){ return SecurityUtils.getSubject(); } @After public void tearDown() throws Exception{ ThreadContext.unbindSubject(); //退出时解除绑定Subject到线程，否则对下次测试造成影响 } } RoleTest：测试Subject判断用户角色方法 public class RoleTest extends BaseTest{ @Test public void testHasRole(){ //zhang拥有role1、role2 login(&quot;classpath:config/shiro-role.ini&quot;,&quot;zhang&quot;,&quot;123&quot;); //判断是否拥有角色：role1 Assert.assertTrue(subject().hasRole(&quot;role1&quot;)); //role1、role2 Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;,&quot;role2&quot;))); //role1、role2和!role3 boolean[] result=subject().hasRoles(Arrays.asList(&quot;role1&quot;,&quot;role2&quot;,&quot;role3&quot;)); Assert.assertEquals(true,result[0]); Assert.assertEquals(true,result[1]); Assert.assertEquals(false,result[2]); } @Test(expected = UnauthorizedException.class) public void testCheckRole(){ login(&quot;classpath:config/shiro-role.ini&quot;,&quot;zhang&quot;,&quot;123&quot;); //断言拥有角色role1 subject().checkRole(&quot;role1&quot;); //断言拥有角色role1.role3，失败抛异常 subject().checkRoles(&quot;role1&quot;,&quot;role3&quot;); } } Subject并没有提供hasAnyRole() checkRole()和hasRole()的区别是它在判断为假的情况下会抛UnauthorizedException异常基于资源的访问控制（显式角色） shiro-permission.ini ;首先根据用户名找到角色 [users] zhang=123,role1,role2 wang=123,role1 ;再根据角色找到权限 [roles] ;角色=权限1，权限2 role1=user:create,user:update role2=user:create,user:delete PermissionTest:测试细粒度的授权 public class PermissionTest extends BaseTest{ @Test public void testIsPermitted(){ login(&quot;classpath:config/shiro-permission.ini&quot;,&quot;zhang&quot;,&quot;123&quot;); //判断拥有权限user:create Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;)); //user:update and user:delete Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;,&quot;user:delete&quot;)); //!user:view Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;)); } @Test(expected = UnauthorizedException.class) public void testCheckPermission(){ login(&quot;classpath:config/shiro-permission.ini&quot;,&quot;zhang&quot;,&quot;123&quot;); //user:create subject().checkPermission(&quot;user:create&quot;); //user:create and user:update subject().checkPermissions(&quot;user:create&quot;,&quot;user:update&quot;); //!user:view,失败抛异常 subject().checkPermissions(&quot;user:view&quot;); } } 没有isPermittedAny() 权限书写规范 规则————资源标识符:操作:对象实例id，即对哪个资源的哪个实例可以进行什么操作。 支持通配符：“:”表示资源、操作和实例之间的分隔，“,”表示操作之间的分隔，“*”表示任意资源、操作或实例。 单个资源单个权限 //用户拥有system:user资源的update权限 subject().checkPermissions(&quot;system:user:update&quot;); 单个资源多个权限 role4=system:user:update,system:user:delete //or role4=&quot;system:user:update,delete&quot; //然后通过如下代码判断 subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;); //or subject().checkPermissions(&quot;system:user:update,delete&quot;); 以上四行代码随意搭配都可 单个资源全部权限 //推荐 role52=system:user:* //or role53=system:user //然后通过以下代码判断 subject().checkPermissions(&quot;system:user:*&quot;); subject().checkPermissions(&quot;system:user&quot;); 所有资源某一权限 //用户拥有所有资源的view权限 role61=*:view subject().checkPermissions(&quot;user:view&quot;); //假设权限是system:user:view,则写法为 role5=*:*:view 前缀匹配：前缀对了就能匹配任意特例 user等价于user:*、user:*:* user:view等价于user:view:* 没有后缀匹配 *:view不能匹配system:user:view *:*:view才能匹配system:user:view 性能问题：通配符陪陪方式比字符串相等匹配方式更复杂，需要花费更多时间。WildcardPermission wildcard:通配符 以下两种方式是等价的 subject().checkPermission(&quot;menu:view:1&quot;); subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;)); 因此没什么必要的话使用字符串更方便。 流程解析 首先调用Subject.isPermitted/hasRole接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer； Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例； 在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限； Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配则isPermitted/hasRole会返回true，否则返回false表示授权失败。 ModularRealmAuthorizer进行多Realm授权流程 首先检查相应的Realm是否实现了Authorizer； 是则调用相应的isPermitted/hasRole方法判断权限； 若有一个Realm匹配那么返回true，否则返回false。 用Realm进行授权应继承AuthorizingRealm，授权流程：1.1. 如果调用hasRole*(role)，则直接AuthorizationInfo.getRoles()获取用户角色与要求角色role对比即可；2.1.1. 如果调用isPermitted(String),首先通过AuthorizationInfo.getStringPermissions()获得字符串集合，再通过PermissionResolver将权限字符串解析为Permission实例，默认使用WildcardPermissionResolver。2.1.2. 如果通过isPermitted(WildcardPermission),则直接通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合即可；2.2. 然后获取用户角色，通过RolePermissionResolver解析角色对应权限集合（无默认实现，可自己定义）；2.3. 调用Permission.implies(Permission p)逐个与传入的用户权限比较，若有匹配的则返回true，否则返回false。 总结：Authorizer的职责是授权，提供了角色、权限判断接口。其子接口为SecurityManager，它的默认实现类为ModularRealmAuthorizer用于多Realm的授权匹配。PermissionResolver用于解析要求的权限字符串到Permission实例，RolePermissionResolver用于根据角色解析相应的权限集合。 指定Authorizer实现 //这里是默认实现，可以改为自定义的Authorizer实现类 authorizer=org.apache.shiro.authz.ModularRealmAuthorizer securityManager.authorizer=$authorizer PS:自定义Authorizer可参考ModularRealmAuthorizer 指定Authorizer的permissionResolver（PermissionResolverAware接口实现类） permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver authorizer.permissionResolver=$permissionResolver 指定Authorizer的rolePermissionResolver（RolePermissionResolverAware接口实现类） rolePermissionResolver=com.github.zhangkaitao.shiro.chapter3 .permission.MyRolePermissionResolver authorizer.rolePermissionResolver=$rolePermissionResolver 代码实例：ideaProjects/shiroHelloWorld 《跟我学shiro第三章》","categories":[],"tags":[]},{"title":"","slug":"Shiro第三章二-授权示例","date":"2019-04-30T08:29:23.012Z","updated":"2019-03-13T12:35:09.916Z","comments":true,"path":"2019/04/30/Shiro第三章二-授权示例/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第三章二-授权示例/","excerpt":"","text":"示例 调用链：开始用户验证login()-&gt;AbstractAuthenticaticator.authenticate()-&gt;子类ModularRealmAuthenticator.doAuthenticate()判断有几个Realm，然后一个个执行-&gt;getAuthenticationInfo()-&gt;AuthenticatingRealm.getAuthenticationInfo()-&gt;MyRealm.doGetAuthenticationInfo()到此完成用户验证-&gt; 开始授权BitAndWildPermissionResolver.resolvePermission()解析所需权限-&gt;MyRealm.doGetAuthorizationInfo()获取用户权限-&gt;BitAndWildPermissionResolver.resolvePermission()解析用户权限中存在的字符串权限+user2+10、user2:*-&gt;MyRolePermissionResolver.resolvePermissionInRole()解析用户角色role1、role2的权限，返回menu:* 根据调用链从外到内 AuthorizerTest：测试类 public class AuthorizerTest extends BaseTest { /** * @Author haien * @Description 测试MyRealm自己设置角色权限的授权方式 * @Date 2019/2/19 * @Param [] * @return void **/ @Test public void testIsPermitted(){ login(&quot;classpath:config/shiro-jdbc-authorizer.ini&quot;,&quot;zhang&quot;,&quot;123&quot;); Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;)); Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;)); Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;)); //新增 Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;)); //查看 Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;)); //新增与查看 Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;)); //没有删除权限 //MyRolePermissionResolver解析得到的权限 Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;)); } } MyRealm：doGetAuthenticationInfo()被login()调用，完成用户验证 public class MyRealm extends AuthorizingRealm { //继承AuthorizingRealm实现Realm接口 /** * @Author haien * @Description 获取身份验证信息（和MyRealm1一样） * @Date 2019/2/19 * @Param [authenticationToken] * @return org.apache.shiro.authc.AuthenticationInfo **/ @Override protected AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken authenticationToken) throws AuthenticationException { String username=(String)authenticationToken.getPrincipal(); //得到用户名 String password=new String((char[])authenticationToken.getCredentials()); //得到密码 //String password=(String)authenticationToken.getCredentials(); //若用户名错误 if(!&quot;zhang&quot;.equals(username)){ throw new UnknownAccountException(); } //若密码错误 if(!&quot;123&quot;.equals(password)){ throw new IncorrectCredentialsException(); } //身份验证成功，返回一个AuthenticationInfo实现 return new SimpleAuthenticationInfo(username,password,getName()); } } 如果想用数据库而不是自己准备用户和权限的话，可以配置shiro-jdbc-authorizer.ini，替换shiro-authorizer.ini和MyRealm类 [main] ;自定义Authorizer authorizer=org.apache.shiro.authz.ModularRealmAuthorizer ;自定义permissionResolver permissionResolver=com.haien.shiroHelloWorld.permission.BitAndWildPermissionResolver authorizer.permissionResolver=$permissionResolver ;自定义rolePermissionResolver rolePermissionResolver=com.haien.shiroHelloWorld.permission.MyRolePermissionResolver authorizer.rolePermissionResolver=$rolePermissionResolver securityManager.authorizer=$authorizer ;以上都和shiro-authorizer.ini一样 ;自定义JdbcRealm； ;一定要放在SecurityManager。authorizer，因为调用setRealms()会将realms设置给Authorizer， ;并将前面给Authorizer设置的属性permissionResolver和RolePermissionResolver设置给realms jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm dataSource=com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql://localhost:3306/shiro dataSource.username=root dataSource.password=123456 jdbcRealm.dataSource=$dataSource jdbcRealm.permissionsLookupEnabled=true //开启权限从数据库查找功能 securityManager.realms=$jdbcRealm BitAndWildPermissionResolver：解析权限字符串（用户拥有的权限和要求的权限） /** * @Author haien * @Description 解析权限字符串：根据字符串是否以+开头解析为BitPermission或WildcardPermission * @Date 2019/2/19 **/ public class BitAndWildPermissionResolver implements PermissionResolver { /** * @Author haien * @Description 根据字符串是否以+开头解析为BitPermission或WildcardPermission * @Date 2019/2/19 * @Param [s] * @return org.apache.shiro.authz.Permission **/ @Override public Permission resolvePermission(String permissionString) { if(permissionString.startsWith(&quot;+&quot;)){ return new BitPermission(permissionString); } return new WildcardPermission(permissionString); } } 其中BitPermission实现了Permission接口 Permission接口 public interface Permission { //权限匹配 boolean implies(Permission var1); } this是用户拥有的权限，var1是所需权限，当this是user:*或user，var1是user:create或两者完全相同时，返回true。 BitPermission /** * @Author haien * @Description 实现位移方式的权限定义，解析要求的权限。被BitAndWildPermissionResolver调用。 * 规则：+资源+权限位。以+开头，中间通过+分隔； * 权限位：0-all权限（二进制0000），1-新增（0001），2-修改（0010）， * 4-删除（0100）、8-查看（1000）；如，+user+10，由于10二进制为1010, * 1位置与2、8相同，按位与返回二进制数非0，所以表示拥有修改、查看权限 * @Date 2019/2/18 **/ public class BitPermission implements Permission { //资源 private String resourceIdentify; //权限位 private int permissionBit; //实例id private String instanceId; public BitPermission(String permissionString) { //解析要求的权限字符串 String[] array=permissionString.split(&quot;\\\\+&quot;); //加//防止+被解析 if(array.length&gt;1){ resourceIdentify=array[1]; //第0个为空 } if(StringUtils.isEmpty(resourceIdentify)){ //开头两个+相连，或者length&lt;=1,即根本没定义权限 resourceIdentify=&quot;*&quot;; } if(array.length&gt;2){ permissionBit=Integer.valueOf(array[2]); }//peimissionBit为空的话即默认值0，不用赋*给它，后面用0来判断即可 if(array.length&gt;3){ instanceId=array[3]; } if(StringUtils.isEmpty(instanceId)){ instanceId=&quot;*&quot;; } } /** * @Author haien * @Description 判断用户是否拥有权限 * @Date 2019/2/18 * @Param [p所需权限](this为用户权限) * @return boolean **/ @Override public boolean implies(Permission p) { if(!(p instanceof BitPermission)) { return false; } BitPermission other=(BitPermission)p; if(!(&quot;*&quot;.equals(this.resourceIdentify) //this：用户拥有的权限，other：所需权限 ||this.resourceIdentify.equals(other.resourceIdentify))){ return false; } if(!(this.permissionBit==0||(this.permissionBit&amp;other.permissionBit)!=0)){ return false; } if(!(&quot;*&quot;.equals(this.instanceId)||this.instanceId.equals(other.instanceId))){ return false; } return true; } } MyRealm：doGetAuthorizationInfo()获取用户权限。 public class MyRealm extends AuthorizingRealm { //继承AuthorizingRealm实现Realm接口 /** * @Author haien * @Description 根据用户身份获取授权信息 * @Date 2019/2/19 * @Param [principalCollection] * @return org.apache.shiro.authz.AuthorizationInfo **/ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { SimpleAuthorizationInfo authorizationInfo=new SimpleAuthorizationInfo(); /*不从数据库查找，自己设置权限进去*/ //用户拥有两个角色 authorizationInfo.addRole(&quot;role1&quot;); //添加角色后调用MyRolePermissionResolver解析出权限 authorizationInfo.addRole(&quot;role2&quot;); //解析出来后应该是添加回authorizationInfo的权限集合 //四个权限 authorizationInfo.addObjectPermission(new BitPermission(&quot;+user1+10&quot;)); authorizationInfo.addObjectPermission(new WildcardPermission(&quot;user1:*&quot;)); authorizationInfo.addStringPermission(&quot;+user2+10&quot;); //10代表2新增与8查看 authorizationInfo.addStringPermission(&quot;user2:*&quot;); //字符串权限，等下会调用BitAndWildPermissionResolver解析 return authorizationInfo; } } 其中，Principle原本是AuthenticationToken的属性之一，表示用户名。 MyRolePermissionResolver：解析角色字符串到用户权限集合 public class MyRolePermissionResolver implements RolePermissionResolver { /** * @Author haien * @Description 如果用户拥有role1，则返回menu:*权限，添加到用户权限集合中 * @Date 2019/2/19 * @Param [roleString] * @return java.util.Collection&lt;org.apache.shiro.authz.Permission&gt; **/ @Override public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) { if(&quot;role1&quot;.equals(roleString)){ //role1的权限（在MyRealm中添加也一样） /* return Arrays.asList(new WildcardPermission(&quot;menu:*&quot;), new BitPermission(&quot;+user1+10&quot;), new WildcardPermission(&quot;user1:*&quot;), new BitPermission(&quot;+user2+10&quot;), new WildcardPermission(&quot;user2:*&quot;)); */ return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;)); } return null; } } 代码实例：ideaProjects/shiroHelloWorld 《跟我学shiro第三章","categories":[],"tags":[]},{"title":"","slug":"Shiro第七章-与web集成、ShiroFilter、基于表单的拦截器","date":"2019-04-30T08:29:23.009Z","updated":"2019-03-31T06:00:14.345Z","comments":true,"path":"2019/04/30/Shiro第七章-与web集成、ShiroFilter、基于表单的拦截器/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第七章-与web集成、ShiroFilter、基于表单的拦截器/","excerpt":"","text":"依赖 shiro-web &lt;!--shiro项目至少的jar--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; Servlet3:编译与测试时的web环境 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; tomcat7-maven-plugin插件: 运行时的web环境 &lt;build&gt; &lt;finalName&gt;shiroHelloWorld-chapter7&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/${project.build.finalName}&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; web.xml配置、ShiroFilter Shiro提供了与web的集成，通过一个ShiroFilter入口来拦截需要安全控制的url，默认实现类是IniShiroFilter。 shiro 1.1版本的ShiroFilter： &lt;filter&gt; &lt;filter-name&gt;iniShiroFilter&lt;/filter-name&gt; &lt;!--使用IniShiroFilter作为shiro安全控制入口点--&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.IniShiroFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;configPath&lt;/param-name&gt; &lt;!--configPath：指定ini配置文件位置；固定--&gt; &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt; &lt;!--默认先从/WEB-INF/shiro.ini加载， 没有再classpath：shiro.ini--&gt; &lt;/init-param&gt; &lt;!-- 或不指定ini位置，直接按下面这样 &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt; [main] authc.loginUrl=/login [users] zhang=123,admin [roles] admin=user:*,menu:* [urls] /login=anon /static/**=anon /authenticated=authc /role=authc,roles[admin] /permission=authc,perms[&quot;user:create&quot;] &lt;/param-value&gt; &lt;/init-param&gt; --&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;iniShiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--指定需要拦截的url--&gt; &lt;/filter-mapping&gt; 使用IniShiroFilter作为Shiro安全控制的入口点。 可以使用configPath指定ini配置文件路径，默认先从/WEB-INF/shiro.ini加载（/表示根目录，为webapp），没有再是classpath:shiro.ini。也可以直接内嵌配置文件内容。 shiro 1.2版本开始引入Environment/WebEnvironment，由它们的实现类提供相应的SecurityManager及其相应的依赖。ShiroFilter会自动找到Environment然后获取相应依赖。 &lt;listener&gt; &lt;!--通过EnvironmentLoaderListener创建相应的WebEnvironment，并自动绑定到ServletContext， 默认使用IniWebEnvironment实现类。--&gt; &lt;listener-class&gt;org.apache.shiro.web.env.EnvironmentLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--可通过如下配置修改默认配置--&gt; &lt;context-param&gt; &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt; &lt;param-value&gt;org.apache.shiro.web.env.IniWebEnvironment&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;shiroConfigLocations&lt;/param-name&gt; &lt;param-value&gt;classpath:shiro.ini&lt;/param-value&gt; &lt;!--默认先/WEB-INF/shiro，没有再classpath:shiro.ini--&gt; &lt;/context-param&gt; 以上俩版本的配置相当于以下代码： //1、获取SecurityManager工厂，并使用ini配置文件初始化SecurityManager Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory= new IniSecurityManagerFactory(&quot;classpath:config/shiro.ini&quot;); //2、得到SecurityManager实例，并绑定SecurityUtils SecurityManager securityManager=factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); 那么以后登录直接从第3步：Subject subject=SecurityUtils.getSubject();写起。 与Spring集成：使用DelegatingFilterProxy，作用是自动到Spring容器查找名为filter-name的bean，并把所有Filter的操作委托给它，所以需要将shiroFilter注册到Spring。 &lt;filter&gt; &lt;!--DelegatingFilterProxy作用是自动到Spring容器查找名为filter-name的bean，并把所有 Filter的操作委托给它，所以需要将shiroFilter注册到Spring。--&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;!--可以不写--&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; ShiroFilter的bean：主要是绑定SecurityManager。需要使用org.springframework.web.context.ContextLoaderListener加载所在配置文件。 &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!—忽略其他，详见与Spring集成部分 --&gt; &lt;/bean&gt; 如果不与Spring集成，则直接声明ShiroFilter即可： &lt;!--绑定SecurityManager--&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.shiro.web.servlet.ShiroFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 常用的身份验证 shiro.ini配置文件 [main] #默认是/login.jsp authc.loginUrl=/login #未登录会自动跳转登录页面 roles.unauthorizedUrl=/unauthorized perms.unauthorizedUrl=/unauthorized [users] zhang=123,admin wang=123 [roles] admin=user:*,menu:* [urls] ;格式：url=拦截器[参数]。anon拦截器表示匿名访问，无需登录；authc则需要登录； ;roles[admin]需要admin角色；perms[&quot;user:create&quot;]需要有user:create权限 /login=anon /unauthorized=anon /static/**=anon /authenticated=authc /role=authc,roles[admin] /permission=authc,perms[&quot;user:create&quot;] urls格式：url=拦截器[参数]。anon拦截器表示匿名访问，无需登录，相当于不需拦截的资源；authc则需要登录;roles[admin]需要admin角色；perms[“user:create”]需要有user:create权限. 按照顺序进行匹配，只采用第一个匹配的进行拦截。 使用Ant风格模式 ?：匹配一个字符，如”/admin?”将匹配/admin1，但不匹配/admin或/admin2； ：匹配零个或多个字符串，如/admin将匹配/admin、/admin123，但不匹配/admin/1； ：匹配路径中的零个或多个路径，如/admin/将匹配/admin/a或/admin/a/b。 接收到请求后，先到ini查看是否需要拦截，不需要则查找url匹配的servlet类，需要则在ini中查找登录的url，再查找匹配的servlet类。 LoginServlet：登录Servlet。get请求时展示登录页面；post请求进行登录验证。 //相当于web.xml配置&lt;servlet&gt; @WebServlet(name=&quot;loginServlet&quot;,urlPatterns = &quot;/login&quot;) //url：http://localhost:8080/shiroHelloWorld-chapter7/login public class LoginServlet extends HttpServlet { /** * @Author haien * @Description get请求时展示登录页面 * @Date 2019/2/28 * @Param [req, resp] * @return void **/ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.getRequestDispatcher(&quot;/jsp/login.jsp&quot;).forward(req,resp); } /** * @Author haien * @Description post请求进行登录验证 * @Date 2019/2/28 * @Param [req, resp] * @return void **/ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String error = null; String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username, password); try { subject.login(token); } catch (UnknownAccountException e) { error = &quot;用户名/密码错误&quot;; } catch (IncorrectCredentialsException e) { error = &quot;用户名/密码错误&quot;; } catch (AuthenticationException e) { //其他错误，比如锁定，如果想单独处理请单独catch处理 error = &quot;其他错误：&quot; + e.getMessage(); } if(error != null) {//出错了，返回登录页面 req.setAttribute(&quot;error&quot;, error); req.getRequestDispatcher(&quot;/jsp/login.jsp&quot;).forward(req, resp); } else {//登录成功 req.getRequestDispatcher(&quot;/jsp/loginSuccess.jsp&quot;).forward(req, resp); } } } 登录成功不能老是跳到成功页面，而是要跳到之前请求的页面，可以在登录时把当前请求保存下来，登录成功再重定向到该请求即可。 基于Basic的拦截器身份验证 同样是做安全控制的拦截器，但是它要求登录的方式不是跳转登录页面，而是弹出登录窗口。 shiro-basicfilterlogin.ini： [main] ;authBasic是org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter类的实例， ;用于实现基于Basic的身份验证;applicationName属性显示在弹出的登录框 authcBasic.applicationName=please login perms.unauthorizedUrl=/unauthorized roles.unauthorizedUrl=/unauthorized [users] zhang=123,admin wang=123 [roles] admin=user:*,menu:* [urls] ;/role需要走authcBasic拦截器，即如果访问/role时未登录则弹出对话框进行登录 /role=authcBasic,roles[admin] 需要将web.xml中配置文件更改为shiro-basicfilterlogin.ini。 未登录访问/role将弹出窗口。再次测试未登录却没弹窗可能是因为Chrome记住了登录信息。 基于表单的拦截器身份验证 和第一种类似，但是更简单，因为已经实现了登录信息与用户库的匹配，我们只需要写登录页面的映射、登录失败处理即可。 原理大致如下，详情参见笔记：Shiro第八章二-自定义拦截器 public class FormLoginFilter extends PathMatchingFilter { private String loginUrl = &quot;/login.jsp&quot;; private String successUrl = &quot;/&quot;; /** * 总方法 */ @Override protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { //1、判断是否已登录，是则直接进入过滤链下一步 if(SecurityUtils.getSubject().isAuthenticated()) { return true;//已经登录过 } //2、未登录则判断是否为登录请求，是，则若是get请求，继续过滤链（跳转登录 //页面），若是post请求，认为是表单验证请求，进行表单验证，执行subject.login()； //否，若是get方法的其他页面请求则保存当前请求并重定向到登录页面，非get请求可能报错吧 HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if(isLoginRequest(req)) { //是登录请求 if(&quot;post&quot;.equalsIgnoreCase(req.getMethod())) { //form表单提交 boolean loginSuccess = login(req); //登录 if(loginSuccess) { //登录成功 return redirectToSuccessUrl(req, resp); } } //是get请求|登录失败，继续过滤器链，可能是被分配到controller处理/login return true; } else { //不是登录请求，保存当前地址并重定向到登录界面 saveRequestAndRedirectToLogin(req, resp); return false; } } /** * 登录成功后调用，若有之前的请求则重定向到它，否则到默认成功页面 */ private boolean redirectToSuccessUrl(HttpServletRequest req, HttpServletResponse resp) throws IOException { WebUtils.redirectToSavedRequest(req, resp, successUrl); return false; } /** * 保存当前请求并跳转登录页面 */ private void saveRequestAndRedirectToLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException { WebUtils.saveRequest(req); WebUtils.issueRedirect(req, resp, loginUrl); } /** * 表单验证，执行登录方法 */ private boolean login(HttpServletRequest req) { String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); try { SecurityUtils.getSubject().login(new UsernamePasswordToken(username, password)); } catch (Exception e) { req.setAttribute(&quot;shiroLoginFailure&quot;, e.getClass()); return false; } return true; } /** * 判断是否登录请求 */ private boolean isLoginRequest(HttpServletRequest req) { return pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req)); } } shiro-formfilterlogin.ini： [main] ;authc是org.apache.shiro.web.filter.authc.FormAuthenticationFilter类的实例； ;loginUrl:指定登录地址、表单提交地址；successUrl：默认是/， 如果有上一个地址会自动重定向到该地址； ;failureKeyAttribute：登录失败信息的在request中的key，默认为shiroLoginFailure， 内容为异常类型名。 authc.loginUrl=/formfilterlogin //get请求即为请求登录页面，由controller映射页面； post为表单验证请求，FormAuthenticationFilter处理 authc.usernameParam=username authc.passwordParam=password authc.successUrl=/ authc.failureKeyAttribute=shiroLoginFailure perms.unauthorizedUrl=/unauthorized roles.unauthorizedUrl=/unauthorized [users] zhang=123,admin wang=123 [roles] admin=user:*,menu:* [urls] /static/**=anon /formfilterlogin=authc /role=authc,roles[admin] /permission=authc,perms[&quot;user:create&quot;] 然后web.xml改为shiro-formfilterlogin.ini。 formfilterlogin.jsp：登录页面。 &lt;body&gt; &lt;div class=&quot;error&quot;&gt;${error}&lt;/div&gt; &lt;form action=&quot;${pageContext.request.contextPath}/formfilterlogin&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;/body&gt; FormFilterLoginServlet：登录失败处理 @WebServlet(name = &quot;formFilterLoginServlet&quot;, urlPatterns = &quot;/formfilterlogin&quot;) public class FormFilterLoginServlet extends HttpServlet { /** * @Author haien * @Description get请求的话FormAuthenticationFilter不做任何处理 直接结束当前过滤链，进入下一过滤链，应该是Spring自己的过滤链了， 应该就是分发给controller处理，所以这里应该是映射登录页面才对，不过交给doPost做 也获取不到shiroLoginFailure，也是直接返回登录页面了 * * @Date 2019/3/15 * @Param [req, resp] * @return void **/ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } /** * @Author haien * @Description 身份验证和成功跳转已被处理，如果失败FormAuthenticationFilter * 并不会返回登录页面或做任何处理，只是结束当前过滤链而进入下一过滤链， * 而下一过滤链应该就是Spring自己的过滤链，也就是将原请求分发到controller， * 所以要准备一个处理登录失败情况的跳转这里只处理失败情况 * * @Date 2019/2/28 * @Param [req, resp] * @return void **/ @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String errorClassName = (String)req.getAttribute(&quot;shiroLoginFailure&quot;); //异常类型名 if(UnknownAccountException.class.getName().equals(errorClassName)) { req.setAttribute(&quot;error&quot;, &quot;用户名/密码错误&quot;); } else if(IncorrectCredentialsException.class.getName().equals(errorClassName)) { req.setAttribute(&quot;error&quot;, &quot;用户名/密码错误&quot;); } else if(errorClassName != null) { req.setAttribute(&quot;error&quot;, &quot;未知错误：&quot; + errorClassName); } req.getRequestDispatcher(&quot;/jsp/formfilterlogin.jsp&quot;).forward(req, resp); //返回登录页面 } } 测试：登录/role，会跳转/formfilterlogin登录页面，登陆成功会跳转/role而不是默认登录成功页面。 权限验证 shiro.ini [main] roles.unauthorizedUrl=/unauthorized perms.unauthorizedUrl=/unauthorized [urls] /role=authc,roles[admin] /permission=authc,perms[&quot;user:create&quot;] unauthorizedUrl: 验证失败重定向到的地址。 roles: org.apache.shiro.web.filter.authz.RolesAuthorizationFilter类的实例，通过[参数]指定访问时需要的权限，如有多个使用”,”分隔，验证需要都通过。 perms：org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter类实例，验证权限字符串。 PermissionServlet类：只处理权限验证成功情况，失败情况ini已处理。 @WebServlet(name = &quot;permissionServlet&quot;, urlPatterns = &quot;/permission&quot;) public class PermissionServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Subject subject = SecurityUtils.getSubject(); subject.checkPermission(&quot;user:create&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/hasPermission.jsp&quot;).forward(req, resp); } } RoleServlet类：角色单位的权限验证，也是只处理成功情况，主要逻辑如下： subject.checkRole(&quot;admin&quot;); 测试：访问/login，使用zhang/123登录后访问/role或/permission，跳转授权成功页面；使用wang/123登录则跳转/unauthorized无授权页面。 Shiro也提供了logout拦截器用于退出，它是org.apache.shiro.web.filter.authc.LogoutFilter类的实例 [main] ;logout是org.apache.shiro.web.filter.authc.LogoutFilter类实例，Shiro内置logout拦截器 logout.redirectUrl=/login [urls] ;指定退出url是/logout2；使用Shiro内置的logout拦截器退出，logout配置在上面main中 /logout2=logout 则无需写Servlet类处理退出请求，只要把退出链接的url改成/logout2即可 &lt;a href=&quot;${pageContext.request.contextPath}/logout2&quot;&gt;退出&lt;/a&gt; 代码实例 ideaProjects/shiroHelloWorldchapter7 参考文章","categories":[],"tags":[]},{"title":"","slug":"Shiro第六章-各种对象详解-完整用户登录认证与授权示例","date":"2019-04-30T08:29:22.998Z","updated":"2019-03-14T08:10:57.910Z","comments":true,"path":"2019/04/30/Shiro第六章-各种对象详解-完整用户登录认证与授权示例/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第六章-各种对象详解-完整用户登录认证与授权示例/","excerpt":"","text":"Realm doGetAuthenticationInfo()和getAuthenticationInfo()一样，都是做用户验证和返回身份凭证的。 从调用链上，getAuthorizationInfo()会调用doGetAuthorizationInfo()，所以大部分时候是重写后者。 AuthenticationToken 收集用户提交的身份信息（如用户名和凭据（如密码））的接口。 public interface AuthenticationToken extends Serializable { Object getPrincipal(); //身份 Object getCredentials(); //凭据 }; 扩展接口RememberMeAuthenticationToken:提供boolean isRememberMe()实现记住我功能。 扩展接口HostAuthenticationToken：提供String getHost()获取用户主机。 内置实现类UsernamePasswordToken：仅保存用户名、密码，并实现了以上两个接口，可以实现记住我和主机验证的支持。 AuthenticationInfo 封装验证通过的身份信息，主要包括Object属性principal(一般存储用户名)和credentials（密码）。 MergableAuthenticationInfo子接口：在多Realm时合并AuthenticationInfo，主要合并Principal，如果是其他信息如credentialsSalt，则会后合并进来的AuthenticationInfo覆盖。 SaltedAuthenticationInfo子接口：比如HashedCredentialsMatcher，在验证时会判断AuthenticationInfo是否是SaltedAuthenticationInfo的子类，是则获取其盐。 Account子接口：相当于我们之前的[users],SimpleAccount是其实现。在IniRealm、PropertiesRealm这种静态创建账号的场景中使用，它们继承了SimpleAccountRealm，其中就有API用于增删查改SimpleAccount。适用于账号不是特别多的情况。 SimpleAuthenticationInfo：一般都是返回这个类型。 PincipalCollection Principal前缀：应该是上面AuthenticationInfo的属性principal。 PincipalCollection:是一个身份集合，保存登录成功的用户的身份信息。因为我们可以在Shiro中同时配置多个Realm，所以身份信息就有多个。可以传给doGetAuthorizationInfo()方法为登录成功的用户授权。 public interface PrincipalCollection extends Iterable, Serializable { Object getPrimaryPrincipal(); //得到主要的身份 &lt;T&gt; T oneByType(Class&lt;T&gt; type); //根据身份类型获取第一个 &lt;T&gt; Collection&lt;T&gt; byType(Class&lt;T&gt; type); //根据身份类型获取一组 List asList(); //转换为List Set asSet(); //转换为Set Collection fromRealm(String realmName); //根据Realm名字获取 Set&lt;String&gt; getRealmNames(); //获取所有身份验证通过的Realm名字 boolean isEmpty(); //判断是否为空 }; 其中，getPrimaryPrincipal()时，如果只有一个Principal，那么直接返回即可，但若有多个则返回第一个，由于其底层由Map存储，所以第一个也就是任意一个。 oneByType() 、 byType()：根据凭据的类型返回对应的Principal。 fromRealm()：根据Realm名字返回对应的Principal。 因为此例中就一个Realm，所以直接调用getPrimaryPrincipal得到之前传入的用户名即可。 @Override protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals) { //PrincipalCollection是一个身份集合，因为我们现在就一个Realm， //所以直接调用getPrimaryPrincipal得到之前传入的用户名即可 String username=(String)principals.getPrimaryPrincipal(); ... } MutablePrincipalCollection：可变的PrincipalCollection接口，提供了如下可变方法 public interface MutablePrincipalCollection extends PrincipalCollection { void add(Object principal, String realmName); //添加Realm-Principal的关联 void addAll(Collection principals, String realmName); //添加一组Realm-Principal的关联 void addAll(PrincipalCollection principals);//添加PrincipalCollection void clear();//清空 } SimplePrincipalCollection：MutablePrincipalCollection唯一实现类。在继承了AbstractAuthenticationStrategy的验证策略中，afterAttemp()会调用SimplePrincipalCollection的merge()将多个Principal合并到一个PrincipalCollection中。 PrincipalCollection示例 准备三个Realm，命名分别为a,b,c，身份凭证只有细微差别。 public class MyRealm1 implements Realm { @Override public String getName() { return &quot;a&quot;; //realm name 为 “a” } @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { return new SimpleAuthenticationInfo( &quot;zhang&quot;, //身份 字符串类型 &quot;123&quot;, //凭据 getName() //Realm Name ); } } //和1完全一样，只是命名为b public class MyRealm2 implements Realm { @Override public String getName() { return &quot;b&quot;; //realm name 为 “b” } @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { return new SimpleAuthenticationInfo( &quot;zhang&quot;, //身份 字符串类型 &quot;123&quot;, //凭据 getName() //Realm Name ); } } //除了命名不同，只是Principal类型为User，而不是简单的String public class MyRealm3 implements Realm { @Override public String getName() { return &quot;c&quot;; //realm name 为 “c” } @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { User user=new User(&quot;zhang&quot;,&quot;123&quot;); return new SimpleAuthenticationInfo( user, //身份 User类型 &quot;123&quot;, //凭据 getName() //Realm Name ); } } shiro-multirealm.ini [main] realm1=com.haien.shiroHelloWorld.principalTest.realm.MyRealm1 realm2=com.haien.shiroHelloWorld.principalTest.realm.MyRealm2 realm3=com.haien.shiroHelloWorld.principalTest.realm.MyRealm3 securityManager.realms=$realm1,$realm2,$realm3 PrincipalCollectionTest：测试方法 public class PrincipalCollectionTest extends BaseTest { @Test public void testPrincipalCollection(){ login(&quot;classpath:config/shiro-multirealm.ini&quot;, &quot;zhang&quot;,&quot;123&quot;); Subject subject=subject(); //获取Map中第一个Principal，即PrimaryPrincipal Object primaryPrincipal1=subject.getPrincipal(); //获取PrincipalCollection PrincipalCollection principalCollection=subject.getPrincipals(); //也是获取PrimaryPrincipal Object primaryPrincipal2=principalCollection.getPrimaryPrincipal(); //获取所有身份验证成功的Realm名字 Set&lt;String&gt; realmNames=principalCollection.getRealmNames(); for(String realmName:realmNames) System.out.println(realmName); //将身份信息转换为Set/List（实际转换为List也是先转为Set） List&lt;Object&gt; principals=principalCollection.asList(); /*返回集合包含两个String类、一个User类，但由于两个String类都是&quot;zhang&quot;， 所以只只剩下一个,转为List结果也是一样*/ for(Object principal:principals) System.out.println(&quot;set:&quot;+principal); //根据realm名字获取身份，因为realm名字可以重复， //所以可能有多个身份，建议尽量不要重复 Collection&lt;User&gt; users=principalCollection.fromRealm(&quot;c&quot;); for(User user:users) System.out.println(&quot;c:user=&quot;+user.getUsername()+user.getPassword()); Collection&lt;String&gt; usernames=principalCollection.fromRealm(&quot;b&quot;); for(String username:usernames) System.out.println(&quot;b:username=&quot;+username); } } 代码实例：ideaProjects/shiroHelloWorld/PrincipalTest AuthorizationInfo 封装权限信息，主要是doGetAuthorizationInfo()时封装授权信息然后返回的。 public interface AuthorizationInfo extends Serializable { Collection&lt;String&gt; getRoles(); //获取角色字符串信息 Collection&lt;String&gt; getStringPermissions(); //获取权限字符串信息 Collection&lt;Permission&gt; getObjectPermissions(); //获取Permission对象信息 } SimpleAuthorizationInfo：实现类，大多数时候使用这个。主要增加了以下方法： authorizationInfo.addRole(&quot;role1&quot;); //添加角色到内部维护的role集合； 添加角色后调用MyRolePermissionResolver解析出权限 authorizationInfo.setRoles(Set&lt;String&gt; roles); //将内部维护的role集合设置为入参 authorizationInfo.addObjectPermission(new BitPermission(&quot;+user1+10&quot;)); //添加对象型权限 authorizationInfo.addObjectPermission(new WildcardPermission(&quot;user1:*&quot;)); authorizationInfo.addStringPermission(&quot;+user2+10&quot;); //字符串型权限 authorizationInfo.addStringPermission(&quot;user2:*&quot;); authorizationInfo.setStringPermissions(Set&lt;String&gt; permissions); Subject Shiro核心对象，基本所有身份验证、授权都是通过Subject完成的。 //获取身份信息 Object getPrincipal(); //Primary Principal PrincipalCollection getPrincipals(); // PrincipalCollection //身份验证 void login(AuthenticationToken token) throws AuthenticationException; //调用各种方法； 登录失败抛AuthenticationException，成功则调用isAuthenticated()返回true boolean isAuthenticated(); //与isRemembered()一个为true一个为false boolean isRemembered(); //返回true表示是通过记住我登录到额而不是调用login方法 //角色验证 boolean hasRole(String roleIdentifier); //返回true或false表示成功与否 boolean[] hasRoles(List&lt;String&gt; roleIdentifiers); boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers); void checkRole(String roleIdentifier) throws AuthorizationException; //失败抛异常 void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException; void checkRoles(String... roleIdentifiers) throws AuthorizationException; //权限验证 boolean isPermitted(String permission); boolean isPermitted(Permission permission); boolean[] isPermitted(String... permissions); boolean[] isPermitted(List&lt;Permission&gt; permissions); boolean isPermittedAll(String... permissions); boolean isPermittedAll(Collection&lt;Permission&gt; permissions); void checkPermission(String permission) throws AuthorizationException; void checkPermission(Permission permission) throws AuthorizationException; void checkPermissions(String... permissions) throws AuthorizationException; void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException; //会话（登录成功相当于建立了会话，然后调用getSession获取 Session getSession(); //相当于getSession(true) Session getSession(boolean create); //当create=false，如果没有会话将返回null， 当create=true，没有也会强制创建一个 //退出 void logout(); //RunAs void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException; //实现允许A作为B进行访问， 调用runAs(b)即可 boolean isRunAs(); //此时此方法返回true PrincipalCollection getPreviousPrincipals(); //得到a的身份信息， 而getPrincipals()得到b的身份信息 PrincipalCollection releaseRunAs(); //不需要了RunAs则调用这个 //多线程 &lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException; void execute(Runnable runnable); &lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable); Runnable associateWith(Runnable runnable); Subject的获取：一般不需要我们创建，直接通过SecurityUtils获取即可 public static Subject getSubject() { Subject subject = ThreadContext.getSubject(); if (subject == null) { subject = (new Subject.Builder()).buildSubject(); ThreadContext.bind(subject); } return subject; } 首先查看当前线程是否绑定了Subject，没有则通过Subject.BUilder构建一个并绑定到线程返回。 如果想自定义Subject实例的创建，代码如下： new Subject.Builder().principals(身份).authenticated(true/false).buildSubject() 然后自己绑定到线程即可。在new Subject.Builder()时如果没有传入SecurityManager，则自动调用SecurityUtils.getsecurityManager()获取一个默认实现类的对象。 Subject一般用法 身份验证login() 授权hasRole*()/isPermitted*/checkRole*()/checkPermission*() 将相应的数据存储到会话Session 切换身份RunAs/多线程身份传播 退出 完整用户登录认证与授权示例：ideaProjects/shiroHelloWorld/chapter6、src/test/UserRealmTest为主测试","categories":[],"tags":[]},{"title":"","slug":"Shiro第九章-jsp标签","date":"2019-04-30T08:29:22.983Z","updated":"2019-03-01T12:33:56.901Z","comments":true,"path":"2019/04/30/Shiro第九章-jsp标签/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第九章-jsp标签/","excerpt":"","text":"jstl标签库 Shiro提供了jstl标签用于在jsp页面、gsp页面进行权限控制，如根据登录页面显示相应的菜单。 导入标签库 &lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt; guest标签：用户未登录时作为游客处理。 &lt;shiro:guest&gt; 欢迎游客访问，&lt;a href=&quot;${pageContext.request.contextPath}/login.jsp&quot;&gt;登录&lt;/a&gt; &lt;/shiro:guest&gt; user标签：用户已登录（身份验证或记住我）。 &lt;shiro:user&gt; 欢迎[&lt;shiro:principal/&gt;]登录&lt;/a&gt; &lt;/shiro:user&gt; authenticated标签：用户已身份验证，不是记住我登录的。 &lt;shiro:authenticated&gt; 用户[&lt;shiro:principal/&gt;]已身份验证通过 &lt;/shiro:authenticated&gt; notAuthenticated标签：用户通过非身份验证方式登录。 &lt;shiro:notAuthenticated&gt; 未身份验证（包括记住我） &lt;/shiro:notAuthenticated&gt; principal标签：显示用户身份信息，默认调用Subject.getPrincipal()。 //相当于Subject.getPrincipals().oneByType(String.class) &lt;shiro:principal type=&quot;java.lang.String&quot;/&gt; //((User)Subject.getPrincipals()).getUsername() &lt;shiro:principal property=&quot;username&quot;/&gt; hasRole标签：拥有指定角色将显示body体内容。 &lt;shiro:hasRole name=&quot;admin&quot;&gt; 用户[&lt;shiro:principal/&gt;]拥有角色admin&lt;br/&gt; &lt;/shiro:hasRole&gt; hasAnyRoles标签 &lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt; 用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt; &lt;/shiro:hasAnyRoles&gt; lacksRole：没有该角色将显示该内容。 &lt;shiro:lacksRole name=&quot;abc&quot;&gt; 用户[&lt;shiro:principal/&gt;]没有角色abc&lt;br/&gt; &lt;/shiro:lacksRole&gt; hasPermission &lt;shiro:hasPermission name=&quot;user:create&quot;&gt; 用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt; &lt;/shiro:hasPermission&gt; lacksPermission &lt;shiro:lacksPermission name=&quot;org:create&quot;&gt; 用户[&lt;shiro:principal/&gt;]没有权限org:create&lt;br/&gt; &lt;/shiro:lacksPermission&gt; 自定义标签库//导入自定义标签库 &lt;%@taglib prefix=&quot;zhang&quot; tagdir=&quot;/WEB-INF/tags&quot; %&gt; //使用定义标签库 &lt;zhang:hasAllRoles name=&quot;admin,user&quot;&gt; 用户[&lt;shiro:principal/&gt;]拥有角色admin和user&lt;br/&gt; &lt;/zhang:hasAllRoles&gt; &lt;zhang:hasAllPermissions name=&quot;user:create,user:update&quot;&gt; 用户[&lt;shiro:principal/&gt;]拥有权限user:create和user:update&lt;br/&gt; &lt;/zhang:hasAllPermissions&gt; &lt;zhang:hasAnyPermissions name=&quot;user:create,abc:update&quot;&gt; 用户[&lt;shiro:principal/&gt;]拥有权限user:create或abc:update&lt;br/&gt; &lt;/zhang:hasAnyPermissions&gt; tags包下分别写了三个脚本：hasAllPermissions.tag、hasAllRoles.tag、hasAnyPermissions.tag，但是逻辑看不懂。 脚本地址 参考文章","categories":[],"tags":[]},{"title":"","slug":"Shiro第二章一-用户认证","date":"2019-04-30T08:29:22.976Z","updated":"2019-04-03T05:50:33.718Z","comments":true,"path":"2019/04/30/Shiro第二章一-用户认证/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第二章一-用户认证/","excerpt":"","text":"简介 Java安全框架 Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。 三个核心组件：Subject、SecurityManager和Realms。 Subject:当前操作用户，代表了当前用户的安全操作。所有Subject都绑定到SEcurityManager，与Subject的所有交互都会委托给SecurityManager，可以把Subject认为是一个门面，SecurityManager才是实际的执行者。 SecurityManager：安全管理器，Shiro框架核心，管理所有用户的安全操作。即所有与安全有关的操作都会与SecurityManager交互；它管理着所有Subject，负责与其他组件进行交互，相当于SpringMvc的DispatcherServlet前端控制器。 Realm：Shiro从Realm（领域）获取安全数据（用户、角色、权限），就是说SecurityManager要验证用户身份，需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从REalm得到用户相应的权限进行验证；可以把Realm看成DataSource，即安全数据源。Shiro和Spring Security比较 Shiro比Spring更容易使用，实现和最重要的理解 Spring Security更加知名的唯一原因是因为品牌名称 “Spring”以简单而闻名，但讽刺的是很多人发现安装Spring Security很难 然而，Spring Security却有更好的社区支持 Apache Shiro在Spring Security处理密码学方面有一个额外的模块 Spring-security 对spring 结合较好，如果项目用的springmvc ，使用起来很方便。但是如果项目中没有用到spring，那就不要考虑它了。 Shiro 功能强大、且 简单、灵活。是Apache下的项目，比较可靠，且不跟任何的框架或者容器绑定，可以独立运行 实战 依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; 包含SecurityManager等最基础的对象。 shiro.ini：准备用户库 [users] zhang=123 wang=123 测试 import org.apache.shiro.SecurityUtils; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.UsernamePasswordToken; import org.apache.shiro.config.IniSecurityManagerFactory; import org.apache.shiro.subject.Subject; import org.apache.shiro.util.Factory; import org.apache.shiro.mgt.SecurityManager; import org.junit.Assert; import org.junit.Test; /** * @Author haien * @Description 运用shiro测试登录登出 * @Date 2019/2/15 **/ public class LoginLogoutTest { @Test public void testHelloWorld(){ //1、获取SecurityManager工厂，并使用ini配置文件初始化SecurityManager Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory= new IniSecurityManagerFactory(&quot;classpath:config/shiro.ini&quot;); //2、得到SecurityManager实例，并绑定SecurityUtils SecurityManager securityManager=factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject，创建用户名、密码身份验证Token（即用户身份凭证） Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken token=new UsernamePasswordToken(&quot;zhang&quot;,&quot;123&quot;); //可能不止用户名、密码，如登录时允许用户名、邮箱、手机选一登录 try { //4、登录，即身份验证 subject.login(token); }catch (AuthenticationException e){ //5、身份验证失败 } Assert.assertEquals(true,subject.isAuthenticated()); //断言用户是否已登录 //6、退出 subject.logout(); } } 其中，验证失败抛出AuthenticationException或其子类，如，DisabledAccountException（禁用的账号）、LockedAccountException（锁定的账号）、UnknownAccountException（错误的账号）、、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等。 对于页面错误消息的显示，最好使用用户名/密码错误，而不是用户名错误、密码错误，防止一些恶意用户没法扫描账号库。 身份验证流程 首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置； SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证； Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator会把相应的表单参数封装类AuthenticationToken传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了，如果返回一个身份信息封装类AuthenticationInfo则身份验证成功。 PS：此处可以配置多个Realm（上面的ini配置方式就是使用org.apache.shiro.realm.text.IniRealm），将按照相应的顺序及策略进行访问。 Realm：获取用户库 public interface Realm { //返回一个唯一的Realm名字 String getName(); //判断此Realm是否支持此Token boolean supports(AuthenticationToken var1); //根据Token获取认证信息 AuthenticationInfo getAuthenticationInfo(AuthenticationToken var1) throws AuthenticationException; } 单Realm配置：自定义Realm实现类 public class MyRealm1 implements Realm { /** * @Author haien * @Description 获得唯一的Realm名字 * @Date 2019/2/15 * @Param [] * @return java.lang.String **/ @Override public String getName() { return &quot;myrealm1&quot;; } /** * @Author haien * @Description 判断此Realm是否支持此Token * @Date 2019/2/15 * @Param [authenticationToken] * @return boolean **/ @Override public boolean supports(AuthenticationToken token) { //仅支持UsernamePasswordToken return token instanceof UsernamePasswordToken; } /** * @Author haien * @Description 根据Token获得Token信息 * @Date 2019/2/15 * @Param [authenticationToken表单参数封装类] * @return org.apache.shiro.authc.AuthenticationInfo身份信息封装类 **/ @Override public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { //表单参数，来自login方法 String username=(String)authenticationToken.getPrincipal(); String password=new String((char[])authenticationToken.getCredentials()); //String password=(String)authenticationToken.getCredentials(); //若用户名错误 if(!&quot;zhang&quot;.equals(username)){ //zhang来自用户库 throw new UnknownAccountException(); } //若密码错误 if(!&quot;123&quot;.equals(password)){ //123来自用户库 throw new IncorrectCredentialsException(); } //身份验证成功，返回一个AuthenticationInfo实现 return new SimpleAuthenticationInfo(username,password,getName()); } } 配置ini文件指定自定义Realm实现 ;第三方用户库：指定自定义Realm（可以在这个Realm里面定义用户库位置） myRealm1=com.haien.shiroHelloWorld.realm.MyRealm1 //相当于调用public无参构造创建对象 ;指定securityManage的realms实现(通过￥name来引入上面的Realm定义) securityManager.realms=$myRealm1 //相当于调用setter方法设置对象引用 多Realm配置。此处我们使用显式指示顺序的方式指定Realm的顺序，若删去第4行，SecurityManager则会按照Realm声明的顺序进行验证（即无需设置realms属性，会自动发现）；而显式指定后，没有被指定到的Realm将会被忽略。 1 myRealm1=com.haien.shiroHelloWorld.realm.MyRealm1 2 myRealm2=com.haien.shiroHelloWorld.realm.MyRealm2 3 ;多Realm配置 4 securityManager.realms=$myRealm1,$myRealm2 Shiro默认提供的Realm 一般继承AuthorizingRealm即可，本身有权限验证doGetAuthorizationInfo()，又继承了用户验证doGetAuthenticationInfo，也继承了缓存功能。其中主要默认实现如下： org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息； org.apache.shiro.realm.text.PropertiesRealm： user.username=password,role1,role2指定用户名/密码及其角色；role.role1=permission1,permission2指定角色及权限信息； org.apache.shiro.realm.jdbc.JdbcRealm：通过sql查询相应的信息，如“select password from users where username = ?”获取用户密码，“select password, password_salt from users where username = ?”获取用户密码及盐；“select role_name from user_roles where username = ?”获取用户角色；“select permission from roles_permissions where role_name = ?”获取角色对应的权限信息；也可以调用相应的api进行自定义sql； 特别地，值需要用户验证而不需要授权，则继承AuthenticatingRealm即可。 而若实现Realm的话，一般是重写getAuthenticationInfo()实现用户验证，没有授权给功能。 JDBC Realm 先到数据库shiro下建表：users,user_roles,roles_permissions，并添加一个用户：username-zhang,password-123. ini配置 ;jdbc用户库 jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm //实例名=全限定类名，创建一个实例 dataSource=com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName=com.mysql.jdbc.Driver //实例名.属性=值，自动调用setter进行赋值 dataSource.url=jdbc:mysql://127.0.0.1:3306/shiro dataSource.username=root dataSource.password=123456 jdbcRealm.dataSource=$dataSource securityManager.realms=$jdbcRealm 代码实例 ideaProjects/shiroHelloWorld参考文章 张开涛跟我学shiro","categories":[],"tags":[]},{"title":"","slug":"Shiro第二章二-验证者Authenticator、验证策略AuthenticationStrategy","date":"2019-04-30T08:29:22.971Z","updated":"2019-02-23T08:02:12.658Z","comments":true,"path":"2019/04/30/Shiro第二章二-验证者Authenticator、验证策略AuthenticationStrategy/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第二章二-验证者Authenticator、验证策略AuthenticationStrategy/","excerpt":"","text":"Authenticator及AuthenticationStrategy Authenticator的职责是验证用户，被subject的login()调用。 public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException { //调用了Realm的getAuthenticationInfo() } Authenticator：SecurityManager是其子接口，默认实现类为ModularRealmAuthenticator，其委托给多个Realm进行验证。 AuthenticatorStrategy：制定多个Realm的验证规则。默认提供的实现： FirstSuccessfulStrategy：只要有一个Realm验证成功即可，值返回第一个验证成功的Realm的认证信息。 AtLeastSuccessfulStrategy：只要有一个Realm验证成功即可，返回所有验证成功的Realm的认证信息。 AllSuccessfulstrategy：默认使用；所有Realm都验证成功才行，返回所有认证信息。 假设我们有三个Realm： myRealm1： 用户名/密码为zhang/123时成功，且返回身份/凭据为zhang/123； myRealm2： 用户名/密码为wang/123时成功，且返回身份/凭据为wang/123； myRealm3： 用户名/密码为zhang/123时成功，且返回身份/凭据为zhang@163.com/123。 现在测试一下AllSuccessfulStrategy验证策略 首先是ini配置文件 ;指定securityManager的authentication实现 authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator securityManager.authenticator=$authenticator ;指定securityManager.authenticator的authenticationStragegy allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy myRealm1=com.haien.shiroHelloWorld.realm.MyRealm1 myRealm2=com.haien.shiroHelloWorld.realm.MyRealm2 myRealm3=com.haien.shiroHelloWorld.realm.MyRealm3 securityManager.realms=$myRealm1,$myRealm3 测试 /** * @Author haien * @Description 测试AllSuccessfulStrategy成功 * @Date 2019/2/16 * @Param [] * @return void **/ @Test public void testAllSuccessfulStrategyWithSuccess(){ //登录成功（因为ini配置文件中没有使用身份必须为wang的myRealm2） login(&quot;classpath:config/shiro-authenticator-all-success.ini&quot;); //登录逻辑代码先通用化了 Subject subject=SecurityUtils.getSubject(); //得到一个身份集合，其包含了Realm验证成功的身份信息 PrincipalCollection principalCollection=subject.getPrincipals(); //包含了zhang和zhang@163.com的身份凭证 Assert.assertEquals(2,principalCollection.asList().size()); } /** * @Author haien * @Description 测试AllSuccessfulStrategy失败 * @Date 2019/2/17 * @Param [] * @return void **/ @Test(expected = UnknownAccountException.class) //括号里表明当方法抛出此异常时测试成功 public void testAllSuccessfulAccountWithFail(){ //但实际登录失败（配置文件改为使用myRealm1和myRealm2） login(&quot;classpath:config/shiro-authenticator-all-fail.ini&quot;); Subject subject=SecurityUtils.getSubject(); } 以上测试失败方法如果捕获异常的话可获得以下调用链 自定义AuthenticationStrategy AuthenticationStrategy接口类 //在所有Realm验证之前调用 AuthenticationInfo beforeAllAttempts(Collection&lt;? extends Realm&gt; realms, AuthenticationToken token) throws AuthenticationException; //在每个Realm之前调用 AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException; //在每个Realm之后调用 AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException; //在所有Realm之后调用 AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate)throws AuthenticationException; //将所有验证成功的身份信息集合起来，便于最后一起返回；FirstSuccessfulStrategy类重写了该方法 AuthenticationInfo merge(AuthenticationInfo info, AuthenticationInfo aggregate) 自定义AuthenticationStrategy实现类一般继承AbstractAuthenticationStrategy即可。 AtLeastTwoAuthenticatorStrategy：至少两个通过才行，返回所有验证信息 public class AtLeastTwoAuthenticatorStrategy extends AbstractAuthenticationStrategy { /** * @Author haien * @Description 在所有Realm验证之前调用 * @Date 2019/2/17 * @Param [realms, token] * @return org.apache.shiro.authc.AuthenticationInfo **/ @Override public AuthenticationInfo beforeAllAttempts(Collection&lt;? extends Realm&gt; realms, AuthenticationToken token) throws AuthenticationException { //和父类方法一样，返回一个空的身份凭证 return new SimpleAuthenticationInfo(); } /** * @Author haien * @Description 在每个Realm验证之前调用 * @Date 2019/2/17 * @Param [realm, token, aggregate] * @return org.apache.shiro.authc.AuthenticationInfo **/ @Override public AuthenticationInfo beforeAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException { //和父类方法一样，返回之前合并的 return aggregate; } @Override public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException { //也是和父类方法一样 AuthenticationInfo info; if(singleRealmInfo==null){ info=aggregateInfo; }else { if(aggregateInfo==null){ info=singleRealmInfo; }else{ //调用父类merge()将所有身份凭证集合起来，最后一起返回 info=merge(singleRealmInfo,aggregateInfo); } } return info; } /** * @Author haien * @Description 真正重写的方法：判断是否至少两个Realm通过 * @Date 2019/2/17 * @Param [token, aggregate] * @return org.apache.shiro.authc.AuthenticationInfo **/ @Override public AuthenticationInfo afterAllAttempts(AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException { if(aggregate==null||CollectionUtils.isEmpty(aggregate.getPrincipals()) ||aggregate.getPrincipals().getRealmNames().size()&lt;2){ //是否至少两个通过 throw new AuthenticationException(&quot;Authentication token of type [&quot; +token.getClass()+&quot;]&quot;+&quot;could not be authenticated by any configured realms.Please ensure that at least two realm can authenticate these tokens.&quot;); } //这一步即父类方法体 return aggregate; } } OnlyOneAuthenticatorStrategy：至少一个通过，重写的是afterAttempt() @Override public AuthenticationInfo afterAttempt(Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException { AuthenticationInfo info; if(singleRealmInfo == null){ //若当前身份凭证为空，说明未通过认证 info=aggregateInfo; //返回之前的身份凭证集合 }else{ //否则需要加入集合 if(aggregateInfo==null){ //若集合为空，则返回当前的身份凭证 info=singleRealmInfo; }else{ //两个都不为空才需要加入集合 info=merge(singleRealmInfo,aggregateInfo); if(info.getPrincipals().getRealmNames().size()&gt;1){ System.out.println(info.getPrincipals().getRealmNames()); //打印集合 throw new AuthenticationException(&quot;Authentication token of type [&quot; +token.getClass()+&quot;]&quot;+&quot;could not be authenticated by any configured &quot; + &quot;realms. Please ensure that only one realm can authenticated &quot; + &quot;these tokens&quot;); } } } return info; } 代码实例：ideaProjects/shiroHelloWord/authenticationstrategy 张开涛跟我学shiro第二章源码","categories":[],"tags":[]},{"title":"","slug":"Shiro第二十章-无状态web应用集成","date":"2019-04-30T08:29:22.964Z","updated":"2019-04-09T08:19:58.072Z","comments":true,"path":"2019/04/30/Shiro第二十章-无状态web应用集成/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第二十章-无状态web应用集成/","excerpt":"","text":"简介 在一些环境中，可能需要把web应用做成无状态的，即服务端无状态，也就是说服务端不会存储像会话这种东西，而是每次请求时带上相应的用户名进行登录。 如不使用OAuth2协议来实现，则可以使用REST+HMAC认证。 REST-HMAC：Hash-based Messager Authentication Code,基于散列的消息认证码。使用一个密钥（只有客户端和服务端知道）和一个消息作为输入，生成它们的消息摘要。访问时使用该消息摘要进行传播，服务端对该消息摘要进行验证。 如果以用户名+密码生成消息摘要，一旦被别人而重复使用该摘要进行验证，解决办法如下： 客户端每次申请一个Token，使用该Token进行加密，而该Token是一次性的； 客户端每次生成一个唯一的token，使用该Token进行加密，服务器端记录下这些token，如果之前用过就认为是非法请求。 本例直接用请求的参数生成消息摘要，即无法篡改数据，虽然可能被窃取而多次使用，不过解决方法如上所示。 服务器端 控制用户登录时不建立会话，而是每次请求带上用户身份进行认证。 禁止建立会话 StatelessDefaultSubjectFactory：自定义Subject工厂，禁止建立会话。 public class StatelessDefaultSubjectFactory extends DefaultWebSubjectFactory { @Override public Subject createSubject(SubjectContext context){ //不创建session,之后调用Subject.getSession()将抛出DisabledSessionException context.setSessionCreationEnabled(false); return super.createSubject(context); } } spring-config-shiro.xml: 注册并使用该Subject工厂。 &lt;!--Subject工厂: 继承DefaultWebSubjectFactory，禁止建立会话--&gt; &lt;bean id=&quot;subjectFactory&quot; class=&quot;StatelessDefaultSubjectFactory&quot;/&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;statelessRealm&quot;/&gt; &lt;property name=&quot;subjectDAO.sessionStorageEvaluator.sessionStorageEnabled&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;subjectFactory&quot; ref=&quot;subjectFactory&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; 认证 StatelessAuthcFilter：拦截每次请求进行认证。主要是获取请求中包含的用户名、参数和消息摘要，封装成token，然后传给realm进行认证。 public class StatelessAuthcFilter extends AccessControlFilter { @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return false; } /** * @Author haien * @Description 获取客户端传入的用户名、参数和消息摘要，生成StatelessToken， 然后交给realm登录（实际是认证）。 * @Date 2019/4/8 * @Param [request, response] * @return boolean **/ @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { //1. 获取客户端生成的消息摘要 String clientDigest=request.getParameter(Constants.PARAM_DIGEST); //2. 获取客户端传入的用户身份 String username=request.getParameter(Constants.PARAM_USERNAME); //3. 获取客户端请求的参数列表 Map&lt;String,String[]&gt; params=new HashMap&lt;&gt;(request.getParameterMap()); params.remove(Constants.PARAM_DIGEST); //4. 封装成无状态Token StatelessToken token=new StatelessToken(username,params,clientDigest); //5. 委托给realm进行登录，准确说是认证 try { getSubject(request, response).login(token); }catch (Exception e){ e.printStackTrace(); //6. 认证失败处理 onLoginFail(response); return false; } //认证成功返回true，执行其他过滤链 return true; } private void onLoginFail(ServletResponse response) throws IOException { HttpServletResponse httpResponse=(HttpServletResponse)response; httpResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED); httpResponse.getWriter().write(&quot;login error&quot;); } } 其中用到的token类为StatelessToken： /** * @Author haien * @Description 将客户端传来的用户信息、请求参数和消息摘要封装成无状态Token * @Date 2019/4/8 **/ public class StatelessToken implements AuthenticationToken { private String username; private Map&lt;String,?&gt; params; private String clientDigest; //全参构造器 @Override public Object getPrincipal() { return username; } @Override public Object getCredentials() { return clientDigest; } //getter、setter } StatelessRealm：自定义realm实现认证，主要是服务端自己生成消息摘要，再配合用户名封装成AuthenticationInfo，跟token比对。其实和之前用户名+密码生成的Info、token相比，也只是把密码换成了消息摘要而已。 public class StatelessRealm extends AuthorizingRealm { //supports、doGetAuthorizationIfo方法 /** * @Author haien * @Description 服务端利用用户名和请求参数生成消息摘要，与客户端消息摘要匹配， 以此作为身份验证； 缺点是一旦别人截获请求，则可以重复请求。 * @Date 2019/4/8 * @Param [token] * @return org.apache.shiro.authc.AuthenticationInfo **/ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { StatelessToken statelessToken=(StatelessToken)token; String username=statelessToken.getUsername(); //根据用户名获取密钥（和客户端一样） String key=getKey(username); //在服务器端使用对客户端参数生成消息摘要 String serverDigest=HmacSHA256Utils.digest(key,statelessToken.getParams()); //然后进行客户端消息摘要和服务端消息摘要的匹配 return new SimpleAuthenticationInfo(username,serverDigest,getName()); } /** * @Author haien * @Description 获取服务端密钥，此处硬编码一个 （原本应该是有一套和客户端一致的算法的） * @Date 2019/4/8 * @Param [username] * @return java.lang.String **/ private String getKey(String username){ if(&quot;admin&quot;.equals(username)) return &quot;dadadswdewq2ewdwqdwadsadasd&quot;; return null; } } spring-config-shiro.xml: 配置以上过滤器和realm。 &lt;!-- Realm实现 --&gt; &lt;bean id=&quot;statelessRealm&quot; class=&quot;com.haien.chapter20.realm.StatelessRealm&quot;&gt; &lt;!--默认应该是true--&gt; &lt;property name=&quot;cachingEnabled&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;statelessRealm&quot;/&gt; &lt;property name=&quot;subjectDAO.sessionStorageEvaluator.sessionStorageEnabled&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;subjectFactory&quot; ref=&quot;subjectFactory&quot;/&gt; &lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;/&gt; &lt;/bean&gt; &lt;!--拦截每次请求做身份认证，因为要截获的参数不止表单参数， 所以不能直接用FormAuthenticationFilter--&gt; &lt;bean id=&quot;statelessAuthcFilter&quot; class=&quot;com.haien.chapter20.filter.StatelessAuthcFilter&quot;/&gt; &lt;!-- Shiro的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;statelessAuthc&quot; value-ref=&quot;statelessAuthcFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /** = statelessAuthc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 测试 依赖： &lt;!--jetty服务器，可代替tomcat--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-server&lt;/artifactId&gt; &lt;version&gt;8.1.8.v20121106&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;version&gt;8.1.8.v20121106&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; ClientTest：准备服务器，模拟客户端发起请求。 public class ClientTest { private static Server server; private RestTemplate restTemplate=new RestTemplate(); /** * @Author haien * @Description 在整个测试开始之前启动服务器 * @Date 2019/4/9 * @Param * @return **/ @BeforeClass //在整个测试开始之前执行 public static void beforeClass() throws Exception { //创建一个Server server=new Server(8080); WebAppContext context=new WebAppContext(); String webappPath=&quot;./src/main/webapp&quot;; context.setDescriptor(webappPath+&quot;/WEB/INF/web.xml&quot;); //指定web.xml配置文件 context.setResourceBase(webappPath); //指定webapp目录 context.setContextPath(&quot;/&quot;); context.setParentLoaderPriority(true); server.setHandler(context); server.start(); } /** * @Author haien * @Description 测试结束后停止服务器 * @Date 2019/4/9 * @Param [] * @return void **/ @AfterClass public static void afterClass() throws Exception { server.stop(); } /** * @Author haien * @Description 测试成功情况 * @Date 2019/4/9 * @Param [] * @return void **/ @Test public void testServiceHelloSuccess(){ String username=&quot;admin&quot;; String param11=&quot;param11&quot;; String param12=&quot;param12&quot;; String param2=&quot;param2&quot;; String key=&quot;dadadswdewq2ewdwqdwadsadasd&quot;; //和服务端使用的key一致 //参数必须按照如下顺序，否则客户端会接收不到某个参数 MultiValueMap&lt;String,String&gt; params=new LinkedMultiValueMap&lt;&gt;(); params.add(&quot;param1&quot;,param11); params.add(&quot;param1&quot;,param12); params.add(Constants.PARAM_USERNAME,username); params.add(&quot;param2&quot;,param2); params.add(Constants.PARAM_DIGEST,HmacSHA256Utils.digest(key,params)); //和服务端生成摘要方式一致 //构造url；UriComponentsBuilder需要spring-web依赖 String url=UriComponentsBuilder.fromHttpUrl(&quot;http://localhost:8080/hello&quot;) .queryParams(params).build().toUriString(); //发起请求并获取响应，指定响应体映射为string对象 ResponseEntity responseEntity=restTemplate.getForEntity(url,String.class); Assert.assertEquals(&quot;hello&quot;+param11+param2,responseEntity.getBody()); } /** * @Author haien * @Description 测试失败情况 * @Date 2019/4/9 * @Param [] * @return void **/ @Test public void testServiceHelloFail(){ String username=&quot;admin&quot;; String param11=&quot;param11&quot;; String param12=&quot;param12&quot;; String param2=&quot;param2&quot;; String key=&quot;dadadswdewq2ewdwqdwadsadasd&quot;; //和服务端使用的key一致 MultiValueMap&lt;String,String&gt; params=new LinkedMultiValueMap&lt;&gt;(); params.add(&quot;param1&quot;,param11); params.add(&quot;param1&quot;,param12); params.add(Constants.PARAM_USERNAME,username); params.add(&quot;param2&quot;,param2); params.add(Constants.PARAM_DIGEST,HmacSHA256Utils.digest(key,params)); //和服务端生成摘要方式一致 //篡改请求参数 params.set(&quot;param2&quot;,param2+&quot;1&quot;); //构造url；UriComponentsBuilder需要spring-web依赖 String url=UriComponentsBuilder.fromHttpUrl(&quot;http://localhost:8080/hello&quot;) .queryParams(params).build().toUriString(); //发起请求并获取响应，指定响应体映射为string对象 try { ResponseEntity responseEntity = restTemplate.getForEntity(url, String.class); } catch (HttpClientErrorException e){ Assert.assertEquals(HttpStatus.UNAUTHORIZED,e.getStatusCode()); Assert.assertEquals(&quot;login error&quot;,e.getResponseBodyAsString()); } } } 代码示例：ideaProjects/shiro-chapter20 《跟我学Shiro》第二十章","categories":[],"tags":[]},{"title":"","slug":"Shiro第二十一章-授予身份及切换身份","date":"2019-04-30T08:29:22.946Z","updated":"2019-04-11T07:23:30.405Z","comments":true,"path":"2019/04/30/Shiro第二十一章-授予身份及切换身份/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第二十一章-授予身份及切换身份/","excerpt":"","text":"使用场景 比如某个领导因故不能登录网站进行一些操作，他想把网站上的工作委托给他的秘书，但却不想把账号、密码告诉她。此时我们可以使用Shiro的RunAs功能，即允许一个用户假装成另一个用户的身份进行访问。 示例 示例基于第十六章，主要功能是用户、公司、角色和资源之间关系的调整，如修改用户所属公司、所有角色，资源所需权限、角色所有资源等。 数据库：新增user_runas表，映射原用户与代用户，必须有相应记录才能切换身份。 实体：新增UserRunAs类。 public class UserRunAs implements Serializable { private Long fromUserId;//授予身份帐号A（老板） private Long toUserId;//被授予身份帐号B（秘书） } dao：新增RunAs增删查改方法。 service：新增RunAs增删查改方法。 @Service(&quot;userRunAsService&quot;) public class UserRunAsServiceImpl implements UserRunAsService { @Autowired private UserRunAsDao userRunAsDao; /** * @Author haien * @Description 授予身份，实际就是新增记录 * @Date 2019/4/10 * @Param [fromUserId, toUserId] * @return void **/ @Override public void grantRunAs(Long fromUserId, Long toUserId) { userRunAsDao.grantRunAs(fromUserId, toUserId); } /** * @Author haien * @Description 回收身份，实际就是删除记录 * @Date 2019/4/10 * @Param [fromUserId, toUserId] * @return void **/ @Override public void revokeRunAs(Long fromUserId, Long toUserId) { userRunAsDao.revokeRunAs(fromUserId, toUserId); } /** * @Author haien * @Description 关系存在判断，实际就是查找 * @Date 2019/4/10 * @Param [fromUserId, toUserId] * @return boolean **/ @Override public boolean exists(Long fromUserId, Long toUserId) { return userRunAsDao.exists(fromUserId, toUserId); } /** * @Author haien * @Description 根据秘书查找其代理的老板 * @Date 2019/4/10 * @Param [toUserId] * @return java.util.List&lt;java.lang.Long&gt; **/ @Override public List&lt;Long&gt; findFromUserIds(Long toUserId) { return userRunAsDao.findFromUserIds(toUserId); } /** * @Author haien * @Description 根据老板查找其委托的秘书 * @Date 2019/4/10 * @Param [fromUserId] * @return java.util.List&lt;java.lang.Long&gt; **/ @Override public List&lt;Long&gt; findToUserIds(Long fromUserId) { return userRunAsDao.findToUserIds(fromUserId); } } controller：新增RunAs增删查改方法，真正实现身份切换。 //判断当前用户是否为代理老板 Subject subject = SecurityUtils.getSubject(); //当前用户是老板，但是个代理老板 if(subject.isRunAs()) { //获取之前的身份信息，一个用户可以切换很多身份，之前的身份使用栈存储 String previousUsername = (String)subject.getPreviousPrincipals().getPrimaryPrincipal(); //得到最近一个 } Subject.isRunAs(): 判断当前用户是否是代理得来的身份。 Subject.getPreviousPrincipals()：得到之前的身份，一个用户可多次切换身份，它们被存在栈中，栈顶为最近用过的身份。 @RequestMapping(&quot;/switchTo/{switchToUserId}&quot;) public String switchTo(@CurrentUser User loginUser, //当前用户 @PathVariable(&quot;switchToUserId&quot;) Long switchToUserId, //要切换到的用户 RedirectAttributes redirectAttributes) { //判断当前用户要切换的身份是否为自身 //查找目标用户的身份 User switchToUser = userService.findOne(switchToUserId); //切换 subject.runAs(new SimplePrincipalCollection(switchToUser.getUsername(), &quot;&quot;)); } subject.runAs(PrincipalCollection, realmName): 切换到指定用户。 Subject subject = SecurityUtils.getSubject(); if(subject.isRunAs()) { //切换回上一个身份；如果A切换到B，B又切换到C，那么需要执行两次才能回到A subject.releaseRunAs(); } subject.releaseRunAs()：切换回上一个身份。 测试： 修改数据库，使admin的角色为超管，而zhang无角色，即zhang比admin低。 登录admin账号，点击切换身份，将身份授予用户zhang。 退出，登录账号zhang，点击切换身份，切换到admin，刷新当前页面，原本空白的菜单栏会出现all选项，因为拥有admin的权限了。 《跟我学Shiro》第二十一章","categories":[],"tags":[]},{"title":"","slug":"Shiro第二十三章-多项目集中权限管理及分布式会话","date":"2019-04-30T08:29:22.927Z","updated":"2019-04-27T07:45:23.934Z","comments":true,"path":"2019/04/30/Shiro第二十三章-多项目集中权限管理及分布式会话/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第二十三章-多项目集中权限管理及分布式会话/","excerpt":"","text":"core模块：提供调用接口。 server模块：管理用户、应用和权限。 app模块：各个应用，如一些内部管理系统应用，登录都跳到server登录，权限也从server获取。 部署到nginx 首先修改nginx.conf: 原文是location部分用正则匹配，但是测试报404，所以改成了直接匹配。 #第一个虚拟主机 server { #监听端口 listen 80; #主机名称 server_name localhost; charset utf-8; location /chapter23-server { proxy_pass http://127.0.0.1:8080; index /; proxy_set_header Host $host; } location /chapter23-app1 { proxy_pass http://127.0.0.1:9080; index /; proxy_set_header Host $host; } location /chapter23-app2 { proxy_pass http://127.0.0.1:10080; index /; proxy_set_header Host $host; } 修改后记得nginx -s reload重启。 把server模块部署到tomcat上。 直接localhost/chapter23-server即可访问该应用。 HTTP invoker是一个新的远程调用模型，作为spring框架的一部分，它执行基于http的远程调用。 httpInvokerServiceExporter实现了HttpRequestHandler，故拥有处理http请求的能力。","categories":[],"tags":[]},{"title":"","slug":"Shiro第二十二章-生成验证码","date":"2019-04-30T08:29:22.921Z","updated":"2019-04-25T07:24:36.559Z","comments":true,"path":"2019/04/30/Shiro第二十二章-生成验证码/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第二十二章-生成验证码/","excerpt":"","text":"简介 在实现登录功能时，大多数情况需要验证码支持，目的是防止机器人暴力破解密码。 目前比较简单的验证码通过一些OCR工具就可以解析出来，复杂的验证码（一般通过扭曲、加线条或噪点等干扰）能够防止OCR识别。更复杂的如填字、算数等验证码则需要人工识别。 目前比较可靠的是手机验证码，但是对于用户来说比普通验证码要麻烦得多。 验证码图片可以通过Java提供的图片API实现，也可以借助如JCaptcha（Completely Automated Public Turing Test To Tell Computers adn Humans Apart）这种开源Java类库生成，它提供了常见的扭曲、加线条和噪点等干扰的支持。 示例 基于第十六章，是一个权限管理系统，但本例中后台管理不是主要内容，现新增一个jcaptcha包，放置所有和验证码有关的类，用于实现用户登录时获取验证码和提交表单后校验验证码的功能。 依赖： &lt;!--jcaptcha核心--&gt; &lt;dependency&gt; &lt;groupId&gt;com.octo.captcha&lt;/groupId&gt; &lt;artifactId&gt;jcaptcha&lt;/artifactId&gt; &lt;version&gt;2.0-alpha-1&lt;/version&gt; &lt;/dependency&gt; &lt;!--支持与servlet集成--&gt; &lt;dependency&gt; &lt;groupId&gt;com.octo.captcha&lt;/groupId&gt; &lt;artifactId&gt;jcaptcha-integration-simple-servlet&lt;/artifactId&gt; &lt;version&gt;2.0-alpha-1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 实际能用的依赖如下： &lt;!--jcaptcha验证码工具--&gt; &lt;dependency&gt;&lt;!--jcaptcha核心--&gt; &lt;groupId&gt;com.octo.captcha&lt;/groupId&gt; &lt;artifactId&gt;jcaptcha&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;exclusions&gt; &lt;!--不排除此包，tomcat启动出错--&gt; &lt;exclusion&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; com.octo.captcha jcaptcha-api 1.0 GMailEngine：验证码图片生成引擎，继承自ListImageCaptchaEngine，只需要简单设置以下图片和字体大小等，即可仿照jcaptcha2.0生成类似GMail验证码的样式。 public class GMailEngine extends ListImageCaptchaEngine { @Override protected void buildInitialFactories() { // 图片和字体大小设置 int minWordLength = 4; int maxWordLength = 5; int fontSize = 20; int imageWidth = 100; int imageHeight = 36; WordGenerator dictionnaryWords = new ComposeDictionaryWordGenerator( new FileDictionary(&quot;toddlist&quot;)); // word2image components TextPaster randomPaster = new DecoratedRandomTextPaster(minWordLength, maxWordLength, new RandomListColorGenerator(new Color[]{ new Color(23, 170, 27), new Color(220, 34, 11), new Color(23, 67, 172)}), new TextDecorator[]{}); BackgroundGenerator background = new UniColorBackgroundGenerator( imageWidth, imageHeight, Color.white); FontGenerator font = new RandomFontGenerator(fontSize, fontSize, new Font[]{new Font(&quot;nyala&quot;, Font.BOLD, fontSize), new Font(&quot;Bell MT&quot;, Font.PLAIN, fontSize), new Font(&quot;Credit valley&quot;, Font.BOLD, fontSize)}); ImageDeformation postDef = new ImageDeformationByFilters( new ImageFilter[]{}); ImageDeformation backDef = new ImageDeformationByFilters( new ImageFilter[]{}); ImageDeformation textDef = new ImageDeformationByFilters( new ImageFilter[]{}); WordToImage word2image = new DeformedComposedWordToImage(font, background, randomPaster, backDef, textDef, postDef); addFactory(new GimpyFactory(dictionnaryWords, word2image)); } } MyManageableImageCaptchaService：使用GMailEngine生成验证码图片、比对验证码（每验证一次无论成功与否都会删除该验证码）。 public class MyManageableImageCaptchaService extends DefaultManageableImageCaptchaService { /** * @Author haien * @Description 构造器，生成验证码图片 * @Date 16:08 2019/4/19 * @Param [captchaStore, captchaEngine, minGuarantedStorageDelayInSeconds, maxCaptchaStoreSize, captchaStoreLoadBeforeGarbageCollection] **/ public MyManageableImageCaptchaService(CaptchaStore captchaStore, CaptchaEngine captchaEngine, int minGuarantedStorageDelayInSeconds, int maxCaptchaStoreSize, int captchaStoreLoadBeforeGarbageCollection) { super(captchaStore,captchaEngine,minGuarantedStorageDelayInSeconds, maxCaptchaStoreSize, captchaStoreLoadBeforeGarbageCollection); } /** * @Author haien * @Description 根据会话id获取当前会话的验证码，与用户输入的比对 * @Date 2019/4/11 * @Param [id会话id, userCaptchaResponse用户输入的验证码] * @return boolean **/ public boolean validate(String id,String userCaptchaResponse){ //验证但不删除 return store.getCaptcha(id).validateResponse(userCaptchaResponse); } } JCaptcha：jcaptcha工具类，利用MyManageableImageCaptchaService生成和验证验证码。 public class JCaptcha { public static final MyManageableImageCaptchaService captchaService= new MyManageableImageCaptchaService(new FastHashMapCaptchaStore(), new GMailEngine(),180, 100000,75000); /** * @Author haien * @Description 比对当前请求输入的验证码是否正确， 并从CaptchaService中移除已使用过的验证码 * @Date 2019/4/11 * @Param [request, userCaptchaResponse用户输入的验证码] * @return boolean **/ public static boolean validateResponse(HttpServletRequest request, String userCaptchaResponse){ //为true应该是没有session则新建 if(request.getSession(false)==null) return false; boolean validated=false; try { //获取会话id String id = request.getSession().getId(); //将用户输入的验证码与库存比对，并移除验证码与id（无论正确与否） validated = captchaService.validateResponseForID(id, userCaptchaResponse) .booleanValue(); }catch (CaptchaServiceException e){ e.printStackTrace(); } return validated; } /** * @Author haien * @Description 比对，但不移除验证码，适用于Ajax异步验证， 此时不是真的验证，还不能删除验证码 * @Date 2019/4/11 * @Param [request, userCaptchaResponse] * @return boolean **/ public static boolean validate(HttpServletRequest request, String userCaptchaResponse){ if (request.getSession(false)==null) return false; boolean validated=false; try { String id=request.getSession().getId(); validated=captchaService.validate(id,userCaptchaResponse); }catch (CaptchaServiceException e){ e.printStackTrace(); } return validated; } } JCaptchaFilter：拦截前端的验证码请求，调用JCaptcha工具类生成并向前端写验证码图片。 //保证只执行一次，注：继承的是spring的Filter public class JCaptchaFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,FilterChain chain) throws ServletException, IOException { //响应内容不缓存 response.setDateHeader(&quot;Expires&quot;,0L); response.setHeader(&quot;Cache-Control&quot;,&quot;no-store,no-cache,must-revalidate&quot;); response.addHeader(&quot;Cache-Control&quot;,&quot;post-check=0,pre-check=0&quot;); response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;); response.setContentType(&quot;image/jpeg&quot;); String id=request.getRequestedSessionId(); //captchaService使用当前会话的id作为key获取相应的验证码图片 BufferedImage bi=JCaptcha.captchaService.getImageChallengeForID(id); ServletOutputStream out=response.getOutputStream(); ImageIO.write(bi,&quot;jpg&quot;,out); try { out.flush(); }finally { out.close(); } } } login.jsp: 前端登录页面请求验证码。 //若支持验证码 &lt;c:if test=&quot;${jcaptchaEbabled}&quot;&gt; 验证码： &lt;input type=&quot;text&quot; name=&quot;jcaptchaCode&quot;&gt; &lt;img class=&quot;jcaptcha-btn jcaptcha-img&quot; src=&quot;${pageContext.request.contextPath}/jcaptcha.jpg&quot; title=&quot;点击更换验证码&quot;&gt; &lt;a class=&quot;jcaptcha-btn&quot; href=&quot;javascript:;&quot;&gt;换一张&lt;/a&gt;&lt;br/&gt; &lt;/c:if&gt; &lt;script&gt; $(function() { $(&quot;.jcaptcha-btn&quot;).click(function() { $(&quot;.jcaptcha-img&quot;).attr(&quot;src&quot;, &apos;${pageContext.request.contextPath}/jcaptcha.jpg?&apos; //按钮对应url， //触发JCaptchaFilter +new Date().getTime()); }); }); &lt;/script&gt; web.xml：分配验证码请求给JCaptchaFilter拦截。 &lt;!--验证码过滤器需要放到ShiroFilter之后，因为Shiro将包装HttpSession； 否则可能造成两次的session id不同--&gt; &lt;filter&gt; &lt;filter-name&gt;JCaptchaFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.haien.chapter22.jcaptcha.JCaptchaFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;JCaptchaFilter&lt;/filter-name&gt; &lt;!--前台登录页面点击“获取验证码”，其url为此，则执行该过滤链， 生成验证码图片并写到客户端--&gt; &lt;url-pattern&gt;/jcaptcha.jpg&lt;/url-pattern&gt; &lt;/filter-mapping&gt; JCaptchaValidateFilter：拦截验证码验证请求的拦截器，主要是调用JCaptcha工具类进行验证。 public class JCaptchaValidateFilter extends AccessControlFilter { //是否开启验证码支持 private boolean jcaptchaEnabled=true; //前台提交的验证码参数名 private String jcaptchaParam=&quot;jcaptchaCode&quot;; //验证失败后存储到的属性名 private String failureKeyAttribute=&quot;shiroLoginFailure&quot;; public void setJcaptchaEnabled(boolean jcaptchaEnabled) { this.jcaptchaEnabled = jcaptchaEnabled; } public void setJcaptchaParam(String jcaptchaParam) { this.jcaptchaParam = jcaptchaParam; } public void setFailureKeyAttribute(String failureKeyAttribute) { this.failureKeyAttribute = failureKeyAttribute; } /** * @Author haien * @Description 验证验证码 * @Date 2019/4/19 * @Param [request, response, mappedValue] * @return boolean **/ @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { //1. 设置验证码是否开启属性，页面据此决定是否显示验证码 request.setAttribute(&quot;jcaptchaEnabled&quot;,jcaptchaEnabled); //将HttpServlet的request转为HttpServlet类型 HttpServletRequest httpServletRequest=WebUtils.toHttp(request); //2. 判断验证码是否禁用|不是由表单提交的 if(jcaptchaEnabled==false || ! &quot;post&quot;.equalsIgnoreCase(httpServletRequest.getMethod())){ //则不用验证，直接结束 return true; } //3. 验证 验证码,正确则返回true，否则false return JCaptcha.validateResponse(httpServletRequest, httpServletRequest.getParameter(jcaptchaParam)); } /** * @Author haien * @Description 验证失败处理 * @Date 2019/4/19 * @Param [request, response] * @return boolean **/ @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { //若验证失败，则存储failureKeyAttribute属性；可通过getFailureKeyAttribute()获取 request.setAttribute(failureKeyAttribute,&quot;jCaptcha.error&quot;); return true; } } MyFormAuthenticationFilter：继承FormAuthenticationFilter，自定义身份验证拦截器，主要是增加验证码错误情况下不验证身份的条件。 public class MyFormAuthenticationFilter extends FormAuthenticationFilter { @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { //若为登录请求，无论登录与否，直接进入onAccessDenied if(isLoginRequest(request,response)) return false; return super.isAccessAllowed(request, response, mappedValue); } @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { //验证码错误则直接返回，不用身份验证了 if(request.getAttribute(getFailureKeyAttribute()) != null) return true; return super.onAccessDenied(request,response,mappedValue); } } spring-config-shiro.xml: &lt;!-- 基于Form表单的身份验证过滤器 --&gt; &lt;bean id=&quot;authcFilter&quot; class=&quot;com.haien.chapter22.jcaptcha.MyFormAuthenticationFilter&quot;&gt; &lt;property name=&quot;usernameParam&quot; value=&quot;username&quot;/&gt; &lt;property name=&quot;passwordParam&quot; value=&quot;password&quot;/&gt; &lt;property name=&quot;rememberMeParam&quot; value=&quot;rememberMe&quot;/&gt; &lt;property name=&quot;failureKeyAttribute&quot; value=&quot;shiroLoginFailure&quot;/&gt;&lt;!--值同JCaptchaValidateFilter--&gt; &lt;/bean&gt; &lt;bean id=&quot;JCaptchaValidateFilter&quot; class=&quot;com.haien.chapter22.jcaptcha.JCaptchaValidateFilter&quot;&gt; &lt;property name=&quot;jcaptchaEnabled&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;jcaptchaParam&quot; value=&quot;jcaptchaCode&quot;/&gt; &lt;property name=&quot;failureKeyAttribute&quot; value=&quot;shiroLoginFailure&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;sysUserFilter&quot; class=&quot;com.haien.chapter22.web.shiro.filter.SysUserFilter&quot;/&gt; &lt;!-- Shiro的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;authc&quot; value-ref=&quot;authcFilter&quot;/&gt; &lt;entry key=&quot;sysUser&quot; value-ref=&quot;sysUserFilter&quot;/&gt; &lt;entry key=&quot;JCaptchaValidate&quot; value-ref=&quot;JCaptchaValidateFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;!--其实第一行可以不配置，因为spring-mvc.xml已经映射了静态资源？--&gt; &lt;value&gt; /static/**=anon /jcaptcha*=anon /login = JCaptchaValidate,authc /logout = logout /authenticated = authc /** = user,sysUser &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 测试：访问http://localhost:8080/chapter22，将重定向到登录页面，显示验证码图片，点击可换一张。输入验证码，错误则返回登录页面，并提示验证码错误。 代码示例：ideaProjects/shiro-chapter22 《跟我学Shiro》第二十二章","categories":[],"tags":[]},{"title":"","slug":"Shiro第八章一-拦截器机制","date":"2019-04-30T08:29:22.911Z","updated":"2019-04-28T13:14:46.456Z","comments":true,"path":"2019/04/30/Shiro第八章一-拦截器机制/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第八章一-拦截器机制/","excerpt":"","text":"拦截器 NameableFilter: 给Filter起了名字，如果没有设置默认就是FilterName；之前的authc就是，当我们组装拦截器链时会根据这个名字找到相应的拦截器实例。 OncePerRequestFilter：防止多次执行Filter，也就是说一次请求只走一次拦截器链（比如一个非法请求过了一次拦截器后被强制转到登录请求，则此登录请求直接映射到处理类上，而不会再走一次拦截器链判断是否有权限或已登录。另外提供enable属性，默认true表示开启该拦截器实例，如果不想让某个拦截器工作，可以直接设置为false。 ShiroFilter:是整个Shiro的入口点，用于拦截需要安全控制的请求进行处理。在其中设置loginUrl后会自动设置到所有的AccessControllerFilter。 AdviceFilter：提供了aop风格的支持。 /* * 调用下面方法的总方法 */ public void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { Exception exception = null; try { //返回true则继续执行过滤链，返回false则执行一些必要的善后即可， //如跳转到登录页面并返回false，则不需要执行过滤链了 boolean continueChain = preHandle(request, response); //调用onPreHandle() if (continueChain) { //chain收集了为该请求配置的all过滤器，该方法将继续执行后续过滤器 executeChain(request, response, chain); } postHandle(request, response); } catch (Exception e) { exception = e; } finally { cleanup(request, response, exception); } } //在过滤链执行前调用，返回true则继续过滤链，否则中断后续的过滤链直接返回。 //进行预处理，比如身份验证、授权 boolean preHandle(ServletRequest request, ServletResponse response) throws Exception； //在过滤链执行后调用，如记录执行时间。 void postHandle(ServletRequest request, ServletResponse response) throws Exception； //类似于aop中的后置最终增强，即不管有没有异常都会执行 //如清理资源（解除Subject与线程的绑定等） void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception; PathMatchingFilter：提供了基于Ant风格的请求路径匹配功能及拦截器参数解析的功能，如”roles[admin,user]”自动根据“,”分割解析到一个路径参数配置并绑定到相应的路径。 //用于path与请求路径进行匹配，匹配则返回true boolean pathsMatch(String path, ServletRequest request) //在preHandle中，当pathsMatch匹配一个路径后，会调用onPreHandle方法并将路径绑定参数配置 //传给mappedValue, //然后可以在该方法中进行一些验证（如权限验证），验证失败返回false中断流程，默认返回true； //也即是子类可以只实现onPreHandle即可，无需实现preHandle()。 //如果没有path与请求路径匹配，默认是通过的（即preHandle返回true）。 boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception AccessControllerFilter：提供了访问控制的基础功能，比如什么情况允许访问或什么情况拒绝访问。 //何时允许访问；mappedValue就是ini配置文件中[urls]中拦截器参数部分，允许则返回true； //返回true则不会再执行onAccessDenied。 abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception; //何时拒绝访问；返回值表示是否需要继续处理，true表示还要继续处理，可能会返回默认地址； //否则直接返回即可（如，发现用户未登录故拒绝访问当前页面，但已重定向到登录页面， //故不需要继续处理了，直接返回即可）。 boolean onAccessDenied(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception; //同上，onPreHandle会自动调用这俩方法决定是否继续处理。 abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception; boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue); } 还提供了处理登录成功后或重定向到上一个请求的方法： void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp String getLoginUrl() Subject getSubject(ServletRequest request, ServletResponse response) //获取Subject实例 boolean isLoginRequest(ServletRequest request, ServletResponse response) //当前请求是否是登录请求 void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response) throws IOException； //将当前请求保存起来并重定向到登录页面 void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求 void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面 如果我们想控制访问可以继承AccessControllerFilter，要添加一些通用数据可以继承PathMatchingFilter。 AuthenticationFilter：继承自AccessControllerFilter，又有AuthenticatingFilter子类，然后是基于表单的拦截器FormAuthenticationFilter。 protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { //判断是否已身份验证 Subject subject = getSubject(request, response); return subject.isAuthenticated(); } //onAccessDenied()只让最底层的类实现，其他父类只提供abstract接口。 以上isAccessAllowed()的bug是，如果用户已登录但还是请求再次登录，那么在执行此方法时将会被直接返回，最后分发到/login的controller进行失败处理，从而重新回到登录页面，导致死循环。因此，最好再加上判断请求是否为登录请求，不是才返回true。 代码示例：ideaProjects/shiro-chapter22/jcaptcha/MyFormAuthenticationFilter AuthorizationFilter：同样继承自AccessControllerFilter。 FormAuthenticationFilter：AccessControllerFilter间接子类。 拦截器调用链 从高到低： AbstractShiroFilter.executeChain(): 开始过滤链。 PathMatchingChainResolver.getExecutionChain(): 获取过滤链，如，/** = kickout,user,sysUser配置了三个过滤链；doFilter(): 执行第一个拦截器。 doFilterInternal()：由doFilter()调用；调用preHandle()，返回true则调用executeChain()继续执行下一拦截器。 AdviceFilter.executeChain()：执行下一拦截器。 doFilter()：开始执行。 FormAuthenticationFilter调用链 扩展上面第3步，调用链从高级到低级： PathMatchingFilter.preHandle()：访问某url，ShiroFilter拦截该url，调用该方法判断它指定了哪个Filter，然后这个Filter实现了哪些方法就执行哪些方法。 AccessControlFilter.onPreHandle()：如果实现了该方法的话，它将会调用isAccessAllow()和onAccessDenied()，但通常是直接让前者返回false，主要的验证逻辑放在后者实现；或者主要研验证逻辑放在前者实现，后者做响应的校验失败处理，比如把失败信息存入request。 FormAuthenticationFilter.onAccessDenied()：在需要权限的方法执行前调用，而不是被拒绝访问后才执行，不要望文生义。比如判断用户是否已登录，未登录则重定向至登录页面，正在登录则调用以下login()接收表单验证，已登录则继续过滤链，最终访问到目标方法。 DelegatingSubject.login() ModularRealmAuthenticator.doAuthenticate() UserRealm.doGetAuthenticationInfo()，若为自定义Realm而是使用ini配置文件准备了用户库的话，那就是调用那个Realm了。 也就是说FormAuthenticationFilter是会调用login()的，而login()又会调用Realm，所以FormAuthenticationFilter的登录验证是通过Realm实现的。 拦截器链 Shiro通过ProxiedFilterChain对Servlet容器的FilterChain进行了代理，它会先执行Shiro自己的Filter链，再执行Servlet容器原始的Filter链。 //传入原始的chain得到一个代理的chain。 FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain); DefaultFilterChainManager：FilterChainManager实现类，维护着拦截器链。默认包含如下拦截器： public enum DefaultFilter { anon(AnonymousFilter.class), authc(FormAuthenticationFilter.class), authcBasic(BasicHttpAuthenticationFilter.class), logout(LogoutFilter.class), noSessionCreation(NoSessionCreationFilter.class), perms(PermissionsAuthorizationFilter.class), port(PortFilter.class), rest(HttpMethodPermissionFilter.class), roles(RolesAuthorizationFilter.class), ssl(SslFilter.class), user(UserFilter.class); } 另外还提供了一个org.apache.shiro.web.filter.authz.HostFilter，即主机拦截器，其提供了属性authorizedIps：已授权的ip，deniedIps:拒绝的ip。不过目前尚未完全实现，不可用。 如果不想启用某个拦截器可以直接在ini禁用： perms.enabled=false FilterChainResolver FilterChainResolver：将url与同名拦截器对应起来。Shiro提供了PathMatchingFilterChainResolver实现类，其根据[urls]中的url解析得到相应的拦截器链（其内部通过FilterChainManager维护着拦截器链）。因此可自定义FilterChainResolver来动态实现url-拦截器的注册。 如果要注册自定义FilterChainResolver，IniSecurityManagerFactory或WebIniSecurityManagerFactory会自动扫描ini配置文件中的[filters]/[main]部分并注册这些拦截器到DefaultFilterChainManager。 /** * 通过实现WebEnvironment接口完成自定义FilterChainResolver */ public class MyIniWebEnvironment extends IniWebEnvironment { @Override protected FilterChainResolver createFilterChainResolver() { //1、创建FilterChainResolver PathMatchingFilterChainResolver filterChainResolver =new PathMatchingFilterChainResolver(); //2、创建FilterChainManager DefaultFilterChainManager filterChainManager = new DefaultFilterChainManager(); //3、注册基本的Filter for(DefaultFilter filter : DefaultFilter.values()) { filterChainManager.addFilter( filter.name(), (Filter) ClassUtils.newInstance(filter.getFilterClass())); } //4、注册URL-Filter的映射关系 filterChainManager.addToChain(&quot;/login.jsp&quot;, &quot;authc&quot;); filterChainManager.addToChain(&quot;/unauthorized.jsp&quot;, &quot;anon&quot;); filterChainManager.addToChain(&quot;/**&quot;, &quot;authc&quot;); filterChainManager.addToChain(&quot;/**&quot;, &quot;roles&quot;, &quot;admin&quot;); //5、设置Filter的属性 FormAuthenticationFilter authcFilter = (FormAuthenticationFilter)filterChainManager.getFilter(&quot;authc&quot;); authcFilter.setLoginUrl(&quot;/login.jsp&quot;); RolesAuthorizationFilter rolesFilter = (RolesAuthorizationFilter)filterChainManager.getFilter(&quot;roles&quot;); rolesFilter.setUnauthorizedUrl(&quot;/unauthorized.jsp&quot;); filterChainResolver.setFilterChainManager(filterChainManager); return filterChainResolver; } } 在web.xml中配置该Environment： &lt;context-param&gt; &lt;param-name&gt;shiroEnvironmentClass&lt;/param-name&gt; &lt;param-value&gt; com.github.zhangkaitao.shiro.chapter8.web.env.MyIniWebEnvironment &lt;/param-value&gt; &lt;/context-param&gt; 代码实例：ideaProjects/shiroChapter8 参考文章 web项目的拦截器链配置 若果定义多个同url的拦截器链，那么Shiro会将其合并，也就是说都有效；但如果当前请求匹配多条拦截器链的话，就只有第一个有效。 &lt;!-- Shiro的Web过滤器 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;property name=&quot;filters&quot;&gt; &lt;util:map&gt; &lt;entry key=&quot;statelessAuthc&quot; value-ref=&quot;statelessAuthcFilter&quot;/&gt; &lt;/util:map&gt; &lt;/property&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /login.jsp = authc /logout = logout /** = statelessAuthc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;","categories":[],"tags":[]},{"title":"","slug":"Shiro第八章二-自定义拦截器","date":"2019-04-30T08:29:22.891Z","updated":"2019-04-28T06:17:00.497Z","comments":true,"path":"2019/04/30/Shiro第八章二-自定义拦截器/","link":"","permalink":"http://47.107.237.149/2019/04/30/Shiro第八章二-自定义拦截器/","excerpt":"","text":"自定义拦截器 自定义拦截器可以扩展一些功能，如，从Subject获取用户身份信息绑定到Request、验证码验证、在线用户信息的保存等。 扩展OncePerRequestFilter OncePerRequestFilter保证请求只调用一次doFilterInternal()。 public class MyOncePerRequestFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException { System.out.println(&quot;once per request filter&quot;); chain.doFilter(request, response); } } shiro.ini: 指定拦截器为自定义拦截器 [main] ;注册Filter myFilter1=com.haien.shiroChapter8.web.filter.MyOncePerRequestFilter ;或在这里注册 #[filters] #myFilter1=com.haien.shiroChapter8.web.filter.MyOncePerRequestFilter ;然后在urls配置url与filter的映射关系即可 [urls] ;访问任意url，后台调用myFilter1拦截器，该拦截器在控制台打印一行字 /**=myFilter1 扩展AdviceFilter 提供了aop的功能。其中preHandle()返回false将中断后续拦截器链的执行。 public class MyAdviceFilter extends AdviceFilter { //根据返回值决定是否继续处理，true：继续过滤过滤链，可以通过它实现权限控制。 @Override protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception { System.out.println(&quot;====预处理/前置处理====&quot;); //返回false将中断后续拦截器链的执行 return true; } //执行完过滤器后正常返回则调用该方法。 @Override protected void postHandle(ServletRequest request, ServletResponse response) throws Exception { System.out.println(&quot;====后处理/后置返回处理====&quot;); } //不过最后有没有异常都会执行，完成如清理资源等功能。 @Override public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception { System.out.println(&quot;====完成处理/后置最终处理====&quot;); } } shiro.ini [filters] myFilter1=com.haien.shiroChapter8.web.filter.MyOncePerRequestFilter myFilter2=com.haien.shiroChapter8.web.filter.MyAdviceFilter [urls] /**=myFilter1,myFilter2 运行结果 扩展PathMatchingFilter 继承了AdviceFilter，提供了url模式过滤的功能，适用于需要对指定请求进行处理的情况。 public class MyPathMatchingFilter extends PathMatchingFilter { @Override protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { System.out.println(&quot;url matches,config is &quot; + Arrays.toString((String[])mappedValue)); return true; } } preHandle：将当前url与已有url进行匹配，成功则调用onPreHandle()；否则直接返回true。 onPreHandle: 被调用后获取ini配置文件中为拦截器配置的参数，默认什么都不处理直接返回true。 shiro.ini [filters] myFilter3=com.github.zhangkaitao.shiro.chapter8.web.filter.MyPathMatchingFilter [urls] /**= myFilter3[config] config：拦截器的参数，指定权限或角色，多个参数用逗号分隔。onPreHandle使用mappedVaule接收该参数。 打印结果：url matches,config is null 扩展AccessControllerFilter 继承了PathMatchingFilter，扩展了两个方法： public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue); } isAccessAllowed：是否允许访问，返回true表示允许。 onAccessDenied：拒绝访问时是否需要继续处理，返回true表示是，则返回上一级调用链，继续过滤链执行，false不用继续处理了，已在方法内处理好了（如重定向到另一个页面，也就不能继续执行过滤链）。 这俩方法的实现有两种模型： isAccessAllowed直接返回false，然后校验逻辑全在onAccessDenied实现。会在需要权限的方法执行前调用这俩，比如判断用户是否已登录，未登录则重定向至登录页面，正在登录则调用以下login()接收表单验证，已登录则继续过滤链，最终访问到目标方法。 isAccessAllowed实现校验逻辑，onAccessDenied做校验失败处理，如，把失败信息存入request。代码示例：ideaProjects/shiro-chapter22/jcaptcha/JCaptchaValidateFilter 自定义AccessControllerFilter： /** * @Author haien * @Description 以下两个方法同时被onPreHandle()调用 * @Date 2019/3/1 **/ public class MyAccessControlFilter extends AccessControlFilter { /** * @Author haien * @Description 是否允许访问，true表示允许 * @Date 2019/3/1 * @Param [request, response, mappedValue] * @return boolean **/ @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { System.out.println(&quot;access allowed&quot;); return true; } /** * @Author haien * @Description 拒绝访问时是否自己处理，返回true表示自己不处理且继续执行拦截器， * false表示自己已经处理了（如重定向到另一页面） * @Date 2019/3/1 * @Param [request, response] * @return boolean **/ @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { //访问未被拒绝的话不会执行该方法 System.out.println(&quot;访问拒绝也不自己处理，继续拦截器链的执行&quot;); return true; /*or ...重定向到另一页面... return false； */ } } shiro.ini: [filters] myFilter4=com.haien.shiroChapter8.web.filter.MyAccessControlFilter [urls] /**=myFilter4 打印结果：access allowed 基于表单的拦截器 之前我们已经接触过Shiro内置的基于表单的拦截器了，具体事例参见笔记：Shiro第七章-与web集成。其实就是截获表单、封装成token传给Subject.login(token)执行登录而已。 现在我们自定义一个： public class FormLoginFilter extends PathMatchingFilter { private String loginUrl = &quot;/login.jsp&quot;; private String successUrl = &quot;/&quot;; /** * 总方法 */ @Override protected boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { //1、判断是否已登录且非登录请求，是则直接进入过滤链下一步 if(SecurityUtils.getSubject().isAuthenticated() &amp;&amp; !isLoginRequest(req)) { return true;//已经登录过且非登录请求 } //2、未登录则判断是否为登录请求，是，则若是get请求，继续过滤链（跳转登录 //页面），若是post请求，认为是表单验证请求，进行表单验证，执行subject.login()； //否，若是get方法的其他页面请求则保存当前请求并重定向到登录页面，非get请求可能报错吧 HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if(isLoginRequest(req)) { //是登录请求 if(&quot;post&quot;.equalsIgnoreCase(req.getMethod())) { //form表单提交 boolean loginSuccess = login(req); //登录 if(loginSuccess) { //登录成功 return redirectToSuccessUrl(req, resp); } } //是get请求|登录失败，继续过滤器链，可能是被分配到controller处理/login return true; } else { //不是登录请求，保存当前地址并重定向到登录界面 saveRequestAndRedirectToLogin(req, resp); return false; } } /** * 登录成功后调用，若有之前的请求则重定向到它，否则到默认成功页面 */ private boolean redirectToSuccessUrl(HttpServletRequest req, HttpServletResponse resp) throws IOException { WebUtils.redirectToSavedRequest(req, resp, successUrl); return false; } /** * 保存当前请求并跳转登录页面 */ private void saveRequestAndRedirectToLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException { WebUtils.saveRequest(req); WebUtils.issueRedirect(req, resp, loginUrl); } /** * 表单验证，执行登录方法 */ private boolean login(HttpServletRequest req) { String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); try { SecurityUtils.getSubject().login(new UsernamePasswordToken( username, password)); } catch (Exception e) { req.setAttribute(&quot;shiroLoginFailure&quot;, e.getClass()); return false; } return true; } /** * 判断是否登录请求 */ private boolean isLoginRequest(HttpServletRequest req) { return pathsMatch(loginUrl, WebUtils.getPathWithinApplication(req)); } } 第一步，直接结束的前提除了是否已登录，还要有是否为登录请求，可能用户已登录但仍然进入登录页面重新登录；否则直接返回后被前端url为/login的controller处理，而该controller只负责失败处理，会重新重定向到登录页面，导致死循环。 表单验证和登录成功的重定向已经实现了，剩下的就是请求登录页面的get请求和登录失败的处理需要自己在controller中实现。 也可以继承AuthenticatingFilter来实现，它提供了很多登录相关的基础代码。另外可以参考Shiro内置FormAuthenticationFilter源码，思路是一样的。 测试：访问/test.jsp,自动跳转登录页面，登录成功后跳回test.jsp。 任意角色授权拦截器 Shiro内置的roles（RolesAuthorizationFilter）拦截器验证用户是否拥有指定的所有角色，但没有提供能验证用户拥有任意角色的拦截器。 我们自定义一个： public class AnyRolesFilter extends AccessControlFilter { private String unauthorizedUrl = &quot;/unauthorized.jsp&quot;; private String loginUrl = &quot;/login.jsp&quot;; /** * 权限验证 */ protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception { String[] roles = (String[])mappedValue; //如果没有设置角色参数，默认成功 if(roles == null) { return true; } //判断用户是否拥有所需权限 for(String role : roles) { if(getSubject(request, response).hasRole(role)) { //未登录情况获取不到任何角色 return true; } } //拒绝访问 return false;//跳到onAccessDenied处理 } @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { Subject subject = getSubject(request, response); //未登录 if (subject.getPrincipal() == null) { //重定向到登录页面 saveRequest(request); WebUtils.issueRedirect(request, response, loginUrl); } //已登录但授权失败 else { //如果有未授权页面跳转过去 if (StringUtils.hasText(unauthorizedUrl)) { WebUtils.issueRedirect(request, response, unauthorizedUrl); } //否则返回401未授权状态码 else { WebUtils.toHttp(response).sendError(HttpServletResponse.SC_UNAUTHORIZED); } } return false; } } 401 可以在web.xml指定方法返回401时映射的错误页面 &lt;error-page&gt; &lt;error-code&gt;401&lt;/error-code&gt; &lt;location&gt;/unauthorized.jsp&lt;/location&gt; &lt;/error-page&gt; 代码实例：ideaProjects/shiroChapter8 参考文章","categories":[],"tags":[]},{"title":"","slug":"最小生成树","date":"2019-04-30T08:25:46.573Z","updated":"2018-06-08T06:10:29.660Z","comments":true,"path":"2019/04/30/最小生成树/","link":"","permalink":"http://47.107.237.149/2019/04/30/最小生成树/","excerpt":"","text":"概念 首先它得是一棵树，是树就说明它没有回路，并且有V个顶点就一定有V-1条边。 其次它还得是生成树，生成树指的是包含V个顶点、V-1条边且再加一条边就会出现回路的图。 最后必须保证它的权重和最小。 最小生成树存在 等价于 图连通","categories":[],"tags":[]},{"title":"","slug":"自定义异常类","date":"2019-04-30T08:25:46.570Z","updated":"2018-07-30T04:17:21.408Z","comments":true,"path":"2019/04/30/自定义异常类/","link":"","permalink":"http://47.107.237.149/2019/04/30/自定义异常类/","excerpt":"","text":"作用 在代码中使用自定义的异常类，可以对异常进行统一的封装处理，使得整个项目的异常处理更规范、更统一、更优雅。同时，使得日志的记录上更加清晰，便于后续查看日志定位问题。步骤 需要自定义异常类，继承自系统的异常类。具体需要什么样类型的异常类，就继承自 相应的系统类。 如果你想写一个检查性异常，则需要继承自Exception类 如果你想写一个运行时异常，需要继承自RuntimeException public class BusinessException extends Exception { private int errCode; private String errMsg; //无参构造 public BusinessException() { } //错误描述和错误代码 public BusinessException(int errCode, String errMsg) { super(errMsg); this.errCode = errCode; this.errMsg = errMsg; } public int getErrCode() { return errCode; } public String getErrMsg() { return errMsg; } } 在需要抛出该异常的类或方法中，定义当出现异常时抛出自定义异常类。 if(!matche){ //抛出一个自定义异常给上级，由方法调用者捕获 throw new BusinessException(ReturnCode.CODE_FAIL,&quot;电话格式错误！&quot;); //异常一抛，方法结束 } 在使用到该类或方法的地方捕捉该异常(或继续抛出，交给上级去处理)，并对异常进行业务相关的响应与处理。 try { result=resolveExcelService.resolveExcel(file); } catch (BusinessException e) { //捕获异常 e.printStackTrace(); //后台打印 return ApiResponse.failOf(-1,e.getErrMsg()); //这个类能在前端展示异常类的错误描述 } 代码实例 SpringMvc02/controller/ResolveExcelController,domain/ApiResponexcelse、BusinessException,service/ResolveExcelServiceImpl、ResolveExcelService","categories":[],"tags":[]},{"title":"","slug":"自定义属性","date":"2019-04-30T08:25:46.562Z","updated":"2018-07-16T02:32:16.200Z","comments":true,"path":"2019/04/30/自定义属性/","link":"","permalink":"http://47.107.237.149/2019/04/30/自定义属性/","excerpt":"","text":"application.properties提供自定义属性的支持，这样我们就可以把一些常量配置在这里。 绑定属性 启动工程访问localhost:8080，打印：嘟嘟MD，祝大家鸡年大吉吧！绑定bean 有时属性太多，一个一个绑定太累，官方提倡绑定一个对象的bean。配置文件还是用上面的application.properties这里我们建一个ConfigBean类 然后在spring boot入口类加上@EnableCon覅个ratio你Proper贴士并指明要装配哪个bean 装配好bean后就可以在controller中直接调用了 启动打印嘟嘟MD在此祝大家鸡年大吉吧！参数间引用 application.properties中的各个参数之间可以直接引用 在上面的例子里给ConfigBean加上属性yearhope，controller类直接调用getYearhope即可得到同样结果。使用自定义配置文件 有时我们不希望把所有哦诶之都放在application.properties中，这时我们可以另外定义一个，如test.properties，路径和application.properties同级 再新建一个bean controller代码如下： 运行打印哟西祝大家鸡年大吉吧 参考博客：嘟嘟独立博客/Spring Boot干货系列：（二）配置文件解析","categories":[],"tags":[]},{"title":"","slug":"转义字符&lt; &gt; &amp; &quot; &copy;","date":"2019-04-30T08:25:46.560Z","updated":"2019-03-30T09:21:56.741Z","comments":true,"path":"2019/04/30/转义字符&lt; &gt; &amp; &quot; &copy;/","link":"","permalink":"http://47.107.237.149/2019/04/30/转义字符&lt; &gt; &amp; &quot; &copy;/","excerpt":"","text":"HTML中&lt; &gt; &amp; &quot; &copy;分别是&lt;,&gt;,&amp;,”,©;的转义字符。 xml中只有5个转移字符 &lt; &gt; &amp; &quot; &apos;","categories":[],"tags":[]},{"title":"","slug":"转发与重定向","date":"2019-04-30T08:25:46.556Z","updated":"2019-02-08T09:28:20.758Z","comments":true,"path":"2019/04/30/转发与重定向/","link":"","permalink":"http://47.107.237.149/2019/04/30/转发与重定向/","excerpt":"","text":"区别 重定向：sendRedirect();浏览器url会改变，request与response均改变，不在原来的请求范围内。 转发：forward();url不会改变，request和response也会跟过去。 转发是服务器行为，重定向是浏览器行为。 转发，浏览器只做一次请求，重定向至少两次应用 重定向的速度比转发慢，因为浏览器还要发出一个新的请求，所以在使用两种方法都无所谓的情况下建议使用转发。Spring中使用的就是转发，如 @RequestMapping(&quot;/register&quot;) public ModelAndView register(){ logger.info(&quot;----请求注册页面----&quot;); ModelAndView modelAndView=new ModelAndView(&quot;/jsp/register&quot;); return modelAndView; } @RequestMapping(value=&quot;/register_check&quot;,method=RequestMethod.POST) public String register(HttpServletRequest request, HttpServletResponse response , Model model) throws UnknownHostException { //用户名 String username=request.getParameter(&quot;username&quot;); //判空 if(StringUtil.isNull(username)){ model.addAttribute(&quot;message&quot;,&quot;请填写用户名&quot;); return &quot;/jsp/register&quot;; } 转发只能访问当前web的应用程序，如果是要访问到另外一个web站点的资源，就只能使用重定向。Spring要使用重定向的话且需要将属性也送过去的话： //在spring-mvc文件添加（放在这个值负责处理controller层的文件即可） //不要放在总的applicationContext.xml中，会导致很多controller注册的url失效 xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd &lt;mvc:annotation-driven/&gt; //在controller中方法上添加入参：org.springframework.web.servlet.mvc.support.RedirectAttributes @RequestMapping(value=&quot;saveProduct&quot;,method=RequestMethod.POST) public String saveProduct(ProductForm productForm,RedirectAttributes redirectAttributes){ //传递参数 redirectAttributes.addFlashAttribute(&quot;message&quot;,&quot;The product is saved successfully&quot;); //执行重定向 return &quot;redirect:/……&quot;; } 重定向是重新发起了一次请求，需要写个对应的controller来处理该请求，而转发则可以直接找到视图，不需要再经过controller处理。 代码实例：D:/ideaprojects/thz/thz-manager-web/spring-mvc.xml、WebPageController 重定向有一个重要的应用场景：避免在用户重新加载页面时两次调用相同的动作。例如，当提交产品表单时，执行保存方法，信息被添加到数据库。但是如果在提交后，重新加载页面，保存方法就很可能被再次执行，从而出现错误。为了避免这种情况，表单提交后可以将用户重定向到一个不同的页面，从而使得多次重新加载都没有副作用。","categories":[],"tags":[]},{"title":"","slug":"注解","date":"2019-04-30T08:25:46.553Z","updated":"2019-03-23T09:18:56.966Z","comments":true,"path":"2019/04/30/注解/","link":"","permalink":"http://47.107.237.149/2019/04/30/注解/","excerpt":"","text":"定义 注解，就是元数据，即一种描述数据的数据。可以说，注解就是源代码的元数据，用来描述一个类、方法、参数、变量、构造器和包的一些特点，比如说某个方法是父类的重写，它的作用域在哪里等等。 简单理解为一种标记，通过这个标记可以获取一定的关联信息。举个栗子 比如，下面这段代码： 上面代码中重写了toString方法并使用了@override注解，它告诉编译器这个方法是一个重写方法，如果父类中不存在该方法，编译器会报错，停水该方法没有重写父类中的方法。如果不小心拼写错误，而且也没有使用@override注解，那程序依然能编译运行，但运行结果就会和期望的大不相同。优点 在使用Annotation（注解）之前，xml被广泛地运用于描述元数据，但是其维护十分困难（因为代码繁琐与松耦合性，某些情况下甚至是完全分离的）。他们希望使用一些和代码紧耦合的东西。 假如你想为应用设置很多的常量或参数，这种情况下，xml是很好的选择，因为它不会和特定的代码相连。如果你想把某个方法声明为服务，那么使用Annotation会更好一些，因为这种情况下需要注射和方法紧密结合。 目前，许多框架将xml和Annotation两种方式结合起来，平衡两者的利弊。 元注解 java提供了四种元注解，专门注解其他的注解。 @Documented–注解是否将包含在javadoc中 @Retention–在什么时期保存该注解（生命周期） RetentionPolicy.SOURCE–注解只保存在.java文件中，编译后被丢弃。这些注解在编译结束后就不再有意义，所以它们不会被写入字节码。如，@Override等。 RetentionPolicy.CLASS–保存到.class文件中，类加载（运行）时丢弃。注解默认使用这种方式。 RetentionPolicy.RUNTIME–始终不会丢弃。自定义注解通常使用的方式。 @Target–注解作用于什么地方。若不明确指出，注解可以放在任何地方。 ElementType.TYPE:用于描述类、接口或enum声明 ElementType.FIELD:用于描述实例变量 ElementType.METHOD ElementType.PARAMETER ElementType.CONSTRUCTOR ElementType.LOCAL_VARIABLE ElementType.ANNOTATION_TYPE 另一个注释 ElementType.PACKAGE 用于记录java文件的package信息 @Inherited–允许子类继承该注解 自定义注解 注解中所有的属性被定义成方法，并允许提供默认值。 下面的例子有三个属性：author、priority和status。 注解的使用： @&lt;注解名&gt;（&lt;成员1&gt;=&lt;成员1值&gt;，&lt;成员2&gt;=&lt;成员2值&gt;，…） 下面的例子演示了如何使用上面的注解： 如果注解中只有一个属性，可以直接命名为“value”，使用时无需再标明属性名。 解析注解 利用反射将被注解的类或方法等的注解信息解析出来（获取注解信息） 下面这个注解是用来描述类或方法的 下面的例子使用了上面的注解 对这个类及其方法解析一下注解(看看注释知道个大概就行了) 运行结果","categories":[],"tags":[]},{"title":"","slug":"主键","date":"2019-04-30T08:25:46.550Z","updated":"2019-02-24T03:35:33.878Z","comments":true,"path":"2019/04/30/主键/","link":"","permalink":"http://47.107.237.149/2019/04/30/主键/","excerpt":"","text":"表中每一行都应该有可以唯一标识自己的一列（或一组列）。 主键（primary key） 一列（或一组列），其值能够唯一区分表中的每个行。唯一标识表中每行的这个列（或这组列）称为主键。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。 条件：任何两行都不具有相同的主键值；每行都必须具有一个主键值复合主键 含有一个以上的字段组成的主键。 create table test ( user_id number, role_id number, primary key (user_id,role_id) ) 上面的user_id&amp;role_id字段组合起来就是test表的复合主键，它的出现是由于user_id和role_id都可能出现重复，所以一起作为主键，只要没有两条记录是user_id和role_id同时一样的，就认为不重复。","categories":[],"tags":[]},{"title":"","slug":"重写override","date":"2019-04-30T08:25:46.546Z","updated":"2019-04-13T04:07:58.863Z","comments":true,"path":"2019/04/30/重写override/","link":"","permalink":"http://47.107.237.149/2019/04/30/重写override/","excerpt":"","text":"七个要求 重写的方法与父类方法签名（方法名称和参数列表,参数类型必须相同，而不能是子类）相同（=） 重写方法的访问限定符范围不能低于父类,因为重写就是为了更好的使用的，所以应用范围应该更广一点（&gt;=） 父类的私有方法不能重写 static修饰的方法不能重写（因为它不是通过对象调用的 如果父类中返回类型是八大基本类型、string或void，则必须相同 如果是其他引用类型，则重写方法中必须返回相同类型a或a的子类（&lt;=） 子类重写方法抛出的异常范围要小于父类方法抛出的异常或或不在同个父类下的异常或没有异常（&lt;=）","categories":[],"tags":[]},{"title":"","slug":"正则表达式的属性","date":"2019-04-30T08:25:46.543Z","updated":"2018-04-27T09:24:01.188Z","comments":true,"path":"2019/04/30/正则表达式的属性/","link":"","permalink":"http://47.107.237.149/2019/04/30/正则表达式的属性/","excerpt":"","text":"静态属性：直接调用，无需声明 代码示例：E-&gt;js-&gt;demo属性.js","categories":[],"tags":[]},{"title":"","slug":"正则表达式","date":"2019-04-30T08:25:46.540Z","updated":"2019-04-27T03:58:58.695Z","comments":true,"path":"2019/04/30/正则表达式/","link":"","permalink":"http://47.107.237.149/2019/04/30/正则表达式/","excerpt":"","text":"符号表 正则表达式（regular expression）是一个描述字符模式的对象，RegExp是一个类，用来表示正则表达式，它定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。其实String类也提供了一些方法，但String是后台代码，也即是服务器来验证的，而RegExp用客户端验证可节省服务器的系统资源。 如何创建正则表达式？1. 用new的方式,类似创建一个字符串 * var box=new RegExp(&apos;Box&apos;); alert(box);//打印 /Box/ 自动加俩反斜杠，即变成字面量，俩反斜杠是字面量表示法 * var box=new RegExp(&apos;Box&apos;,&apos;ig&apos;);//第二参数可选 alert(box);//打印 /Box/gi 顺序无所谓 2. 用字面量表示法（常用） * var box=/Box/; alert(box);//打印 /Box/ * var box=/Box/ig;//直接加修饰符 alert(box);//打印 /Box/gi test与exec方法 test用法：匹配是否存在而不是相等 用new方法 var pattern=new RegExp(‘Box’);//模式 var str=’box’; alert(pattern.test(str));//打印 false 因为大小写不同 字面量方法 var pattern=/Box/i; var str=’box’; alert(pattern.test(str));//true 匹配一句话呢？ var pattern =/Box/i; var str=’This is a box!’; alert(pattern.test(str));//true 字符串中包含忽略大小写的Box 字面量一句话过（不提倡） alert(/Box/i.test(‘box’)); exec（匹配是否存在，返回数组） var pattern=/Box/i; var str=’box’; alert(pattern.exec(str));//打印 box //alert(typeof pattern.exec(str));//打印 object，数组确实是对象 var pattern =/Box/i; var str=’sss’; alert(pattern.exec(str));//打印 null 表示某些规则的字符范围 匹配成功返回true，否则false 把我们想匹配的范围用中括号括起来，如，第一行最后一列，[a-z]表示匹配范围是a-z,多种范围可以直接连着写然后中括号括起来；[abc]表示只能是a\\b\\c ^Hi,表示匹配到Hi的位置必须是行首 那么特殊字符如何匹配呢？ 比如，^已经是正则里的特殊字符，可是我就想匹配它，那么在前面加\\把它转义成普通字符 分组其实就相当于循环节，单独使用分组没有什么意义 /(abc)\\1/表示把abc分组，\\表示abc，那么就相当于匹配到的必须是两个abc连着的 仅分组表示只是分组，并不应用到\\上，那么/(?:abc)(def)\\1/表示应用到\\上的是(def)，于是.test(‘abcdefdef’);返回true abc表示重复0次或多次，采用贪婪算法表示优先匹配重复次数多的，如上面优先匹配abcccccc;加个?表示采用非贪婪算法，则abc ?优先匹配ab 从返回false或true的角度上看，x*?、x+?匹配0次、1次或多次；x?匹配0次或1次 x|y 中间是竖线而非斜线 x{1,3}表示x应重复1-3次 锚元字符匹配 代码示例：E-&gt;js-&gt;demo匹配.js 正则表达式中有三个标签，第一个表示 把整串字符串匹配完，不加的话可能匹配到第一个它就结束了，那么我们希望它匹配到所有的话就要加global 第二个表示忽略大小写 第三个表示跨行检索 /abc/gim.test(“ABC”)，写gim表示加了三个标签，顺序无所谓，匹配返回true String的字符串匹配方法也可以用到正则表达式中，如，match、search、 代码示例：E-&gt;js-&gt;demo.js 在notepad写什么文件完要运行之前都记得保存啊，否则怎么运行都出不来结果，还找不到哪里出错 反正运行出错首先检查保存了没 alert(“密码必须在6—12位之间”);document.getElementById(&apos;password&apos;).focus();//获取焦点 上面这段代码将陷入死循环，改正： alert(&quot;密码必须在6—12位之间&quot;); setTimeout(function () { document.getElementById(&apos;password&apos;).focus(); }, 500);","categories":[],"tags":[]},{"title":"","slug":"账号、密码","date":"2019-04-30T08:25:46.536Z","updated":"2019-04-28T08:09:11.146Z","comments":true,"path":"2019/04/30/账号、密码/","link":"","permalink":"http://47.107.237.149/2019/04/30/账号、密码/","excerpt":"","text":"三星 136手机号码 佳纯电话前三位百度网盘 同上 慕课网 手机 QQ密码高数网站 QQ邮箱 Jiayi!电话/Jiachun!电话WPS QQ邮箱或手机 佳纯电话前三位运动世界校园 账号：学号 密码：佳纯电话前三位github 用户名：Eliyser 注册邮箱：QQ邮箱 密码：QQ密码 博客网址：https://eliyser.github.io/MySQL123456微信公众号账号：QQ邮箱密码：佳纯电话前三位微信公众平台用户名：QQ邮箱密码：佳纯电话前三位163邮箱、有道云账号：海恩乐园@163.com密码：QQ旧密码绑定手机：日租卡号批改网账号：QQ邮箱密码：QQ密码七牛云、极简图床账号：QQ邮箱密码：QQ旧密码绑定手机：日租卡手机WiFi密码：WaF4008781908在postman注册的谷歌账号用户名：haien密码：佳纯电话前三位码云用户名：Eliyser登录时用户名：旧手机密码：佳纯电话前三位coding.net用户名：Eliyser邮箱：QQ邮箱密码：佳纯电话前三位易展翅手机：136手机号密码：14084046keep用户名：136手机号密码：佳纯电话前三位幕布用户名：海恩密码：佳纯电话前三位酷狗用户名：123670319954密码：佳纯电话前三位anyview学号：网17025109密码：卡号VMware账号：haienleyuan用户名：admin密码、开机登录密码：佳纯电话前三位京东账号：136手机号密码：我妹是傻逼挑战杯账号：QQ邮箱用户名：haien密码：佳纯电话前三位国学智慧账号：手机、邮箱或学号皆可密码：一卡通卡号CentOSroot密码：佳纯电话前三位阿里云会员名：不如不遇墨殇花登录密码：佳纯电话前三位云服务器root、git等用户ssh密码：Jiachun,电话前三位（也就是在控制窗口登录时输入root后输入的密码）客服电话：95187用户名：root远程连接密码：电话前六位RAM用户名：haienOracle用户名：QQ邮箱密码：Jiachun电话前三位又拍网用户名：haien密码：佳纯电话前三位阿里顽图用户名：海恩随意云用户名：海恩密码：佳纯电话前三位哔哩哔哩用户名：136手机密码：佳纯电话前三位CSDN账号：136手机密码：佳纯电话前六位蓝桥账号：手机号密码：佳纯电话前三位高考考号0501102358微博账号：136手机密码：佳纯电话前三位 学习通账号：136手机密码：一卡通 秀米账号：136手机密码：佳纯电话前三位 知到账号：136手机密码：卡号 中山一院账号：136手机密码：海恩乐园 易班账号：136手机密码：海恩123","categories":[],"tags":[]},{"title":"","slug":"在GitHub新建文件夹","date":"2019-04-30T08:25:46.533Z","updated":"2018-04-21T07:38:39.531Z","comments":true,"path":"2019/04/30/在GitHub新建文件夹/","link":"","permalink":"http://47.107.237.149/2019/04/30/在GitHub新建文件夹/","excerpt":"","text":"网址","categories":[],"tags":[]},{"title":"","slug":"杂记","date":"2019-04-30T08:25:46.530Z","updated":"2019-03-29T07:37:03.691Z","comments":true,"path":"2019/04/30/杂记/","link":"","permalink":"http://47.107.237.149/2019/04/30/杂记/","excerpt":"","text":"parse 从语法上描述 wrapped 包装类 高淇58集讲述了String类的StringBuilder以及一些常用方法的使用 null指没有，而不是0；让一个对象=null后它在栈里分配了空间，但是在堆里没有类的构造；使用该对象调用方法通常会抛出NullPointerException异常 65讲到时间Date 66集DateFormat、SimpleDateFormat的使用 67集讲到Calendar类 70集讲到File类 tread 线程 File f = new File(“D:\\test.txt”); 声明一个文件对象 只有成员变量（包含静态变量）会被自动初始化 构造器的第一句总是super（指向直接父类），即一级一级往上调用父类的构造器 返回值不同不构成重载 toString()方法就是把对象转换成String类型，转换的算法根据类型和实际需要而定。 hashCode()方法和equal()方法的作用其实一样，在java里都是用来对比两个对象是否相等一致。 因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。 但是hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠 要做日期计算的话有限考虑GregorianCalendar native 声明表示调用本地（操作系统）的方法，所以不用实现。 JavaBean 只有属性和set、get方法的一种非常简单的类 常量就是全局的（static），定义时会隐式地加上static final Entry&lt;K,V&gt;简析Map中一个封装键值对的接口，Map的子类们（HashMap等）都有实现 使用方法： 其中rooms是一个HashMap对象 使用详解 判断字符串是否全是空格：str.trim().isEmpty() 不能用#define ElemType int来代替typedef ElemType int,因为define不能识别int是类型 重命名之后可能会出现诡异的报错，所以尽量避免重命名，实在不行复制文件得了 span 跨度 搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。 引擎（Engine）是电子平台上开发程序或系统的核心组件。利用引擎，开发者可迅速建立、铺设程序所需的功能，或利用其辅助程序的运转。一般而言，引擎是一个程序或一套系统的支持部分。 工作空间就是你项目存放的位置，方便下次查找。每个工作空间里面都有一个.metadata文件夹。多个java项目可以存放在一个工作空间中，eclipse可以设置多个不同的工作空间路径。一个工作空间就等于一个分类的文件夹 sts是一个定制版的eclipse，专为spring开发定制的，方便创建调试运行维护spring应用。 plugin 插件yml文件 是yaml（一种基于Unicode容易阅读、容易和脚本语言交互的、用来表达资料序列的编程语言。）编写的文件格式。和.xml和propertie文件一样，都是配置文件 spring-boot web项目偶尔抽风访问不了的话，可以换成运行而不是调试来访问。编译 包括编译和链接两个过程。 编译部分，是把源文件（代码）转换成机器可以识别的二进制语言，之歌过程是针对每一个源文件的。 链接，是把编译生成的二进制文件，组合成为一个可以执行的可执行文件。运行 把编译出来的可执行文件，在系统中运行的过程，成为程序的运行。java中的编译和运行 java讲究的是一次编译处处运行，也就是提高了程序的一致性。java的程序之所以能在不同的操作系统上的运行结果是一样的，是因为java的虚拟机。 所以要运行java要装一个叫jdk的东西，里面有java的虚拟机。这个虚拟机就是来解释我们写的代码。通过这份虚拟机，就实现了代码的移植。 我们写好的程序，通过虚拟机，编译成.class文件，然后再运行，但是我们只需要编译一次即可。javadoc 一种编写程序员自己的类、成员、方法的API文档的技术。容器 容器与虚拟机类似，可以对应用程序及其关联性进行隔离，从而构建起一套能够随处运行的自容纳单元。pojo 简单的Java对象（Plain Ordinary Java Objects）实际就是普通JavaBeans。.iml文件 iml是intellij idea的工程配置文件，里面是当前project的一些配置信息。它包含了项目依赖的所有jar包。request.getContextPath() 返回当前页面所在的应用的名字,也就是工程名 各种获取路径方法XPath xml路径语言，它是一种用来确定该xml文档中某部分位置的语言。也即是一门在xml文档中查找信息的语言。DDL 在命令行创建操作数据库的语言Hutool java工具类库，包含很多的Util类，都是一些开箱即用的工具类。Lombok 在idea安装这个插件并添加此项依赖可以使用它提供的注解来代替一些简单的重复性高的代码。 传入的参数可以同时有@RequestParam和HttpServletRequest、HttpServletRequest。 java版本与jdk版本的关系 获取文件属性 HPScore/FileUtil中有获取文件基本属性（如最后更新时间）的方法 格式化代码 Ctrl+Alt+L 跑项目突然很慢 服务器刚好被别人用到跑项目，占用资源，会使自己的项目跑起来很慢。 @Transactional加在非测试类上 不会恢复到数据库原样 private static final long serialVersionUID = 1L serialVersionUID作用：表明类的不同版本间的兼容性。相当于java类的身份证，主要用于版本控制。序列化时保持版本的兼容性，即在版本升级时反序列化是仍保持对象的唯一性。在程序中定义，会使软件版本兼容，无论怎么改，都可相互序列化和反序列化。 有两种定义方式： 一个是默认的1L，如标题。 一个是根据类名、接口名、成员方法即属性等来生成一个64位的哈希字段，比如，public static final long serialVersionUID = xxxxL; SSH Struts、Spring、Hibernate，Struts进行流程控制，Spring进行业务流转，Hibernate进行数据库操作的封装。EJB Enterprise Java Bean,企业级Java Bean,是一个用来构筑企业级应用的服务器端可被管理组件，设计目标与核心应用是部署分布式应用程序。 EJB最初的设计思想是为分布式应用服务。分布式是针对大型应用构造的跨平台的协作计算，EJB最初的目的就是为这种计算服务的。但是软件发展到目前为止，大多数应用不需要采用分布式的解决方案，因此用EJB显得太臃肿了。Spring的出现恰恰解决了这个问题。 这两个框架有着一个共同的核心设计理念：为松耦合的pojo类提供中间件服务。框架通过在运行时截取执行环境，或将服务对象注射给pojo类的方式，将应用服务和pojo类连接起来。pojo类本身并不关注如何连接，而且也很少依赖于框架。 联系：二者都是容器类框架。 区别： EJB来源于官方，一经通过，即成标准。Spring来源于开源社区，是由广大开发者共同参与开发的。 EJB是重量级的，而Spring是轻量级的，倡导零侵入性。 分布式能力。EJB主要用来做分布式开发，但是Spring不具备分布式能力。### Set&lt;String&gt; set=null; //无序的set set=map.keySet(); //获取所有的key List&lt;String&gt; list=new ArrayList&lt;&gt;(set); //转换为有序的list 句柄Handle 大概就是和指针差不多的意思SDK software development kit，软件开发工具包 是指由第三方服务商提供的实现软件产品某项功能的工具包。 一般以API和使用文档、范例、工具的形式出现。服务器 服务器其实也可以算电脑的一种，只是服务器一般用来提供服务。 比如我们天天访问百度网页，就是百度公司的服务器在默默为我们服务着，我们玩网络游戏，也是网游公司的服务器给我们服务着。哪天百度的服务器或网游服务器被黑了，不能提供服务了，你也就打不开百度网页了，也玩不了游戏了。 服务器与一般的电脑又有所不同，服务器支持常年不关机，所以服务器上面的配件与电脑上的都不一样，硬件要求高得多。 而且服务器不像电脑，电脑一般一块硬盘就够了，服务器要很多块，这时会要求做一个磁盘阵列（可以提高磁盘访问速度或者安全性的方法） 服务器有两大功能：存储数据、便捷通信 比如说你用App给我的手机发送了一条信息但是我关机了，发完后你关上手机我打开手机却能收到你的信息，那么在你我手机之间一定还有其他东西在默默的奉献着。这就是服务器。其实App是将信息发给了服务器，服务器发现我的手机关机就将信息暂存下来。当服务器监测到我的手机打开App上线时，就会将这段时间的信息都发给我了。 当需要数据或者信息的时候，App都会通过互联网向服务器发起请求；当一个用户希望联系到另一个用户时，服务器就在中间起到了牵线搭桥、方便通信的作用。完整的App是如何工作的 我们首先需要明白API是程序调用的接口，数据库存储了所有的信息，服务器应用则是调度、处理所有请求、信息、响应的中枢。服务器上的应用通过API来监听App传来的请求并进行响应，同时回传数据库中的检索信以及处理结果。 当你登录时，App会将你的登录信息通过API传到服务器，服务器应用就会与数据库中的信息进行比对。随后根据比对结果通过API向App回传相应的信息（登录成功/失败）。 从下往上看 很多大公司有自己的服务器机房，但是如今开发者有了新的选择，例如亚马逊AWS、微软的Azure以及Digital Ocean等云服务商都提供所谓的虚拟服务器。 开发者无需购买任何的硬件，就可以通过这些服务商提供的服务器来运行自己的应用，你需要做的只是提交自己的服务器应用，设置相应的参数即可。 发布项目 就是说编码完工了，经过专业测试后确定项目可以上线，给客户使用了。这个时候，找一台及其当做服务器，里面安装软件所需要的环境（Java、数据库、服务器软件Tomcat等）把代码打包成jar包或war包。丢进服务器软件指定目录，开启服务。ADT 抽象数据类型（Abstract Data Type）是指抽象数据组织和与之相关的操作。 带宽 单位时间内通过链路的数据量，度量单位是比特bit。 宽带：比如我们去办理100兆的宽带，这里的100兆指的是100兆比特（Mbps,Million bit per s,每秒100兆比特，比特也就是字节了,8bit=1B）,换算成网速就是12.5Mps，这里的M是指MB。 一般来说，我们说网速时指的是单位为MB、KB之类的网速，而带宽、带宽网速指的则是单位为bit的那个，其实概念上没啥区别，只是需要换算而已。 SSH协议 Secure Shell,是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。 利用ssh协议可以有效防止远程管理过程中的信息泄露问题。 ssh最初是Unix系统上的一个远程控制的工具。Linux的服务器可以配置成ssh的服务器，然后客户端通过ssh工具可以远程 sshd服务：Secure Shell Daemon（守护进程），使用ssh来进行远程控制的服务。 SSL Secure Sockets Layer，安全套接层，在传输层对网络进行加密，为网络通信安全提供安全及数据完整性。 利用数据加密技术，确保数据在传输过程中不会被截取及窃听。 广泛应用于web浏览器与服务器之间的身份认证和加密数据传输。 域名 由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位，例如，baidu.com。 ECS不需要域名即可使用，除非想利用ESC来作为web站点，那就需要注册一个域名。 sftp Secure File Transfer Protocol,安全文件传输协议。可以为传输文件提供一种安全的网络加密方法。传输效率比ftp低很多。对网络安全性要求更高时可以选择sftp。 shell 壳，也就是为使用者提供操作界面的命令解析器（软件），它类似于控制窗口。 Xshell 能在Windows界面下访问远端不同系统下的服务器。简单来说，你可以通过这款软件控制ECS。 Xftp 基于MS Windows平台的功能强大的sftp、ftp文件传输软件。简单来说，通过这款软件你可以在你的电脑和云服务器之间传输文件。 jar包和war包的区别 jar包：通常是开发时需要引用通用类，打成包方便引用管理。 war包：做好一个web应用后，通常是网站，打成war包部署到容器中。一个war包就是以为web应用程序。 win10防火墙 win10防火墙虽然是系统的安全防护屏障，但是现在大家都使用第三方杀毒软件，所以win10防火墙就变成了一种累赘。 resin服务器 跟tomcat一样是应用服务器。 ini文件 Initialization File的缩写，即初始化文件。 ini文件由节、键、值组成。 //节,用来表示一个短路，区分不同用途的参数区。 [section name] //参数 键=值 ;分号后面一行都是注解啦","categories":[],"tags":[]},{"title":"","slug":"邮件","date":"2019-04-30T08:25:46.527Z","updated":"2018-05-01T03:43:25.538Z","comments":true,"path":"2019/04/30/邮件/","link":"","permalink":"http://47.107.237.149/2019/04/30/邮件/","excerpt":"","text":"邮件发送协议 使用易邮是不要把它关了，否则发送不了邮件 用邮件服务器模拟邮件收发 发得好好的突然发不了的话改个端口号，随便改，运行一下再改回来就好了","categories":[],"tags":[]},{"title":"","slug":"用.properties配置常量出现乱码问题","date":"2019-04-30T08:25:46.524Z","updated":"2018-08-08T07:47:20.353Z","comments":true,"path":"2019/04/30/用.properties配置常量出现乱码问题/","link":"","permalink":"http://47.107.237.149/2019/04/30/用.properties配置常量出现乱码问题/","excerpt":"","text":"乱码的话：设置 File Encodings的Transparent native-to-ascii conversion为true 具体步骤如下：依次点击 File -&gt; Settings -&gt; Editor -&gt; File Encodings 将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。 还不行的话可以加上一下配置： banner.charset=UTF-8 server.tomcat.uri-encoding=UTF-8 spring.http.encoding.charset=UTF-8 spring.http.encoding.enabled=true spring.http.encoding.force=true spring.messages.encoding=UTF-8","categories":[],"tags":[]},{"title":"","slug":"异常-找不到main方法","date":"2019-04-30T08:25:46.521Z","updated":"2018-08-05T02:09:10.290Z","comments":true,"path":"2019/04/30/异常-找不到main方法/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-找不到main方法/","excerpt":"","text":"点开eclipse-&gt;window-&gt;preference-&gt;run and debug-&gt;启动，把保存脏编辑器（第一行改为always即可。","categories":[],"tags":[]},{"title":"","slug":"异常机制","date":"2019-04-30T08:25:46.506Z","updated":"2018-09-23T01:59:09.235Z","comments":true,"path":"2019/04/30/异常机制/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常机制/","excerpt":"","text":"异常处理办法之一：try/catch执行顺序 执行顺序 遇到异常，跳出try，执行catch里面的语句 不管是否遇到异常，finally里面的代码都会被执行，但是后面的就不会。 try介绍 异常如何被抛出 package cn.haien.trycatch; import java.io.*; /** 关于FileInputStream的try/catch测试 @author 14103 /public class TryCatch03 { public static void main(String[] args) {String str = new TryCatch03().openFile(); System.out.println(str); } String openFile() {try { System.out.println(&quot;aaa&quot;); //创建文件字节读取流对象fis FileInputStream fis = new FileInputStream(&quot;D:\\\\test.txt&quot;);//将字符串路径封装成File对象 int a = fis.read();//返回读取到的字节 System.out.println(&quot;bbb&quot;); System.out.println(a); return &quot;step1&quot;; }catch(FileNotFoundException e) { e.printStackTrace(); System.out.println(&quot;catch!!!&quot;); return &quot;step2&quot;; }catch(IOException e) { e.printStackTrace(); return &quot;step3&quot;; }finally { //这里忽略关闭文件操作 System.out.println(&quot;finally1!!&quot;); //return &quot;fff&quot;; //如果这里加入return，那么返回值一定是fff了,因为会覆盖前面的返回值 } /*总结：执行顺序 执行try、catch语句，给返回值赋值 执行finally return*/ }}异常处理办法之二：声明异常——throws作用谁调我往谁抛出，就谁来处理手动抛出可以在try里面自己new一个异常对象然后抛出，称为手动抛出，用得不多 try-with-resource及其异常抑制背景 在Java编程中，如果打开了外部资源（文件、数据库连接、网络连接等），必须在使用完毕后关闭。因为外部资源不由JVM管理，无法享用JVM垃圾回收机制，如果我们不在编程时确保关闭外部资源，就会导致外部资源泄露，紧接着就会出现文件被异常占用、数据库连接过多导致数据池溢出等严重问题。传统的资源关闭方式 通常关闭代码被写入finally代码块中，当然我们还必须注意到关闭代码时可能抛出的异常。 public static void main(String[] args) { FileInputStream inputStream = null; try { inputStream = new FileInputStream(new File(&quot;test&quot;)); System.out.println(inputStream.read()); } catch (IOException e) { throw new RuntimeException(e.getMessage(), e); } finally { if (inputStream != null) { try { inputStream.close(); } catch (IOException e) { throw new RuntimeException(e.getMessage(), e); } } } } JDK7及以后的try-with-resource资源关闭方式 当一个外部资源的句柄对象（比如FileInputStream对象）实现了AutoCloseable接口，那么上述代码就可以简化为如下形式： public static void main(String[] args) { try (FileInputStream inputStream = new FileInputStream(new File(&quot;test&quot;))) { System.out.println(inputStream.read()); } catch (IOException e) { throw new RuntimeException(e.getMessage(), e); } } 将外部资源的句柄对象的创建挡在try关键字的括号之中，当这个try/catch代码块执行完毕后，Java会确保外部资源的close方法被调用。代码简介许多。实现原理 try-with-resouce并不是JVM的新增功能，而是JDK实现的一个语法糖。将以上代码反编译后如下： public static void main(String[] args) { try { FileInputStream inputStream = new FileInputStream(new File(&quot;test&quot;)); Throwable var2 = null; //定义一个即将抛出的异常 try { System.out.println(inputStream.read()); } catch (Throwable var12) { //对资源进行处理（读或写）时遭遇异常 var2 = var12; //获取这个异常 throw var12; //并抛出 } finally { if (inputStream != null) { if (var2 != null) { //如果前面抛出了异常 try { inputStream.close(); } catch (Throwable var11) { var2.addSuppressed(var11); //则将关闭时遭遇的异常信息添加到前面的异常，控制台只打印处理异常，但通过异常的getSupperssed方法，可以提取出被抑制的关闭异常 } } else { inputStream.close(); //如果前面无异常，那么关闭异常将被抑制 } } } } catch (IOException var14) { throw new RuntimeException(var14.getMessage(), var14); } }","categories":[],"tags":[]},{"title":"","slug":"异常-从数据库中获取值时报NullPointException","date":"2019-04-30T08:25:46.504Z","updated":"2018-08-14T07:29:19.813Z","comments":true,"path":"2019/04/30/异常-从数据库中获取值时报NullPointException/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-从数据库中获取值时报NullPointException/","excerpt":"","text":"执行以下数据库操作后抛异常 Student4 student4=(Student4)session.get(Student4.class, Long.valueOf(1)); 先检查数据库是否存在主键为1的记录，再检查是否用错数据库；没办法了就再试几次自然就好了","categories":[],"tags":[]},{"title":"","slug":"异常-Parameter index out of range (1 大于号 number of parameters, which is 0）","date":"2019-04-30T08:25:46.500Z","updated":"2018-11-08T02:02:22.988Z","comments":true,"path":"2019/04/30/异常-Parameter index out of range (1 大于号 number of parameters, which is 0）/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-Parameter index out of range (1 大于号 number of parameters, which is 0）/","excerpt":"","text":"占位符与参数个数不一致时抛此异常 xml中like应该是’%${name} %’ 而不是 ‘%#{name} %’","categories":[],"tags":[]},{"title":"","slug":"异常-NullPointException","date":"2019-04-30T08:25:46.496Z","updated":"2018-08-06T02:01:19.047Z","comments":true,"path":"2019/04/30/异常-NullPointException/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-NullPointException/","excerpt":"","text":"突然抛异常，没发现什么错误，过一会自己好了","categories":[],"tags":[]},{"title":"","slug":"异常-java.sql.SQLException-Before start of result set","date":"2019-04-30T08:25:46.493Z","updated":"2018-05-18T00:36:58.601Z","comments":true,"path":"2019/04/30/异常-java.sql.SQLException-Before start of result set/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-java.sql.SQLException-Before start of result set/","excerpt":"","text":"解决方法：使用rs.getString();前一定要加上rs.next();","categories":[],"tags":[]},{"title":"","slug":"异常-java.lang.IllegalStateException-Could not load TestContextBootstrapper","date":"2019-04-30T08:25:46.490Z","updated":"2018-09-14T11:08:02.313Z","comments":true,"path":"2019/04/30/异常-java.lang.IllegalStateException-Could not load TestContextBootstrapper/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-java.lang.IllegalStateException-Could not load TestContextBootstrapper/","excerpt":"","text":"报错描述 java.lang.IllegalStateException: Could not load TestContextBootstrapper [null]. Specify @BootstrapWith’s ‘value’ attribute or make the default bootstrapper class available. 解决 spring-web与spring-test版本不一致，把版本号注释掉，屏蔽最新版本消息 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;!--&lt;version&gt;RELEASE&lt;/version&gt;--&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;","categories":[],"tags":[]},{"title":"","slug":"异常-java.lang.AbstractMethodError","date":"2019-04-30T08:25:46.487Z","updated":"2018-08-13T10:50:13.483Z","comments":true,"path":"2019/04/30/异常-java.lang.AbstractMethodError/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-java.lang.AbstractMethodError/","excerpt":"","text":"MySQL的jar包版本太低，换个高的，不过记得把低版本的从构建路径中删除，不然默认还是引用原来低版本的","categories":[],"tags":[]},{"title":"","slug":"异常-Error resolving template someURL, template might not exist or","date":"2019-04-30T08:25:46.485Z","updated":"2018-10-14T08:54:50.435Z","comments":true,"path":"2019/04/30/异常-Error resolving template someURL, template might not exist or/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-Error resolving template someURL, template might not exist or/","excerpt":"","text":"前端以ajax方式获取后台数据，但是后台没有声明@RestController或加上@ResponseBody就会出现这种情况 。","categories":[],"tags":[]},{"title":"","slug":"异常-Error creating bean with name","date":"2019-04-30T08:25:46.480Z","updated":"2018-08-05T02:19:08.111Z","comments":true,"path":"2019/04/30/异常-Error creating bean with name/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-Error creating bean with name/","excerpt":"","text":"查看代码中是否引用了未定义的类或方法 出现Injection of autowired dependencies failed字样，就是跟和Controller之中的Autowired注解相关","categories":[],"tags":[]},{"title":"","slug":"异常-Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jp","date":"2019-04-30T08:25:46.477Z","updated":"2018-08-02T05:39:14.824Z","comments":true,"path":"2019/04/30/异常-Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jp/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jp/","excerpt":"","text":"这个异常好像隔天再试试就不会了，目前还没有找到解决方法","categories":[],"tags":[]},{"title":"","slug":"异常classnotfoundexception-javax.servlet.servletContext","date":"2019-04-30T08:25:46.474Z","updated":"2018-11-30T03:40:27.147Z","comments":true,"path":"2019/04/30/异常classnotfoundexception-javax.servlet.servletContext/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常classnotfoundexception-javax.servlet.servletContext/","excerpt":"","text":"应该是配置文件applicationContext.xml中多了一行 &lt;mvc:annotation-driven/&gt; 多着一行它会去找servlet-context.xml文件，但是我们项目中并没有配置该文件","categories":[],"tags":[]},{"title":"","slug":"异常-check the manual that corresponds to your MySQL server version for the right","date":"2019-04-30T08:25:46.471Z","updated":"2018-10-07T02:01:35.621Z","comments":true,"path":"2019/04/30/异常-check the manual that corresponds to your MySQL server version for the right/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-check the manual that corresponds to your MySQL server version for the right/","excerpt":"","text":"表名和字段名不要用关键字，通常在表名之前加t_是为了防止用到关键字。MySQL关键字","categories":[],"tags":[]},{"title":"","slug":"异常-Cannot forward after response has been committed","date":"2019-04-30T08:25:46.467Z","updated":"2018-05-18T00:41:23.394Z","comments":true,"path":"2019/04/30/异常-Cannot forward after response has been committed/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常-Cannot forward after response has been committed/","excerpt":"","text":"request.getRequestDispatcher(“saler.jsp”).forward(request, response); return;//记得加return，不然后面还是会被","categories":[],"tags":[]},{"title":"","slug":"异常","date":"2019-04-30T08:25:46.457Z","updated":"2019-04-19T07:32:24.628Z","comments":true,"path":"2019/04/30/异常/","link":"","permalink":"http://47.107.237.149/2019/04/30/异常/","excerpt":"","text":"一 IDEA springboot+myBatis 报错：BindingException: Invalid bound statement (not found) 一般都是dao层的方法会报这种错误，可能是因为配置扫描mappers文件时指定扫描*.xml文件，但是idea生成的mapper文件名不含后缀，重命名加上后缀即可。 二 No converter found for return value of type: class java.util.HashMap controller层返回值无法转换成json字符串传回前端 主要是因为忘记配置fastjson //ssm中增加在spring-mvc.xml中配置fastjson支持即可 &lt;!--启动SpringMvc注解功能，完成请求和注解Controller层的映射； 启用Flash属性，发送属性到重定向的页面--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;!-- 配置Fastjson支持 --&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;features&quot;&gt; &lt;list&gt; &lt;value&gt;WriteMapNullValue&lt;/value&gt; &lt;value&gt;QuoteFieldNames&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 三 报错：SpringJUnit4ClassRunner requires JUnit 4.12 or higher. 可能是Junit版本太低或spring-test版本太高，导致spring做测试时两个版本不搭。 之前出错的版本搭配是： &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--集成Spring做测试必备的依赖，比如要注入Spring容器中的bean--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.3.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 降到4.2.4就好了 四 报错：No mapping found for HTTP request with URI [/shirochapter12/hello1] in DispatcherServlet with name ‘spring’ 描述：springmvc框架的web项目访问某controller的路径时，前端404，后台报以上错误。 原因：可能是spring-mvc.xml中component-scan扫描包路径没有配置好，导致DispatcherServlet不能将请求分发给对应的controller。 代码实例：ideaProjects/shirochapter12/web/mvc/AnnotionController、resources/sping-mvc.xml 五 报错：访问jsp页面时抛异常：Servlet.service() for servlet jsp threw exception java.lang.NullPointerException 原因：项目jar包和tomcat的jar包冲突了，删掉jsp-api.jar即可。 参考文章 六 Shiro报错：There is no session id xxx。 原因:可能是没有在ehcache.xml里配置某个cache。 七 报错：Failed to start component [StandardEngine[Tomcat]]: A child container failed。 原因：第三方类库包括了servlet-api依赖，在Dependencies中查找是哪个类库引入了servlet-api，排除即可。 &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;","categories":[],"tags":[]},{"title":"","slug":"依赖注入","date":"2019-04-30T08:25:46.439Z","updated":"2018-07-11T23:27:33.223Z","comments":true,"path":"2019/04/30/依赖注入/","link":"","permalink":"http://47.107.237.149/2019/04/30/依赖注入/","excerpt":"","text":"是什么 所谓依赖，举个例子说明，一个类Person，另一个类Car，如果Person的某个方法比如说drive，需要引用Car，则称Person类依赖于 Car类，延伸到对象，这种依赖关系依然成立，比如说Person类的对象boy依赖于Car类的对象toyota。再讲讲这个drive方法的实现，假定代码如下： 为什么 A类和B类,如果A要用到B在A类中加一个setB()就OK了,再通过spring的IOC容器实例化好的对象用属性注入就OK了 由上例， 这其中的依赖关系，就导致了对象boy需要负责对象toyota的创建，甚至是整个生命周期的管理，而这样显然会带来耦合度高，不易维护等缺点，比如说要让这个男孩驾驶一辆Audi，则还需要修改类Person的代码。怎么做 在java的设计理论中就提出了一条非常著名的原则，依赖倒转原则（Dependence Inversion），其核心思想就是要将这种具体类之间的依赖，尽量转换成抽象依赖，也就是说类Person应该依赖于抽象类ICar，而不是具体的类 Car，这里java就大力推荐了抽象和接口的使用。 这个依赖倒转原则在设计模式也体现得非常多，比如说工厂模式和构建模式，个人认为控制反转IoC，其实也可以认为是实现这个原则的一种设计模式。控制反转的另外一种说法也就是依赖注入（dependence injection）。还是以上文的boy与toyota为例，其核心就是要将boy依赖的对象toyota注入到boy中去，而无需boy自己去引用toyota，这个注入的过程，通常是由一个控制程序来完成的，无需对象去关心，举例如下： 这个时候，进行注入并且调用的过程，就很简单了，如下： 注：这里我们假定，Toyota类是ICar接口类的一个具体实现。 这个例子就演示一个最简单的注入方式的例子，也就是构造子方式注入，通过将依赖对象注入到对象的构造子中来实现。 另外还有一种常用的注入方式，就是属性方式注入，意思就是通过将依赖对象注入到对象的属性中来实现，还是以boy和toyota的例子说明，如下： 这个时候，进行注入并且调用的过程，就变成如下所示： Spring中实现IoC Spring中其实主要通过两个概念来实现IoC，首先通过XML配置文件，将对象和依赖对象都配置到某个XML文件中，当然该XML文件需要符合Spring指定的规范，然后通过架构中的BeanFactroy类，来自动实现上文所述注入过程，还是以boy与toyota为例，如下： 首先，Person类还是一样的,然后xml配置文件增加点东西-（假定为bean.xml）： 最后，调用的过程，就变成如下：","categories":[],"tags":[]},{"title":"","slug":"一个js函数死活不执行","date":"2019-04-30T08:25:46.435Z","updated":"2018-05-15T15:26:08.701Z","comments":true,"path":"2019/04/30/一个js函数死活不执行/","link":"","permalink":"http://47.107.237.149/2019/04/30/一个js函数死活不执行/","excerpt":"","text":"可能是定义到关键字了，或者js文件保存后滞后生效","categories":[],"tags":[]},{"title":"","slug":"一个jsp两个submit","date":"2019-04-30T08:25:46.432Z","updated":"2018-04-30T16:12:44.410Z","comments":true,"path":"2019/04/30/一个jsp两个submit/","link":"","permalink":"http://47.107.237.149/2019/04/30/一个jsp两个submit/","excerpt":"","text":"在jsp中给不同submit提交按钮不同的名字，然后在servlet中代码实现： jsp: servlet的doPost方法: String a = request.getParameter(“s1”); String b = request.getParameter(“s2”); if(a !=null){ //“通过”的实现代码 } if(b !=null){ //“删除”的实现代码 }","categories":[],"tags":[]},{"title":"","slug":"新建一个要连接数据库并且要在服务器上跑的项目注意事项","date":"2019-04-30T08:25:46.429Z","updated":"2018-04-23T08:10:35.195Z","comments":true,"path":"2019/04/30/新建一个要连接数据库并且要在服务器上跑的项目注意事项/","link":"","permalink":"http://47.107.237.149/2019/04/30/新建一个要连接数据库并且要在服务器上跑的项目注意事项/","excerpt":"","text":"引用库：要有两个mysql的jar包 项目需要连接数据库的话要按这个配置，才能显示连接成功！ jdbc：一个mysql的jar包 要有tomcat包 lib下：mysql的jar包 lib下导入mysql的jar包 修改了web.xml后tomcat要重启，其实就是把server栏下tomcat点一下，然后点虫子，然后到浏览器跑，就算是重启 运行时找不到main方法，点保存然后再运行就好了","categories":[],"tags":[]},{"title":"","slug":"项目调试异常","date":"2019-04-30T08:25:46.425Z","updated":"2018-07-29T08:35:04.255Z","comments":true,"path":"2019/04/30/项目调试异常/","link":"","permalink":"http://47.107.237.149/2019/04/30/项目调试异常/","excerpt":"","text":"一个项目有多个main方法的话会抛很多异常 java.lang.reflect.InvocationTargetException异常：最后是因为传入的Excel表格格式不对","categories":[],"tags":[]},{"title":"","slug":"线性结构","date":"2019-04-30T08:25:46.413Z","updated":"2018-06-05T05:51:58.534Z","comments":true,"path":"2019/04/30/线性结构/","link":"","permalink":"http://47.107.237.149/2019/04/30/线性结构/","excerpt":"","text":"多项式的表示方法数组表示 下标对应项的指数 会造成空间的浪费结构数组表示 存的时候应该按指数顺序来存，看起来好看链表表示 计算两组多项式的和 算法实例：第二讲-&gt;2.1-&gt;第1小节线性表 线性表必须用结构体来表示 基本操作实现：第二讲-&gt;2.1-&gt;第2、3、4、5小节广义表 以上链表的第一个域（系数域）指向另一张表 顺序存储结构就是指数组，链式存储结构就是指链表。","categories":[],"tags":[]},{"title":"","slug":"线程","date":"2019-04-30T08:25:46.409Z","updated":"2018-04-13T13:53:07.124Z","comments":true,"path":"2019/04/30/线程/","link":"","permalink":"http://47.107.237.149/2019/04/30/线程/","excerpt":"","text":"概念 程序：指令集 （静态） 进程：操作系统调度程序，一个程序就是一个进程 （动态） 线程：在进程内的多条执行路径，在一个复杂程序内发现一条路径不能满足要求，另开辟多条路径来执行（线程其实就是一个进程里的多条路径，也叫做轻量级进程） 多进程：操作系统同时运行多个任务，如，eclipse、PPT main方法叫主进程 创建线程一、继承Thread+重写run() 启动：创建子类对象+对象.start() 二、implements Runnable+run() 启动：使用静态代理 1. 创建真实角色 2. 创建代理角色Thread(引用) 3. 代理角色.start() 推荐使用接口：推荐使用Thread静态代理 避免单继承的局限性 方便共享资源 三、实现Callable接口 状态 死亡状态：未在给定时间片内完成程序则被挂起，进入就绪状态；完成则进入死亡状态。 死亡状态如何停止线程： 自然终止：线程体正常执行完毕。 外部干涉： 线程类中：定义线程体使用的标识 线程体使用该标识 提供对外方法改变该标识：set、stop等 外部根据条件调用该方法 阻塞 join：合并进程 yield：暂停自己执行别人 static （写在谁的线程体内暂停谁） sleep：static 不释放锁基本信息 同步一、概念：也称为并发：赞成多个线程对同一个资源进行访问，那么就必须确保资源安全，所以加入同步确保线程安全。synchronized 同步的（加锁，使用该关键字声明即获得该方法的锁）二、死锁：过多的同步容易造成死锁总结","categories":[],"tags":[]},{"title":"","slug":"我的阿里云服务器ECS","date":"2019-04-30T08:25:46.406Z","updated":"2019-02-05T02:35:27.631Z","comments":true,"path":"2019/04/30/我的阿里云服务器ECS/","link":"","permalink":"http://47.107.237.149/2019/04/30/我的阿里云服务器ECS/","excerpt":"","text":"根目录下有一个mydocument文件夹，保存一些.sql文件 git安装目录:/usr/src/git-2.8.3 jdk、tomcat安装目录：/usr/java对象存储 在阿里云的对象存储中存储图片后，获取到的url非常长，而且有时效限制。通过以下设置可以使链接永久有效 进入特定bucket，选择基础设置，将Bucket ACL从私有改为公共读写，保存","categories":[],"tags":[]},{"title":"","slug":"文件上传与下载、form的enctype属性","date":"2019-04-30T08:25:46.390Z","updated":"2019-04-13T03:51:41.779Z","comments":true,"path":"2019/04/30/文件上传与下载、form的enctype属性/","link":"","permalink":"http://47.107.237.149/2019/04/30/文件上传与下载、form的enctype属性/","excerpt":"","text":"上传Excel表格（不下载到服务器）并解析到数据库 上传文件的话必须指定form的enctype（encode type，编码类型）属性为multipart/form-data，表示表单数据有多部分组成，既有文本又有文件等二进制数据，指定浏览器使用二进制上传，否则浏览器默认使用ASCII发送数据从而导致文件发送失败。 enctype默认为application/x-www-form-urlencoded，只能上传纯文本格式的文件。 enctype属性取值： application/x-www-form-urlencoded:在发送前编码all字符。 multipart/form-data:不对字符编码，指定传输数据为二进制类型。 text/plain:纯文本的传输，空格转换为加号，但不对特殊字符编码。 代码实例：learngit/HPScore/ResolveExcelController、ResolveExcleServiceImpl 步骤 获取文件的绝对路径。 获取文件名，如果是中文文件名还需要进行编码。 设置content-disposition响应头控制浏览器器，告诉浏览器以下载的形式打开文件。 获取要下载的文件输入流。 创建数据缓冲区。 通过response对象获取OutputStream流。 将文件的FileInputStream流写入buffer缓冲区。 使用OutputStream将缓冲区的数据输出到客户端浏览器。 使用OutputStream下载中文名文件public class ServletDemo03 extends HttpServlet { private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } /* * 主要方法 */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取文件的下载绝对路径 String downloadPath=this.getServletContext().getRealPath(&quot;/download/示例.jpg&quot;); //获取文件名 String fileName=downloadPath.substring(downloadPath.lastIndexOf(&quot;\\\\&quot;)+1); //设置响应头，告诉浏览器以下载的方式打来文件，设置中文编码，如果不设置会出现乱码 response.setHeader(&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;)); /* * 1. 使用OutputStream字节流 */ //获取目标文件的字节输入流 InputStream is=new FileInputStream(downloadPath); //缓冲区 byte[]b=new byte[1024]; //获取客户端输出流 OutputStream os=response.getOutputStream(); int len=0; while((len=is.read(b))!=-1){ //将缓冲区数据输出到浏览器 os.write(b,0,len); } is.close(); /* * 2. 使用PrintWriter字符流 */ //获取目标文件的字符输入流 FileReader fr=new FileReader(downloadPath); //缓冲区 char[] b=new char[1024]; PrintWriter os=response.getWriter(); int len=0; while((len=fr.read(b))!=-1){ //将缓冲区数据输出到浏览器 os.write(b,0,len); } fr.close(); } } 测试：浏览器访问http://localhost:8080/servlet_study/ServletDemo03访问该Servlet，请求下载页面，当使用PrintWriter时，虽然可以成功下载到本地，但无法打开该照片： 原因：用PrintWriter字符流来处理字节流，会导致数据丢失，因此下载文件时要使用OutputStream. 参考文章","categories":[],"tags":[]},{"title":"","slug":"为什么要把文件存入服务器","date":"2019-04-30T08:25:46.387Z","updated":"2018-07-26T02:58:13.836Z","comments":true,"path":"2019/04/30/为什么要把文件存入服务器/","link":"","permalink":"http://47.107.237.149/2019/04/30/为什么要把文件存入服务器/","excerpt":"","text":"文件需要被多台计算机共享，那就要放进服务器","categories":[],"tags":[]},{"title":"","slug":"外键","date":"2019-04-30T08:25:46.384Z","updated":"2018-07-23T00:45:49.923Z","comments":true,"path":"2019/04/30/外键/","link":"","permalink":"http://47.107.237.149/2019/04/30/外键/","excerpt":"","text":"外键用于与另一张表的关联，是能确定另一张表记录的字段，用于保持数据的一致性。 比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。 表的外键大多是另一表的主键,外键可以有重复的,可以是空值 用来和其他表建立联系用的 一个表可以有多个外键 外键默认的作用有两点：一个对父表，一个对子表（外键字段所在的表） 对子表约束：子表数据进行写操作（增和改）的时候，如果对应的外键字段在父表找不到对应的匹配，那么操作会失败（约束子表数据操作） 对父表约束：父表数据进行写操作（删和改：都必须涉及到主键本身），如果对应的主键在子表中已经被数据所引用，那么就不允许操作 外键约束有三种约束模式：都是针对父表的约束 District：严格模式（默认），父表不能删除或者更新一个已经被子表数据引用的记录 Cascade：级联模式：父表的操作，对应子表关联的数据也跟着被删除；即直接删除父表（主键所在表），子表相应记录也同时被删除 Setnull：置空模式：父表的操作之后，子表对应的数据（外键字段）被置空","categories":[],"tags":[]},{"title":"","slug":"图书管理系统","date":"2019-04-30T08:25:46.381Z","updated":"2018-04-21T02:54:38.306Z","comments":true,"path":"2019/04/30/图书管理系统/","link":"","permalink":"http://47.107.237.149/2019/04/30/图书管理系统/","excerpt":"","text":"建库 馆藏图书数据库，实现按类别、书名等多方面的查询 外借读者数据库 工作人员数据库，限定每个工作人员操作权限 实现新书入库、旧书注销、建立书籍档案的操作，方便进货功能借阅、归还、用户管理、图书馆参数管理、图书管理、统计查询","categories":[],"tags":[]},{"title":"","slug":"图的最短路径问题","date":"2019-04-30T08:25:46.378Z","updated":"2018-06-08T06:01:12.628Z","comments":true,"path":"2019/04/30/图的最短路径问题/","link":"","permalink":"http://47.107.237.149/2019/04/30/图的最短路径问题/","excerpt":"","text":"问题描述 单源最短路径分为无权图和有权图，可以是有向的。单源最短路算法无权图 算法实例：第七讲-&gt;7.1第2小节 有权图 最短路径是权重之和最小的路径，而不一定是边数最少的路径。 不考虑负值圈问题 算法实例：第七讲-&gt;7.1第3小节多源最短路算法 算法实例：第七讲-&gt;7.1第4小节","categories":[],"tags":[]},{"title":"","slug":"图","date":"2019-04-30T08:25:46.374Z","updated":"2018-06-08T02:45:56.517Z","comments":true,"path":"2019/04/30/图/","link":"","permalink":"http://47.107.237.149/2019/04/30/图/","excerpt":"","text":"定义 加上数字（权重）就成了网络。 图的表示邻接矩阵 对角线必须全部是0，因为我们不允许自回路 对称矩阵。0到3有边，3到0也有边。但是这样就浪费了一半的空间。 对于有向图来说，有入度和出度。 邻接矩阵的缺点：浪费空间，如果顶点很多边很少的话；浪费时间，在统计边的时候，如果很多都是没边的话。 完全图：任意两个顶点间都有边，边数达到极大。邻接表 定义一个长度为顶点数的数组，存放指向一个链表的头指针，这个头指针指向的链表存放着所有和顶点相连的顶点。 其实也并不节省空间，因为边同样是被存了两次，链表中每个结点都要有数据域和指针域，如果这个图是网络的话还要加上权重，所以一定要够稀疏才合算。 深度优先搜索 利用堆栈来做。 其实就是把每一条路都走一遍，走进死胡同则结束递归进入最近一个分叉路口的下一个循环，即另一条岔路。 可以把深度优先搜索想象成是一组发散的线。 算法实例：第六讲-&gt;6.2第1小节广度优先搜索 利用队列来做。 其实就是把结点的所有邻接点都入队，然后往这边岔路走几步，往那边岔路也走几步。就像长了分身一样，这条岔路前进一点，那条岔路也前进一点，一圈一圈的往外走，只要出口被包围到圈子里就结束循环。 可以把广度优先搜索想象成是辐射圈。 算法实例：第七讲-&gt;6.2第3小节两种遍历的比较 算法实例：第七讲-&gt;6.2第5小节图的连通 不简单的路径就是指路径上有环，有环则称为回路。 所有连通的顶点都包含在里面 连通分量指的是无向图 是双向路径而不是双向边。 弱连通：不是强连通，但是抹掉方向以后是连通的。 D自己是一个单独的强连通分量。 第二个算法就是用来找所有的连通分量的","categories":[],"tags":[]},{"title":"","slug":"算法的复杂度","date":"2019-04-30T08:25:46.371Z","updated":"2018-06-04T11:42:57.332Z","comments":true,"path":"2019/04/30/算法的复杂度/","link":"","permalink":"http://47.107.237.149/2019/04/30/算法的复杂度/","excerpt":"","text":"算法的复杂度 时间复杂度 计算机算加减的时间很短，所以主要看算法中做了几次乘除。 空间复杂度 看一个递归打印100000个数的例子 因为系统每一次都要划分一块内存出来保存程序的一个状态，但是系统的内存就那么多，数据一大，就很容易非正常退出（爆掉）。 上述例子的空间复杂度跟数据量N成正比平均复杂度与最坏情况复杂度 常分析最坏情况复杂度，因为平均是很难计算的复杂度的渐进表示法 第一个函数是T(n)的上界，比如前面T(n)=C1n^2+C2n,当n充分大时，n^2的作用远远大于n，所以我们可以只考虑n^2.通常上界我们取能取到的最小的上界。比如说T(n)=n，上界可取n^2,n^3…，但为了符合实际，我们取最小的。 第二个是下界，下界取最大 空间复杂度也一样 一些复杂度随输入规模的变化 1代表常数，复杂度不随输入规模变化的意思 log n不写底数是因为相差只是个常数倍，无关紧要的 看到n^2的时候，想一下能不能降成nlog n,这样就会快很多。 例子： 为什么是n^3呢？因为这里面有三重循环，最里面一重循环虽然看不太出来是n次的，但其实也是（反正跟循环次数肯定跟数据量有关这个看得出来吧） 将两段算法拼在一起的时候，复杂度上界就是两个上界取大。 嵌套则是上界相乘。 算法实例：第一讲-&gt;1.3最大子列和(分而治之和在线处理太恐怖了)","categories":[],"tags":[]},{"title":"","slug":"数据库事务","date":"2019-04-30T08:25:46.363Z","updated":"2018-05-26T13:45:11.414Z","comments":true,"path":"2019/04/30/数据库事务/","link":"","permalink":"http://47.107.237.149/2019/04/30/数据库事务/","excerpt":"","text":"事务,从特性开始看就了","categories":[],"tags":[]},{"title":"","slug":"数据库导入导出sql文件","date":"2019-04-30T08:25:46.359Z","updated":"2019-01-14T08:41:53.698Z","comments":true,"path":"2019/04/30/数据库导入导出sql文件/","link":"","permalink":"http://47.107.237.149/2019/04/30/数据库导入导出sql文件/","excerpt":"","text":"Navicat导入导出 heidisql导入导出","categories":[],"tags":[]},{"title":"","slug":"树习题之完全二叉搜索树","date":"2019-04-30T08:25:46.355Z","updated":"2018-06-07T11:08:20.501Z","comments":true,"path":"2019/04/30/树习题之完全二叉搜索树/","link":"","permalink":"http://47.107.237.149/2019/04/30/树习题之完全二叉搜索树/","excerpt":"","text":"题目：构建一棵完全二叉树，它同时必须具有二叉搜索树的性质，也就是左子树比根结点小，右子树比根结点大。 算法实例：第七讲-&gt;树之习题选讲-Comple…所有小节","categories":[],"tags":[]},{"title":"","slug":"树习题之非递归中序遍历","date":"2019-04-30T08:25:46.352Z","updated":"2018-06-07T09:47:32.990Z","comments":true,"path":"2019/04/30/树习题之非递归中序遍历/","link":"","permalink":"http://47.107.237.149/2019/04/30/树习题之非递归中序遍历/","excerpt":"","text":"压栈操作为先序遍历，弹栈为中序遍历，最后再根据压栈和弹栈过程所形成的数组来打印出后序序列，那么这一道题就涉及三种遍历了。 算法实例：第七讲-&gt;树之习题选讲第1、2小节","categories":[],"tags":[]},{"title":"","slug":"树","date":"2019-04-30T08:25:46.348Z","updated":"2018-06-11T07:54:06.496Z","comments":true,"path":"2019/04/30/树/","link":"","permalink":"http://47.107.237.149/2019/04/30/树/","excerpt":"","text":"哨兵 在数组中查找某个元素 能不能把循环内的判断条件缩减一下呢？这个时候我们可以建立哨兵 将第0号元素设为待查找元素，这样循环中断的条件就只能是当前元素等于待查找元素了。二分查找 比方说有11个元素从小到大（一定要按顺序）存放在数组中，那么二分查找某个元素，首先访问第6个元素，然后接下来可能访问第3/9个元素，再一层层二分下去，可能访问的元素的下标（+1）整理成一棵二叉树是这样的： 判定树上每个结点需要的查找次数指的是访问到该结点时是第几次查找了。 n个结点的判定树的深度的计算方法：因为每次查找都将查找范围除以2（缩小一半），所以判断n能除几个2就行了，也就是log n，+1是因为最后范围应该是缩小到1而不是2 ASL表示查找某个元素所需查找次数的平均值树 对于A来说，它的子树就是那么4个了 结点的度也就是一个结点下面连有多少边了 树的度就是找哪个结点下面的边最多了，最多的边数就是树的度了树的表示 如果每个结点的指针域要存放所有指向子结点的指针的话，那么就要根据最多的子结点来设计，会造成空间浪费。 多数情况下我们会选择用链表来存储二叉树，因为如果一个二叉树有很多结点是空的话（非完全二叉树）,数组当中就会浪费很多空间来存放这些没有的结点。 要对一棵树进行层序遍历的话，如果这棵树是用数组存储的，那直接顺序打印数组就是层序遍历的结果了。特殊二叉树 完美二叉树：除了最底层是叶节点，其余每个结点都有两个子结点。 完全二叉树：从满二叉树中按顺序从尾到头拿掉一些结点后形成的树。比如，如果把上面I结点拿掉的话那么6原本9号应该是D的儿子H的兄弟，现在却变了，因而不是完全二叉树。 完全二叉树可以用数组来存储，不会浪费空间的。二叉树的性质 二叉树的存储 先给二叉树编号，然后把数组的下标当成编号，存入对应的结点，访问二叉树时就可以根据下标来找相应结点了。 二叉树的遍历 由上述遍历过程可以总结出，每个结点都会被碰到三次 算法实例：第三讲-&gt;3.3第2小节 那个初始化栈不知道是怎么初始化的，反正就是能保证未压栈前非空，全部弹栈后为空就对了。二叉树遍历的运用 算法实例：第三讲-&gt;3.3第3小节 在先序遍历的打印语句上加个条件判断是否叶子结点，是才打印。 利用后序遍历的框架来做 根结点是运算符，叶结点是运算数；每个运算符都要把左右子树相加。 中缀表达式是不准的，如果把某两个符号调换一下： 显然所得的就不是原本的二叉树想要计算的表达式了。但是，我们可以在输出左子树的时候先输出左括号，左子树结束的时候再输出右括号。这样就可以输出正确的表达式了。 至少要给出两种遍历序列，并且其中一种必须是中序遍历 (因为前序和后序分别将根结点放到了最前和最后访问，因此前序遍历序列的首元素就是、后序遍历的尾元素就是二叉树的主根，但是有时候其他元素是左是右我们是不清楚的)。 比如上面那个就是了 算法实例：第三讲-&gt;3.3第4小节二叉搜索树 总之就是左子树比根结点小，右子树比根结点大。 有可能不平衡，不一定是完全二叉树的。堆才是完全二叉树。 尾递归一般都能用循环来代替，因为非递归效率更高。 如果树全部往左边靠或者全部往右边靠的话，查找的效率就大大降低了 算法实例：第四讲-&gt;4.1第1小节 算法实例：第四讲-&gt;4.1第3小节那灿若星辰的眼底，有惊喜，随即换上了气恼，有憎恨，但很快又被爱意淹没，最后竟是满眼的无奈","categories":[],"tags":[]},{"title":"","slug":"属性大写映射到字段变成下划线","date":"2019-04-30T08:25:46.345Z","updated":"2018-08-25T10:37:18.128Z","comments":true,"path":"2019/04/30/属性大写映射到字段变成下划线/","link":"","permalink":"http://47.107.237.149/2019/04/30/属性大写映射到字段变成下划线/","excerpt":"","text":"参考文章 属性的驼峰命名方法映射到数据库后会变成下划线形式，这种形式将来提取字段有歧义，通常是不管怎么提取都找不到该字段的 可以配置命名策略保证正确映射，比如在application.properties中添加以下配置： spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl 再给属性加上注释,比如： @Column(name=&quot;userName&quot;) //额其实不加也可以了 private String userName;","categories":[],"tags":[]},{"title":"","slug":"输入框下拉框失效","date":"2019-04-30T08:25:46.340Z","updated":"2018-05-11T08:16:24.837Z","comments":true,"path":"2019/04/30/输入框下拉框失效/","link":"","permalink":"http://47.107.237.149/2019/04/30/输入框下拉框失效/","excerpt":"","text":"可能是外层div遮挡，试试看去掉外层div","categories":[],"tags":[]},{"title":"","slug":"实体类共享泛型repository接口","date":"2019-04-30T08:25:46.336Z","updated":"2018-09-18T12:57:30.963Z","comments":true,"path":"2019/04/30/实体类共享泛型repository接口/","link":"","permalink":"http://47.107.237.149/2019/04/30/实体类共享泛型repository接口/","excerpt":"","text":"多个实体类的repository实现的方法都差不多，比如llcweb项目中document、image、file几个类的动态查询（findAll）、findBy一类的方法，汇总到一个泛型接口中定义 /** * @Author Haien * @Description 资源类的泛型接口,可分别创建某种资源的repository来继承该接口 * @Date 2018/9/14 * @Param * @return **/ @NoRepositoryBean //不要暴露出来，数据库中没有表和这个接口匹配 public interface ResourceRepository&lt;T,ID extends Serializable&gt; extends JpaRepository&lt;T,ID&gt; { //id序列化,传入id的类型 /** * 分页动态查询(只能叫findAll) **/ Page&lt;T&gt; findAll(Specification&lt;T&gt; specification, Pageable pageable); Page&lt;T&gt; findByAuthorId(int id,Pageable pageable); Page&lt;T&gt; findByModel(String model,Pageable pageable); } 实体类的repository继承此泛型接口，传入实体类，可以另外添加一些具体到某个数据库的新方法（即使不定义新方法也要继承） public interface ImageRepository extends ResourceRepository&lt;Image,Integer&gt; { /** * 模糊查询 **/ @Query(&quot;from Image i where i.description like %?1% or i.author like %?1% or i.model like %?1%&quot;) Page&lt;Image&gt; fuzzySearch(String key,Pageable pageable); } 实例化 @Autowired private ImageRepository imageRepository;","categories":[],"tags":[]},{"title":"","slug":"上传文件到七牛云","date":"2019-04-30T08:25:46.334Z","updated":"2018-10-02T05:40:27.080Z","comments":true,"path":"2019/04/30/上传文件到七牛云/","link":"","permalink":"http://47.107.237.149/2019/04/30/上传文件到七牛云/","excerpt":"","text":"自定义七牛空间 先在七牛云创建空间，如haien、haien2、llcweb这些，地区选择华南、华东都没问题，不过地区选择和后面的zone有关。目前定义的空间是llcweb，只能更换，不能同时定义多个空间。 通过程序上传图片到极简图床，极简图床保存到自定义的空间。上传图片 引入依赖（下面引入的是7.2.17，但是会引起incorrect region, please use up-z2.qiniup.com异常，必须更换为7.2.11版本） &lt;dependency&gt; &lt;groupId&gt;com.qiniu&lt;/groupId&gt; &lt;artifactId&gt;qiniu-java-sdk&lt;/artifactId&gt; &lt;version&gt;[7.2.0,7.2.99]&lt;/version&gt; &lt;!--自动选择最新版本--&gt; &lt;/dependency&gt; 登录七牛云进入个人面板-&gt;密钥管理，复制公钥、私钥 配置文件application.yml qiniu: accessKey: McAf9AJmcH3c86M_b4FM_Z0RQg45vgaDmBBbI2u3 secretKey: j2AjkfuUscIwyIEJ1n6Yc4tsJTjPJIEPR0YyGF1P bucket: llcweb path: pfrai6t0h.bkt.clouddn.com 编写主要逻辑service类 @Service public class QiniuService { private static final Logger logger=LoggerFactory.getLogger(QiniuService.class); //注入常量如果出错的话那就多运行几次就自动解决了 @Value(&quot;${qiniu.accessKey}&quot;) private String accesskey; @Value(&quot;${qiniu.secretKey}&quot;) private String secretKey; @Value(&quot;${qiniu.bucket}&quot;) private String bucket; //空间名称 @Value(&quot;${qiniu.path}&quot;) private String path; //存储空间-&gt;空间概览中的测试域名 /** * @Author haien * @Description 上传图片到七牛云 * @Date 2018/9/28 * @Param [file, key] key: 保存在空间中的名字，为空会使用文件内容的hash值作为文件名 * @return java.lang.String **/ public String uploadImg(FileInputStream file, String key)throws QiniuException { //构造一个带指定Zone（区域）对象的配置类（七牛云的依赖记得加verson才有这个Zone类） Configuration cfg=new Configuration(Zone.zone2()); //llcweb是华南区域的 //其他参数参考类注释 UploadManager uploadManager=new UploadManager(cfg); Auth auth=Auth.create(accesskey,secretKey); String upToken=auth.uploadToken(bucket); //默认不指定key情况下，以文件内容的hash值作为文件名 Response response=uploadManager.put(file,key,upToken,null,null); //解析上传成功的结果 DefaultPutRet putRet=JSON.parseObject(response.bodyString(),DefaultPutRet.class); System.out.println(putRet.key); //即参数key System.out.println(putRet.hash); //根据文件内容生成的hash值 String return_path=path+&quot;/&quot;+putRet.key; logger.info(&quot;保存地址: {}&quot;,return_path); //图片外链：http://return_path return return_path; } } 其中的Zone： zone0：华东 zone1：华北 zone2：华南 zoneNa0：北美 httpAutoZonehttp上传，自动识别上传区域 上传接口方法(不考虑日志、异常、返回信息等) @RestController public class UploadController { private static final Logger logger=LoggerFactory.getLogger(UploadController.class); @Resource private QiniuService qiniuService; @RequestMapping(&quot;/image/qiniu&quot;) public Map&lt;String,Object&gt; uploadImage(@RequestParam(&quot;file&quot;)MultipartFile multipartFile){ FileInputStream inputStream=(FileInputStream)multipartFile.getInputStream(); String path=qiniuService.uploadImg(inputStream, Constants.getUUID()); //Constants是自定义的一个工具类 return path; } } 代码实例：SpringMvc02/QiniuService、Constants、UploadController","categories":[],"tags":[]},{"title":"","slug":"散列应用-词频统计","date":"2019-04-30T08:25:46.331Z","updated":"2018-06-10T01:16:52.418Z","comments":true,"path":"2019/04/30/散列应用-词频统计/","link":"","permalink":"http://47.107.237.149/2019/04/30/散列应用-词频统计/","excerpt":"","text":"InsertAndCount():查找表中是否含有该单词，有的话词频加1，没有则插入并置词频为1. 用一数组统计从1到最大词频的单词数，比如词频范围为1到100，那么设置长度100的数组，下标为词频，元素为单词数。 计算前10%的词频应该是多少：比如说出现80次才算前10%，那等一下就打印词频为80的单词。","categories":[],"tags":[]},{"title":"","slug":"散列查找","date":"2019-04-30T08:25:46.327Z","updated":"2018-06-09T05:46:13.735Z","comments":true,"path":"2019/04/30/散列查找/","link":"","permalink":"http://47.107.237.149/2019/04/30/散列查找/","excerpt":"","text":"已知的查找方法 定义 散列主要就是给关键字计算一个整数，这个整数作为散列表（一个数组）的下标，关键字则作为它的对应元素。散列表的操作 先构造一个散列函数，把关键字放进去，将来根据这个散列函数计算出关键字的位置，来对关键字进行查找和删除等操作。 为了解决冲突，用二维数组作为散列表，把多出来的关键字放在第二列。 关键字是数字的定址方法直接定址法 取余法 数字分析法 有的关键字只有特定位是变化的，其余位都跟其他关键字一样或是差不多。可以取这几位出来转换为一个整数，作为散列函数的key。 折叠法和平方取中法 平方取中法就是把关键字平方之后取中间几位。关键字是字符的定址方法ASC码加和法 改进一下 把字符串前三位看成27进制，累加起来再求余；不过前三位可能是一样的。 再改进一下 同样是要求余 但是如何快速计算呢？ *32实际就是把数字移5位了。处理冲突的方法 开放定址法 线性探测：如果散列函数计算出来的地址冲突，那么第一次加1，寻找下一个地址，如果第二次也冲突就加2，… 平方探测：第一次加1^2,第二次减1^2,第三次加2^2,第四次减2^2,… 双散列：再设计一个散列函数h2线性探测 设计表长为13是为了留出空间以备冲突使用。 d表示冲突次数 注意：出现了聚集现象。线性探测一旦出现冲突，就会导致聚集现象。 ASLs就是查找表中存在的数据所用的平均查找次数，没冲突的数据可以一次找到，有冲突的则需要下一个下一个地查找，如，29需要查找2次。 ASLu表示要查找的数据不存在于表中，，根据余数情况11种分为11类来考虑，每一类的查找次数都相同。如，22和33，先求余=0，然后查找0位上key为11，怀疑可能是因为放入时冲突所以放到了下一位，故查找下一位，1位上为30，再下一位，2位上为空，证明表中根本没有这个数，查找不成功，查找次数为3.将这11类累计起来求平均即得ASLu。 再举个例子 用首字母减去a作为下标 平方探测法 由于平方探测法是跳着找的，所以可能会找不到空余空间。 不过只要表长设计好了也可以解决这个问题。 平方探测法能明显地减轻聚集问题。散列函数算法实现初始化 散列表可以设计成一个结构体，包含表的最大长度和存放key的数组。 数组设计成一个结构数组（也就是结构体数组）。结构体内存放标记和key。 删除散列表中的一个key时是不可以真的把它删掉的，而是改变标记为已删除，这样查找散列表时，发现某个位置为已删除，还会接着往后面找，但如果被删掉了，这个位置就是空的我就会认为要查找的key不在表中，这回造成误判。 插入的时候发现某个位置的key已被删除，就用要插入的key替换上去。 计算散列值之前先判断散列表会不会太小，太小的话就不需要做散列直接放数组里就好了。 NextPrime函数：返回一个不小于表长度的素数。查找 Hash():调用某个哈希函数求散列值插入 再散列 装填因子太大时，应将散列表扩大，然后重新计算key的散列值，再放进去。 算法实例：第十一讲-&gt;11.3第5小节分离链接法 查找 散列表的性能分析 线性探测法 求ASLu则代入第一个公式 不过实际的计算可能跟公式计算结果不同，因为公式计算的是一般情况。平方探测法和双散列探测法 横坐标代表装填因子，纵坐标代表查找次数 装填不到一半时，查找次数都差不多分离链接法 散列表的优缺点 散列方法的优缺点开放地址法 分离链接法","categories":[],"tags":[]},{"title":"","slug":"三大范式","date":"2019-04-30T08:25:46.324Z","updated":"2018-04-21T03:33:36.276Z","comments":true,"path":"2019/04/30/三大范式/","link":"","permalink":"http://47.107.237.149/2019/04/30/三大范式/","excerpt":"","text":"第一范式：原子性–不可再分 第二范式：非主属性完全依赖于主属性 第三范式：非主属性直接而非通过非主属性间接依赖于主属性","categories":[],"tags":[]},{"title":"","slug":"容器（包含重写equals方法）","date":"2019-04-30T08:25:46.321Z","updated":"2019-04-08T03:35:20.995Z","comments":true,"path":"2019/04/30/容器（包含重写equals方法）/","link":"","permalink":"http://47.107.237.149/2019/04/30/容器（包含重写equals方法）/","excerpt":"","text":"概念 Java中要用到数组的地方一般都用容器替代了。 接口图 Set 重复的话会被覆盖，即任意两个元素e1、e2都有e1.equals(e2)=false，因此存入Set的对象必须重写equals()和hashCode()。 Set 最多只能有一个null元素。 Set 只能遍历不能get得到某元素，因为无序无索引 List 可以重复。 List 有序。 List接口下还有一些子（实现）类 数组：查询快 链表：插入、修改快 ArrayList 初始长度就是10，超容量后扩容 LinkedList 链表实现 其添加方法文档中为：void add(int index, E element);//尽管有索引但是查找的时候也是遍历的方式 list.get() 返回Object类，需要强制转换 list.set(0) 指定位置往里扔 Map Map接口下也有一些子（实现）类 无序、不可重复，因为它是无序的，所以需要通过key来查找，所以不能重复。 map.values()：返回值的Collection，不能向下转换（如强转为List），只能向上转为Object之类的父类。 public static void main(String[] args) { Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;A&quot;, &quot;A&quot;); map.put(&quot;B&quot;, &quot;B&quot;); map.put(&quot;C&quot;, &quot;C&quot;); map.put(&quot;D&quot;, &quot;D&quot;); map.put(&quot;E&quot;, &quot;E&quot;); //直接打印 System.out.println(map.values()); //[A, B, C, D, E] //报错：java.util.HashMap$Values cannot be cast to java.util.List //List&lt;String&gt; valuesList = (List&lt;String&gt;) map.values(); //向上转换 //Object values=map.values(); //不过后面就不能直接遍历打印了 //除了向上转换，也可以利用ArrayList的构造方法(Collection)传入一个Collection List&lt;String&gt; valuesList=new ArrayList&lt;&gt;(map.values()); for(String str:valuesList){ System.out.println(str); //A回车B回车... } } 代码示例：ideaProjects/shiro-chapter20/test/MapValuesTest、chapter20/codec/HmacSHA256Utils 参考文章 参考文章 HashMap 无序，且不保证顺序恒久不变。 底层是数组，数组元素是链表，因此查找容易，插入和删除也容易。 当我们调用put()存储对象到HashMap时，它先调用键对象的hashCode()，返回hashCode作为索引；然后再调用equals()方法判断是否已有键的hashCode和当前的一样，一样则覆盖，否则存为新的键值对。 当两个对象的hashCode相同时，它们也可能不相同，即equals()=false，还是需要存为新元素，此时HashMap把它们存在同个位置的链表下一结点中。 而get()时，HashMap使用键对象的hashCode找到其在数组中的位置，接着调用key.equals()方法找到正确的结点。因此即使这一位置的链表中存在多个结点，HashMap也能找到正确的。 允许使用null键和null值。 线程不安全，效率高。 HashTable 线程安全，效率低 map.entrySet():获取一个个体为Map.Entry对象的Set集合，即Set&lt;Map.Entry&lt;k,V&gt;&gt;。Map.Entry包含getKay和getValue方法。 for(Map.Entry&lt;String,String&gt; entry:map.entrySet()){ System.out.println(entry.getKey()+entry.getValue()); } //或 Iterator i=map.entrySet().iterator(); while(i.hasNext()){ System.out.println(i.next()); //等同于下两行 Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;)i.next(); System.out.println(&quot;key:&quot; + entry.getKey() + &quot; value&quot; + entry.getValue()); } map.keySet()：单独获取key的集合 Set keys = m.keySet( ); if(keys != null) for(String s : keys) t.append(s + &quot;: &quot; + m.get(s) + &quot;/n&quot;); 方法实现 //重写equals方法，判断两个对象内容上是否相同，相同返回ture public boolean equals(Object obj){ if(this == obj) //比较的是引用（地址），不同对象地址肯定不同，相同则肯定是同一个对象 return ture; if(obj == null) return false; if(getclass() != obj.getclass()) //判断类型上是否相同，不相同也肯定不是相同对象 return false; Person other = (person) obj; if(id != other.id) return false; return ture; //都不是上面的情况表示相同，返回true } Map的底层实现 存入元素放入一个链表数组中，即元素为链表的数组，同一链表各结点hashcode相同（当链表太长时自动转换为红黑树，提高查找效率） Object中有hashcode方法，也就意味着所有的类中都有hashcode方法 Set HashSet的底层实现是HashMap测试 Iterator迭代器 集合内部一般都会实现Iterator接口以便遍历集合元素，下面模拟ArrayList内的迭代器实现 /** * @Author haien * @Description 模拟ArrayList内部类Itr对Iterator的实现 * @Date 2018/10/23 **/ public class MyIterator { //下一个元素的游标 int cursor; //上一个元素的游标(cursor、lastRet在数组中的位置是相邻的) int lastRet=-1; //预期被修改（add/set/remove）的次数;modCount是外部类的属性,也是预期被修改的次数 int exceptedModCount=modCount; final void checkForComodification(){ //在调用Iterator遍历时，如果其他线程修改list则外部类的modCount会改变，但内部类的exceptedModCount不会，那么抛异常 if(exceptedModCount!=modCount){ throw new ConcurrentModificationException(); } } public boolean hasNext(){ return cursor!=size; //size是外部类的属性，是数组容量 } //用过一次这个方法就相当于把一个元素给出栈了一样，而lastRet就相当于指着栈顶元素，cursor指着第二个元素 public E next(){ checkForComodification(); //cursor指着当前要被返出去的元素 int i=cursor; //尽管调用该方法前调用者会先检查是否hasNext()，但依然要做异常处理 if(i&gt;size){ throw new NoSuchElementException(); } //ArrayList实际是用一个数组来盛放元素的，迭代的时候要把这个数组拿到 Object[] elementData=ArrayList.this.elementData; //可能i刚传进来elementData就在另一个线程里被删了一个元素 if(i&gt;=elementData.length){ throw new ConcurrentModificationException(); } cursor++; return (E)elementData[lastRet=i]; } /**相当于栈顶元素出栈；调用方式一般为： * if(&quot;abc&quot;.equals(it.next())) * { * it.remove(); * } */ public void remove(){ if(lastRet&lt;0){ throw new IllegalStateException(); } checkForComodification(); //lastRet就是要删除的元素，remove方法不会改变lastRet，但会改modCount；删除元素后把后面的元素前移一位 try { ArrayList.this.remove(lastRet); //前移之后lastRet就指着被删除元素的下一个元素了 cursor = lastRet; lastRet = -1; exceptedModCount = modCount; }catch (IndexOutOfBoundsException e){ //溢出了一定是线程并发的问题 throw new ConcurrentModificationException(); } } } 代码实例：DataStructure/iterator/MyIterator","categories":[],"tags":[]},{"title":"","slug":"容器(1)","date":"2019-04-30T08:25:46.318Z","updated":"2018-04-12T15:00:08.258Z","comments":true,"path":"2019/04/30/容器(1)/","link":"","permalink":"http://47.107.237.149/2019/04/30/容器(1)/","excerpt":"","text":"概念 我们在编写程序时，常常需要对大量的对象引用进行管理，为了实现有效的归类管理，我们常常将同类的引用放在同一个数据容器中。 接口图 Set 重复的话会被覆盖 List接口下还有一些子（实现）类 数组：查询快 链表：插入、修改快 ArrayList 初始长度就是10，超容量后扩容list.get() 返回Object类，需要强制转换 list.set(0) 指定位置往里扔 Map接口下也有一些子（实现）类 HashMap 线程不安全，效率高HadhTable 线程安全，效率低","categories":[],"tags":[]},{"title":"","slug":"日志","date":"2019-04-30T08:25:46.314Z","updated":"2019-03-09T03:36:39.724Z","comments":true,"path":"2019/04/30/日志/","link":"","permalink":"http://47.107.237.149/2019/04/30/日志/","excerpt":"","text":"简介 平时控制台输出的那些信息流就叫日志，它记录了程序调试、运行时发生的变化。 slf4j不是具体的日志框架，而是一系列的日志接口，也即是日志框架的抽象log4j和logback才是实现了的日志框架。 logback和log4j非常相似，但是logback在一些关键执行路径上性能提升10倍以上，而且初始化内存也更小。 它们可以单独使用，也可以绑定slf4j一起使用。单独使用，分别调用自己的方法来输出日志信息。绑定使用，调用slf4j的api，具体使用与底层日志框架无关，日志框架提供的只是一些配置。 推荐绑定，假设项目中已经使用了logback，而我们此时加载了一个使用log4j的类库进来，那我们这时候就需要维护两个日志框架，很麻烦。而使用绑定的话，由于调用的是抽象层的API，与底层日志框架是无关的，因此可以任意更换日志框架。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; @Controller @RequestMapping(&quot;/&quot;) public class LoginController { private static final Logger logger=LoggerFactory.getLogger(LoginController.class); } 要进行绑定的话就要引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; 包含以下必要jar包 log4j-1.2.xx.jar slf4j-api-x.x.x.jar slf4j-log4j12-x.x.x.jar 或 &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.7&lt;/version&gt; &lt;/dependency&gt; 包含以下必要jar包 logback-classic-0.9.21.jar(目前已经有1.0.0) logback-core-0.9.21.jar(目前已经有1.0.0) slf4j-api-1.6.x.jar log4j2 spring 4.2.1开始推荐使用log4j2，即log4j 2.x。 2.3以后的版本要求jdk1.7，2.11.1或更早就已经要求为1.8了 依赖： &lt;!--依赖管理--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-bom&lt;/artifactId&gt; &lt;!--引入官方依赖管理文件--&gt; &lt;version&gt;2.9.1&lt;/version&gt; &lt;!--版本统一定义为2.9.1--&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependency&gt; &lt;!--log4j2核心包--&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--log4j2核心包--&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--web项目需要--&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-web&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--异步输出配置前置环境支持； 没有的话报错：Unable to invoke factory method in class org.apache.logging.log4j.core.async.AsyncLoggerConfig--&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--用于与slf4j桥接--&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- slf4j核心包,已包含在com.github.miemiedev:mybatis-paginator中--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; 一般都是匹配这个版本&lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt;--&gt; 使用前需要在classpath（WEB-INFO和resources）下新建一个配置文件，但不支持.properties文件，只能为”.xml”,”.json”或者”.jsn”。 系统选择配置文件的优先级（从先到后）： classpath下的名为log4j2-test.json 或者log4j2-test.jsn的文件 classpath下的名为log4j2-test.xml的文件 classpath下名为log4j2.json 或者log4j2.jsn的文件 classpath下名为log4j2.xml的文件 如果写在别的地方，则需要在web.xml中配置路径 &lt;!-- log4j2配置文件路径 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt; &lt;param-value&gt;classpath:config/log4j2.xml&lt;/param-value&gt; &lt;/context-param&gt; 我们一般默认使用log4j2.xml。默认配置文件：只向控制台打印error级别以上的日志 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;error&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggersration&gt; 配置文件实例 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- status:指定log4j本身打印日志的级别，只对log4j本身的事件有效， off表示不记录，其余的记录有trace，debug，info，warn，error，fatal； monitorinterval:指定自动重新配置的监测间隔时间即更改日志配置文件不用重启程）， 单位s最小5s，0或负数表示不检测 --&gt; &lt;configuration status=&quot;error&quot;&gt; &lt;!-- 常量定义 --&gt; &lt;properties&gt; &lt;property name=&quot;LOG_HOME&quot;&gt; /home/work/log/${service_name} &lt;!--service_name是maven打包传进来的--&gt; &lt;/property&gt; &lt;property name=&quot;FORMAT&quot;&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n &lt;/property&gt; &lt;/properties&gt; &lt;!--定义所有的appender--&gt; &lt;appenders&gt; &lt;!--控制台--&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--target默认即为SYSTEM_OUT--&gt; &lt;!--添加过滤器ThresholdFilter，控制台只输出level及以上信息 onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;意思是匹配就接受,否则直接拒绝--&gt; &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!--输出日志的格式；可以直接pattern=&quot;S{FORMAT}&quot; --&gt; &lt;PatternLayout pattern=&quot;[%d{HH:mm:ss.SSS}] [%-5p] %l - %m%n&quot;/&gt; &lt;/Console&gt; &lt;!--File:日志文件，打印出所有信息，名为log，下面引用这个appender时直接用log; fileName:指定输出日志的目的文件的全路径，log/为项目下log目录，./log/也一样； 由于append为false，故每次运行日志都被更新，这个也挺有用的，适合临时测试用 --&gt; &lt;File name=&quot;log&quot; fileName=&quot;log/test.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;[%d{HH:mm:ss.SSS}] [%-5p] %l - %m%n&quot;/&gt; &lt;/File&gt; &lt;File name=&quot;ERROR&quot; fileName=&quot;logs/error.log&quot;&gt; &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;[%d{yyyy.MM.dd &apos;at&apos; HH:mm:ss z}] [%-5p] %l - %m%n&quot;/&gt; &lt;/File&gt; &lt;!--RollingFile:定义超过指定大小自动删除旧的创建新的日志文件; RollingRandomAccessFile:功能相同，属性也完全一样，只是效率较高--&gt; &lt;RollingRandomAccessFile name=&quot;RollingFile&quot; fileName=&quot;logs/web.log&quot; filePattern=&quot;logs/$${date:yyyy-MM}/web-%d{MM-dd-yyyy}-%i.log.zip&quot;&gt; &lt;!--不要以.gz/.zip结尾文件就不会被压缩，建议为.zip--&gt; &lt;PatternLayout pattern=&quot;[%d{yyyy-MM-dd &apos;at&apos; HH:mm:ss z}] [%-5p] %l - %m%n&quot;/&gt; &lt;Policies&gt; &lt;!--设置每天打包日志一次--&gt; &lt;!-- TimeBasedTriggeringPolicy:基于时间的滚动策略; interval:integer型，指定多久滚动一次，默认是1hour。 指定两次封存动作之间的时间间隔, 单位:以日志的命名精度来确定单位，比如yyyy-MM-dd-HH 单位为小时， yyyy-MM-dd-HH-mm 单位为分钟。 --&gt; &lt;!-- modulate:boolean型，说明是否对封存时间进行调制, 若modulate=true，则封存时间将以0点为边界进行偏移计算。 比如现在是早上3am，interval是4，那么第一次滚动是在4am， 接着是8am，12am…而不是7am。 --&gt; &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; modulate=&quot;true&quot;/&gt; &lt;!--SizeBasedTriggeringPolicy:基于指定文件大小的滚动策略; size:定义每个日志文件的大小每次大小超过size， 则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩， 作为存档。单位推荐MB,数字和单位间推荐写个空格--&gt; &lt;SizeBasedTriggeringPolicy size=&quot;2 MB&quot;/&gt; &lt;/Policies&gt; &lt;!--DefaultRolloverStrategy:指定同一个文件夹下最多有几个日志文件时 开始删除最旧的，创建新的(通过max属性,默认7个，超出7个的文件夹将被删除)。 compressionLevel：压缩等级，值为0-9，只在filePattern为zip时作用， 0表示不压缩，值打包为zip格式，9表示最高压缩比（个人测试1MB能压缩到4KB）--&gt; &lt;DefaultRolloverStrategy max=&quot;60&quot; compressionLevel=&quot;9&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效； root：根logger；logger：logger--&gt; &lt;loggers&gt; &lt;!-- 建立一个默认的root的logger，没有定义level的appender则以此为level --&gt; &lt;root level=&quot;trace&quot;&gt; &lt;!--指定该日志输出到哪个appender--&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;!-- 异步根logger，跟上面root只能存在一个，不能两个都配置; 不过log4j2依赖应该要到2.11.1才能使用这个--&gt; &lt;!-- 如果日志代码是正常代码逻辑的一部分货程序运行在单核单线程CPU上（这种情况 使用多线程的就是傻），推荐使用普通logger，如果单纯只是为了记个日志， 推荐使用异步logger，效能可能会有几十倍的提高。 &lt;AsyncRoot level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;consoleAppender&quot; /&gt; &lt;/AsyncRoot&gt; --&gt; &lt;!--logger:单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。 以下是过滤掉spring和mybatis的一些无用的DEBUG信息； name:指定适用的类或者类所在包的全路径； appender-ref：指定日志输出的appender，默认继承root结点下定义的appender， 如果指定了，那么会在指定的这appender和root的appender都输出，此时我们可以设置additivity=&quot;false&quot;，只在指定的appender中输出；但在代码实例定义了false居然没打印任何日志 ，只有true才有打印，且只打印一次中--&gt; &lt;logger name=&quot;org.springframework&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;logger name=&quot;org.mybatis&quot; level=&quot;INFO&quot;&gt;&lt;/logger&gt; &lt;!-- 定义一个异步logger，可以和普通logger共存 --&gt; &lt;AsyncLogger name=&quot;com.foo.Bar&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt; &lt;AppenderRef ref=&quot;AppenderName&quot; /&gt; &lt;AppenderRef ref=&quot;AppenderName1&quot; /&gt; &lt;/AsyncLogger&gt; &lt;/loggers&gt; &lt;/configuration&gt; 参考文章 参考文章 参考文章 参考文章 涉及异步日志 代码实例：D:/ideaprojects/thz/thz-parent/thz-manager-web/reourrces/config/log4j2.xml日志级别 以下是log4j日志级别： log4j定义了8个级别的log，优先级从高到低依次为： OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL log4j只建议用4个级别，ERROR、WARN、INFO、DEBUG为什么要打印日志 开发时可以只输出到控制台，但是程序投入生产时就应该打印日志，供维护人员改bug。SpringBoot默认日志框架 SpringBoot默认使用Logback作为日志框架，默认配置error、warn和info级别的日志。 日志输出内容元素： 时间日期：精确到毫秒 日志级别：ERROR, WARN, INFO, DEBUG or TRACE 进程ID 分隔符：— 标识实际日志的开始 线程名：方括号括起来（可能会截断控制台输出） Logger名：通常使用源代码的类名 日志内容 启用Logback原本需要引入下面依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 不过由于该依赖包含于spring-boot-starter，而spring-boot-starter包含于spring-boot-thymeleaf，所以只要引入后面其中一个即可。 日志配置 一般都是写在日志配置文件中，很少在application.properties。命名优先推荐为logback-spring.xml（节点）、log4j-spring.xml、log4j2-spring.xml或ldgging.properties（键值对），这样被正确加载。默认放在resources下。 没有配置文件的话会使用系统默认的配置文件。 具体配置细节参见代码实例中的配置文件。 其中logger结点：写了logger节点就要同时在代码里定义logger。 不写logger节点是没有具体到类的日志的，写了之后才会有指定类的日志，一般要求每个controller中都会有一个logger属性。 log4j配置 #输出级别最低为debug级别，后面为输出器名称 log4j.rootLogger=DEBUG, Console, Tofile, Exception #看网上命名好像都喜欢大写开头 #Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout # 可以灵活地指定布局模式 log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n # 灵活指定布局模式 #不是很懂，应该是打印sql语句吧 log4j.logger.java.sql.ResultSet=INFO log4j.logger.org.apache=INFO log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG #File log4j.appender.Tofile=org.apache.log4j.DailyRollingFileAppender #每天产生一个日志文件 log4j.appender.Tofile.layout=org.apache.log4j.PatternLayout log4j.appender.Tofile.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n #日志格式 log4j.appender.Tofile.File=logFile.%d{yyyy-MM-dd}.txt #路径，不能在前面加/，识别不了的；这么写就表示项目 log4j.appender.Tofile.File=${webApp.root}/log_path/logFile.log //webapp根目录 log4j.appender.Tofile.Append=true #将消息追加到指定文件中，默认为true，false，覆盖 log4j.appender.Tofile.Encoding=UTF-8 #定义日志编码 #还可以单独打印个异常日志出来 log4j.appender.Exception = org.apache.log4j.DailyRollingFileAppender #当前目录的上一级目录，如果此配置文件在resources下，则当前目录为项目 log4j.appender.Exception.File = ../logs/springmvc-mybatis-demo_error.log log4j.appender.Exception.Append = true log4j.appender.Exception.Threshold = ERROR log4j.appender.Exception.layout = org.apache.log4j.PatternLayout log4j.appender.Exception.layout.ConversionPattern = [sspringmvc_mybatis_demo][%p] [%-d{yyyy-MM-dd HH:mm:ss}] %C.%M(%L) | %m%n 语法： log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN 其中，Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台）， org.apache.log4j.FileAppender（文件）， org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）， org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件 一般会配合log4j.appender.输出器name.MaxFileSize=500KB定义最大容量， 超出则会再生成一个原先日志文件name+.1的文件来存放日志，还可以配合 log4j.appender.OutFile.MaxHistory=30定义最大保留天数）， org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 配置日志信息的格式（布局），其语法为： log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.option = valueN 其中，Log4j提供的layout有以下几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“ ”，Unix平台为“ ” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss.SSS}，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) log4j.appender.appenderName.DatePattern=yyyy-MM-dd&apos;.log&apos; # DatePattern配合DailyRollingFileAppender使用 # 每天滚动一次文件;若前面配置日志文件名为logFile.log，则当天生成的日志名为logFile.log # 到明天若有新日志生成则昨天的将更名为logFile.log昨日期.log，并生成新的logFile.log存今天日志 # 注意，没有新日志的话过了一天也不会更名 # yyyy-MM:每月， # yyyy-ww:每周， # yyyy-MM-dd:每天， # yyyy-MM-dd-a:每天两次， # yyyy-MM-dd-HH:每小时， # yyyy-MM-dd-HH-mm:每分钟 。 示例 log4j.rootLogger=DEBUG, Console, OutFile #Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n log4j.logger.java.sql.ResultSet=INFO log4j.logger.org.apache=INFO log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG #File # 每天产生一个日志文件 log4j.appender.OutFile=org.apache.log4j.DailyRollingFileAppender log4j.appender.OutFile.layout=org.apache.log4j.PatternLayout log4j.appender.OutFile.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n #日志路径 log4j.appender.OutFile.File=log_path/logFile.log #一分钟更名一次 log4j.appender.OutFile.DatePattern=yyyy-MM-dd-HH-mm&apos;.log&apos; log4j.appender.OutFile.Append=true #日志最大容量，超出自然将原内容移到别的文件里 log4j.appender.OutFile.MaxFileSize=500KB #最大保留天数 log4j.appender.OutFile.MaxHistory=30 参考文章 参考文章 DatePattern参考文章slf4j的应用 Logger必须作为类的静态变量使用（最好加final关键字），如此不论这个类实例化多少个，大家用的都是同一个logger，它记录的只是当前类的日志，不是每个实例的日志。 private static final Logger logger=LoggerFactory.getLogger(类名.class); //创建Logger对象，后面添加日志信息时要用到；这条语句并不会向控制台打印任何信息 用占位符记录日志，降低代码中字符串连接次数，节省了新建String对象。这意味着只有需要的String对象才会被创建，可以在运行时延迟字符串的创建。 //需要“{}”时用\\\\转义 logger.debug(&quot;Set \\\\{} differs from {}&quot;,&quot;3&quot;); //3被当做字符 //多个占位符 logger.error(&quot;{},{},{}&quot;,1,2,3); //结果 2018-08-18 10:58:38 [cn.xm.exam.test.Slf4jTest]-[DEBUG] Set {} differs from 3 2018-08-18 10:58:38 [cn.xm.exam.test.Slf4jTest]-[ERROR] error:1,2,3 项目中一般是将捕捉到的异常作为日志记录的最后一个参数，而且要放在{}可以格式化的参数之外，而且只能放在最后一个，防止被{}转为e.toString()，放在中间也不会被打印错误信息。 public class Slf4jTest { private static final Logger log=LoggerFactory.getLogger(Slf4jTest.class); public static void main(String[] args) { openFile(&quot;e://test.txt&quot;); } public static void openFile(String filePath){ File file=new File(filePath); try { InputStream in=new FileInputStream(file); } catch (FileNotFoundException e) { log.error(&quot;cann&apos;t found file [{}]&quot;,filePath,e); //打印一行提示信息cannt...，再打印一段异常信息 } } } 结果 21:16:28.364 [main] ERROR com.java1234.test.Slf4jTest - cann&apos;t found file [e://test.txt] java.io.FileNotFoundException: e:\\test.txt (系统找不到指定的文件。) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at com.java1234.test.Slf4jTest.openFile(Slf4jTest.java:21) at com.java1234.test.Slf4jTest.main(Slf4jTest.java:15) 尽量不要使用e.getMessage()，有的异常不一定有message代码实例 D:/ideawork参考文章 日志配置文件中各个属性意义详见笔记：Mybatis与Spring、SpringMvc整合","categories":[],"tags":[]},{"title":"","slug":"全局异常","date":"2019-04-30T08:25:46.307Z","updated":"2019-03-06T08:22:00.735Z","comments":true,"path":"2019/04/30/全局异常/","link":"","permalink":"http://47.107.237.149/2019/04/30/全局异常/","excerpt":"","text":"java异常分类 java把异常当做对象来处理。Throwable是所有错误或异常的超类。Throwable类有两个直接子类：Error类和Exception类。 Error：java运行时系统的内部错误和资源耗尽错误，是程序无法处理的异常，应用程序不会抛出该类对象。 Exception：程序本身可以处理的异常，应尽可能去处理这些异常。Exception分两类，一个是运行时异常RuntimeException，一个是检查异常CheckedException。 CheckedException：可以理解为在代码编写阶段就会被编译器检查到并标示的异常。一般是外部错误，这种异常发生在编译阶段，java编译器会强制程序去捕获此类异常。这类异常必须进行处理（捕获或向上抛出），如果不处理，程序将会出现编译错误。一般情况下，API中写了throws的Exception都是CheckedException。 RuntimeException：那些在java虚拟机正常运行期间抛出的异常的超类。这种错误是由程序员引起的错误，可以修正代码解决。由于这类异常要么是系统异常，无法处理，如网络问题；要么是程序逻辑异常，如空指针异常，JVM必须停止以改进这种错误，所以可以不进行处理（比如向main外抛出），而由JVM自行处理。Java Runtime会自动catch到程序throw的RuntimeException，然后停止线程，打印异常。 常见CheckedException： 常见RuntimeException： throws、throw new XxxException和try/catch的区别 throws: 出现在方法头，可以单独使用，表示可能会出现某种异常，而不是一定会出现异常。 throw: 出现在方法体，不可以单独使用，要和throws或try/catch之一配套使用，表示已经出现了某种异常 public void function() throws Exception1, Exception3 { try { …… } catch(Exception1 e) { throw e; } catch(Exception2 e) { System.out.println(&quot;出错了&quot;); } if (a != b) throw new Exception3(&quot;自定义异常&quot;); } 如果产生Exception1，则捕获之后由方法的调用者去处理,，所以这个方法不能是最外层的方法，不能没人调用。 如果产生Exception2，则方法自己打印异常信息，所以不会再向外抛出Exception2异常 如果产生Exception3，则调用者处理。 如果在controller层throw new的话，那么异常堆栈就会被返回给浏览器，出现下面这种情况，给用户造成了非常不好的体验 用@ControllerAdvice+@ExceptionHandler实现全局异常处理 通常在Controller层需要去捕获service层的异常，防止返回一些不友好的信息到客户端，但如果controller层每个方法都用模块化的try/catch去捕获异常，会很难看也很难维护。 异常处理最好是解耦的，并且都放在一个地方集中管理。Spring能够较好的处理这种问题。核心如下： @ControllerAdvice：定义全局异常处理类 @ExceptionHandler：定义异常处理方法 @ResponseStatus：可以将异常映射为http状态码,如@ResponseStatus(HttpStatus.UNAUTHORIZED) 单独使用@ExceptionHandler，只能在当前Controller中处理异常，与@ControllerAdvice组合使用，则可以实现全局异常处理，不用每个controller都配置。 优缺点 优点：实现全局异常处理后，所有声明或未声明的异常，只要是在controller层抛出的，都会转到全局处理类处理。减少模板代码，提升扩展性和可维护性。 缺点：只能处理controller层未捕获（往外抛）的异常，对于Interceptor（拦截器）层、Spring框架的异常无能为力。全局异常处理类 @ControllerAdvice：定义全局异常处理类GlobalExceptionHandler @ExceptionHandler：声明异常处理方法，使用value指定异常类 /** * @Author haien * @Description 全局异常，对多个异常进行处理 * @Date 2018/9/12 **/ @ControllerAdvice public class GlobalExceptionHandler { private static final Logger logger=LoggerFactory.getLogger(GlobalExceptionHandler.class); @ResponseBody //返回json格式的数据 @ExceptionHandler(value=Exception.class) //处理Controller层抛出的Exception及其子类,出异常会自动找到词类中对应的方法执行 public Object defaulterrorHandler(HttpServletRequest request, Exception e){ JSONObject jsonObject=new JSONObject(); jsonObject.put(&quot;message&quot;,e.getMessage()); //不用专门定义一个字段（如errMsg）也能返回事先填入的信息，未填入返回null //jsonObject.put(&quot;message&quot;,&quot;哎呀出错了&quot;); //自定义的登录异常（目前没有应用） if(e instanceof AuthenticationException){ jsonObject.put(&quot;result&quot;,((AuthenticationException) e).getErrCode()); //获取抛出异常时塞进去的状态码 } //自定义的参数异常（目前没有应用） else if(e instanceof BadRequestException){ jsonObject.put(&quot;result&quot;,ReturnCode.INVALID_PARAM); //其实状态码在这里塞进去好一点吧 } /*错误的请求方式||输入的参数类型不正确||输入参数不全。 MissingServletRequestParameterException： 参数缺失异常，第一个参数：parameterName；第二个：parameterType； 其getMessage()返回：&quot;Required &quot; + this.parameterType + &quot; parameter &apos;&quot; + this.parameterName + &quot;&apos; is not present&quot;;*/ else if(e instanceof HttpRequestMethodNotSupportedException || e instanceof TypeMismatchException || e instanceof MissingServletRequestParameterException){ jsonObject.put(&quot;result&quot;,ReturnCode.INVALID_PARAM); } //输入参数不满足约束（是配合@Valid才会抛出地异常；好像都是抛的BindException异常） else if(e instanceof ValidationException || e instanceof MethodArgumentNotValidException //接口数据验证异常 || e instanceof BindException){ jsonObject.put(&quot;result&quot;,ReturnCode.INVALID_PARAM); } else{ //其他情况均以系统异常处理 jsonObject.put(&quot;result&quot;,ReturnCode.SYSTEM_ERROR); //e.printStackTrace(); //打印 } return jsonObject; //直接返回到前端显示 } } 就算不明着写打印堆栈，异常也会自动在后台打印，全局异常只是让前端接收到的信息比较友好。 还可以分开方法来处理这些异常 @ControllerAdvice public class GlobalExceptionHandler { private static final Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 处理所有不可知的异常 * @param e * @return */ @ExceptionHandler(Exception.class) @ResponseBody AppResponse handleException(Exception e){ LOGGER.error(e.getMessage(), e); AppResponse response = new AppResponse(); response.setFail(&quot;操作失败！&quot;); return response; } /** * 处理所有业务异常 * @param e * @return */ @ExceptionHandler(BusinessException.class) @ResponseBody AppResponse handleBusinessException(BusinessException e){ LOGGER.error(e.getMessage(), e); AppResponse response = new AppResponse(); response.setFail(e.getMessage()); return response; } /** * 处理所有接口数据验证异常 * @param e * @return */ @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) @ResponseBody AppResponse handleMethodArgumentNotValidException(MethodArgumentNotValidException e){ LOGGER.error(e.getMessage(), e); AppResponse response = new AppResponse(); response.setFail(e.getBindingResult().getAllErrors().get(0).getDefaultMessage()); return response; } } 自定义异常类，继承Exception 在Service层抛出AuthenticationException： 代码中使用@Valid进行数据校验 @Controller @RequestMapping(&quot;/&quot;) public class LoginController { private static final Logger logger=LoggerFactory.getLogger(LoginController.class); private UserRepository userRepository; @RequestMapping(value = &quot;login&quot;) @ResponseBody public Map&lt;String,Object&gt; login(@Valid User user){ //自动封装；@Valid可以验证字段，不符合抛出异常并由GlobalExceptionHandler处理 Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); String userName=user.getUserName(); String password=user.getPassword(); //System.out.println(userName); //System.out.println(password); User user1=userRepository.findByUserNameAndPassword(userName,password); if(user!=null){ map.put(&quot;result&quot;,1); map.put(&quot;role&quot;,user.getRole()); }else{ map.put(&quot;result&quot;,0); } return map; } } 数据校验失败时，SpringMvc框架会抛出MethodArgumentNotValidException，在GlobalExceptionHandler中加上对该异常的声明和处理，就可以全局处理数据校验的异常了。 测试 代码实例：SpringBootJpaCrud(D:/SpringBootJpa) 参考文章 更详细的文章","categories":[],"tags":[]},{"title":"","slug":"前端jsp或html页面获取项目根路径","date":"2019-04-30T08:25:46.304Z","updated":"2019-02-08T02:27:56.238Z","comments":true,"path":"2019/04/30/前端jsp或html页面获取项目根路径/","link":"","permalink":"http://47.107.237.149/2019/04/30/前端jsp或html页面获取项目根路径/","excerpt":"","text":"假设项目的请求根路径是/demo 方式一：EL表达式 &lt;form action=&quot;${pageContext.request.contextPath}/com/getClicomdetailList.do&quot;&gt; html中则不是这样 background-image:url(${request.contextPath}/images/3.jpg) 方式二：小脚本 &lt;%=request.getContextPath() %&gt;&lt;br&gt; //显示结果：/demo &lt;script src=&quot;&lt;%=request.getContextPath() %&gt; /home/test.js&quot;&gt;&lt;/script&gt; 方式三：c标签 &lt;c:url value=&quot;/index.jsp&quot;&gt;&lt;/c:url&gt;&lt;br&gt; //显示结果：/demo/index.jsp -方式四：js &lt;script type=&quot;text/javascript&quot;&gt;var baseUrl=&apos;&lt;%=request.getContextPatn() %&gt;&apos;;&lt;/script&gt;&lt;br&gt; //显示结果：baseUrl=&quot;/demo&quot;","categories":[],"tags":[]},{"title":"","slug":"判断字符相等千万不要用==","date":"2019-04-30T08:25:46.285Z","updated":"2018-05-19T14:22:59.088Z","comments":true,"path":"2019/04/30/判断字符相等千万不要用==/","link":"","permalink":"http://47.107.237.149/2019/04/30/判断字符相等千万不要用==/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"排序","date":"2019-04-30T08:25:46.281Z","updated":"2018-06-08T10:06:14.763Z","comments":true,"path":"2019/04/30/排序/","link":"","permalink":"http://47.107.237.149/2019/04/30/排序/","excerpt":"","text":"简单排序 统一接口 默认从小到大排序 内部排序：内存足够存储所有数据，在内存中对数据进行排序操作 稳定性：如果排序前两个相等的数据是挨在一起的，必须对两个都叫小明的人排序，起初小明1在小明2左边，那么排完后还是得在他左边，不能变成右边。冒泡排序 加了一个flag来标记数据是否已有序，如果一趟排序中全程没有进行交换，那么flag为0，说明数据已有序，可以结束了。 缺点：耗时 优点：简单，适用于单向链表的排序 算法实例：第九讲-&gt;9.1第2节插入排序 稳定性：元素不比当前元素大的时候不用往后移，所以是稳定的。 比冒泡法好，因为冒泡需要交换，交换需要3步，而这里往后移只需比它大的元素往后移，都移完了再把当前元素插入就行了。 算法实例：第九讲-&gt;9.1第3节 用冒泡和插入分别对这串数据排序的话，交换次数都是9次，而这里面逆序对的个数也是9次。因为美交换一次消去一个逆序对，因此有几个逆序对就需交换几次。 I是原始序列中逆序对的个数。插入排序不仅跟数据个数有关，还跟逆序对个数有关。快速排序分而治之 算法实例：第十讲-&gt;10.1第1小节选主元 如果数据已经排好序，但是主元都是选第一个的话，那就相当于没有排序。 随机取的话，随机函数是很费时的。 我们可以取第一个元素、中间一个元素和最后一个元素中第二大的。 利用算法把这三个元素从小到大排序，然后等一下就返回那个第二大的。不过等一下是要等什么呢？我们先把中间这个第二大的元素换到最后一个元素的前一个元素（等一下就返回倒数第二个元素），因为我们知道第一个元素一定比等下作为枢纽的元素小，最后一个元素一定比它大，如果规定相等就放在后面的话，那么第二大元素本身就是枢纽，我们知道肯定是要放在后面的，所以我们提前把它放在后面，那等一下只比较第二个到倒数第三个元素与枢纽的大小关系就好了，而中间那个元素就换成了原来倒数第二的元素。否则中间那个元素本身就是枢纽，是已经知道大小关系的，却还要再比一次，就有点浪费时间了。小规模数据的处理 分而治之将数据分得很小的时候调用简单排序，不要一直递归下去。算法实现 要在外面套一个壳，否则不符合接口规范。 算法实例：第十讲-&gt;10.1所有小节表排序 一种间接排序 不需要动元素本身，只是动元素的指针。也就是用它们的下标代替元素本身来排序，下标排在哪个位置，元素就在哪个位置。物理排序 就是排完下标后怎么排元素 我们有结论：N个数字的排列由若干个独立的环组成；比如，表的第一个元素是3，第三个元素是1，…，这样下去一定会回到3的，也就是形成了一个环。 那这样我们可能会陷入环的死循环里，所以我们要判断什么时候环结束了。可以把访问过的table的元素设置为和A下标一样，这样在访问前判断一下元素和下标是否一样就知道环是否结束了。复杂度分析 算法实例：第十讲-&gt;10.2第1、3小节桶排序 给每个程序都设置个桶 但是如果桶很多但是人很少怎么办呢？ 算法实例：第十讲-&gt;10.3第1小节基数排序 分桶跟进制有关系，这里是10进制就分10个桶 如果桶的个数非常小的话，那么复杂度接近线性复杂度。 算法实例：第十讲-&gt;10.3第2小节在多关键字排序上的应用 算法实例：第十讲-&gt;10.3第3小节","categories":[],"tags":[]},{"title":"","slug":"内部类","date":"2019-04-30T08:25:46.271Z","updated":"2018-10-27T03:34:54.813Z","comments":true,"path":"2019/04/30/内部类/","link":"","permalink":"http://47.107.237.149/2019/04/30/内部类/","excerpt":"","text":"作用 提供了更好的封装。只能让外部类直接访问，不能让其他所有类访问。 内部类可以直接访问内部类的私有属性，但外部类不能访问内部类的属性 在外部类的某个方法中new一个内部类对象之后，可以用这个内部类对象直接访问内部类的似有属性。分类非静态内部类（和平时使用的其他类没什么不同）（上一级是成员内部类，除了成员内部类还有局部内部类，即定义在方法内的类，极少用） 非静态内部类寄存于外部类对象，定义了外部类对象才会有内部类。 不能有静态成员，因为静态成员从属于类，而内部类从属于对象（Java类加载顺序：先加载类，同时执行static变量初始化，并将其加载到方法区；内部类则必须在外部类实例化后才被加载，而JVM要求所有的静态变量必须在对象创建之前完成，这样便产生了矛盾。不过为什么可以有静态常量呢？因为常量放在常量池中，加载常量是不需要加载类的）。静态内部类 但一个静态内部类的对象存在，并不一定存在对应的外部类对象。因此不能调外部类的非静态成员，因为外部对象都不一定有。 静态内部类看作外部类的一个静态成员，可以直接作为一个普通类来使用，而不需实例一个外部类。 内部接口不管写不写static它都是static的。 匿名内部类//模板设计模式 subFiles =src.listFiles(new FilenameFilter(){ //FilenameFilter是个接口，只包含accept()一个方法声明 @Override /** * 重写了文件过滤器，返回为真时才将文件挑选出来，否则将剔除出listFiles * dir 代表src */ public boolean accept(File dir, String name) { //System.out.println(dir.getAbsolutePath()); return new File(dir,name).isFile()&amp;&amp;name.endsWith(&quot;.java&quot;); } }); 特点 只能使用一次 当你想使用一个类的protected 方法时，但是又不和这个类在同一个包下，你是没办法调用的。这时候匿名类就派上用场了，你可以声明一个匿名类继承该类，并定义一个方法，在这个方法内使用super调用你想调用的那个方法（其实你也可以写个类继承这个类，就能调用父类的protected方法了，但是匿名类更简洁，因为你只想调用这个方法而已） 举个栗子 总结反正两种都不能调与自己静态性相反的外部类成员","categories":[],"tags":[]},{"title":"","slug":"模板设计模式","date":"2019-04-30T08:25:46.256Z","updated":"2018-08-20T03:59:03.870Z","comments":true,"path":"2019/04/30/模板设计模式/","link":"","permalink":"http://47.107.237.149/2019/04/30/模板设计模式/","excerpt":"","text":"模板类 举一个冲泡饮料的例子。泡茶喝泡咖啡除了某些步骤不一样外，大体是一样的，我们可以把冲泡饮料抽象成一个模板，进行共用。而到具体内容的时候，它们再有具体的实现。 模板方法：1.烧开水；2.把饮料放到水杯里；3.倒入开水；4.加调味剂。第1、3步都是一样的，只有2、4需要根据需要调整，因此写为抽象方法由子类具体实现。 public abstract class Beverage { // 具体的模板方法， 要用final关键字进行修饰，避免子类进行修改 public final void prepareBeverageTemplate() { // 1, 烧开水 boilWater(); // 2, 放到杯中 putIntoCup(); // 加入开水 addHotWater(); // 加入调味应有剂 addCondiments(); } private void boilWater() { System.out.println(&quot;烧开水&quot;); } protected abstract void putIntoCup(); private void addHotWater() { System.out.println(&quot;加水&quot;); } protected abstract void addCondiments(); } 声咖啡子类和茶子类实现这两个方法 public class Coffee extends Beverage { @Override protected void putIntoCup() { System.out.println(&quot;把咖啡放到水杯中&quot;); } @Override protected void addCondiments() { System.out.println(&quot;加入糖和牛奶&quot;); } } public class Tea extends Beverage { @Override protected void putIntoCup() { System.out.println(&quot;把咖啡放到水杯中&quot;); } @Override protected void addCondiments() { System.out.println(&quot;加入糖和牛奶&quot;); } } 建立一个test类来测试一下模板模式 public class Test { public static void main(String[] args) { // 咖啡制作 Beverage coffee = new Coffee(); coffee.prepareBeverageTemplate(); // 调用模版 System.out.println(&quot;\\n***********************\\n&quot;); // 茶制作 Beverage tea = new Tea(); tea.prepareBeverageTemplate(); // 调用模版 } } 钩子函数 其实第4个步骤不是必须的，因为有些人喝茶或咖啡不喜欢加调料，那么如何让程序更加通用化或者更加体现个性化需求呢？这就需要提供一个钩子函数，具体到每个场景，使用不同的钩子函数。 我们把原来的额addCondiments方法放入一个if函数中调用，而if条件就是我们的钩子函数的调用。 prepareBeverageTemplate方法中的代码修改如下： if(isCustomered){ //加入调味剂 addCondiments(); } //新增isCustomered方法 protected abstract boolean isCustomered(){ return true; } 这时只要在子类中重写这个钩子函数，就实现个性化需求，比如在茶中重写这个方法 public class Tea extends Beverage(){ @Override protected void putIntoCup(){ System.out.println(&quot;把茶放入水杯中&quot;); } @Override protected void addCondiments() { System.out.println(&quot;加入糖和牛奶&quot;); } @Override protected boolean isCustomered(){ return false; } } 运行Test，就可以去掉加调料这个步骤 再举一个例子，下面也是重写了钩子函数的情况 //模板设计模式 subFiles =src.listFiles(new FilenameFilter(){ @Override /** * 重写了文件过滤器，返回为真时才将文件挑选出来，否则将剔除出listFiles * dir 代表src */ public boolean accept(File dir, String name) { //System.out.println(dir.getAbsolutePath()); return new File(dir,name).isFile()&amp;&amp;name.endsWith(&quot;.java&quot;); //符合条件 } });","categories":[],"tags":[]},{"title":"","slug":"密钥对和AccessKey","date":"2019-04-30T08:25:46.253Z","updated":"2018-11-18T06:37:02.805Z","comments":true,"path":"2019/04/30/密钥对和AccessKey/","link":"","permalink":"http://47.107.237.149/2019/04/30/密钥对和AccessKey/","excerpt":"","text":"SSH SSH密钥对简称密钥对，是阿里云提供的远程登录ECS云服务器的认证方式，与传统的的用户名加密码模式的认证方式相比，密钥对的安全性更高。 密钥对通过加密算法生成一对密钥，一个对外界公开的叫公钥，另一个自己保留的叫私钥。 把公钥放到云服务器中，那么在本地或者另外的云服务器中，你可以使用私钥通过Xshell等软件登录而不用输入密码。 参考文章AccessKey AccessKey是您访问阿里云API的密钥 创建AccessKey","categories":[],"tags":[]},{"title":"","slug":"路径拼接","date":"2019-04-30T08:25:46.237Z","updated":"2018-04-27T06:46:45.432Z","comments":true,"path":"2019/04/30/路径拼接/","link":"","permalink":"http://47.107.237.149/2019/04/30/路径拼接/","excerpt":"","text":"&lt;%String path = request.getContextPath();String basePath = request.getScheme()+”://“+request.getServerName()+”:”+request.getServerPort()+path+”/“;%&gt; 这个语句是用来拼装当前网页的相对路径的。 是用来表明当前页面的相对路径所使用的根路径的。比如，页面内部有一个连接，完整的路径应该是 http://localhost:80/myblog/authen/login.do其中http://server/是服务器的基本路径，myblog是当前应用程序的名字，那么，我的根路径应该是那么http://localhost:80/myblog/。 有了这个 以后，我的页面内容的连接，我不想写全路径，我只要写 authen/login.do就可以了。服务器会自动把 指定的路径和页面内的相对路径拼装起来，组成完整路径。如果没有这个 &lt;base…&gt;，那么我页面的连链接就必须写全路径，否则服务器会找不到。","categories":[],"tags":[]},{"title":"","slug":"连接池","date":"2019-04-30T08:25:46.230Z","updated":"2018-07-23T09:43:49.063Z","comments":true,"path":"2019/04/30/连接池/","link":"","permalink":"http://47.107.237.149/2019/04/30/连接池/","excerpt":"","text":"事实上一个connection可以有多个statement（会话声明），所以为了节省数据库资源开销和缩短会话周期（因为每次都重新申请一个connection属于物理连接，物理连接很耗时），我们可以不要每次都申请一个connection，转而在原有的连接上申请更多的statement来完成数据库的操作。连接池就是为了实现这一点。 连接池将connection封装起来，使的我们申请一个connection实际就是在原有的connection里申请一个新的statement（原本的关闭连接操作实际变成了回收连接而未关闭，下一次申请一个新连接其实是在在旧连接的基础上申请一次新的statement），所以我们只需在原有的代码上将getConnection()改为getConnnectionPool()即可。 连接池同时能够限制每个应用或系统可以拥有的最大数据库资源。所谓数据库资源也就是每次访问数据库新开的connection、statement和ResultSet（结果集游标。因为如果其中某个应用或系统耗尽了数据库的所有资源，其他应用也就无法正常进行。这种工作也称为确定连接池的大小。 数据库也允许我们能同时对不同类型的数据库操作。 阿里巴巴连接池","categories":[],"tags":[]},{"title":"","slug":"类与类之间的关系","date":"2019-04-30T08:25:46.227Z","updated":"2018-04-09T14:23:39.634Z","comments":true,"path":"2019/04/30/类与类之间的关系/","link":"","permalink":"http://47.107.237.149/2019/04/30/类与类之间的关系/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"类","date":"2019-04-30T08:25:46.223Z","updated":"2018-04-01T12:11:26.851Z","comments":true,"path":"2019/04/30/类/","link":"","permalink":"http://47.107.237.149/2019/04/30/类/","excerpt":"","text":"所有类型都隐式地继承自System.Object类型 一个类（也即是一个文件）中只能有一个公用类型（带public），并且文件名必须与其相同。 Java中类只能单继承，不能像C++一样多继承。但是接口可以多继承。","categories":[],"tags":[]},{"title":"","slug":"跨域请求","date":"2019-04-30T08:25:46.218Z","updated":"2019-01-20T09:16:35.833Z","comments":true,"path":"2019/04/30/跨域请求/","link":"","permalink":"http://47.107.237.149/2019/04/30/跨域请求/","excerpt":"","text":"简介 有一个小小的东西叫cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景： 你准备去清空你的购物车，于是打开了买买买网站www.maimaimai.com，然后登录成功，一看，购物车东西这么少，不行，还得买多点。 你在看有什么东西买的过程中，你的好基友发给你一个链接www.nidongde.com，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。 你饶有兴致地浏览着www.nidongde.com，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向www.maimaimai.com发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号，那……这就是传说中的CSRF攻击浅谈CSRF攻击方式。 形式：由于浏览器同源策略，范式请求url的协议、域名、端口三者之间任意一个与当前页面地址不同即为跨域。形式如下 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90。CORS跨域资源共享 同源策略禁止跨域请求，但是这会给我们带来许多不便，所以在防止供给的前提下出现了跨域资源共享CORS（Cross-Origin Resource Sharing），是现代浏览器支持跨域资源请求的一种最常用的方式。","categories":[],"tags":[]},{"title":"","slug":"聚合函数","date":"2019-04-30T08:25:46.214Z","updated":"2018-04-16T07:39:30.400Z","comments":true,"path":"2019/04/30/聚合函数/","link":"","permalink":"http://47.107.237.149/2019/04/30/聚合函数/","excerpt":"","text":"SELETE COUNT(*) FROM t_grande//记录总数 SELETE COUNT(*) AS total FROM t_grande//把总计栏位字段名改为total 统计每个学生考了几门课 求张三分数之和 根据学生姓名分组，求各自总分 用AVG替换SUM，求平均分 查张三的最高分功课 以姓名分组，分别查询最高分功课 ps:select后面的字段只能和group by里的一样","categories":[],"tags":[]},{"title":"","slug":"接口interface","date":"2019-04-30T08:25:46.206Z","updated":"2019-03-14T09:27:48.072Z","comments":true,"path":"2019/04/30/接口interface/","link":"","permalink":"http://47.107.237.149/2019/04/30/接口interface/","excerpt":"","text":"概述 接口实际不是类，类是由Class定义，而接口是以interface定义的。 更抽象的抽象类，只有常量和抽象方法 定义的是一种准入规范 接口可以通过(多)继承来实现准入规范的累加 一个类可以实现多个接口 接口属性默认为public static final，即把它们定义为常量，防止继承的不同接口中出现同名变量，防止继承的子类对常量进行更改（因为接口本身就是一种规范，要是常量还能被修改那它还定义这个常量干什么） 接口方法默认为public abstract 实现接口的类里也可以有自己的方法 接口只能用public和default修饰，后者表示只能在本包写一个类去implement，包外则不能implement。不能用private是因为只能由自身去访问的接口无意义；不能用protected是因为它只比default多出包外的子类可以去访问，但接口并没有任何子类（子接口不叫子类，也不需要访问父接口的方法），所以也无意义。 在接口中定义的内部类好像必须是静态的，或者是静态类型的，比如枚举类。 很多人习惯在接口名前加一个“I”，表示interface 接口不可以被new但是接口数组可以被new，比如，Comparable是一个接口，Comparable[] a=new Comparable[n]; (√) 优点 统一访问：在创建对象的时候用接口创建，【接口名】 【对象名】= new 【实现接口的类】，这样你想用哪个类的对象就可以new哪个对象了，不需要改原来的代码。如果要写两个都有method1方法的类，如果用接口，就可以直接对象.method1()；这样，new a()就是用a的方法，new b()就是用b的方法。 曲线实现多重继承：java不支持多重继承但是可以实现多个接口，这个在某种程度上可以看成是多重继承的一种方法。 项目开发便利：接口里是一些公用的东西，大家都去实现它的话比每次重新定义要方便。比如，开发时遇到客户改需求，多人修改代码导致牵连，如果使用接口，只需要重新写它的实现类即可。默认方法 Java8新特性：允许给接口添加一个|多个已经实现的方法，只需使用default定义即可，这个特征又叫做扩展方法 public interface Formula { default double sqrt(int a){ return Math.sqrt(a); } double calculate(int a); } 实现Formula接口的子类需要重写calculate方法（当然，想要重写sqrt方法也可以），而sqrt则可以直接使用 public static void main(String[] args) { //这里不采用子类实现接口，而是直接在实例化的时候重写方法 Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a*100); } }; formula.sqrt(100); formula.calculate(100); }","categories":[],"tags":[]},{"title":"","slug":"将项目导入eclipse","date":"2019-04-30T08:25:46.202Z","updated":"2018-05-10T04:50:50.363Z","comments":true,"path":"2019/04/30/将项目导入eclipse/","link":"","permalink":"http://47.107.237.149/2019/04/30/将项目导入eclipse/","excerpt":"","text":"将项目导入eclipse","categories":[],"tags":[]},{"title":"","slug":"将更新和新建写成一个方法","date":"2019-04-30T08:25:46.198Z","updated":"2018-09-09T08:12:14.776Z","comments":true,"path":"2019/04/30/将更新和新建写成一个方法/","link":"","permalink":"http://47.107.237.149/2019/04/30/将更新和新建写成一个方法/","excerpt":"","text":"情景：经常会遇到更新与新建的页面其实是一样的，前者字段都是全新编辑的，后者是在原有的基础上加以修改的，但后台要执行的都是保存操作，所以我们一般都写成一个save方法，但是如何区别要进行的究竟是更新还是新建呢？ 思路：通过判断对象是否存在或者id是否为空，来决定前端要进行的是新建还是更新操作；若为新建则new一个对象来接收传进来的字段，否则让这个对象指向数据库查询到的对象，最后同样都是保存这个对象到数据库，即可。 /** * 保存文档，若id不存在则新建文档 **/ @RequestMapping(value = &quot;/save&quot;,method = RequestMethod.POST) @ResponseBody public Map&lt;String,Object&gt; save(HttpServletRequest request, HttpServletResponse response){ Map&lt;String,Object&gt; map =new HashMap&lt;String,Object&gt;(); String id = request.getParameter(&quot;id&quot;); String content = request.getParameter(&quot;content&quot;); String title = request.getParameter(&quot;title&quot;); String infor = request.getParameter(&quot;infor&quot;); String group = request.getParameter(&quot;group&quot;); Document document; boolean flag = true; //更新文档 if (id!=null&amp;&amp;!id.equals(&quot;&quot;)&amp;&amp;Integer.parseInt(id)&gt;0){ document = documentRepository.findOne(Integer.parseInt(id)); if(document==null){ flag= false; } } //新建文档 所以前端新建文档时，传的id要为空 else document = new Document(); if(flag){ document.setContent(content); document.setTitle(title); document.setInfor(infor); document.setModel(group); documentRepository.save(document); map.put(&quot;result&quot;, 1); map.put(&quot;message&quot;, &quot;成功保存文档！&quot;); logger.info(&quot;成功保存文档！&quot;); }else{ map.put(&quot;result&quot;, 0); map.put(&quot;message&quot;, &quot;保存文档失败！&quot;); logger.error(&quot;保存文档失败！&quot;); } map.put(&quot;data&quot;,document); return map; } 代码实例：LLCWEB/DocumentContoller/save方法","categories":[],"tags":[]},{"title":"","slug":"将本地项目push到github上","date":"2019-04-30T08:25:46.195Z","updated":"2018-07-24T07:33:02.030Z","comments":true,"path":"2019/04/30/将本地项目push到github上/","link":"","permalink":"http://47.107.237.149/2019/04/30/将本地项目push到github上/","excerpt":"","text":"在github上新建一个仓库（相当于新建一个项目） 复制https地址 接下来就到本地操作了，首先右键项目git bash 把刚才的仓库克隆到本地 这个步骤以后你的本地项目里就会多出个文件夹，名字是仓库的名字。将项目的其他文件全部复制到这个文件夹里。 接着继续输入：cd 多出来的文件夹(假如是Test）,进入Test 接下来依次输入以下操作即可完成push git add . //.是把Test文件夹下的文件都添加进来 git commit -m &quot;提交信息&quot; git push -u origin master //把本地仓库push到github上面，需要输入账号和密码","categories":[],"tags":[]},{"title":"","slug":"监听器","date":"2019-04-30T08:25:46.192Z","updated":"2018-04-24T13:47:26.798Z","comments":true,"path":"2019/04/30/监听器/","link":"","permalink":"http://47.107.237.149/2019/04/30/监听器/","excerpt":"","text":"监听web事件，如，application、session、request，当它们setAttribute时可以监听到；也是实现接口 代码实例：HeadFirstServletChap05-&gt;com.java1234.listener包-&gt;SessionAttributeListener.java","categories":[],"tags":[]},{"title":"","slug":"获取元数据","date":"2019-04-30T08:25:46.186Z","updated":"2018-06-15T07:16:20.250Z","comments":true,"path":"2019/04/30/获取元数据/","link":"","permalink":"http://47.107.237.149/2019/04/30/获取元数据/","excerpt":"","text":"获取数据库基本信息 代码实例：ideaProject-&gt;src.main.java.com.haien.APP","categories":[],"tags":[]},{"title":"","slug":"回调CallBack","date":"2019-04-30T08:25:46.179Z","updated":"2018-03-31T08:40:44.632Z","comments":true,"path":"2019/04/30/回调CallBack/","link":"","permalink":"http://47.107.237.149/2019/04/30/回调CallBack/","excerpt":"","text":"是什么？ 回调也叫钩子，模板方法模式 为什么？ 当不知道某一步该怎么实现或者实现方式有很多种反正都是要被重写的（不如paint有时画圆画方），那么干脆不定义，用回调来实现。钩子一挂，随时换对象，传哪个调哪个 怎么做？ 其实也就是多态 有什么条件？ 将父类对象传入含钩子的类的static方法内（可直接传入接口） 被传入的父类对象有重写代码示例 package 才cn.haien.CallBack01; //写一个接口类 public interface IMyFrame { /*默认是 public */void paint(); } package 才cn.haien.CallBack01; public class PaintFrame { public static void drawFrame(IMyFrame f) { System.out.println(&quot;启动线程&quot;); System.out.println(&quot;增加循环&quot;); System.out.println(&quot;查看消息栈&quot;); f.paint(); System.out.println(&quot;启动缓存，增加效率&quot;); } public static void main(String[] args) { drawFrame(new GameFrame01());//传01画圆，传02画方 } } class GameFrame01 implements IMyFrame{ public void paint() { System.out.println(&quot;画圆&quot;); } } class GameFrame02 implements IMyFrame{ public void paint() { System.out.println(&quot;画方&quot;); } }","categories":[],"tags":[]},{"title":"","slug":"后台可以取到session里的attribution","date":"2019-04-30T08:25:46.176Z","updated":"2018-05-15T05:44:46.212Z","comments":true,"path":"2019/04/30/后台可以取到session里的attribution/","link":"","permalink":"http://47.107.237.149/2019/04/30/后台可以取到session里的attribution/","excerpt":"","text":"有的时候取不到，怪怪的","categories":[],"tags":[]},{"title":"","slug":"过滤器拦截器","date":"2019-04-30T08:25:46.165Z","updated":"2019-01-19T03:41:15.934Z","comments":true,"path":"2019/04/30/过滤器拦截器/","link":"","permalink":"http://47.107.237.149/2019/04/30/过滤器拦截器/","excerpt":"","text":"过滤器JavaWeb三大组件之一，它与Servlet很相似！不它过滤器是用来拦截请求的，而不是处理请求的。 当用户请求某个Servlet时，会先执行部署在这个请求上的Filter，如果Filter“放行”，那么会继承执行用户请求的Servlet；如果Filter不“放行”，那么就不会执行用户请求的Servlet。 其实可以这样理解，当用户请求某个Servlet时，Tomcat会去执行注册在这个请求上的Filter，然后是否“放行”由Filter来决定。可以理解为，Filter来决定是否调用Servlet！当执行完成Servlet的代码后，还会执行Filter后面的代码。 过滤非法请求，如，直接访问上面的main.jsp，那要登录有啥用，过滤掉，让它跳回登录界面 比如说，在Chap05中，运行登录页面，输入用户名和密码之后不是执行action指定的Login这个servlet来获取前台传来的数据，而是先执行过滤器来判断是否放行 代码实现： 实现Filter接口 强转servletRequest-&gt;request 获取前台数据 判断过滤与否 public class LoginFilter implements Filter{ @Override public void destroy() { // TODO 自动生成的方法存根 } @Override//最主要的方法 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // TODO 自动生成的方法存根 /*怎么过滤呢？比如先获取session， * session里面有值的话就直接跳到登录成功的页面那里去 * 获取要用request，但servletRequest并不是HttpServlet里的request */ //直接强转 HttpServletRequest request=(HttpServletRequest)servletRequest; HttpSession session =request.getSession();//获取session Object o=session.getAttribute(&quot;currentUser&quot;);//得到的是一个Object String path=request.getServletPath();//获取用户请求路径 //o=null:没登录、登录超时。直接转发到登录页面，重定向的话待会又要请求，又要走一遍过滤器 //path.indexOf(&quot;login&quot;)&lt;0，不是从login发出的请求，因为是从login发出的请求的话就不是非法请求， //应该是走登陆判断而不是过滤器 if(o==null&amp;&amp;path.indexOf(&quot;login&quot;)&lt;0) { request.getRequestDispatcher(&quot;login.jsp&quot;).forward(servletRequest, servletResponse); }else {//假如已经登录了 filterChain.doFilter(servletRequest, servletResponse);//继续往下请求 } } @Override public void init(FilterConfig arg0) throws ServletException { // TODO 自动生成的方法存根 } } 代码实例：HeadFirstServletChap05-&gt;com.java1234.filter包-&gt;LoginFilter.java","categories":[],"tags":[]},{"title":"","slug":"工厂类","date":"2019-04-30T08:25:46.154Z","updated":"2018-04-04T10:39:23.535Z","comments":true,"path":"2019/04/30/工厂类/","link":"","permalink":"http://47.107.237.149/2019/04/30/工厂类/","excerpt":"","text":"作用 将new和init对象的工作从构造器中分离开。 我们以类Sample为例， 如果我们要创建Sample的实例对象: Sample sample=new Sample(); 可是，实际情况是，通常我们都要在创建sample实例时做点初始化的工作,比如赋值 查询数据库等。 首先，我们想到的是，可以使用Sample的构造函数，这样生成实例就写成: Sample sample=new Sample(参数); 但是，如果创建sample实例时所做的初始化工作不是象赋值这样简单的事，可能是很长一段代码，如果也写入构造函数中，那你的代码很难看了（就需要Refactor重整）。 难看指的是有背于Java面向对象的原则，面向对象的封装(Encapsulation)和分派(Delegation)告诉我们，尽量将长的代码分派“切割”成每段，将每段再“封装”起来(减少段和段之间偶合联系性)。这样，就会将风险分散，以后如果需要修改，只要更改每段，不会再发生牵一动百的事情。 所以，我们需要将创建实例的工作与使用实例的工作分开。 这时我们就需要Factory工厂模式来生成对象了，不能再用上面简单new Sample(参数)。 还有,如果Sample有个继承如MySample, 按照面向接口编程,我们需要将Sample抽象成一个接口.现在Sample是接口,有两个子类MySample 和HisSample .我们要实例化他们时,如下: Sample mysample=new MySample();Sample hissample=new HisSample(); 随着项目的深入,Sample可能还会”生出很多儿子出来”, 那么我们要对这些儿子一个个实例化,更糟糕的是,可能还要对以前的代码进行修改:加入后来生出儿子的实例.这在传统程序中是无法避免的. 工厂方法你会建立一个专门生产Sample实例的工厂: public class Factory{ public static Sample creator(int which){ if (which==1) return new SampleA(); else if (which==2) return new SampleB(); } } 那么在你的程序中,如果要实例化Sample时.就使用 Sample sampleA=Factory.creator(1); 使用工厂方法，要注意几个角色： 首先你要定义产品接口，如上面的Sample,产品接口下有Sample接口的实现类,如SampleA,其次要有一个factory类，用来生成产品Sample 抽象工厂工厂模式中有: 工厂方法(Factory Method) 抽象工厂(Abstract Factory). 这两个模式区别在于需要创建对象的复杂程度上。如果我们创建对象的方法变得复杂了,如上面工厂方法中是创建一个对象Sample,如果我们还有新的产品接口Sample2. 这里假设：Sample有两个concrete类SampleA和SamleB，而Sample2也有两个concrete类Sample2A和SampleB2 那么，我们就将上例中Factory变成抽象类,将共同部分封装在抽象类中,不同部分使用子类实现，下面就是将上例中的Factory拓展成抽象工厂: 从上面看到两个工厂各自生产出一套Sample和Sample2,也许你会疑问，为什么我不可以使用两个工厂方法来分别生产Sample和Sample2? 抽象工厂还有另外一个关键要点，是因为 SimpleFactory内，生产Sample和生产Sample2的方法之间有一定联系，所以才要将这两个方法捆绑在一个类中，这个工厂类有其本身特征，也许制造过程是统一的，比如：制造工艺比较简单，所以名称叫SimpleFactory。","categories":[],"tags":[]},{"title":"","slug":"给按钮添加超链接","date":"2019-04-30T08:25:46.151Z","updated":"2018-05-11T02:47:24.736Z","comments":true,"path":"2019/04/30/给按钮添加超链接/","link":"","permalink":"http://47.107.237.149/2019/04/30/给按钮添加超链接/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"高效Java技巧之重写hashCode方法","date":"2019-04-30T08:25:46.134Z","updated":"2019-02-24T07:19:37.487Z","comments":true,"path":"2019/04/30/高效Java技巧之重写hashCode方法/","link":"","permalink":"http://47.107.237.149/2019/04/30/高效Java技巧之重写hashCode方法/","excerpt":"","text":"原始的equals是比较两个对象的地址，而hashCode也是由地址构造来的。 重写equals方法并改变其中比较的参数时，hashCode也应该改变。 如果根据equals方法，两个对象是一样的，那么它们的hashCode也应该一样。 如果两个对象不相等，hashCode不强制要求不一样，但是能不一样更好。 以下代码是一个手机号码的例子，手机号码由区号和本地手机号构成。我们重写了equals方法，但没有重写hashCode。 public class TantanitReaderPhone { private String areaCode; private String localNumber; public TantanitReaderPhone(String areaCode, String localNumber) { this.areaCode = areaCode; this.localNumber = localNumber; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TantanitReaderPhone that = (TantanitReaderPhone) o; //区号、号码都相同即为相同 return Objects.equals(areaCode, that.areaCode) &amp;&amp; Objects.equals(localNumber, that.localNumber); } @Override public int hashCode() { return super.hashCode(); } } 以下测试代码定义了一个以TantanitReaderPhone为key的HashMap。我们在保存和取出时，分别都new了一个对象，这两个对象有着相同的areaCode和localNumber，根据我们重写的equals方法，它们是相等的。但是由于我们没有重写hashCode方法，导致get()时调用hashCode方法获取hashCode来定位时得到这两个对象的哈希值不同，所以第二个对象无法再HashMap里面找到第一次存进去的值。 Map&lt;TantanitReaderPhone,String&gt; map=new HashMap&lt;&gt;(); map.put(new TantanitReaderPhone(&quot;86&quot;,&quot;13200001234&quot;),&quot;张三&quot;); //取不出来 map.get(new TantanitReaderPhone(&quot;86&quot;,&quot;13200001234&quot;)); 因此，hashCode方法应该包含equals中所有字段，而不能包含没有的字段，可能导致相等的对象有不同哈希值。比如，String的hashCode是根据每一个字符来构造的，而本例中的hashCode(): @Override public int hashCode() { int result=17; //若areaCode、localNumber两个字符串分别相同则返回hashCode相同 result=31*result+areaCode.hashCode(); result=31*result+localNumber.hashCode(); return result; }","categories":[],"tags":[]},{"title":"","slug":"分布式","date":"2019-04-30T08:25:46.130Z","updated":"2018-11-19T08:14:06.729Z","comments":true,"path":"2019/04/30/分布式/","link":"","permalink":"http://47.107.237.149/2019/04/30/分布式/","excerpt":"","text":"单机结构 一个系统业务；量很小的时候，所有代码都放在一个项目中就毫克，然后这个项目部署在一台服务器上就好了。 然而，单机的处理能力毕竟是有限的，当你的业务增长到一定程度，单机的硬件资源将无法满足你的业务需求。此时便出现了集群模式。集群结构 把单机复制一份，就构成了集群。集群中的每台服务器叫做这个集群的一个节点。每个节点都提供相同的服务 一般会在所有的节点前加一个“调度者”的角色，用户的所有请求都先交给他，然后它根据当前所有结点的负载情况，把请求交给负载较小的节点处理，这个调度者就是负载均衡服务器。 集群结构的有点事易于扩展，如果当前的系统支撑不住了，那就再增加结点。但是，当业务增加到一定程度时，你会发现无论怎么增加节点，整个集群结构的提升效果都不明显了。这时候，就需要使用分布式结构（微服务结构）。分布式 将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，每个子系统被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。 举个栗子，我们可以把一个在线商城拆分为用户服务、产品服务、订单服务、后台管理服务和数据分析服务等。这一个个服务都是独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。 优点： 系统之间的耦合度大大降低。 系统之间的耦合度降低，从而系统易于扩展。我们可以针对性地扩展某些服务。 服务的复用性高。比如，当我们将用户系统作为单独的服务后，该公司的所有产品都可以使用该系统作为用户系统，无需重复开发。总结","categories":[],"tags":[]},{"title":"","slug":"访问项目图片并显示到页面","date":"2019-04-30T08:25:46.119Z","updated":"2018-10-04T04:25:53.076Z","comments":true,"path":"2019/04/30/访问项目图片并显示到页面/","link":"","permalink":"http://47.107.237.149/2019/04/30/访问项目图片并显示到页面/","excerpt":"","text":"首先图片是被我们保存到了项目，然后根据前端传过来的图片路径，我们要访问到该图片，并返回前端，显示在页面上 项目图片： /** * @Param：path--比如以上图片的路径是: ./images\\10数据组1.jpg **/ public void getOutputStream(String path, HttpServletResponse response) throws IOException { byte[] buff = new byte[1024]; //构建此图片的输入流 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(path)); //构建要返回前端的输出流 OutputStream os = response.getOutputStream(); //服务器向浏览器发送字节输出流 //设置响应内容类型 response.setHeader(&quot;Content-type&quot;,&quot;image/png&quot;); //读取输入流，写到输出流 int len = 0; while ((len = bis.read(buff)) != -1) { os.write(buff, 0, len); } os.flush(); bis.close(); } response.setHeader(“Content-type”,”image/png”)：不设置这个的话前端解析为text类型，会输出一片编码。虽然设置的是png,但是连gif也可以正常显示 如果换成response.setContentType(image/*)的话，那不会显示图片，而是跳出一个下载窗口","categories":[],"tags":[]},{"title":"","slug":"泛型","date":"2019-04-30T08:25:46.116Z","updated":"2019-03-16T05:39:09.600Z","comments":true,"path":"2019/04/30/泛型/","link":"","permalink":"http://47.107.237.149/2019/04/30/泛型/","excerpt":"","text":"为什么当传入对象不明确时，我们一般用多态实现根据传入对象来调用重写方法（以Animal为例，我们需要对需要操作的对象声明为它们的父类，如Animal的voice中定义形参为Animal类，这样可以传入Cat、Dog等子类，甚至要定义成共同父类Object）如： //定义一个类，其属性为Object类 //实例化对象 这可能会导致： 装入数据的类型都被当作Object对待（往往不只是Animal类而是更宽容的Object类），从而“丢失”自己的实际类型 获取数据时需要强制类型转换，可能出错，因此还要手动类型检查（instanceof），效率低 是什么泛型就是参数化类型，使用广泛的类型 有啥用 在编译的时候自动检查类型安全，比如存入的类型与实例化时指定的类型不同。 所有的强转都是自动和隐式的，提高代码的重用率。 分类泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 泛型类 不能使用基本类型，如： Student&lt;String,Integer&gt; //Integer不能写成int 声明类时使用泛型，实例化时指定类型（若不指定则可传入任意类型，但这样它就不会自动转换和检查类型，失去了泛型的意义）。 一个最普通的泛型类：常用的占位符：T，任意类型Type，E，集合中任意元素Element，K、V，键值对中的key和value，N,Number数字。 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型；标识可以写多个 //在实例化泛型类时，必须指定T的具体类型 /* 但是父类Genrator可以不指定类型，即其后面的可以不写，叫做泛型的擦除，这时统一用Object代替父类中出现的所有T类型 也可以子类、父类同时擦除 反正错误情况只有一种：子类擦除，父类不擦除 要么同时擦除，要么子类&gt;=父类（只擦除子类实际上等同于子类的成员类型都被定死，是&lt;=） public class Generic{ //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外 部指定 return key; } }不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic) //可能是因为编译（甚至连运行）的时候JVM都无法识别泛型的具体类型，就像泛型数组一样 最典型的泛型类就是各种容器类，如：List、Set、Map。 泛型接口 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： //定义一个泛型接口 public interface Generator { public T next(); } 就直接把class换成interface就行了 T就只是个占位符，要叫什么都可以，有人习惯写Item 实现泛型接口的类可选择传入或不传入实参（指定或不指定类型） 不传入泛型实参 /** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中，必须跟它一样是T * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{ * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; * */ class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;{ public T next() { return null; } } 传入泛型实参 /** * 传入泛型实参时： *所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成下面传入的String类型。 */ public class FruitGenerator implements Generator&lt;String&gt; { private String[] fruits = new String[]{&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;}; public String next() { } } 父类的原属性类型随父类而定，子类的新属性随子类而定 方法重写随父类而定 泛型通配符同一种泛型可以对应多个版本（因为参数类型是不确定的），但是不同版本的泛型类实例是不兼容的。也即是传入泛型类的泛型实参为父类时，子类并不能传入。如： public void showKeyValue1(Generic&lt;Number&gt; obj){ } Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123); showKeyValue(gInteger);//编译器会为我们报错：Generic&lt;java.lang.Integer&gt; cannot be applied to Generic&lt;java.lang.Number&gt; 因此我们需要一个在逻辑上可以表示同时是Generic和Generic父类的引用类型。由此类型通配符应运而生。 将上面的方法改一下： public void showKeyValue1(Generic&lt;?&gt; obj){ Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); } 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参。 此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 不能在类上使用？只能在声明时使用？，不能在使用时使用。因为？表示声明时不定，使用时确定。 test(stu)编译报错：使用时不能用？型，使用时要确定 不能写Student&lt;?&gt; stu = new Student&lt;?&gt; ();//因为new就是使用时 泛型方法与Class泛型类class对象泛型方法，是在调用方法的时候指明泛型的具体类型 。 public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass){ //public与返回值中间&lt;T&gt;非常重要， 可以理解为声明此方法为泛型方法。T表明返回值为泛型T T instance = tClass.newInstance(); return instance; } 其中Class表示泛型类的class对象，如User.class。 public final class Class&lt;T&gt; implements Serializable { ………… } 当泛型方法出现在泛型类中时: class GenerateTest&lt;T&gt;{ //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t){ System.out.println(t.toString()); } //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t){ System.out.println(t.toString()); } } 再看一个例子： public class GenericFruit { class Fruit{ } class Apple extends Fruit{ } class Person{ } class GenerateTest&lt;T&gt;{ //注意，没有声明为泛型方法，T还是上面从类传进来的T public void show_1(T t){ } //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t){ } //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t){ } } public static void main(String[] args) { Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();//JDK1.7之后可以省略后一个&lt;Fruit&gt;而达到同样的效果 generateTest.show_1(apple);//apple是Fruit的子类，所以这里可以 //PS：这里apple是传给方法，而前面Integer是传给类，传给类是一种特例。 //上面将GenerateTest指定为Fruit类，那么show_1中应该传入Fruit类，而apple也属于Fruit类 generateTest.show_1(person);//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //使用以下两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用以下两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); } 泛型方法与可变参数public &lt;T&gt; void printMsg( T... args){//T可以是某个类，...表示可以传入该类型的无数个参数；只能放在最后 for(T t : args){ Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t); } } printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55); 可变参数处理方法 静态方法与泛型静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 public class StaticGenerator&lt;T&gt; { .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t){..},此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t){ } } 泛型方法总结 泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则： 无论何时，如果你能做到，你就该尽量使用泛型方法。 擦除后编译时不会类型检查 } test(stu1)编译通过，因为擦除，不会类型检查test(stu)编译报错 泛型上下边界 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 //改一下非泛型方法 public void showKeyValue1(Generic&lt;? extends Number&gt; obj){ Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); } //改一下泛型类 public class Generic&lt;T extends Number&gt;{ } //改一下泛型方法 //必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加 public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)//编译器会报错：&quot;Unexpected bound&quot; public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container){ } 由此可见，泛型的上下边界添加，必须与泛型的声明在一起 。 以上extends改为super则必须传入父类 报错，因为都是Student类，方法签名相同 泛型数组 不能创建一个确切的泛型类型的数组 也就是说下面的这两个例子是不可以的： List[] ls = new ArrayList[10]; 而使用通配符或者不指定是可以的： List&lt;?&gt;[] ls = new ArrayList[10]; List[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题： List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. 此行编译后擦除类型信息，JVM陷入迷航 Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // 傻傻的让int型也放进来，编译时不报错.Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException.悲剧了，运行的时候报错！ //而上面两种声明方式在取出时手动强转的时候，转错的话会在编译报错，总比运行才报错的好 那么对于元素为泛型类的数组，我们要怎么创建指定类型的数组呢？ List&lt;Integer&gt;[] listArray=(List&lt;Integer&gt;[])new List[5]; //先创建容量为5的泛型list数组，再强转为integer型的list数组，最后用integer型的list数组变量接收 泛型的嵌套 外部类与内部类的关系 public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{ private T item; /** * 普通内部类：不声明泛型的话会自动继承外部类的泛型，声明泛型则即使同为T也与外部类的不同 */ private class Node&lt;T&gt;{ private T item1=item; //飘红：Incompatible types:required:T,found:T } /** * 静态内部类：不声明不会自动继承外部类的泛型， * 因为不需要有外部类对象就可以直接用外部类创建内部类对象， * 此时具体类型还未指定，继承了也没用，所以不会自动继承； * 声明泛型则即使同为T也与外部类的不同 */ } 获取泛型参数的实际类型 参考文章","categories":[],"tags":[]},{"title":"","slug":"多态polymorphism","date":"2019-04-30T08:25:46.106Z","updated":"2018-09-29T11:40:30.303Z","comments":true,"path":"2019/04/30/多态polymorphism/","link":"","permalink":"http://47.107.237.149/2019/04/30/多态polymorphism/","excerpt":"","text":"做梦都要背出来的三个必要条件 要有继承 要有重写 父类引用要指向子类对象三种实现方式 接口实现 继承父类进行方法重写 同一个类内进行方法重载（只有返回值类型不同不叫重载） 代码实例 package cn.haien.polymorphism; public class Animal { public void voice() { System.out.println(&quot;普通动物的叫声&quot;); } } class Cat extends Animal{ public void voice() { System.out.println(&quot;喵喵喵&quot;); } public void catchMouse() { System.out.println(&quot;抓老鼠&quot;); } } class Dog extends Animal{ public void voice() { System.out.println(&quot;汪汪汪&quot;); } } package cn.haien.polymorphism; public class Test { public static voidtestAnimalVoice(Animal c) {//形参使用多态 //编译时，扫描到Animal //并发现其中有voice这个方法就通过了 c.voice(); if(c instanceof Cat)//instanceof 表示判断前者是不是后面类的实例化对象 ((Cat)c).catchMouse();//如果是的话，强制转换为Cat类型并调用它自己的方法 } public static void main(String[] args) { Animal a = new Cat(); Animal b = new Dog(); testAnimalVoice(a); testAnimalVoice(b); Cat a2 = (Cat)a;//只能把引用该子类的父类对象强制转换为相应子类，其他都不行 //Cat b2 = (Cat)b; a2.catchMouse(); //b2.catchMouse();//编译通过，但运行出错，编译通过是因为编译器比较傻，你让它强制转换为什么它就强制转换为什么 //但是真正运行的时候实际是什么就是什么，不能把一只狗强制转换为一只猫 } }其实返回值也可以使用多态 内存分析 编译文件，从上到下、从左到右开始扫描，首先将Test加载到方法区即帧中（在Test文件中点运行） 扫描到main方法则开始运行 遇到类名则将其加载到帧中 遇到new则创建对象并在栈中分配内存，那么要先调用类的构造器。 PS：构造器中实际隐式地传入this和supper，，而supper指向上级父类，一直找到Object类后开始一级一级往下执行构造器，每一级的this都指向最终要创建的对象而不会不同，只有supper是不同的 遇到testAnimalVoice方法开始传参，开辟栈帧存放形参c，同样指向堆中的类构造 内存情况 内存深入分析package cn.haien.polymorphism2; public class HttpServlet { public void service() { System.out.println(&quot;HttpServlet.service()&quot;); doGet();//实际上是this.doGet(); } public void doGet() { System.out.println(&quot;HttpServlet.doGet()&quot;); } } class myServlet extends HttpServlet{ public void doGet() { System.out.println(&quot;myServlet.doGet()&quot;); } } package cn.haien.polymorphism2; public class TestHttpServlet { public static void main(String[] args) { HttpServlet a = new myServlet(); a.service();//内含doGet的调用，实际上调用的是子类myServlet的doGet函数 } }","categories":[],"tags":[]},{"title":"","slug":"对称加密、非对称加密","date":"2019-04-30T08:25:46.103Z","updated":"2019-03-08T06:33:40.086Z","comments":true,"path":"2019/04/30/对称加密、非对称加密/","link":"","permalink":"http://47.107.237.149/2019/04/30/对称加密、非对称加密/","excerpt":"","text":"对称加密 又称私钥加密，使用单个私钥来加密和解密数据，收发双方都用同一密钥进行解密，必须保护密钥传输过程中不被他人得到。由于同一密钥同时用于加解密，所以称为对称加密。 私钥加密算法非常快，特别适合加密较大的数据流。 原理 举个栗子，甲和乙是一对生意搭档，他们住在不同的城市。由于生意上的需要，他们经常会相互之间邮寄重要的货物。为了保证货物的安全，他们商定制作一个保险盒，将物品放入其中。他们打造了两把相同的钥匙分别保管，以便在收到包裹时用这个钥匙打开保险盒，以及在邮寄货物前用这把钥匙锁上保险盒。只要甲乙小心保管好钥匙，就算有人得到保险盒也无法打开。 在对称加密中，数据发送方将明文（原始数据）和加密密钥一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。接收方收到密文后，若想解读原文，则需要使用加密密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。 特征 加密解密的速度比较快，适合数据比较长时的使用。 秘钥传输过程不安全，且容易被破解，秘钥管理也比较麻烦。 不对称加密 又称公钥加密，使用公钥和私钥，公钥和私钥都在数学上相关联，用公钥加密的数据只能用私钥解密，而用私钥签名的数据只能用公钥验证。公钥可以被任何人发现，用于对发送到私钥持有者的数据加密。称为不对称算法的原因是用公钥加密而解密确实用的私钥。 例子，小红和小明使用不对称加密传送数据。首先，小红在本地生成公钥/私钥对，并通过不安全的网络将公钥发送给小明（因为小明发起发送数据请求，向她索要公钥了）。接着，小明使用该公钥加密数据后发送，而小红使用她的私钥解密该数据。 反之，小红若想给小明会消息，则会先向小明索要其公钥，然后用该公钥加密消息再发送，而小明用自己的私钥解密该消息。 即使黑客中途截获密钥和消息，但没有私钥也解密不了。 算法：RSA,DSA,DH asymmetric cryptography。 缺点：公钥算法非常慢，不适合用来加密大量数据，仅对传输少量的数据有用。 数字签名 数字签名验证发送方的身份并帮助保护数据的完整性。 使用不对称加密对消息生成数字签名，首先，小红用哈希算法加密消息生成消息摘要。然后，再用私钥应用于该消息摘要生成个人签名，将消息摘要+个人签名发送给小明。小明收到后首先使用小红的公钥解密签名得到消息摘要，如果该消息摘要与收自小红的消息摘要一致，则可以确定该消息来自私钥持有人，并且数据未被篡改。 但公钥易被窃取，因此任何人都可以验证签名，所以还需要对消息进行加密。 总结 公钥用于加密和验章，私钥用于解密和签章。","categories":[],"tags":[]},{"title":"","slug":"队列","date":"2019-04-30T08:25:46.091Z","updated":"2018-06-05T10:12:11.519Z","comments":true,"path":"2019/04/30/队列/","link":"","permalink":"http://47.107.237.149/2019/04/30/队列/","excerpt":"","text":"基本概念①队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 ②队列中没有元素时，称为空队列。 ③建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。 ④队列采用的FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出） 先进先出 循环队列 队列满和空时，rear和front都相等，那么如何判断相等时是满还是空呢？ 可以标记size，0是空，n是满；或者标记tag，每次插入，将tag置1，删除置0，看tag就可以知道最后一次操作是删除还是插入；也可以放弃其中一个数据域。","categories":[],"tags":[]},{"title":"","slug":"堆栈实现四则运算","date":"2019-04-30T08:25:46.088Z","updated":"2018-06-05T09:30:52.180Z","comments":true,"path":"2019/04/30/堆栈实现四则运算/","link":"","permalink":"http://47.107.237.149/2019/04/30/堆栈实现四则运算/","excerpt":"","text":"中缀转后缀","categories":[],"tags":[]},{"title":"","slug":"堆","date":"2019-04-30T08:25:46.085Z","updated":"2018-06-07T08:11:23.566Z","comments":true,"path":"2019/04/30/堆/","link":"","permalink":"http://47.107.237.149/2019/04/30/堆/","excerpt":"","text":"定义 堆的表示 为了插入和删除的方便，我们将堆设计成一种特殊的二叉树： 在每一棵子树中，根结点最大。比如说我们每次要删的都是最大值，如果根结点不是最大，而是右结点最大，那么删除几次之后树都斜到左边了，这个树的高度就不是log2 n了。而根结点最大的话就能保持树一直是完全二叉树。堆的操作 创建堆 这里是存放在数组中的 哨兵的作用后面再说 插入元素 首先插入最后一个位置，然后将其与根结点比较，若比根结点大则和根结点交换，再接着将其和更上一级根结点比较，还大的话再调换，知道不比根结点大为止。 进入循环之前，用i记录待插入元素，然后将其与根结点比较，若根结点小，则根结点会被挪到最后，再跟上上一级根结点比，根结点还是小，则会被挪到下一级根结点的位置上；若待插入元素比所有根结点大，则会放到哨兵的位置上。 算法实例：第五讲-&gt;5.1第2小节 删除元素 把5号赋给1号，然后删除5号 1号再跟它的子结点比较，小的话就和它交换位置，交换完了再和子结点比较，直到不小为止。 算法实例：第五讲-&gt;5.1第3小节 堆的创建 主要研究第二种方法 根据堆的删除算法，我们是先将根结点替换为最后一个结点，然后一个一个比较交换位置。这种算法的前提是，根结点的左右子树已经是堆了。利用这种算法来创建堆。 从底层第一个有儿子的结点87开始，它的左右必定已经是堆，然后利用堆的删除算法将其包括子树调整成堆；接着对前一个同级结点30也这么做。 时间复杂度是O(n).","categories":[],"tags":[]},{"title":"","slug":"迭代器Iterator","date":"2019-04-30T08:25:46.083Z","updated":"2018-04-06T09:44:37.281Z","comments":true,"path":"2019/04/30/迭代器Iterator/","link":"","permalink":"http://47.107.237.149/2019/04/30/迭代器Iterator/","excerpt":"","text":"Interface Iterator{hasNext()等基本规则} 上下是两个平行的类，Iterable中应用了Iterator类 Iterface Iterable{iterator()方法，返回Iterator对象} ↑实现 Collection、List、Set{重写iterator方法}","categories":[],"tags":[]},{"title":"","slug":"登录注册页面","date":"2019-04-30T08:25:46.079Z","updated":"2018-04-24T23:23:55.640Z","comments":true,"path":"2019/04/30/登录注册页面/","link":"","permalink":"http://47.107.237.149/2019/04/30/登录注册页面/","excerpt":"","text":"dao包：数据库操作model：放实体类service：放逻辑层web:放连接层 导图不设置宽高的话浏览器不显示 在table里面没有办法把图片绝对居中的，使用padding也不行（比如往下移一点，好像只能往左右移动），要在外面套一层div： &lt;div align=&quot;center&quot; style=&quot;padding-top:50px;&quot;&gt; &lt;table width=&quot;739&quot; height=&quot;499&quot; background=&quot;images/554.png&quot;&gt; &lt;/table&gt; &lt;/div&gt; 新建项目的话如果要用到Http’servlet之类需要Tomcat的类，就要引进lib包里 步骤 导入图片的话，先在WebContent下新建文件夹（普通文件夹），然后把图片拖进去 处理请求和响应的方法里也要修改字符集，如LoginServlet和RegistServlet 在存、取cookie时分别要进行转码与解码，参见StudentInfoManage项目LoginServlet与main2.jsp","categories":[],"tags":[]},{"title":"","slug":"当前目录","date":"2019-04-30T08:25:46.076Z","updated":"2018-07-24T09:58:53.098Z","comments":true,"path":"2019/04/30/当前目录/","link":"","permalink":"http://47.107.237.149/2019/04/30/当前目录/","excerpt":"","text":"是当前项目","categories":[],"tags":[]},{"title":"","slug":"错误响应码302","date":"2019-04-30T08:25:46.073Z","updated":"2018-07-31T03:28:57.892Z","comments":true,"path":"2019/04/30/错误响应码302/","link":"","permalink":"http://47.107.237.149/2019/04/30/错误响应码302/","excerpt":"","text":"302定义 302：redirect，代表暂时性转移；意思就是你访问网址a，但是因为服务端的拦截器或者其他代码处理，会被重定向到网址b。","categories":[],"tags":[]},{"title":"","slug":"存储过程和存储函数","date":"2019-04-30T08:25:46.071Z","updated":"2019-03-12T07:55:58.762Z","comments":true,"path":"2019/04/30/存储过程和存储函数/","link":"","permalink":"http://47.107.237.149/2019/04/30/存储过程和存储函数/","excerpt":"","text":"存储过程 把一些通用的sql语句放进去 提高系统的性能 delimiter 分隔符，默认是分号，即MySQL解释器遇到分号即执行前面所有MySQL语句 上图用delimiter &amp;&amp;将分隔符改为&amp;&amp;，那么解释器遇到&amp;&amp;后才会执行 因为select可能有多条语句，所以不能遇到分号就马上执行，故用&amp;&amp;放在最后面作为结束标志 pro_book是存储过程的名称，相当于函数名 参数列表中，IN表示名为bT的变量是要传入的变量，并且类型为int型（类型必须是MySQL支持的类型），OUT则表示count_num为要返回的、输出的参数 READS SQL DATA声明存储过程执行了读数据的操作 BEGIN跟END定义存储过程的始末点 SELECT是表操作语句，count就是要输出的变量 delimiter ; ：改回默认的分隔符 第一次运行，创建一个存储过程并运行CALL语句，返回结果；后面运行只能把CALL语句刷黑，选择“运行已选择的”，若全部运行的话，则又要创建一个存储过程，这会报错：pro_book已存在 存储函数 returns varchar(20):声明返回值的类型，注意这里用的是returns，有加“s” return+sql语句：直接返回执行sql语句的结果，注意这里return没s select：调用存储函数 定义变量 关键字是declare，后面跟变量名，可以是多个，然后变量类型，默认值是null 赋值 直接给变量赋值 引用别的表的值 游标 declare关键字定义游标，名为cur_t_user2，类型为cursor（游标），for后面接sql语句；定义的游标即为sql语句结果集的游标 open：打开游标 fetch：取游标当前值赋给a,b；本来应该是循环的，不过还没学，现在只能取首个结果 close：关闭游标 if语句 要用end if结尾 还可以有else if case语句 循环语句 aaa:循环标签，相当于循环的名字，随便起 leave：跳出循环 跳出本次循环 repeat循环 while语句","categories":[],"tags":[]},{"title":"","slug":"从github上克隆项目","date":"2019-04-30T08:25:46.068Z","updated":"2018-07-29T07:26:47.382Z","comments":true,"path":"2019/04/30/从github上克隆项目/","link":"","permalink":"http://47.107.237.149/2019/04/30/从github上克隆项目/","excerpt":"","text":"参考文章 在github上点击项目的Clone or download，复制https地址。 若要对拉下来的项目进行版本管理则在一个版本仓库（如learngit）里git bash，否则选择一个普通文件夹即可 输入命令：git clone+刚才的https地址,文件夹中即多出一个以项目名为名的文件夹","categories":[],"tags":[]},{"title":"","slug":"创建spring-boot项目","date":"2019-04-30T08:25:46.063Z","updated":"2019-02-15T06:41:46.794Z","comments":true,"path":"2019/04/30/创建spring-boot项目/","link":"","permalink":"http://47.107.237.149/2019/04/30/创建spring-boot项目/","excerpt":"","text":"ps: 社区版IDEA没有spring initializr，它用的不是spring boot插件，而是spring assistant插件。插件安装过程创建方式 使用sts插件/IDEA自带的插件创建（需要联网,往往失败） 第一次选择create new project,选中spring assistant，project SDK即是选择jdk版本，下面的http://start.spring.io是基础结构的下载地址 group：项目的组织id type：是maven依赖管理的项目 version：项目版本号，自定义 description：可以不写 package：包，尽量短一点 选择web 直接使用Maven创建项目的方式创建（不用联网） 任意IDE新建空maven项目（不选择任何模板） 其中ideaProjects是不存在的目录，idea会自动创建，以后可以把项目都建在这个目录下面 后期运行找不到工作路径的话可以点击Run-&gt;Edit configuration修改项目目录 基础配置 &lt;!--在这里配置了之后可以在别的地方通过${project.build.sourceEncoding}引用--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!--让整个项目统一编码，默认的，不写也可以--&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;!--源码编译版本，其实就是jdk版本，下同--&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;!--目标平台编译版本--&gt; &lt;/properties&gt; 修改pom.xml添加spring starter project的父级依赖spring-boot-starter-parent，添加之后这个项目就是一个spring boot项目了 spring-boot-starter-parent是一个特殊的starter，用来提供相关的maven默认依赖，使用之后，常用的包依赖可以省略version标签。1.5.9版本最常用。 ：配置一个父模块的pom的相对路径的话，表示多模块Maven项目中的子项目可以继承父pom，默认值是./pom.xml也就是Maven默认父pom在上一层目录下；但此处为空则表示始终从本地或远程仓库查找依赖。查找顺序：配置的路径（如果有的话）-本地仓库-远程仓库。 修改pom.xml添加web支持的starter 添加测试的起步依赖 添加spring boot编译插件 把项目打包成一个可执行的超级JAR（uber-JAR）,包括把应用程序的所有依赖打入JAR文件内，并为JAR添加一个描述文件，其中的内容能让你用java -jar来运行应用程序。 搜索public static void main()方法来标记为可运行类。 项目生成后，会在根包目录下生成一个入口类，添加一个测试控制器简单测试一下 执行main方法之后，在浏览器中访问http://localhost:8080，可以得到： 添加必要配置 在java目录下面新建包，包下建App类，代码如下： 按debug按钮，访问localhost：8080： 代码实例：E://springboot-web/src/main/java/com.haien/App","categories":[],"tags":[]},{"title":"","slug":"抽象类abstractClass","date":"2019-04-30T08:25:46.060Z","updated":"2018-08-20T03:54:51.434Z","comments":true,"path":"2019/04/30/抽象类abstractClass/","link":"","permalink":"http://47.107.237.149/2019/04/30/抽象类abstractClass/","excerpt":"","text":"作用：将方法的设计与实现分开 要求：子类一定要对父类的抽象方法进行实现 抽象方法一般用public或protected描述，表明能被本包和其他包的子类调用，不能用private私有化 抽象类不能实例化，只能用来接收子类的引用 方式：抽象类存在的意义在于被继承","categories":[],"tags":[]},{"title":"","slug":"查询","date":"2019-04-30T08:25:46.056Z","updated":"2018-04-16T13:35:22.585Z","comments":true,"path":"2019/04/30/查询/","link":"","permalink":"http://47.107.237.149/2019/04/30/查询/","excerpt":"","text":"两张表结构 t_book t_booktype 3*4=12种 把符合条件的找出来 提倡起个别名来标识哪个字段是哪个表的 左连接，左边的表一定要全部罗列出来，但是右边只列出符合条件的，ON表示条件（右边找不到则用null表示）（RIGTH JOIN则是右连接） 多条件查询，在where后面可以加多个and添加条件 子查询，查到的booktypeid一定得是t_booktype里面存在的id NOT IN则不在范围内 再来一张表t_bookpricelevel 价格必须&gt;=括号里的价格等级 第一条，括号里的查询结果是存在的（不为空）则执行括号外的查询操作 第二条相反 括号里查出来是个集合，不能直接大于等于；加any表示大于等于其中任何一个就足够了，换成all表示需满足所有条件 union 合并，将查询结果合并，去除重复；union all则不去除 给表取别名，加不加as都可以","categories":[],"tags":[]},{"title":"","slug":"不能建test文件","date":"2019-04-30T08:25:46.054Z","updated":"2018-08-22T08:22:13.192Z","comments":true,"path":"2019/04/30/不能建test文件/","link":"","permalink":"http://47.107.237.149/2019/04/30/不能建test文件/","excerpt":"","text":"首先测试文件所在目录应该是src/test/java下面，然后点击File-&gt;project structure，选中src/test/java目录然后点击test将其设置为test文件的根目录。成功的话java包前面的图标应该变成绿色。","categories":[],"tags":[]},{"title":"","slug":"表单数据自动封装成对象","date":"2019-04-30T08:25:46.050Z","updated":"2018-09-14T03:50:45.704Z","comments":true,"path":"2019/04/30/表单数据自动封装成对象/","link":"","permalink":"http://47.107.237.149/2019/04/30/表单数据自动封装成对象/","excerpt":"","text":"写后台接口时直接用对象来接收表单数据，前台将会把数据自动封装成对象。 注意：表单中的name属性要与实体类的属性名称一致。 在Spring进行数据封装时，提交到后台的数据都是String型，对于基本的数据类型会自动转化，比如将String转为int、float等。但是int型输入的不是全数字时转化就会失败，最终该字段被设置为0，即取其默认值。而Data型属性（字段类型对应为text）前台无论输入什么后台获得的都是null。解决方法另寻。 当表单中还包含上传文件则会报错： &lt;form action=&quot;savefile&quot; method=post enctype=&quot;multipart/form-data&quot;&gt; 然后，为了接收文件，在方法接口参数增加MultipartFile public String save(@RequestPart(&quot;file&quot;) MultipartFile file, User user) //假设对象是User 报错： The request sent by the client was syntactically incorrect.","categories":[],"tags":[]},{"title":"","slug":"报错","date":"2019-04-30T08:25:46.046Z","updated":"2018-05-08T09:48:13.318Z","comments":true,"path":"2019/04/30/报错/","link":"","permalink":"http://47.107.237.149/2019/04/30/报错/","excerpt":"","text":"代码没错但反复使用一个页面提交报错的话可能是部署出了问题，重启下Tomcat","categories":[],"tags":[]},{"title":"","slug":"包装类","date":"2019-04-30T08:25:46.044Z","updated":"2018-04-01T13:10:33.547Z","comments":true,"path":"2019/04/30/包装类/","link":"","permalink":"http://47.107.237.149/2019/04/30/包装类/","excerpt":"","text":"自动装箱和自动拆箱 代码示例 报错，null是没有而不是0，因此b这个对象是没有，因此不能调用方法 第一行false 第二行true 因为对象不会=对象，类型或数值才会相等 两行都是true 因为编译器把[-128,127]还是当成基本数据类型处理，因此可以直接=","categories":[],"tags":[]},{"title":"","slug":"把项目打成war包并部署到tomcat","date":"2019-04-30T08:25:46.032Z","updated":"2019-03-12T06:36:50.659Z","comments":true,"path":"2019/04/30/把项目打成war包并部署到tomcat/","link":"","permalink":"http://47.107.237.149/2019/04/30/把项目打成war包并部署到tomcat/","excerpt":"","text":"把web项目打成war包 使用eclipse 右击项目选择export，选择web文件夹中的war file 选择存储位置，可以直接选Tomcat下的webapps目录，反正等一下部署到服务器上也是要放到那里去的 使用命令行 命令行进入项目StudentInfoManager中，运行 jar -cvf StudentInfoManager.war * 等待打包 maven打包 如果是对多模块maven项目打成war包则对web模块执行mvn package即可。 可以在pom.xml中指定war包的一些特性，不声明以下插件则使用默认配置： &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--打成war包名，则部署到tomcat后访问https://localhost:8443/finalName(/login) 跳转登录页面--&gt; &lt;warName&gt;${project.build.finalName}&lt;/warName&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/webapp/WEB-INF&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;targetPath&gt;WEB-INF&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; 以上三种方法打包成功后会在项目或项目target下生成StudentInfoManager.war文件，将其放到tomcat的webapps目录下 然后直接启动tomcat就行，一般都用自动部署而不配置server了，不过可以了解下server配置。一般Tomcat/conf/server.xml如下配置即可： &lt;!--host虚拟主机的作用是运行多个web应用； AppBase:指定web应用所在目录（相对于tomcat根目录） deployOnStartup:启动时检测是否有新的web并自动部署，一般有autoDeploy就够了 autoDeploy:运行时定期检测是否有新的web并应用--&gt; &lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot; xmlValidation=&quot;false&quot; xmlNamespaceAware=&quot;false&quot;&gt; &lt;!--一个Context代表一个web应用，每个web应用基于war文件，或war文件解压后对应的目录 docBase:war包位置和appBase不一样才需要指定 path:访问路径，默认是/项目名；path=&quot;&quot;表示这是虚拟主机的默认web应用，当请求的url与all path都不符合的时候就用它； 但是在自动部署的场景下，不能指定path属性--&gt; &lt;Context path=&quot;/StudentInfoManage&quot; docBase=&quot;D:\\Eclipse\\webApp\\StudentInfoManage.war&quot; reloadable=&quot;false&quot;/&gt; 启动Tomcat：双击bin/startup.bat，窗口闪退的话编辑startup.bat，在末尾增加“pause”,记得下面还要剩下一行或是两行的，否则不生效 再次启动，失败的话看下日志，如果是读取环境变量失败的话，编辑startup.bat setlocal &lt;!--添加这两行--&gt; SET JAVA_HOME=D:\\jdk\\1.8 SET TOMCAT_HOME=D:\\apache-tomcat-7.0.86 重新启动，浏览器输入localhost:8080/StudentInfoManager即可访问，访问全程不要叉掉两个启动窗口。 其中一个窗口在访问过程中会打印日志，如果出现WARN： Establishing SSL connection without server&apos;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&apos;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &apos;false&apos;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 原因是mysql在高版本需要指明是否进行SSL连接 把项目部署到Linux下的tomcat 把项目war包发送到Linux下tomcat的webapps里，执行命令启动tomcat cd /usr/java/tomcat/apache-tomcat-7.0.91/bin //进入bin目录 //方式一：直接启动 ./startup.sh //缺点：客户端断开连接后tomcat服务也会立即停止 //方式二：作为服务启动 nohup ./startup.sh &amp; //作为Linux服务一直运行，和方式一一样会将日志写到tomcat的日志文件catalina.out中，不能直接看到 //方式三：在当前连接界面动态输出tomcat日志 ./catalina.sh run //Ctrl+c退出 //关闭tomcat ./shutdown.sh 默认网址是————服务器ip:8080/项目名 怕冲突想要修改端口的话可以修改server.xml，把8005改成8006,8080-&gt;8081,8009-&gt;8010.然后改bin/catalina.sh，在文件首部一堆注释里面加两个export 不过好像都不改也可以的 不过要保证启用的端口有添加在ECS中，添加过程：实例–管理–本实例安全组–配置规则–添加安全组规则 另外，不用改jdbc的url，本地的数据库是localhost:3306，而对于在服务器上运行的web，它访问服务器上的数据库也是localhost，不过3306端口要记得添加到安全组里，虽然 不是外部访问的，但是添加上去好像也没事。","categories":[],"tags":[]},{"title":"","slug":"安装jdk","date":"2019-04-30T08:25:46.029Z","updated":"2018-08-30T11:55:58.548Z","comments":true,"path":"2019/04/30/安装jdk/","link":"","permalink":"http://47.107.237.149/2019/04/30/安装jdk/","excerpt":"","text":"参考文章 进入安装向导之后有两次需要选择目录，第一次是选择jdk目录，第二次是选择jre目录，务必选择同一根目录，比如都在D:/java/下 最后做测试的时候一定要试试java -version和javac，都通过了才算好。","categories":[],"tags":[]},{"title":"","slug":"WPS技巧","date":"2019-04-30T08:25:46.026Z","updated":"2018-12-15T02:52:30.723Z","comments":true,"path":"2019/04/30/WPS技巧/","link":"","permalink":"http://47.107.237.149/2019/04/30/WPS技巧/","excerpt":"","text":"去红色波浪线 点击左上角“WPS文字”-&gt;工具-&gt;选项-&gt;拼写检查，取消输入时拼写检查的勾选。","categories":[],"tags":[]},{"title":"","slug":"Windows命令","date":"2019-04-30T08:25:46.022Z","updated":"2019-04-27T06:01:52.039Z","comments":true,"path":"2019/04/30/Windows命令/","link":"","permalink":"http://47.107.237.149/2019/04/30/Windows命令/","excerpt":"","text":"进入某个目录 进入盘 //直接输出盘符，不需cd e: 进入盘后才需要cd命令来进入盘下其他目录。","categories":[],"tags":[]},{"title":"","slug":"Windows路径表示","date":"2019-04-30T08:25:46.008Z","updated":"2019-04-28T03:50:15.540Z","comments":true,"path":"2019/04/30/Windows路径表示/","link":"","permalink":"http://47.107.237.149/2019/04/30/Windows路径表示/","excerpt":"","text":"绝对路径 绝对路径就是完整路径 比如，D:\\Windows\\System32\\calc.exe以\\\\?\\开头的路径 还不知道这种命名方式是什么，反正绝对路径也可以用它来表示，比如，\\\\?\\C:Windows\\System32\\calc.exe相对路径 比如使用cd命令进入一个文件夹，那么这个文件夹就成为当前文件夹（工作文件夹）。如果在进程操作文件时传递一个相对路径，那么进程会将当前文件夹的路径与这个相对路径合并，得到一个完整路径。 相对路径格式如下，Windows\\System32\\calc.exe。 要注意的是相对路径开头不能有\\，有\\是另一种路径。以\\开头的路径 相当于当前文件夹根目录的路径 例如当前文件夹是C:Windows，那么\\System32\\calc.exe就表示C:\\System32\\calc.exe。无论当前文件夹的路径有多深，只取根目录进行合并。对于SpringBoot项目是当前项目（有时可能是项目所在盘）。.\\的表示 ./src/ 当前目录中的src文件，./对于SpringBoot项目是就是这个项目 ../src/ 当前目录的上一级目录中的src文件夹 /src/ 项目根目录（可以指磁盘这种根目录，也可以指项目根目录，SpringBoot项目的话就是项目）PS Unix使用/作为路径分隔符，而Windows使用反斜杠\\，但是目前Windows下两种都可以。java中路径的书写 Javaweb路径书写 java中各种获取路径方法${pageContext.request.contextPath} 获得工程名——/工程名，/表示localhost:8080/;等价于&lt;%=request.getContextPath()%&gt;. 把一个相对路径解析为绝对路径：request.getRealPath(String str),但已过 可替换的方法：request.getSession().getServletContext().getRealPath(String str) 在XxxServlet里面用this.getServletcontext.getRealPath(“/“)：获取项目根路径，得到的应该是项目所在目录，如，D:/Eclise/myprojects/market2 例如：exper.tx位于C:/tomcat 6.0/webapps/root/下，在该目录下写一个.jsp文件： ServletContext context=getServletContext(); context.getRealPath(&quot;exper1.txt&quot;); //C:/tomcat 6.0/webapps/root/exper1.txt &lt;a href=&quot;${pageContext.request.contextPath}/student/preSave.do&quot;&gt;添加学生&lt;/a&gt; 相当于在网址栏上刷新之前的路径换成localhost:8080/工程名/student/preSave.do，访问这个路径会被后台web.xml拦截并分发到RequestMapping为/student/preSave的Controller处理。 这种获取绝对路径的方法是为了防止相对路径有时会出现嵌套、重复等访问失灵情况。 代码实例：SpringMvc02/WebContent/WEB-INFO/jsp/student/list.jspclasspath根目录 maven项目中为src/main/java、resources和webapp。 具体参见笔记：classpath根目录","categories":[],"tags":[]},{"title":"","slug":"VMware下载Linux虚拟机","date":"2019-04-30T08:25:45.995Z","updated":"2018-11-10T01:49:02.351Z","comments":true,"path":"2019/04/30/VMware下载Linux虚拟机/","link":"","permalink":"http://47.107.237.149/2019/04/30/VMware下载Linux虚拟机/","excerpt":"","text":"我们下载CentOS版本，首先准备CentOS镜像。官网地址，从首页进入的话就点击Mirror List跳转到该页面。从下面这一串列表里面选一个镜像，我选最后一个 点击链接，从一串版本里面选择6/7开头的；选择isos；选择x86 64；选择DVD（轻便满足需求）或Everything（一应俱全）版；开始下载后是一个压缩包，不需要解压，待用。 安装Linux教程从第3步看起 第6步处理器数量1/2皆可 第7步内存设置不要超过最大推荐内存即可 第8步网络类型一般都是选择NAT 第12步指定自盘容量，由于我准备的磁盘F盘有100G，所以我指定了50G；然后好像挺多教程都选择“将磁盘拆分成多个文件” 第15步浏览选择刚才下载的镜像文件压缩包 安装CentOS,从第十二步开始看起 配置静态ip","categories":[],"tags":[]},{"title":"","slug":"UUIDUtil获取八位UUID","date":"2019-04-30T08:25:45.992Z","updated":"2018-10-09T06:24:16.451Z","comments":true,"path":"2019/04/30/UUIDUtil获取八位UUID/","link":"","permalink":"http://47.107.237.149/2019/04/30/UUIDUtil获取八位UUID/","excerpt":"","text":"思路 短8位UUID思想源于微博短域名的生成方式，但是原版的重复概率过高，而且每次生成4个，需要随机选取一个。 本算法利用62个可打印字符，通过随机生成32位UUID，由于UUID都为十六进制，所以将UUID分为8组，每4个为一组，然后通过模62操作，结果作为索引取出字符。 这样重复率大大降低。经测试，在生成一千万个数据也没有出现重复，完全满足大部分需求。 代码public class UUIDUtils { //字符库 public static String[] chars = new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; }; public static String getUUID() { //调用Java提供的生成随机字符串的对象：32位，十六进制，中间包含- String uuid= UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); StringBuffer shortBuffer = new StringBuffer(); for (int i = 0; i &lt; 8; i++) { //分为8组 String str = uuid.substring(i * 4, i * 4 + 4); //每组4位 int x = Integer.parseInt(str, 16); //输出str在16进制下的表示 shortBuffer.append(chars[x % 0x3E]); //用该16进制数取模62（十六进制表示为314（14即E）），结果作为索引取出字符 } return shortBuffer.toString();//生成8位字符 } }","categories":[],"tags":[]},{"title":"","slug":"url乱码导致400错误，语法错误","date":"2019-04-30T08:25:45.989Z","updated":"2018-05-11T11:51:01.181Z","comments":true,"path":"2019/04/30/url乱码导致400错误，语法错误/","link":"","permalink":"http://47.107.237.149/2019/04/30/url乱码导致400错误，语法错误/","excerpt":"","text":"url带的参数有中文发生乱码导致网址无法访问","categories":[],"tags":[]},{"title":"","slug":"UriComponentsBuilder和UriComponents","date":"2019-04-30T08:25:45.979Z","updated":"2019-04-09T07:43:00.483Z","comments":true,"path":"2019/04/30/UriComponentsBuilder和UriComponents/","link":"","permalink":"http://47.107.237.149/2019/04/30/UriComponentsBuilder和UriComponents/","excerpt":"","text":"简介 spring mvc提供了一种机制，可以构造和编码URI，即使用UriComponentsBuilder和UriComponents。功能相当于uelencode()函数，对url进行编码（比如请求中含有空格时编码为%20），同时支持变量替换。 需引入spring-web依赖。 示例 最简单粗暴： UriComponents uriComponents=UriComponentsBuilder .fromHttpUrl(&quot;http://localhost:8080//hello&quot;) .queryParams(params).build() //params是个Map String uri=uriComponents.toUriString(); expand(): 替换参数。 encode(): 编码，默认使用utf-8。 UriComponents uriComponents = UriComponentsBuilder .fromUriString(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;).build(); URI uri = uriComponents.expand(&quot;42&quot;, &quot;21&quot;).encode().toUri(); 注意：UriComponents是不可变的，expand()和encode()返回新的实例。 上述例子也可以这样实现： UriComponents uriComponents = UriComponentsBuilder.newInstance() .scheme(&quot;http&quot;).host(&quot;example.com&quot;).path(&quot;/hotels/{hotel}/bookings/{booking}&quot;).build() .expand(&quot;42&quot;, &quot;21&quot;) .encode(); 参考文章 代码示例：ideaProjects/shiro-chapter20/test/ClientTest","categories":[],"tags":[]},{"title":"","slug":"transient关键字","date":"2019-04-30T08:25:45.971Z","updated":"2018-10-23T14:03:28.241Z","comments":true,"path":"2019/04/30/transient关键字/","link":"","permalink":"http://47.107.237.149/2019/04/30/transient关键字/","excerpt":"","text":"短暂的 修饰某些变量表示不需要序列化 序列化指的是将Java中的对象转换成以字节序列的形式来表示，相当于文件可以是可视化的文字或图片也可以是字节流的形式。一个序列化后的对象可以被写到数据库或文件中，也可以用于网络传输。 一般当我们使用缓存cache而内存空间不够时就有可能会本地存储到硬盘，这就需要我们的实体类实现Serializable接口。 序列化的目的是为了反序列化，恢复成原先的Java对象。 那么什么样的变量不需要序列化呢？ 可以根据其他属性推导出来的变量，比如一个长方形类有三个属性：长、宽、面积，则面积不需要序列化（反序列化后面积变量为默认值），它可以根据长宽推测出来。 为什么要不被序列化呢，主要是为了节省空间，但其实可能会带来一些弊端，有些属性需要初始化、重新计算之类。总的来说，利大于弊。","categories":[],"tags":[]},{"title":"","slug":"tomcat7-run报错-Fail to load 某个依赖from 私服仓库地址","date":"2019-04-30T08:25:45.968Z","updated":"2019-01-15T12:56:01.021Z","comments":true,"path":"2019/04/30/tomcat7-run报错-Fail to load 某个依赖from 私服仓库地址/","link":"","permalink":"http://47.107.237.149/2019/04/30/tomcat7-run报错-Fail to load 某个依赖from 私服仓库地址/","excerpt":"","text":"因为私服中根本没有这个jar包，然后手动上传到私服的过程又好像除了什么差错，导致项目部署到tomcat的时候一直报错，后来把私服的中央仓库地址改了，oschina里更新还是太慢，没有很多jar包，改回中央仓库原地址。","categories":[],"tags":[]},{"title":"","slug":"Thymeleaf","date":"2019-04-30T08:25:45.964Z","updated":"2018-07-17T03:27:09.730Z","comments":true,"path":"2019/04/30/Thymeleaf/","link":"","permalink":"http://47.107.237.149/2019/04/30/Thymeleaf/","excerpt":"","text":"Thymeleaf SpringBoot支持前端页面使用Thymeleaf渲染，并不支持jsp。 web工程项目结构如下： 在templates目录下写前端html等页面的形式就称为thymeleaf 引入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;artifactId&gt; 启用不严格检查 引入nokohtml库: 修改配置文件加入： thymeleaf: mode:LEGACYHTML5 代码实例 SpringMvc02/:earnResourceController、domain/LearnResource 教程上的效果是这样： 不知道为什么运行出来是这样 参数配置","categories":[],"tags":[]},{"title":"","slug":"there is no getter for property xxx","date":"2019-04-30T08:25:45.960Z","updated":"2019-02-08T03:14:10.043Z","comments":true,"path":"2019/04/30/there is no getter for property xxx/","link":"","permalink":"http://47.107.237.149/2019/04/30/there is no getter for property xxx/","excerpt":"","text":"mybatis异常，可能是#{}中误写成了字段名，正确为属性名。 也可能是韩束入参为一个String型参数，引用该入参应改为#{_parameter}","categories":[],"tags":[]},{"title":"","slug":"test","date":"2019-04-30T08:25:45.945Z","updated":"2018-09-03T05:22:45.756Z","comments":true,"path":"2019/04/30/test/","link":"","permalink":"http://47.107.237.149/2019/04/30/test/","excerpt":"","text":"参考文章自动创建测试类 在你所需要测试的类或者接口名称上按ctrl+shift+t 一般类的测试controller类的测试//mvc.perform执行一个请求 mvc.perform(MockMvcRequestBuilders.get(url) //构造一个请求，Post就用.post方法 .accept(MediaType.APPLICATION_JSON_UTF8) //客户端希望接受的数据类型为application/json;charset=UTF-8 //还有一个contentType代表发送端发送的数据格式。默认为application/x-www-form-urlencoded .session(session) //注入一个session，通过拦截器 ) .andExpect(MockMvcResultMatchers.status().isOk()) //添加执行完成后的断言；MockMvcResultMatchers.status().isOk()看请求的状态响应码是否为200，否则抛异常，测试不通过 .andDo(MockMvcResultHandlers.print()); //添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息 一般测试方法前面会加上@Transaction注释，加上此注释则会默认加上@Rollback(true)注释，开启事务回滚，测试完数据被还原。assertThat新断言单元测试回滚","categories":[],"tags":[]},{"title":"","slug":"System.err.println","date":"2019-04-30T08:25:45.933Z","updated":"2018-09-26T13:42:38.601Z","comments":true,"path":"2019/04/30/System.err.println/","link":"","permalink":"http://47.107.237.149/2019/04/30/System.err.println/","excerpt":"","text":"System.err.println是运行期异常和错误反馈的输出流的方向 标准输出往往是带缓存，而标准出错没有缓存 与System.out.println混用会导致输出顺序错乱 public class TestCodeSeg { static{ System.out.println(&quot;1&quot;); } { System.out.println(&quot;2&quot;); } public TestCodeSeg(){ System.err.println(&quot;3&quot;); } public static void main(String[] args){ new TestCodeSeg(); //可能3/n 1 /n 2,因为out输出有缓存，err是立即输出，所以混用会导致3与1、2顺序错乱 } } 所以，一旦用了哪一个就始终只用那个 代码实例：SpringMvc02/TestCodeSeg","categories":[],"tags":[]},{"title":"","slug":"SVN","date":"2019-04-30T08:25:45.929Z","updated":"2018-06-01T09:35:32.889Z","comments":true,"path":"2019/04/30/SVN/","link":"","permalink":"http://47.107.237.149/2019/04/30/SVN/","excerpt":"","text":"生命周期创建仓库 版本库是存放终极版本的地方，是集中版本控制系统的版本库。在一台电脑上操作时，可以选择一个文件夹作为版本库。通常是新建一个文件夹，然后右键文件夹，在此创建版本库。这里版本库路径为E:/SVN/Myproject 此时版本库还是空的，我们需要把本机的项目导入版本库使其成为修改的起源（基线）。新建一个文件夹new，文件夹下应有这样三个子目录： 其中，trunk是主干，用来存放项目的，我们把项目移动进来 选择new，右键导入,URL 选择 file:///E:/SVN/Myproject 。导入成功后，右键单击版本库文件夹，选择版本库浏览器，导航至trunk可看到项目在里面了 检出工作副本。把项目加入版本库之后，要把版本库里的项目检出到本地文件夹，成为工作副本，以后就对工作副本进行修改。新建文件夹用于存放工作副本，右键检出设置 URL 为 file:///E:/SVN/MyProject/trunk。检出成功，工作副本会出现对勾。 在工作副本里添加文件，编辑好之后，想提交到版本库，需要先“添加”，然后再“提交”。 修改工作副本已有的文件，直接“提交”就可以了","categories":[],"tags":[]},{"title":"","slug":"Sublime Text 3","date":"2019-04-30T08:25:45.927Z","updated":"2018-05-06T09:48:58.027Z","comments":true,"path":"2019/04/30/Sublime Text 3/","link":"","permalink":"http://47.107.237.149/2019/04/30/Sublime Text 3/","excerpt":"","text":"常用必备插件、常用快捷键以及修改、推荐设置 ctrl + shift + c调出取色器","categories":[],"tags":[]},{"title":"","slug":"String类","date":"2019-04-30T08:25:45.922Z","updated":"2019-03-13T02:32:06.549Z","comments":true,"path":"2019/04/30/String类/","link":"","permalink":"http://47.107.237.149/2019/04/30/String类/","excerpt":"","text":"构造方法之一 String():构造空字符串对象。 String(String str):用已知字符串构造String对象，然后就可以调用String的各种方法来操作这个str。 String(char chars[],int startINdex,int length):用字符数组chars的第startIndex位开始length构造String对象。 String(byte[] bytes):用字节数组构造String对象。 byte[] strb = new byte[]{65,66}; String str6 = new String(strb); //相当于String str6 = new String(&quot;AB&quot;); String中各种方法 String.valueOf(boolean/char/char[]/char[],offset,length/double/float/int/long/Object):将各种基本类型、各种对象转为字符串，如 int i=10; String str=String.valueOf(i); //str=“10” Integer.parseInt(String):整型转回字符串，其他基本类型转为String int lastIndexOf(int ch/String str):返回此字符串指定字符ch/字符串str最后一次出现的位置，不出现返回-1 String.trim()：去掉首位空格 str.replaceAll(“ “,””)：去掉所有空格（包括首尾、中间） str.replaceAll(“\\\\s*”,””)：去掉所有空白符（空格、制表符、换页符） str.split(String regex):以regex为分隔符将字符串分割为String数组，从左到右扫描，遇到regex字符截止。 String permission=&quot;+user+view&quot;; //最后再加一个+结果一样 String[] array=permission.split(&quot;\\\\+&quot;); System.out.println(array.length); //3 for(String perm:array){ //空白\\n user\\n view\\n System.out.println(perm); } substring(int beginIndex, int endIndex)：截取字符串。","categories":[],"tags":[]},{"title":"","slug":"static静态代码块","date":"2019-04-30T08:25:45.918Z","updated":"2018-09-26T12:23:31.095Z","comments":true,"path":"2019/04/30/static静态代码块/","link":"","permalink":"http://47.107.237.149/2019/04/30/static静态代码块/","excerpt":"","text":"简介 一般情况下，如果有些代码必须在项目启动的时候就执行的话，就需要使用静态代码块。这些代码是主动执行的，在项目启动的时候就初始化。格式 举个例子，给某个集合里面预先塞值 静态代码块和静态方法的区别 静态代码块是自动执行的 静态方法是被调用的时候才执行的 静态代码块可以连着写 public class TestCodeSeg { static{ System.out.println(&quot;1&quot;); } { System.out.println(&quot;2&quot;); } public TestCodeSeg(){ System.err.println(&quot;3&quot;); } public static void main(String[] args){ new TestCodeSeg(); } } 代码实例 SpringMvc02/StudentController","categories":[],"tags":[]},{"title":"","slug":"SSO单点登录","date":"2019-04-30T08:25:45.904Z","updated":"2019-03-19T12:40:32.163Z","comments":true,"path":"2019/04/30/SSO单点登录/","link":"","permalink":"http://47.107.237.149/2019/04/30/SSO单点登录/","excerpt":"","text":"简介 单点登录：SSO，Single Sign On。 令牌Ticket代替密码访问的技术。 很早期的公司，一家公司可能只有一个Server，慢慢的Server开始变多了。每个Server都要进行注册登录，退出的时候又要一个个退出。用户体验很不好！你可以想象一下，上豆瓣要登录豆瓣FM、豆瓣读书、豆瓣电影、豆瓣日记……真的会让人崩溃的。我们想要另一种登录体验：一家企业下的服务只要一次注册，登录的时候只要一次登录，退出的时候只要一次退出。怎么做？ 一次注册。 一次注册不难，想一下是不是只要Server之间同步用户信息就行了？可以，但这样描述不太完整，后续讲用户注册的时候详细说。实际上用户信息的管理才是SSO真正的难点，只是作为初学者，我们的难点在于实现SSO的技术！我们先讨论实现手段。 一次登录与一次退出。 回头看看普通商场的故事，什么东西才是保持登录状态关键的东西？记录器（session）？那种叫做cookie的纸张？写在纸张上的ID?是session里面记录的信息跟那个ID，cookie不只是记录ID的工具而已。客户端持有ID，服务端持有session，两者一起用来保持登录状态 。客户端需要用ID来作为凭证，而服务端需要用session来验证ID的有效性（ID可能过期、可能根本就是伪造的找不到对于的信息、ID下对应的客户端还没有进行登录验证等）。但是session这东西一开始是每个server自己独有的，豆瓣FM有自己的session、豆瓣读书有自己的session，而记录ID的cookie又是不能跨域的。所以，我们要实现一次登录一次退出，只需要想办法让各个server的共用一个session的信息，让客户端在各个域名下都能持有这个ID就好了。再进一步讲，只要各个server拿到同一个ID，都能有办法检验出ID的有效性、并且能得到ID对应的用户信息就行了，也就是能检验ID。 目前单点登录主要基于web的多种应用程序。 CAS Central Authentication Service,中央认证服务，一种独立开放指令协议，是耶鲁大学发起的一个开源项目，旨在为web应用提供一种可开的单点登录方法。 jasig CAS：cas在2004年成为jasig的一个项目，因此别名也叫jasig CAS。 cas包含两个部分：CAS Server和CAS Client。 CAS Server：负责用户认证。 CAS Client：权限验证。 原理：比如有一个让web应用系统Biz,其部署在bizserver上，CAS系统搭建在CAS Server上。 CAS Client与受保护的客户端应用部署在一起，以Filter方式保护受保护的资源。当发起请求http://bizserver/index.jsp访问系统主页时，CAS Client会分析该url中是否包含Service Ticket，如果没有，则说明当前用户尚未登录，于是重定向到指定好的CAS Server登录地址，并传递service（即要访问的目的资源地址，以便登录成功后跳转回该地址），url：https://casserver/cas/servlet/login?service=http://bizserver/index.jsp。 用户在cas的登录页上输入用户名密码登录，CAS Server验证通过后，随机产生一个唯一Service Ticket，并缓存以待将来验证，然后系统重定向到service所在地址，url：http://bizserver/index.jsp?ticket=casticket；并为客户端设置一个Ticket Granted Cookie（TGC）,即存放Service Ticket的cookie。 CAS Client在拿到service和新产生的Ticket后，与CAS Server进行身份核实，即再次确认身份，url：https://casserver/cas/servlet/validate?service= http://bizserver/index.jsp&amp;ticket=casticket，确保Service Ticket合法，不合法则再次登录。 所有与CAS的交互均采用ssl协议，确保ST与TGC的安全性。 总结：其实也就只是拿了一个Ticket而已。","categories":[],"tags":[]},{"title":"","slug":"SringBoot学习之Jpa主要是自定义查询和条件拼接与分页","date":"2019-04-30T08:25:45.889Z","updated":"2018-10-10T08:04:27.519Z","comments":true,"path":"2019/04/30/SringBoot学习之Jpa主要是自定义查询和条件拼接与分页/","link":"","permalink":"http://47.107.237.149/2019/04/30/SringBoot学习之Jpa主要是自定义查询和条件拼接与分页/","excerpt":"","text":"首先是建一个实体类，打上注解，运行后自动在指定数据库中创建数据表。 配置文件换用.yml，这种格式层次分明，不易冗余;连接上数据库。 写一个dao接口继承一下JpaRepository，自定义方法可以自己添加。即可操作数据库。自定义@Query查询 在dao中写自定义查询方法 /* 自定义方法实现模糊查询 */ @Query(&quot;select b from Book b where b.name like %?1%&quot;) //使用hql（操作对象），Book表示类型，?1传入第一个参数，前后都有%表示前后都可以是其他文字 public List&lt;Book&gt; findByName(String name); /* 原生sql */ @Query(value = &quot;select * from book b where b.name=?1&quot;, nativeQuery = true) List&lt;Book&gt; findByName(String name); /* 自定义任意查询几条数据出来 */ @Query(value=&quot;select * from t_book order by RAND() limit ?1&quot;,nativeQuery = true) //默认是false，这里使用本地sql应开启 public List&lt;Book&gt; randomList(Integer n); @Query(value = &quot;select name,author,price from Book b where b.price&gt;?1 and b.price&lt;?2&quot;) List&lt;Book&gt; findByPriceRange(long price1, long price2); @Query(value = &quot;select name,author,price from Book b where b.name like %:name%&quot;) List&lt;Book&gt; findByNameMatch(@Param(&quot;name&quot;) String name); @Query(value = &quot;select * from book b where b.name=?1&quot;, nativeQuery = true) List&lt;Book&gt; findByName(String name); /* 使用@Param注解注入参数 */ @Query(&quot;select name,author,price from Book b where b.name=:name and b.author=:author and b.price=:price&quot;) List&lt;Book&gt; findByNamedParam(@Param(&quot;name&quot;)String name,@Param(&quot;author&quot;)String author,@Param(&quot;price&quot;)String price); 对于like语句，参数为null时查不到数据；而动态查询则能获取全部数据 建议使用sql语句定义Predicate动态查询、条件拼接 以下是扩充findAll进行动态查询。主要是考虑搜索条件可能并不俱全，有时甚至是空搜，空搜的话会把所有记录都查出来 public ModelAndView list2(Book book){ //自动封装 ModelAndView mav=new ModelAndView(); List&lt;Book&gt; bookList=bookDao.findAll(new Specification&lt;Book&gt;(){ /* 拼接条件 */ @Override public Predicate toPredicate(Root&lt;Book&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cd) { //cb是条件构造器；query是一种高级查询；root可以获取数据库字段 Predicate predicate=cd.conjunction(); //conjunction：结合 //条件全为null的话查询全部数据 if(book!=null){ if(book.getName()!=null&amp;&amp;!&quot;&quot;.equals(book.getName())){ //如果用户输入了此查询条件 predicate.getExpressions().add(cd.like(root.get(&quot;name&quot;),&quot;%&quot;+book.getName()+&quot;%&quot;)); //cb.like(root.get(&quot;name&quot;)：获取对应字段，按like规则查询，类似的还有equal等；后面为具体查询规则 } if(book.getAuthor()!=null&amp;&amp;!&quot;&quot;.equals(book.getAuthor())){ predicate.getExpressions().add(cd.like(root.get(&quot;author&quot;),&quot;%&quot;+book.getAuthor()+&quot;%&quot;)); } } return predicate; //返回拼接好的查询条件 } }); mav.addObject(&quot;bookList&quot;,bookList); mav.setViewName(&quot;bookList&quot;); return mav; } 除了like查询语句还有其他： //大于等于，可用于时间 predicate.getExpressions().add(cd.greaterThanOrEqualTo(root.get(&quot;createDate&quot;), document.getFirstDate())); //小于等于 predicate.getExpressions().add(cd.lessThanOrEqualTo(root.get(&quot;createDate&quot;), document.getLastDate())); 拼接+分页 除了拼接条件，一般还会伴随着分页。我们可以定义一个方法同时实现条件拼接和分页 //dao层 public interface DocumentRepository extends JpaRepository&lt;Document,Integer&gt;{ Page&lt;Document&gt; findAll(Specification&lt;Document&gt; specification, Pageable pageable); } //service层定义接口 public interface DocumentService { public Page&lt;Document&gt; findAll(UsefulDocument document, int pageNum, int pageSize); } //service实现层 @Override public Page&lt;Document&gt; findAll(UsefulDocument document, int pageNum, int pageSize) { //传入页码和每页容量 List&lt;Sort.Order&gt; orders = new ArrayList&lt;Sort.Order&gt;(); //排序规则 //搜索条件包含时间则按时间排 if (document.getFirstDate() != null) { orders.add(new Sort.Order(Sort.Direction.DESC, &quot;createDate&quot;)); } else if (document.getLastDate() != null) { orders.add(new Sort.Order(Sort.Direction.DESC, &quot;createDate&quot;)); } else { //否则按id排 orders.add(new Sort.Order(Sort.Direction.ASC, &quot;id&quot;)); } //封装排序规则 Sort sort = new Sort(orders); //创建分页对象，传入页码、容量和排序规则三个条件 Pageable pageable=new PageRequest(pageNum,pageSize,sort); //调用findAll方法开始动态拼接（重写拼接方法并传入分页对象） Page&lt;Document&gt; documentList = documentRepository.findAll(new Specification&lt;Document&gt;() { @Override …… }, pageable); //这样，根据传入的pageNum不同即可返回不同数据 return documentList; } 其中的Sort与Order是这么用的：Sort是排序方法，Order则是定义排序规则。如果只有一种排序规则那可以这样写 Sort sort=new Sort(Sort.Direction.ASC,&quot;age&quot;); //第二个参数是实体类的属性（记住不是数据库的字段） //底层是把字段全部转换为String进行比较 但如果我想要先按age降序，再按grade升序，再按dnum降序怎么办？ 这个时候就要用到org.springframework.data.domain.Sort.Order这个包下面的Order类了 根据排序规则我们分别建立三个Order如下： //设置规则 Sort.Order order1=new Sort.Order(Sort.Direction.DESC,&quot;age&quot;); Sort.Order order2=new Sort.Order(Sort.Direction.ASC,&quot;grade&quot;); Sort.Order order3=new Sort.Order(Sort.Direction.DESC,&quot;dnum&quot;); //放入集合 List&lt;Sort.Order&gt; list=new ArrayList&lt;&gt;(); list.add(order1); list.add(order2); list.add(order3); //放到Sort里 Sort sort=new Sort(list); 排序Iterable&lt;T&gt; findAll(Sort sort); 分页获得的对象集合其实就跟普通集合一样，可以用任何遍历方法来遍历 documentList.getTotalElements() //全部查询结果总行数，Long型，测试时应该这么判断：is(4L) //后面加个L documentList.getTotalPages() //查询总页数 Document document = documentList.getContent() //获取结果对象 documents.getNumberOfElements() //本页结果条数 documents.getNumber() //同上 documents.getSize() //每页容量 documents.getSort() //排序方法：字段 升/降代码实例 D:/SpringBootJpa/BookDao、BookController、entity/Book（增删查改图书） D:/civalWeb/LLCWEB/DocumentRepository、DocumentService、DocumentServiceImpl、DocumentRepositoryTest","categories":[],"tags":[]},{"title":"","slug":"spring注解","date":"2019-04-30T08:25:45.884Z","updated":"2019-03-24T07:02:21.413Z","comments":true,"path":"2019/04/30/spring注解/","link":"","permalink":"http://47.107.237.149/2019/04/30/spring注解/","excerpt":"","text":"参考文章注解位置 注解可以放在方法头上，也可以放在方法限定符后面 @RequestMapping(value=&quot;/testuploadimg&quot;, method = RequestMethod.POST) public @ResponseBody String uploadImg() {} @ReponseBody 返回json字符串或json对象。 在SpringMvc中当返回值是String时，如果不加此注解则Spring就会找这个String对应的页面，找不到则报404错误。 如果加上的话@ResponseBody就会把返回值放到response对象中@RequestBody 提取json形式的入参中的属性绑定到同名属性上。 例如： $.ajax({ url:&quot;/login&quot;, type:&quot;POST&quot;, data:&apos;{&quot;userName&quot;:&quot;admin&quot;,&quot;pwd&quot;,&quot;admin123&quot;}&apos;, content-type:&quot;application/json charset=utf-8&quot;, success:function(data){ alert(&quot;request success ! &quot;); } }); @requestMapping(&quot;/login&quot;) public void login(@requestBody String userName,@requestBody String pwd){ System.out.println(userName+&quot; ：&quot;+pwd); } 以上情况是将json中的两个变量赋给了同名的字符串，假如有一个User类，拥有userName和pwd两个属性，则上述参数形式可以改为：@RequestBody User user。 @RequestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。 在一些特殊情况下@RequestBody也可以用来处理content-type类型为application/x-www-form-urlcoded的内容，比如jQuery easyUI的datagrid请求数据的时候、小型项目值创建一个pojo类的话也可以。 @Autowired加在属性上 自动注入bean 在声明变量语句前加上该注释，即完成了免new直接实例化（免new的意思是前面已通过@Configuration(+@Bean)或者@Component注册好bean了） @Autowired private Car BMW; 默认先byType，找Car类的bean，如果找到多个bean，则按照byName方法比对找名为BMW的bean，如果还有多个，则抛出异常。 使用@Qualifier才可以手动指定先byName方式注入，由于Spring搞成的bean默认都是类名小写，所以一般这里的值都是类名小写。 //通过此注解完成查找满足Fruit的bean，然后找到指定的pear @Autowired @Qualifier(&quot;pear&quot;) public Fruit fruit; 如果要允许null值，可以设置它的required属性为false，如：@Autowired（required=false)。这样找不到bean时不会报错而是赋予null。 默认单例模式，在不同的类里用此注解注入的同类的bean都是同一个。 required属性：默认required=true，若设为false则表示被注解的属性即使找不到对应的bean来装配也没事，不用报错，程序照常执行。 加在方法上 同样也是注入bean，加载方法上则方法会被自动调用，方法参数则被自动装配 public class TextEditor { //一个自定义的类 private SpellChecker spellChecker; @Autowired //自动装配，这个方法被自动调用 public void setSpellChecker(SpellChecker spellChecker){ //被调用后实例化一个SpellChecker this.spellChecker = spellChecker; //赋予类属性 } //直接调用这个方法，其中spellChecker由于上面setSpellChecker被自动调用所以已经实例化了 public void spellCheck() { spellChecker.checkSpelling(); } } @Resource 和@Autowired相似，只是默认装配优先规则不同，并且@Resource是J2EE的注解，是Java自己的东西。因此建议使用@Resource，以减少代码和Spring之间的耦合。 默认byName自动注入（用byName会快一点），如果找不到再byType，再找不到则抛异常，无论按那种方式如果找到多个则抛异常。 可以手动指定bean,它有2个属性分别是name和type，使用name属性，@Resource(name=”bean名字”),则使用byName的自动注入，从上下文查找名称（id）匹配的bean注入；而使用type属性,@Resource(type=”bean的class”)则使用byType自动注入。 不能用于注入静态属性 public class Zoo { @Resource(name = &quot;tiger&quot;) private Tiger tiger; @Resource(type = Monkey.class) private Monkey monkey; public String toString() { return tiger + &quot;\\n&quot; + monkey; } } 默认单例模式，在不同的类里用此注解注入的同类的bean都是同一个。 在service层我们经常定义接口，然后写实现类，然后搞成bean的是实现类，但是我们用本注解引入这个bean时，只能将类型声明为接口，而不能是实现类： @Resource private UserService userService; //不能是UserServiceImpl 否则报错：Can not set field to $Proxy;不知道@Autowired是不是这样的。 一定要用实现类的话可以在配置文件加入： &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; proxy-target-class=&quot;true&quot;/&gt; &lt;!--或者--&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; @SpringBootApplication 包含下面三个注解 @Configuration 定义配置类，可替换xml配置文件，被注解的类内包含被@Bean注解的方法，这些方法即注册了bean。 @Configuration public class MockConfuration{ 属性 方法 } 以上代码相当于把该类作为spring的xml配置文件中的（默认单例），作用为配置spring容器（上下文） 被注解的类不可以是final类型，不可以是匿名类，嵌套的@Configuration必须是静态类。 类中任何一个标注了@Bean的方法，其返回值将作为一个bean注册到spring的IOC容器，方法名则为其实例化对象 @Configuration public class MockConfuguration{ @Bean(name=&quot;...&quot;) //指定bean名称默认为方法名 public MockService mockService(){//假定MockService是一个接口 return new MockServiceImpl();//MockServiceImpl是其实现类，它未加任何注解 } } 相当于xml中的，作用为注册bean对象。 @Bean相当于下面配置 在类内立即使用这个bean @Configuration public class WebSecurityConfig extends WebSecurityConfigurerAdapter { /** * 注册bean */ @Bean private UserDetailsService loginService() { return new LoginServiceImpl(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(loginService());//执行这个方法，注册bean后作为方法参数使用 } } 表达bean与bean之间的依赖关系 @Bean不能单独使用，应搭配@Configuration、@Component、@Controller、@Service、@Ripository使用。 SpringBoot项目的config包就经常用这种方式来注册bean。 也可以用@Configuration+@Component来注册bean /*bean类*/ @Component //添加注册bean的注解 public class TestBean { } /*配置类*/ @Configuration @ComponentScan(basePackages = &quot;com.dxz.demo.configuration&quot;) //自动扫描TestBean包路径搞成bean public class TestConfiguration { } 因为扫描的话会把整个包的类都搞成bean，所以只想把一个搞成bean的话，可以直接用第一种方法，或者只在那个类上加@Component、@Controller、@Service、@Ripository注解；如果确实都要搞成bean那肯定是第二种方法更适合。 spring4.0之二：@Configuration的使用:详细介绍了bean的注册原理与多种方式。 @ComponentScan @ComponentScan(“包路径”)：等价于&lt;context:component-scan base-package=”com.dxz.demo”/&gt;，扫描指定包下的所有类，发现带@Controller,@Service,@Repository,@Component注解的都会搞成bean，如果这些注解都没有指定bean名的话默认用类名首字母小写。默认扫描和被注解类所在包及all子包。 springboot工程启动时，由于入口类有这个注解，所以会默认加载和入口类所在目录及子目录下的所有类，所以一般情况下这些类都不用再加@ComponentScan。 spring的话一般会写一个配置类加上该注解，负责扫描工程所有的bean，或者在配置文件指定扫描路径 写一个类 package com.study.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.ComponentScan.Filter; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.FilterType; import org.springframework.web.servlet.config.annotation.EnableWebMvc; @Configuration //必须与此连用 @ComponentScan(basePackages={&quot;com.study&quot;}, excludeFilters={@Filter(type=FilterType.ANNOTATION, value=EnableWebMvc.class)}) public class RootConfig { } 然后不知道是不是要在bean那边new一下这个类 参考文章 @EnableAutoConfiguration 像一只八爪鱼一样搜集所有的@Configuration配置，加载到springboot的IOC容器中 @Component 一种通用名称，泛指可以通过spring来管理的组件。加在类上以被扫描到并搞成bean，默认直接类名小写 @Controller，@Service，@Repository则是一种特定的组件，通常用来表示某种场合下的组件。比如@Repository用来表示仓库（数据层，dao)；@Service则用来表示服务层相关的类；@Controller则用来表示展示层（控制层）的类；不是前三种一般就用@Component了。 注解在类上之后通过配置文件制定路径来扫描（或者写个能扫描的java类）并搞成bean；如果最后还是被配置文件中的bean节点依赖的话，那么也可以不用注解 &lt;!-- 自定义拦截器 --&gt; &lt;beans:bean id=&quot;securityInterceptor&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecurityInterceptor&quot;&gt; &lt;beans:property name=&quot;securityMetadataSource&quot; ref=&quot;secureResourceFilterInvocationDefinitionSource&quot; /&gt; &lt;/beans:bean&gt; &lt;!-- 获取访问url对应的所有权限 --&gt; &lt;beans:bean id=&quot;secureResourceFilterInvocationDefinitionSource&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecureResourceFilterInvocationDefinitionSource&quot; /&gt; //配置class属性，那么会自动到该路径去扫描并搞成bean @Service(“name”)：指定搞成的bean名 @PostConstruct和@PreDestroy 实现初始化和销毁之前进行的操作。分别只能注释一个方法，且该方法不能有参数，返回值必须是void，方法不能是静态的。 @Primary 自动装配当出现多个bean候选者时，被注解的将作为首选者，无注解将抛出异常 @Named @Named和Spring的@Component功能相同。@Named可以有值，如果没有值生成的Bean名称默认和类名相同。 @Named public class Person; //或 @Named(&quot;cc&quot;) public class Person; @RequestParam 接收请求中的参数 //将请求中参数为number映射到方法的number上，required=false表示该参数不是必需的，请求上可带可不带;若为必需，则请求中没有相应参数会导致404错误；defaultValue：默认值，表示如果哦请求中没有同名参数时的默认值 @RequestParam(value=&quot;number&quot;,required=false,defaultValue=&quot;0&quot;) String number; 其实不写也是接收得到的，只是有时候作为一个标志或者需要它的某些属性 如果参数是int类型并且required=false的话，建议以Integer变量接收，因为这时如果不传参数值会把null赋值给int，会报错。 @PathVariable 将@RequestMapping指定的请求所带的参数映射到方法的参数上 @RequestMapping(&quot;/zyh/{type}&quot;) //传入参数type，其值来自/zyh/{type}请求所带的名为type的参数，其实括号中不写也行 public String zyh(@PathVariable(value=&quot;type&quot;) int type) { } 和@RequestParam类似 @ResponseBody 自动把被注解的类中的方法的返回值中的java对象(Map或JSONObject等)转为json串，前台才能解析 可标注在方法上面或方法返回值类型前面 相当于ajax请求，不用指明返回哪个页面，会自动从来的地方回去 @RequestBody 将前台传来的json串转为java对象，后台才能处理。 前台传参格式有两种，一种是跟在url后面的键值对，一种是json串。 @Param 给参数命名 @Query(&quot;from User u where u.name=:username&quot;) User findUser(@Param(&quot;username&quot;) String name1); //给name1命名为username，使入参被u.name=:username识别 //@Param中的值必须和冒号后一样，至于形参和实参叫做什么就不重要了 @ConfigurationProperties 可以把配置文件中指定前缀的变量全部封装到类的实例中 要配合@Component使用，因为不需保证注释的类能被Spring扫描到，不然Spring扫描到此注解也不知道装配到哪个类里去 使用方式有两种 第一种：加在类上 @Component @ConfigurationProperties(prefix = &quot;com.example.demo&quot;) public class People { private String name; private Integer age; private List&lt;String&gt; address; private Phone phone; //只有一个String类的number属性 } application.properties中的变量 com.example.demo.name=${aaa:hi} com.example.demo.age=11 com.example.demo.address[0]=北京 com.example.demo.address[1]=上海 com.example.demo.address[2]=广州 com.example.demo.phone.number=1111111 大功告成，实例化 @Resource private People people; 第二种：通过@Bean的方式声明，这里我们加在入口类即可 @SpringBootApplication public class DemoApplication { @Bean @ConfigurationProperties(prefix = &quot;com.example.demo&quot;) public People people() { return new People(); } public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 大功告成，实例化 @Resource private People people; PS：如果发现@ConfigurationPropertie不生效，有可能是项目的目录结构问题，你可以通过@EnableConfigurationProperties(People.class)来明确指定需要用哪个实体类来装载配置信息。 @RequestMapping @RequestMapping(value=”/produces”,produces=”application/json”)：表示注解方法将返回json格式的数据，此时若请求头中的Accept为application/json则可匹配。 @RequestMapping(value=&quot;/queryLearnList&quot;,method=RequestMethod.POST, produces = &quot;application/json;charset=utf-8&quot;) //produces:指定返回值类型和字符集，不过使用了@ResponseBody的话就不用指定返回值了 支持通配符和ant风格的路径： @RequestMapping(value = { &quot;&quot;, &quot;/page&quot;, &quot;page*&quot;, &quot;view/*,**/msg&quot; }) 匹配url如下： localhost:8080/home localhost:8080/home/ localhost:8080/home/page localhost:8080/home/pageabc localhost:8080/home/view/ localhost:8080/home/view/view 配合属性headers=”Accept=application/json”更能表明你的目的。 value值可以是含有变量或正则表达式的一类值 @RequestMapping(&quot;/preUpdate/{id}&quot;) //请求方式：/preUpdate/1 @RequestMapping( &quot;/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}.{extension:\\.[a-z]}&quot; ) method属性默认为无，也就是什么类型的HTTP请求都可以映射。 @PostConstruct Java EE 5引入的注解，Spring允许开发者在受管Bean中使用它。当DI容器实例化当前受管Bean时，@PostConstruct注解的方法会被自动触发，从而完成一些初始化工作。 @Component public class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource { @Resource private ResourcesDao resourcesDao; private static Map&lt;String, Collection&lt;ConfigAttribute&gt;&gt; resourceMap = null; public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { return null; } public boolean supports(Class&lt;?&gt; clazz) { return true; } /** * @PostConstruct是Java EE 5引入的注解， * Spring允许开发者在受管Bean中使用它。当DI容器实例化当前受管Bean时， * @PostConstruct注解的方法会被自动触发，从而完成一些初始化工作 */ @PostConstruct private void loadResourceDefine() { //加载所有资源与权限的关系 if (resourceMap == null) { resourceMap = new HashMap&lt;String, Collection&lt;ConfigAttribute&gt;&gt;(); List&lt;Resources&gt; list = resourcesDao.queryAll(new Resources()); for (Resources resources : list) { Collection&lt;ConfigAttribute&gt; configAttributes = new ArrayList&lt;ConfigAttribute&gt;(); // 通过资源名称来表示具体的权限 注意：必须&quot;ROLE_&quot;开头 ConfigAttribute configAttribute = new SecurityConfig(&quot;ROLE_&quot; + resources.getResKey()); configAttributes.add(configAttribute); resourceMap.put(resources.getResUrl(), configAttributes); } } } //返回所请求资源所需要的权限 public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException { String requestUrl = ((FilterInvocation) object).getRequestUrl(); // System.out.println(&quot;requestUrl is &quot; + requestUrl); if(resourceMap == null) { loadResourceDefine(); } //System.err.println(&quot;resourceMap.get(requestUrl); &quot;+resourceMap.get(requestUrl)); if(requestUrl.indexOf(&quot;?&quot;)&gt;-1){ requestUrl=requestUrl.substring(0,requestUrl.indexOf(&quot;?&quot;)); } Collection&lt;ConfigAttribute&gt; configAttributes = resourceMap.get(requestUrl); return configAttributes; } } 参考文章 @PropertySource、@Value @PropertySource({“classpath:jdbc.properties”})：注解在类头上，加载资源文件 然后在类内属性头上 /* * 绑定资源属性 */ @Value(&quot;${jdbc.driver}&quot;) private String driverClass=&quot;hhh&quot;; //无论此处赋值为何，都会被@Value覆盖 //设置默认值 @Value(&quot;${some.key:my default value}&quot;) //默认值也可设为空：${some.key:} private String stringWithDefaultValue; //数组的默认值用逗号分隔 @Value(&quot;${some.key:1,2,3}&quot;) private int[] intArrayWithDefaults; 不过有一个例子，它没有指定配置文件，直接注入，好像也可以，代码：ideaProjects/shiro-chapter16/service/impl/PasswordHelper、resources/spring-config.xml。 @RestController 相当于@ResponseBody+@Controller合在一起，规定类中所有方法返回值被转换为json字符串传回前端 @ModelAttribute 作用在参数上，将客户端请求中的参数按名称注入到指定对象中，并将此对象作为传送数据存入ModelMap，便于在前端页面取用。 public String test1(@ModelAttribute(&quot;user&quot;) User user){} 将user以“user”为名绑定到模型对象的属性中，若请求参数为?username=zhang&amp;password=123&amp;workInfo.city=bj,则User类应包含username、password和workInfo属性的city属性，那么这三个参数将被注入到“user”attribute对应的属性中，并且以“user”命名被存入模型对象汇总，在前端页面可通过${user.username}来获取username属性。 运用在方法上，会在每一个@RequestMapping注解的方法前执行，若有返回值，则自动将其存入ModelMap。 /** * 设置这个注解之后可以直接在前端页面使用hb这个对象（List）集合 */ @ModelAttribute(&quot;hb&quot;) //此方法在@RequestMapping方法之前执行，并将返回值存入模型对象 public List&lt;String&gt; hobbiesList(){ List&lt;String&gt; hobbise = new LinkedList&lt;String&gt;(); hobbise.add(&quot;basketball&quot;); hobbise.add(&quot;football&quot;); hobbise.add(&quot;tennis&quot;); return hobbise; } /** * 前端使用hb */ &lt;c:forEach items=&quot;${hb}&quot; var=&quot;hobby&quot; varStatus=&quot;vs&quot;&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${hobby == &apos;basketball&apos;}&quot;&gt; 篮球&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot; value=&quot;basketball&quot;&gt; &lt;/c:when&gt; ... &lt;/c:choose&gt; &lt;/c:forEach&gt; 若@ModelAttribute不指定属性名称则默认为返回类型的首字符小写，如返回类型为Account，则属性名为account。 若@ModelAttribute和@RequestMapping同时注释一个方法，则此时返回值并不表示一个视图的名称，而是model属性的值，视图名称则由RequestToViewNameTranslator根据请求“/helloWorld.do”转换为视图HelloWorld。 @Controller public class HelloWorldController { @RequestMapping(value = &quot;/helloWorld.do&quot;) @ModelAttribute(&quot;attributeName&quot;) public String helloWorld() { return &quot;hi&quot;; } }","categories":[],"tags":[]},{"title":"","slug":"Spring项目集成tomcat","date":"2019-04-30T08:25:45.880Z","updated":"2019-03-06T09:58:07.511Z","comments":true,"path":"2019/04/30/Spring项目集成tomcat/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring项目集成tomcat/","excerpt":"","text":"添加插件 &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 如果是要把项目部署到远程tomcat则需要url、server标签 &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;!--固定，端口可改，和port一致就行--&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--端口可改--&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;server&gt;tomcat7&lt;/server&gt; --&gt; &lt;!--引用build标签下finalName属性（默认是项目名-版本）, 设为/则为localhost:8080--&gt; &lt;path&gt;/${project.build.finalName}&lt;/path&gt; &lt;/configuration&gt; &lt;!-- &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; --&gt; &lt;/plugin&gt; 其中，tomcat7配置在maven本地仓库setting.xml: &lt;server&gt; &lt;id&gt;tomcat7&lt;/id&gt; &lt;username&gt;tomcat7&lt;/username&gt; &lt;password&gt;tomcat7&lt;/password&gt; &lt;/server&gt; 也可以直接在pom.xml如下配置替代以上server &lt;username&gt;tomcat7&lt;/username&gt; &lt;password&gt;tomcat7&lt;/password&gt; 然后就可以使用mvn tomcat7:run运行webapp了 也可以在run config设置运行命令","categories":[],"tags":[]},{"title":"","slug":"Spring建立单元测试","date":"2019-04-30T08:25:45.867Z","updated":"2019-03-22T08:59:38.482Z","comments":true,"path":"2019/04/30/Spring建立单元测试/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring建立单元测试/","excerpt":"","text":"参考文章 代码实例：ideaProjects/thz/thz-manager-web/test 普通测试@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations=&quot;classpath:config/applicationContext.xml&quot;) //classpath:在当前项目查找；classpath*：在所有依赖的jar包的classpath下找 @Transactional public class UserServiceImplTest { @Resource private UserService userService; @Test public void addUser() { User user=new User(); user.setUsername(&quot;test&quot;); user.setPassword(&quot;123456&quot;); int result=userService.addUser(user); Assert.assertThat(result,is(1)); } } @RunWith: 运行器。@RunWith(JUnit4.class)就是指用JUnit4来运行测试；@RunWith(SpringJUnit4ClassRunner.class)则是运行于Spring测试环境。 @ContextConfiguration：当我们想要在测试类使用@Resource注解注入bean时，只需要添加该注解指明去哪里能找到这些bean即可。我们知道注册bean的方法有： 在xml中注册bean：先定义好这个类然后到xml中注册成bean。 &lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; value=&quot;ehcacheManager&quot;/&gt; &lt;/bean&gt; 那么测试时： @ContextConfiguration(locations = &quot;classpath:spring-beans.xml&quot;) 代码示例：ideaProjects\\shirochapter12\\ShiroTest 定义类时顺便加@Component等注解注册成bean，再扫描这些bean，扫描bean的方式也分两种： i. 在xml中配置component-scan： &lt;context:component-scan base-package=&quot;com.haien.chapter16&quot;&gt; 那么测试时引入该配置文件即可： @ContextConfiguration(locations = &quot;classpath:spring-config.xml&quot;) ii. 在Java configuration类中加@ComponentScan @ComponentScan(basePackages = &quot;com.haien.sping.cache.service&quot;) public class AnnotationCacheConfig { } 那么测试时引入这个类即可： @ContextConfiguration(classes=AnnotationCacheConfig.class) 多个则： @ContextConfiguration(classes = {WebMvcConfig.class, HibernateConfig.class}) 代码示例：ideaProjects\\spring-cache\\test\\UserServiceTest 参考文章 controller层测试@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations={&quot;classpath:config/applicationContext.xml&quot;,&quot;classpath:config/spring-mvc.xml&quot;}) public class GoodsControllerTest { @Resource private GoodsController goodsController; private MockMvc mockMvc; @Before public void setUp() { mockMvc=MockMvcBuilders.standaloneSetup(goodsController).build(); //缺少这一步抛异常：No mapping found for HTTP request with URI [...] in DispatcherServlet；找不到路径 } @Test public void queryGoods() throws Exception { String url=&quot;/goods/query?pageNum=1&amp;rows=5&amp;type=液体&quot;; ResultActions resultActions=mockMvc.perform(MockMvcRequestBuilders.get(url)); MvcResult mvcResult=resultActions.andReturn(); String result=mvcResult.getResponse().getContentAsString(); System.out.println(&quot;客户端获得反馈数据：&quot;+result); //也可以从response中获取状态码、header、cookies... System.out.println(mvcResult.getResponse().getStatus()); } } 事务自动回滚 引入依赖 &lt;dependency&gt; &lt;!--用于开启事务，否则测试将无法自动回滚--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; applicationContext.xml：配置事务管理器、开启事务 &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!--开启事务--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 创建单元测试，添加@Transactional注解 @RunWith(SpringJUnit4ClassRunner.class) //告诉Junit使用Spring TestRunner @ContextConfiguration(locations = {&quot;classpath:spring-beans.xml&quot;, &quot;classpath:spring-shiro.xml&quot;}) //指定bean注入的配置文件 @Transactional public class ShiroTest { @Autowired protected RoleService roleService; @Test public void addRole(){ Role r = new Role(&quot;test&quot;, &quot;测试&quot;, Boolean.TRUE); r=roleService.createRole(r); Assert.assertThat(r.getId(),is(51L)); } } 如果前面不配置事务管理器并开启事务的话，测试类加@Transactional不会报错，但也不会回滚。","categories":[],"tags":[]},{"title":"","slug":"Spring基础概念","date":"2019-04-30T08:25:45.861Z","updated":"2019-04-27T07:33:13.912Z","comments":true,"path":"2019/04/30/Spring基础概念/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring基础概念/","excerpt":"","text":"bean装配 Spring可以管理bean，也即是免new直接实例化一个对象，也可以将对象注入到其他类中。默认单例模式管理。 步骤：定义一个实体类，bean.xml注册bean，在测试类获取该bean并使用它的成员方法。 bean.xml注册bean： &lt;!-- 注册bean --&gt; &lt;bean id=&quot;permissionDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.PermissionDaoImpl&quot;/&gt; &lt;!-- Service:注入到其他bean中 --&gt; &lt;bean id=&quot;permissionService&quot; class=&quot;com.haien.shirochapter12.service.impl.PermissionServiceImpl&quot;&gt; &lt;property name=&quot;permissionDao&quot; ref=&quot;permissionDao&quot;/&gt; &lt;/bean&gt; 其中，属性id和name一样，都是指定bean的名称，只是id要求唯一（推荐），而name则可以重复，当获取bean时，会返回名称相同的第一个；当id和name都缺失时，bean名为class类全名。 则PermissionServiceImpl必须有PermissionDaoImpl的setter，否则报错 public class PermissionServiceImpl implements PermissionService { public void setPermissionDao(PermissionDao permissionDao){ this.permissionDao=permissionDao; } } 代码实例：ideaProjects/shirochapter12/resources/spring-beans.xml、service/impl/PermissionServiceImpl 代码实例：Spring1ManageBean IOC入门 控制权反转：解耦，改内部类为参数传入形式，用set(接口)的方式来使方法调用者能动态指定。 代码例子：有一个任务JavaWork，它的主要工作就是测试，所以它的主要方法就是doTest()。我们可以在这个方法中实例化一个测试员Tester的对象，并调用它的test()方法进行测试，但是这样我们要换人就留必须修改实例化的代码，所以我们决定让doTest()把控制权转交到JavaWork的调用者手上。我们在JavaWork中写一个setTester的方法，让JavaWork的调用者通过这个方法来指定测试员。那么这些测试员就都要实现一个相同的含有test()的接口，所以setTester()的入参类型就是这个接口了。 代码实例：Spring2IOCFirstIOC详解 依赖注入：也就是怎么把属性为其他实体类的类注册成bean 代码实例:Spring3BeanZhuRu（普通属性）、Spring4BeanZhuRu2（含类属性）、Spring5BeanAutoWire（指定by某种方式注入） 方法注入：配合scope=prototype实现动态注入 代码实例：Spring5FunctionAutoWire bean之间的关系 继承、依赖、引用 代码实例：Spring6RelationOfBeans bean作用范围 重点是singleton（默认）和prototype。singleton是指整个IOC容器中就只有一个bean，就算再申请一个也只是把原来的那个返回，SpringBoot中用注解注入的bean也是这样；prototype则每申请一次就返回一个新的bean 切换bean作用范围参见笔记：Shiro第十六章-综合实例 代码实例：Spring5FunctionAutoWire FactoryBean 在spring中可以利用FactoryBean来产生一些自定义配置的bean。 AOP简介 面向切面编程，是软件开发中的一个热点。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低。 主要功能：日志记录、性能设计、安全控制、事务处理、异常处理等等。 举个例子，旧式的日志管理是这样的： public class StudentServiceImpl implements StudentService{ @Override public void addStudent(String name) { // 日志记录 System.out.println(&quot;开始添加学生&quot;+name); System.out.println(&quot;添加学生&quot;+name); // 日志记录 System.out.println(&quot;完成学生&quot;+name+&quot;的添加&quot;); /*这种日志记录方式入侵了逻辑代码，增加了代码的耦合度，完全不一样作用的代码也写到了一起*/ } } 代码实例：Spring7AOPFirst 详解各种通知对逻辑代码的切入 前置通知：方法执行前切入 后置通知 环绕通知（前置+后置） 异常通知 代码实现 编写逻辑代码 public class StudentServiceImpl implements StudentService{ @Override public void addStudent(String name) { System.out.println(&quot;添加学生&quot;+name); } } 定义通知切面类 /* * 通知切面类 */ public class StudentServiceAspect { //前置通知 public void doBefore(JoinPoint jp) { System.out.println(&quot;类名:&quot;+jp.getTarget().getClass().getName()); //jp可以获取类名，这里应该是StudentServiceImpl System.out.println(&quot;方法名:&quot;+jp.getSignature().getName()); //addStudent System.out.println(&quot;开始添加学生:&quot;+jp.getArgs()[0]); //获取参数，返回数组，这里只有一个参数，所以直接拿出第0个 } //后置通知 public void doAfter(JoinPoint jp) { System.out.println(&quot;类名:&quot;+jp.getTarget().getClass().getName()); //jp可以获取类名，这里应该是StudentServiceImpl System.out.println(&quot;方法名:&quot;+jp.getSignature().getName()); //addStudent System.out.println(&quot;学生添加完成:&quot;+jp.getArgs()[0]); //获取参数，返回数组，这里只有一个参数，所以直接拿出第0个 } } 3.配置xml文件 多加三行 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 使用切面应该多加上面三行带“aop”的东西 --&gt; 装配bean（逻辑代码+切面） &lt;bean id=&quot;studentServiceAspect&quot; class=&quot;com.java1234.advice.StudentServiceAspect&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.java1234.service.impl.StudentServiceImpl&quot;&gt;&lt;/bean&gt; 配置切面 &lt;aop:config&gt; &lt;!-- 定义切面 --&gt; &lt;aop:aspect id=&quot;studentServiceAspect&quot; ref=&quot;studentServiceAspect&quot;&gt; &lt;!-- 定义切点 --&gt; &lt;!-- execution表示执行，括号内写方法，*表示任意（第一个表示任意返回值， 第二个表示以前面为前缀的任意包，第三个表示包下任意方法；这样就能匹配 service接口和实现中的任意方法了），..表示方法接受任意（数目、类型）参数 --&gt; &lt;!-- 定义通知 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.java1234.service.*.*(..))&quot; id=&quot;businessService&quot;/&gt; &lt;aop:before method=&quot;doBefore&quot; pointcut-ref=&quot;businessService&quot;/&gt; &lt;!-- 执行切点businessService之前执行doBefore方法 （执行“添加学生”之前先打印“开始添加学生”）--&gt; &lt;aop:after method=&quot;doAfter&quot; pointcut-ref=&quot;businessService&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 匹配规则： ()匹配了一个不接受任何参数的方法，(..)匹配一个接受任何数量、类型参数的方法，()匹配了一个接受任何类型参数的方法，(,String)则第一个参数可以是任何类型，但第二个必须是String。 任意公共方法：execution（public （..）） 任意以“set”开头的方法：execution（ set（..）） AccountService接口中的任意方法：execution（ com.xyz.service.AccountService.（..）） service包的任意方法：execution（ com.xyz.service..*（..）） service包及其子包的任意方法：execution（ com.xyz.service..\\.*（..）） //..匹配任何数量子包，包括零个 +：匹配指定类型的子类型：execution( com.haien.chapter16..service..\\+.*(..)) java.*.String: 匹配java包下任意一级子包下的String类，如匹配java.lang.String,但不匹配java.lang.ss.String。 java..* ：匹配java包及任何子包下的任何类型;如匹配java.lang.String、java.lang.annotation.Annotation java.lang.Number+：匹配java.lang包下的任何Number的子类型；如匹配java.lang.Integer，也匹配java.math.BigInteger 参考文章 更详细的通配符说明 测试执行 public class T { private ApplicationContext ac; public static void main(String[] args) { ApplicationContext aContext=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); StudentService studentService=(StudentService)aContext.getBean(&quot;studentService&quot;); studentService.addStudent(&quot;张三&quot;); } } 测试结果：开始添加学生:张三 添加学生张三 学生添加完成:张三 其他通知参见代码实例：Spring8AOPDetails jdbc支持 Spring使用JdbcTemplate封装了jdbc的配置 代码实例：Spring9JdbcTemplate（实现对学生的增删查改） JdbcDaoSupport的使用：能使JdbcTemplate的使用简单一点点 代码实例：Spring9JdbcDaoSupport NamedParameterJdbcTemplate的使用：可以替代JdbcTemplate，支持命名的参数变量，具体体现在用问号蹲坑的形式被替换为用命名参数蹲坑，代码可读性up。 代码实例：Spring10NamedParameterJdbcTemplate（主要是把Spring9JdbcTemplate的beans.xml和StudentDaoServiceImpl.java的JdbcTemplate类替换为NamedParameterJdbcTemplate类） Spring对事务的支持编程式事务管理：业务代码受到入侵public void transferAccounts(final int count, final int userIdA, final int userIdB) { //因为内部类问题要加final //编程式事务管理，缺点：乱七八糟的代码侵入到业务逻辑里面了，这里的业务逻辑就两个方法而已 transactionTemplate.execute(new TransactionCallbackWithoutResult() { //new一个内部类 @Override protected void doInTransactionWithoutResult(TransactionStatus arg0) { //把方法加进来这两个方法就在一个事务中了 bankDao.outMoney(count, userIdA); bankDao.inMoney(count, userIdB); } }); } 代码实例：Spring11BianchengTransaction（转账的例子） 使用xml配置声明式事务管理（常用） 在xml中配置事务管理即可，无需在业务代码中穿插任何其他代码 首先是要引入命名空间 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 使用Spring的事务管理应该多加上面三行带“tx”的东西，aop的也不能少 --&gt; 然后配置事务管理 &lt;!-- jdbc事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 暂定事务对所有方法都切入 --&gt; &lt;tx:method name=&quot;*&quot; /&gt; &lt;!-- 不过常见的配置应该像下面这样 --&gt; &lt;!-- 以下配置是有优先级的，假如前面方法名都扫描不到， 那么应用最后的*，也即是扫描任意方法 --&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;!-- propagation传播方式为required，当没有事务时自动创建事务 （最常见的传播方式配置） --&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;edit*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;new*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;set*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;remove*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;change*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;!-- 只是查询数据库的方法则设为只读 --&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;load*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut id=&quot;serviceMethod&quot; expression=&quot;execution(* com.java1234.service.*.*(..))&quot; /&gt; &lt;!-- 配置事务通知 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceMethod&quot;/&gt; &lt;/aop:config&gt; 逻辑代码清清爽爽，事务自动切入 public void transferAccounts(int count, int userIdA, int userIdB) { bankDao.outMoney(count, userIdA); bankDao.inMoney(count, userIdB); } 代码实例：Spring12StatementTransaction 使用注解配置声明式事务管理 引入tx的命名空间，xml配置如下 &lt;!-- jdbc事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; &lt;!--不用配置事务切面了--&gt; 在service实现层添加@Transactional注解 @Transactional public class BankServiceImpl implements BankService{ private BankDao bankDao; public void setBankDao(BankDao bankDao) { this.bankDao=bankDao; } @Override public void transferAccounts(int count, int userIdA, int userIdB) { bankDao.outMoney(count, userIdA); bankDao.inMoney(count, userIdB); } } 代码实例：Spring12AnnotationTransaction Spring整合Struts2和hibernate 项目中使用了泛型接口：dao层接口使用泛型，可以实现对指定的不同实体进行数据库操作，而不用一个实体写一个接口处理。 spring必要maven依赖 spring核心依赖 spring-core：基本框架核心工具类，其他spring组件都需要依赖这个包（但好像不加也可以） spring-beans：包含配置文件，创建和管理bean spring-context spring dao依赖(提供jdbcTemplate)：spring-jdbc、spring-tx spring web依赖：spring-web（好像不加也可以）、spring-webmvc","categories":[],"tags":[]},{"title":"","slug":"Spring抽象bean abstract=true声明","date":"2019-04-30T08:25:45.857Z","updated":"2019-03-04T09:58:33.739Z","comments":true,"path":"2019/04/30/Spring抽象bean abstract=true声明/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring抽象bean abstract=true声明/","excerpt":"","text":"由于Java中的抽象类不能被实例化，所以我们不能注册bean，但如果在注册该bean时指定属性abstract为true，则该bean被声明为抽象bean，它不会被实例化，但是其属性可以注入到其他bean了。 抽象bean甚至不必映射到任何类。 抽象bean的一个好处是可以做模板，比如，有两个类含有相同的几个属性，那么在xml配置文件中，我们可能要通过两次重复的操作来为它们注入这些属性，定义抽象bean则很好地解决了这个问题。 //两个有相同属性的类（不用声明父类） public class FooDao { private DataSource dataSource; private SomeHelper someHelper; private FooHelper fooHelper; //setters } public class BarDao { private DataSource dataSource; private SomeHelper someHelper; private BarHelper barHelper; //setters } //xml定义抽象bean（并不会实例化这个bean） &lt;bean id=&quot;dao&quot; abstract=&quot;true&quot;&gt; &lt;!--实际根本没有这个类--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;someHelper&quot; ref=&quot;someHelper&quot;/&gt; &lt;/bean&gt; &lt;!--指定parent为dao,则只需要再注入自己特别的属性即可--&gt; &lt;bean id=&quot;fooDao&quot; class=&quot;FooDao&quot; parent=&quot;dao&quot;&gt; &lt;property name=&quot;fooHelper&quot; ref=&quot;fooHelper&quot; /&gt; &lt;/bean&gt; &lt;bean id=&quot;barDao&quot; class=&quot;BarDao&quot; parent=&quot;dao&quot;&gt; &lt;property name=&quot;barHelper&quot; ref=&quot;barHelper&quot; /&gt; &lt;/bean&gt; 不过，引入这两个类都能继承的抽象Dao类还可以节省类定义时的属性声明代码 //抽象Dao类 public abstract Dao { protected DataSource dataSource; protected SomeHelper someHelper; //setters } //这两个类都来继承它 public class FooDao extends Dao { private FooHelper fooHelper; //setters } public class BarDao extends Dao { private BarHelper barHelper; //setters } xml配置文件不变 因为抽象bean不需要实例化，所以一般不指明class属性。 但其实抽象bean Dao也可以指定class属性，映射到某个类上面，当子bean FooDao未指明class属性时，Spring就会找到父bean Dao的class，并把子bean都实例化为Dao类实例，因此这里的Dao不能是抽象类。 也即是说，抽象bean的映射类不一定是抽象类，因为抽象bean的“抽象”本不是抽象类的意思，是我们望文生义了。 参考文章 代码实例：ideaProjects/shirochapter12/resources/spring-beans.xml","categories":[],"tags":[]},{"title":"","slug":"SpringMVC执行步骤、Model的使用","date":"2019-04-30T08:25:45.849Z","updated":"2019-03-06T07:35:11.521Z","comments":true,"path":"2019/04/30/SpringMVC执行步骤、Model的使用/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringMVC执行步骤、Model的使用/","excerpt":"","text":"第一个SpringMvc HelloWorld无启动类 springboot才有启动类前端操作 访问项目名进入默认主页，显示一个链接 点击链接后请求helloWorld.do跳转另一个jsp页面 后台执行步骤 *也对应controller的RequestMapping，若要映射多有请求则为/ web.xml负责拦截请求并分发到controller处理 spring-mvc.xml负责解析controller的返回值，跳转到相应的页面上。 spring-mvc.xml以及在web.xml中的声明都可以用Java Configuration来代替，参考文章 项目实例：eclipse/SpringMvc01第二个SpringMvc项目项目简介 访问首页，请求后台controller初始化学生列表，装入ModelAndView后返回list.jsp，显示学生列表。 list.jsp点击“添加学生”链接请求后台controller，controller处理页面跳转为add.jsp。 list.jsp点击“修改”操作，带学生id参数到后台controller处理，controller调出该id学生信息，封装到ModelAndView中并返回update.jsp页面。知识点整合 SpringMvc对象属性自动封装。参见add.jsp。 SpringMvc乱码解决：配置一个过滤器。参见web.xml。 SpringMvc重定向与转发：转发能带参数，但是网址栏不会改变，重定向会改变。参见StudentController SpringMvc对servlet API的支持：支持request、response等。参见UserController。 SpringMvc自动解析json：引入jar包、命名空间、加注解。参见UserController。代码实例：SpringMvc02SpringMvc对rest风格url的支持 特点：请求任何controller都没有.do后缀，请求前端页面没有.jsp；所有的url都没有后缀（但博主似乎支持带.html后缀）。 @PathVariable获取url参数。 SpringMvc对静态资源的映射 代码实例：SpringMvc5RestSpringMvc文件上传 引入jar包、配置beanSpringMvc文件上传 引jar包、配置bean 单文件上传 多文件上传 代码实例：SpringMvc6FileUpload","categories":[],"tags":[]},{"title":"","slug":"SpringBoot最佳工程结构目录","date":"2019-04-30T08:25:45.846Z","updated":"2019-02-15T07:05:36.574Z","comments":true,"path":"2019/04/30/SpringBoot最佳工程结构目录/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringBoot最佳工程结构目录/","excerpt":"","text":"zjava根目录下面还要分三级，com、域名、工程名，然后才开始分层","categories":[],"tags":[]},{"title":"","slug":"Springboot整合Mybatis","date":"2019-04-30T08:25:45.843Z","updated":"2018-11-02T04:16:49.717Z","comments":true,"path":"2019/04/30/Springboot整合Mybatis/","link":"","permalink":"http://47.107.237.149/2019/04/30/Springboot整合Mybatis/","excerpt":"","text":"引入依赖 mybatis-spring-boot-starter依赖： 自动检测现有的DataSource（一般配置在application.properties中） 创建并注册SqlSessionFactory的实例，该实例使用SqlSessionFactoryBean将DataSource作为输入进行传递 自动扫描mappers，注册到Spring上下文 也就是说，使用了该starter之后只需要定义一个DAtaSource即可","categories":[],"tags":[]},{"title":"","slug":"Springboot整合Mybatis(1)","date":"2019-04-30T08:25:45.840Z","updated":"2018-11-30T06:00:38.102Z","comments":true,"path":"2019/04/30/Springboot整合Mybatis(1)/","link":"","permalink":"http://47.107.237.149/2019/04/30/Springboot整合Mybatis(1)/","excerpt":"","text":"引入mybatis-spring-boot-starter依赖 &lt;!--整合mybatis，不用再引入spring-boot-starter-jdbc，因为这个包含了它--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;!--必须指定版本，不然找不到@Mapper注解--&gt; &lt;/dependency&gt; &lt;!--同时要引入mysql驱动--&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; mybatis-spring-boot-starter依赖： 自动检测现有的DataSource 创建并注册SqlSessionFactory的实例，该实例使用SqlSessionFactoryBean将该DAtaSource作为输入进行传递 自动扫描mappers，将它们注入到Spring上下文，以便将它们注入到你的bean中。 就是说，使用了该starter之后，只需要定义一个DataSource即可 配置数据源 spring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username = root spring.datasource.password = root spring.datasource.driver-class-name = com.mysql.jdbc.Driver 自定义数据源：Springboot默认使用tomcat-jdbc数据源，如果想用其他数据源，除了在配置原件配置数据源以外，还要额外添加以下依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt; &lt;/dependency&gt; 然后这里使用直接引用配置文件的方式来配置数据库连接池 application.properties #阿里巴巴连接池配置 #最大连接池数量 spring.datasource.max-active=20 #最小连接池数量 spring.datasource.min-idle=8 #获取连接时最大等待时间 spring.datasource.maxWait=60000 #初始化时建立连接的个数 spring.datasource.initialSize=2 #申请连接时执行ValidationQuery检测连接是否有效，建议为false，因为做了这个配置会降低性能；若下面那行括号为null则这一行怎么写都不生效 spring.datasource.testOnBorrow=false #用来检测连接是否有效的sql，要求是一个查询语句 spring.datasource.validationQuery=&quot;SELECT 1&quot; #建议配置为true，不影响性能且保证安全性；作用是在ValidationQuery上加个条件：当空闲时间大于timeBetweenEvictionRunsMillis时才执行连接检测 spring.datasource.testWhileIdle=true #是否缓存preparedStatement spring.datasource.poolPreparedStatements=true - Application.java @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } @Bean(destroyMethod = &quot;close&quot;) //destroyMethod = &quot;close&quot;：当数据库连接不使用时就把该连接重新放到数据池中，方便下次调用 @ConfigurationProperties(prefix=&quot;spring.datasource&quot;) //直接使用配置文件中前缀为这个的属性来set DataSource的属性 public DataSource dataSource(){ return new DruidDataSource(); } } ok，这样就算我们自己设置了一个DataSource，Springboot会自动选择我们自己配置的这个DataSource实例 建张表learn_resource，写个实体类LearnResource public class LearnResource { private Long id; private String author; private String title; private String url; } 方式一：注解方式 dao层写增删查改接口，类上加个@Mapper注解或在入口类加个@MapperScan(“com.dudu.dao”) @Component //不加的话service那边引入LearnMappers时会警告 @Mapper public interface LearnMapper { //简单的可以直接用注解完成 @Insert(&quot;insert into learn_resource values(#{id},#{author},#{title},#{url})&quot;) public int add(LearnResource learnResource); @Update(&quot;update learn_resource set author=#{author},title=#{title},url=#{url} where id=#{id}&quot;) public int update(LearnResource learnResource); //复杂的需要创建动态sql @DeleteProvider(type=LearnSqlBuilder.class,method=&quot;deleteByIds&quot;) public int deleteByIds(@Param(&quot;ids&quot;)String[] ids); @Select(&quot;select * from learn_resource where id=#{id}&quot;) @Results( { @Result(id=true,column=&quot;id&quot;,property = &quot;id&quot;), @Result(column=&quot;author&quot;,property = &quot;author&quot;), @Result(column=&quot;title&quot;,property = &quot;title&quot;), } ) public LearnResource queryLearnResourceById(@Param(&quot;id&quot;) Long id); /** * @Author haien * @Description 动态查询 * @Date 2018/11/3 * @Param [params] * @return java.util.List&lt;com.dudu.domain.LearnResource&gt; **/ @SelectProvider(type=LearnSqlBuilder.class,method=&quot;queryLearnResourceByParams&quot;) public List&lt;LearnResource&gt; queryLearnResourceList(Map&lt;String,Object&gt; params); /** * @Author haien * @Description 动态sql的创建类 * @Date 2018/11/3 **/ class LearnSqlBuilder{ /** * @Author haien * @Description 动态查询 * @Date 2018/11/2 * @Param [params] * @return java.lang.String **/ public String queryLearnResourceByParams(final Map&lt;String,Object&gt; params){ //方式一、使用java1234的做法 SQL sql= new SQL(){ { SELECT(&quot;*&quot;); FROM(&quot;learn_resource&quot;); StringBuffer sb=new StringBuffer(); if(params.get(&quot;author&quot;)!=null){ sb.append(&quot; and author like &apos;%&quot;+params.get(&quot;author&quot;) +&quot;%&apos;&quot;); } if(params.get(&quot;title&quot;)!=null){ sb.append(&quot; and title=&quot;+params.get(&quot;title&quot;)); } if(!sb.toString().equals(&quot;&quot;)){ WHERE(sb.toString().replaceFirst(&quot;and&quot;,&quot;&quot;)); } } }; System.out.println(sql.toString()); return sql.toString(); //方式二、用嘟嘟博客的做法 /* StringBuffer sql=new StringBuffer(); sql.append(&quot;selelct * from learn_resource where 1=1&quot;); if(params.get(&quot;author&quot;)!=null){ sql.append(&quot; and author like &apos;%&quot;).append(params.get(&quot;author&quot;)).append(&quot;%&apos;&quot;); } if(params.get(&quot;title&quot;)!=null){ sql.append(&quot; and title like &apos;%&quot;).append(params.get(&quot;title&quot;)).append(&quot;%&apos;&quot;); } System.out.println(&quot;查询sql==&quot;+sql.toString()); return sql.toString(); */ } /** * @Author haien * @Description 批量删除 * @Date 2018/11/2 * @Param [ids] * @return java.lang.String **/ public String deleteByIds(@Param(&quot;ids&quot;)final String[] ids){ StringBuffer sql=new StringBuffer(); sql.append(&quot;delete from learn_resource where id in(&quot;); for(int i=0;i&lt;ids.length;i++){ if(i==ids.length-1){ sql.append(ids[i]); //最后一个则不用再跟个逗号 }else{ sql.append(ids[i]).append(&quot;,&quot;); } } sql.append(&quot;)&quot;); return sql.toString(); } } } 方式二：xml配置文件 xml配置方式一：通过mybatis.config-location指定config.xml路径，然后在里面设置别名、指定mapper包 application.properties mybatis.config-location=mybatis-config.xml mybatis-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;sample.mybatis.domain&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;sample/mybatis/mapper/CityMapper.xml&quot;/&gt; &lt;mapper resource=&quot;sample/mybatis/mapper/HotelMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 这样既起了别名，映射文件也被扫描到了，数据层接口就不需要@Mapper注解了 二：通过mybatis.type-aliases-package指定实体类路径，mybatis.mapperLocations指定映射文件路径，数据层接口要加@Mapper接口 application.properties mybatis.type-aliases-package=com.dudu.domain; mybatis.mapperLocations=classpath:mapper/*.xml //当mapper文件和mapper接口在同一个包下时不用配置 - dao层 @Mapper public interface LearnMapperWithXml { public int add(LearnResource learnResource); public int update(LearnResource learnResource); public int deleteByIds(String[] ids); public LearnResource queryLearnResourceById(Long id); public List&lt;LearnResource&gt; queryLearnResourceList(Map&lt;String,Object&gt; params); } 根据方式二的路径我们在resources下新建一个文件夹mapper，写LearnMapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--为指定接口中的方法配置sql语句--&gt; &lt;mapper namespace=&quot;com.dudu.dao.LearnMapperWithXml&quot;&gt; &lt;!--指定接口--&gt; &lt;resultMap id=&quot;LearnResource&quot; type=&quot;com.dudu.domain.LearnResource&quot;&gt; &lt;!--一定要用完整路径--&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;author&quot; property=&quot;author&quot;/&gt; &lt;result column=&quot;title&quot; property=&quot;title&quot;/&gt; &lt;result column=&quot;url&quot; property=&quot;url&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;queryLearnResourceList&quot; resultMap=&quot;LearnResource&quot; parameterType=&quot;hashmap&quot;&gt; &lt;!--大小写不分--&gt; select * from learn_resource &lt;where&gt; &lt;if test=&quot;author!=null and author !=&apos;&apos;&quot;&gt; and author like &apos;%${author}%&apos; &lt;!--like的话是%${author}%而不是%#{author}%--&gt; &lt;/if&gt; &lt;if test=&quot;title!=null and title!=&apos;&apos;&quot;&gt; and title like &apos;%${title}%&apos; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;queryLearnResourceById&quot; resultMap=&quot;LearnResource&quot; parameterType=&quot;Long&quot;&gt; select * from learn_resource where id=#{id} &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;com.dudu.domain.LearnResource&quot;&gt; insert into learn_resource values(#{id},#{author},#{title},#{url}) &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.dudu.domain.LearnResource&quot;&gt; update learn_resource set author=#{author},title=#{title},url=#{url} where id=#{id} &lt;/update&gt; &lt;delete id=&quot;deleteByIds&quot; parameterType=&quot;String&quot;&gt; delete from learn_resource where id in &lt;foreach collection=&quot;params&quot; item=&quot;idItem&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{idItem} &lt;/foreach&gt; &lt;/delete&gt; &lt;/mapper&gt; ：封装sql语句，：调用sql语句 SELECT * FROM body_index &lt;select id=&quot;find&quot; resultType=&quot;*&quot; resultMap=&quot;*&quot;&gt; &lt;include refid=&quot;select&quot;/&gt; &lt;/select&gt; mybatis的分页：PageHelper分页插件 物理分页 原理：分页本质上是sql limit去获取数据，而mybatis则是在Statement生成之前对sql进行改造，之后生成的Statement中包含的sql就能实现分页功能了。这是利用mybatis拦截器实现的。 首先引入依赖 &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 在service实现层中使用（当然你要放在controller层还是其他层使用都可以） /** * @Author haien * @Description 动态查询 * @Date 2018/11/3 * @Param [params] * @return java.util.List&lt;com.dudu.domain.LearnResource&gt; **/ @Override public List&lt;LearnResource&gt; queryLearnResourceList(Map&lt;String, Object&gt; params) { //物理分页:对mybatis流程进行增强，添加了limit以及count查询 PageHelper.startPage(Integer.parseInt(params.get(&quot;pageNum&quot;).toString()), Integer.parseInt(params.get(&quot;rows&quot;).toString())); //page: 页码（从0开始），rows：容量 return learnMapperWithXml.queryLearnResourceList(params); } 在controller层转换为pageInfo类，它将数据用List封装，另外还包含许多类似总页数、总条数的属性 List&lt;LearnResource&gt; learnResourceList=learnService.queryLearnResourceList(params); PageInfo&lt;LearnResource&gt; pageInfo=new PageInfo&lt;LearnResource&gt;(learnResourceList); //不能直接强转：PageInfo&lt;LearnResource&gt; pageInfo=(PageInfo&lt;LearnResource&gt;)learnService.queryLearnResourceList(params); JSONObject jo=new JSONObject(); jo.put(&quot;rows&quot;,pageInfo); //LearnResource实体类集合 jo.put(&quot;total&quot;,pageInfo.getPages()); //总页数 jo.put(&quot;records&quot;,pageInfo.getTotal()); //总记录数 缺点：不支持条件查询的sql（具体不知道是什么条件查询），不过网上有改良后能支持的PageHelper &lt;dependency&gt; &lt;groupId&gt;com.mybatis.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; 代码实例：SpringbootIntegrateMybatis 代码实例：SpringbootIntegrateMybatis","categories":[],"tags":[]},{"title":"","slug":"SpringBoot整合jpa操作数据库","date":"2019-04-30T08:25:45.838Z","updated":"2019-02-16T06:17:32.853Z","comments":true,"path":"2019/04/30/SpringBoot整合jpa操作数据库/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringBoot整合jpa操作数据库/","excerpt":"","text":"连接数据库添加依赖 配置 建立数据库 新建数据库test，但不用建表设计实体类 运行controller 运行后test数据库出现demo表操作数据库","categories":[],"tags":[]},{"title":"","slug":"SpringBoot学习之表单验证@Valid","date":"2019-04-30T08:25:45.835Z","updated":"2018-09-10T14:00:50.781Z","comments":true,"path":"2019/04/30/SpringBoot学习之表单验证@Valid/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringBoot学习之表单验证@Valid/","excerpt":"","text":"新建一个entity，添加表单验证注解 @Entity @Table(name=&quot;t_student&quot;) public class Student { @Id @GeneratedValue private Integer id; @NotEmpty(message=&quot;姓名不能为空！&quot;) //限制不为null且不为空，否则返回提示信息到页面 @Column(length=50) private String name; @NotNull(message=&quot;年龄不能为空！&quot;) @Min(value = 18,message = &quot;年龄必须大于18岁！&quot;) private Integer age; setter、getter } controller层添加进行表单验证的注解，并处理验证不通过信息 @RequestMapping(&quot;/add&quot;) public String add(@Valid Student student, BindingResult bingdingResult){ //@Valid：进行验证；BindingResult：验证返回的结果，不加的话会在验证不通过时抛出异常 if(bingdingResult.hasErrors()){ //一开始拦截器拦截请求时就进行了验证，假如不通过的话 return bingdingResult.getFieldError().getDefaultMessage(); //返回错误信息，比如姓名没填则返回“姓名不能为空！” }else { studentService.add(student); return &quot;添加成功&quot;; } } 限制条件清单 @Null 限制只能为null @NotNull 限制必须不为null @AssertFalse 限制必须为false @AssertTrue 限制必须为true @DecimalMax(value) 限制必须为一个不大于指定值的数字 @DecimalMin(value) 限制必须为一个不小于指定值的数字 @Digits(integer,fraction) 限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction @Future 限制必须是一个将来的日期 @Max(value) 限制必须为一个不大于指定值的数字 @Min(value) 限制必须为一个不小于指定值的数字 @Past 限制必须是一个过去的日期 @Pattern(value) 限制必须符合指定的正则表达式 @Size(max,min) 限制字符长度必须在min到max之间 @Past 验证注解的元素值（日期类型）比当前时间早 @NotEmpty 验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0） @NotBlank 验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的空格 @Email 验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 代码实例：D:/SpringBootJpa/entity/Student、StudentController","categories":[],"tags":[]},{"title":"","slug":"SpringBoot学习之HelloWorld","date":"2019-04-30T08:25:45.832Z","updated":"2019-01-20T03:07:15.039Z","comments":true,"path":"2019/04/30/SpringBoot学习之HelloWorld/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringBoot学习之HelloWorld/","excerpt":"","text":"第一个SpringBoot HelloWorld SpringBoot内置集成Tomcat，不需要启动服务器，直接启动App类即可运行项目。 static下面放图片、js文件、css文件等。 application.properties配置文件 # 不用输入项目名直接访问,因为默认值为/，改为如下则输入localhost:8080/HelloWorld server.context-path=/HelloWorld 绑定配置文件中的属性 @Value(&quot;${helloWorld}&quot;) //绑定application.properties文件该属性 private String helloWorld; 将配置文件中的属性封装成对象 application.properties mysql.jdbcName=com.mysql.jdbc.Driver mysql.dbUtil=jdbc:mysql://localhost:3306/db_book mysql.userName=root mysql.password=123456 写一个配置类 @Component //交给Spring容器搞成bean @ConfigurationProperties(prefix=&quot;mysql&quot;) //到application.properties中找到前缀为mysql的属性,自动将属性封装成对象 public class MysqlConfiguration { private String jdbcName; private String dbUtil; private String userName; private String password; getter、setter } 在需要用到的地方注入 //不过要是MySQL配置也像上面这么绑那就太累了，可以将属性封装成对象再注入到这里 @Resource private MysqlConfiguration mysqlConfiguration; 默认单例模式，在不同的类里用注解注入的同类的bean都是同一个。 代码实例：D:/ideaPro使用freemarker 配置maven &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 编写controller（免后缀） @RequestMapping(&quot;/say&quot;) public ModelAndView say(){ ModelAndView mav=new ModelAndView(); mav.addObject(&quot;message&quot;,&quot;SpringBoot大爷你好！&quot;); mav.setViewName(&quot;helloWorld&quot;); //免后缀 return mav; } 编写相应freemarker（可以先建HTML文件然后改后缀为ftl。这种文件的优点就在于访问路径不用加后缀，其他跟HTML没差。记得要写在resources/templates下才能通过上面路径访问到） &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; show:${message} &lt;!-- 还是这样获取数据 --&gt; &lt;/body&gt; &lt;/html&gt; 下面代码是简化的取集合 &lt;#list bookList as book&gt; &lt;!--把集合里取出来的个体放到book中 --&gt; &lt;tr&gt; &lt;td&gt;${book.id}&lt;/td&gt; &lt;td&gt;${book.name}&lt;/td&gt; &lt;td&gt;${book.author}&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;/book/preUpdate/${book.id}&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;/book/delete?id=${book.id}&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;!--这里应该会飘红，但是注意到文件本身不飘红，所以没事--&gt; 代码实例：D:/ideaProspringMVC整合freemaker spring-mvc.xml &lt;!-- freeMarker视图解析 17061434 --&gt; &lt;bean id=&quot;freeMarkerViewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;&quot;/&gt; &lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt; &lt;property name=&quot;viewNames&quot; value=&quot;*.ftl&quot;/&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt; &lt;/bean&gt; &lt;!-- ftl配置 --&gt; &lt;bean id=&quot;freeMarkerConfigurer&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/ftl/&quot;/&gt; &lt;/bean&gt; &lt;!-- 后面这个不知道需不需要 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;mediaTypes&quot;&gt; &lt;map&gt; &lt;entry key=&quot;json&quot; value=&quot;application/json&quot;/&gt; &lt;entry key=&quot;jsonp&quot; value=&quot;application/javascript&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;viewResolvers&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot; /&gt; &lt;ref bean=&quot;freeMarkerViewResolver&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;defaultViews&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;&gt; &lt;/bean&gt; &lt;bean class=&quot;com.suning.viewsolver.JsonpView&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; @RestController支持ajax请求 写一个页面，在该页面实现ajax请求，比如index.html(放在static下直接访问就行了) &lt;head&gt; &lt;!-- ajax请求 --&gt; &lt;script src=&quot;http://www.java1234.com/jquery-easyui-1.3.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function show(){ $.post(&quot;ajax/hello&quot;,{},function(result){ alert(result); }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;show()&quot;&gt;你大爷&lt;/button&gt; &lt;/body&gt; 写一个controller类处理ajax请求 @RestController @RequestMapping(&quot;/ajax&quot;) public class HelloWorldAjaxController { @RequestMapping(&quot;/hello&quot;) public String say(){ //返回json字符串 return &quot;{&apos;message1&apos;:&apos;SpringBoot大爷你好&apos;,&apos;message2&apos;:&apos;Spring大爷你好2&apos;}&quot;; } } 以上操作结果为，在首页点击“你大爷”后弹窗显示{‘message1’:’SpringBoot大爷你好’,’message2’:’Spring大爷你好2’} 代码实例：D:/ideaPro","categories":[],"tags":[]},{"title":"","slug":"SpringBoot学习之AOP","date":"2019-04-30T08:25:45.829Z","updated":"2018-08-10T09:54:40.480Z","comments":true,"path":"2019/04/30/SpringBoot学习之AOP/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringBoot学习之AOP/","excerpt":"","text":"新建一个切面类，定义要切入的方法及如何切入即可，不用写入到逻辑代码中 @Aspect //声明这是一个切面类 @Component //保证被扫描到 public class RequestAspect { private Logger logger=Logger.getLogger(RequestAspect.class); @Pointcut(&quot;execution(public * com.java1234.controller.*.*(..))&quot;) //设置切点，对任意返回值、controller包下任意类、任意方法都切入 public void log(){ } @Before(&quot;log()&quot;) public void doBefore(JoinPoint joinPoint){ //执行前要调用的 //以info等级打印日志 logger.info(&quot;方法执行前...&quot;); //获取request ServletRequestAttributes sra=(ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request=sra.getRequest(); //通过request获取url、IP等 logger.info(&quot;url:&quot;+request.getRequestURI()); logger.info(&quot;ip:&quot;+request.getRemoteHost()); //获取提交方法（get、post） logger.info(&quot;method:&quot;+request.getMethod()); //获取方法名 logger.info(&quot;class_method:&quot;+joinPoint.getSignature().getDeclaringTypeName()+&quot;.&quot;+joinPoint.getSignature().getName()); //获取参数列表 logger.info(&quot;args:&quot;+joinPoint.getArgs()); //得到的参数列表是个数组，打印第一个 Student student=(Student) joinPoint.getArgs()[0]; //打印这传入的第一个参数 System.out.println(student); } @After(&quot;log()&quot;) public void doAfter(JoinPoint joinPoint){ logger.info(&quot;方法执行后...&quot;); } @AfterReturning(returning=&quot;result&quot;,pointcut=&quot;log()&quot;) //方法返回后要调用的 public void doAfterReturning(Object result){ logger.info(&quot;方法返回值：&quot;+result); //打印执行此方法的返回值（比如“添加成功”这样的提示信息） } } controller那边一有方法被执行，这些日志信息就被切入到方法执行过程打印出来 代码实例：D:/SpringBootJpa/aspect/RequestAspect","categories":[],"tags":[]},{"title":"","slug":"SpringBoot使用自动以yml配置文件","date":"2019-04-30T08:25:45.825Z","updated":"2018-09-06T13:07:41.208Z","comments":true,"path":"2019/04/30/SpringBoot使用自动以yml配置文件/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpringBoot使用自动以yml配置文件/","excerpt":"","text":"默认文件名为application.yml,在其中这样配置： smartTalk: qa_manage_url: https://nlsapi.aliyun.com/manage/qas 注意：配置后面的：是要加空格的，否则SpringBoot识别不出来 在类中这样获取： @Value(&quot;${smartTalk.qa_manage_url}&quot;) private String qa_manage_url;","categories":[],"tags":[]},{"title":"","slug":"springboot配置devtools实现热部署","date":"2019-04-30T08:25:45.823Z","updated":"2018-07-13T09:44:02.520Z","comments":true,"path":"2019/04/30/springboot配置devtools实现热部署/","link":"","permalink":"http://47.107.237.149/2019/04/30/springboot配置devtools实现热部署/","excerpt":"","text":"https://www.cnblogs.com/lspz/p/6832358.html","categories":[],"tags":[]},{"title":"","slug":"springboot访问静态资源与配置文件","date":"2019-04-30T08:25:45.820Z","updated":"2019-03-13T04:08:22.252Z","comments":true,"path":"2019/04/30/springboot访问静态资源与配置文件/","link":"","permalink":"http://47.107.237.149/2019/04/30/springboot访问静态资源与配置文件/","excerpt":"","text":"参考文章默认 上面这几个都是静态资源的映射路径，优先级顺序为：META-INF/resources &gt;resources/resources &gt; static &gt; public,在这四个目录中都写一个index.html,访问localhost：8080，会访问到META-INF/resource下的index.html，而如果该目录为空则会访问resource下的index.html，像这样依次去寻找资源来展示。开发存放目录 一般来说，开发时会把不需要权限就可以访问的页面直接放在static下面，比如index.html等，还有css、js、images文件夹都会建在static下面。而需要权限限制的页面放在resources/templates下面，这个位置相当于WEB-INF，这些文件一般需要通过controller来进行跳转。 如果一定要把默认主页这种可以直接访问的页面都放在templates下的话，那可以配置个controller保证访问得到它（一般我们会顺便获取一些信息，比如文件列表或者评委名单之类，带回到页面显示）： @Controller @RequestMapping public class IndexController { @RequestMapping(&quot;/index.html&quot;) public ModelAndView index(){ ModelAndView modelAndView = new ModelAndView(&quot;index&quot;); …… return modelAndView; } } 当然我们可以通过下面这种方法改变这种默认的配置 # 默认值为 /** spring.mvc.static-path-pattern= # 默认值为 classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ spring.resources.static-locations=这里设置要指向的路径，多个使用英文逗号隔开 或者还可以写个class继承自WebMvcConfigurerAdapter来指定方式访问页面，参见下面指定方式访问静态资源自定义 上面主要是修改类似默认主页这样的静态资源的访问方式，如果现在我们在项目中放了一张图片，这不是springboot能管理得了的，那么我们应该如何访问它呢？指定方式访问静态资源 这就是自己额外增加配置的情况，我们可以通过自定义资源映射来定义访问的方式，具体方法则是重写一个叫做addResourceHandlers方法。 @Configuration public class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter { /** * 配置静态访问资源 * @param registry */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/my/**&quot;).addResourceLocations(&quot;classpath:/my/&quot;); super.addResourceHandlers(registry); } } 通过addResourceHandler添加映射路径，然后通过addResourceLocations来指定路径。我们访问resources下自定义my文件夹中的elephant.jpg 图片的地址为 http://localhost:8080/my/elephant.jpg 如果你想指定外部的目录也很简单，直接addResourceLocations指定即可，代码如下： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/my/**&quot;).addResourceLocations(&quot;file:E:/my/&quot;); super.addResourceHandlers(registry); } 指定方式访问页面 在thymeleaf的默认路径resources/templates下找login页面 一般会报下面这种错误可能是系统找到了模板页，但却不是请求的模板页，或者是th标签使用错误，比如忘记引入命名空间之类。 拦截器 实现步骤： 实现HandlerInterceptor接口 重写WebMvcConfigyurerAdapter的addInterceptors方法，将自定义的拦截器类添加进来 代码实例：SpringMvc02/interceptor/MyInterceptor、domain/MyWebMvcConfigurerAdapter、template/login.html、controller/LearnResourceController(功能：登录后访问学习资料页面，未登录直接访问学习资料页面则会直接跳转登录页面；这里有个小bug好像登录不上去，但拦截的功能是实现了的)配置文件存放目录 项目根目录下 项目根目录中config目录下 项目的resources目录下 项目resources目录中config目录下读取顺序 config/application.properties（项目根目录中config目录下） config/application.yml application.properties（项目根目录下） application.yml resources/config/application.properties（项目resources目录中config目录下） resources/config/application.yml resources/application.properties（项目的resources目录下） resources/application.yml","categories":[],"tags":[]},{"title":"","slug":"springboot","date":"2019-04-30T08:25:45.817Z","updated":"2018-11-12T08:14:22.942Z","comments":true,"path":"2019/04/30/springboot/","link":"","permalink":"http://47.107.237.149/2019/04/30/springboot/","excerpt":"","text":"缺点 因为不用自己做配置，有时，启动时不知道框架哪里抽风，会导致系统无法启动，报的错都很神奇，搜完百度和谷歌和stackflow都没解决方案。 解决方案 重新建一个sb项目，把代码啥的都拷贝过去，就好了； 还是老老实实的自己弄配置，安全，万一报错，也能查到原因。 现在：玩了几个sb项目后，还是老老实实自己搭框架，其实搭好以后，还是一劳永逸的（起码不用担心框架自己抽风。就算抽风，也能找出原因。）建议 推荐刚接触的同学先用原始的xml方式把spring springmvc maven老老实实配置一遍，不然默认了哪些配置都搞不清。简介 spring boot是spring家族中的一个全新框架，用来简化spring应用程序的创建和开发过程 整合了很多框架，类似一个大型的容器 抛弃了繁琐的xml配置，采用大量的默认配置简化我们的开发过程 可以开发web项目，也可以开发java项目四大核心 自动配置：针对很多spring应用程序和常用的应用功能，spring boot能自动提供相关配置 起步依赖：告诉spring boot需要什么功能，它就能引入需要的依赖库 actuator：健康检查，让你能够深入运行中的spring boot应用程序，一探spring boot程序的内部信息 命令行界面：这是spring boot的可选特性，主要针对groovy语言使用创建项目 具体操作步骤见“创建spring-boot项目”笔记web项目 前端后台分开写，前端连接后台用js，后台不用连接前端。 输入网址，自动访问默认前端页面，点击操作，参数传至js，js指定路径（url）去请求后台某个controller，那么多个controller中，RequestMapping和url相同的将会处理该请求，并将处理结果存放进ModelAndView，js继续定位到下一个页面，跳转之后在那个页面取什么值系统就会拿相应的ModelAndView出来展示。单例模式 默认单例模式，在不同的类里用注解注入的同类的bean都是同一个。","categories":[],"tags":[]},{"title":"","slug":"Spring Security之用户验证","date":"2019-04-30T08:25:45.809Z","updated":"2019-02-15T03:49:14.759Z","comments":true,"path":"2019/04/30/Spring Security之用户验证/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring Security之用户验证/","excerpt":"","text":"spring security验证流程： spring security的登录验证是由UsernamePasswordAuthenticationFilter这个过滤器完成，在该类的父类AbstractAuthenticationProcessingFilter（585行）中有一个AuthenticationManager接口属性，验证工作主要是通过这个AuthenticationManager接口的实例来完成的。默认情况下，spring security会把ProviderManager类的实例注入到该属性。而自定义AbstractAuthenticationProcessingFilter的情况下，一般会在配置文件：，起别名，然后注入该自定义类的某个属性中，看上面那个配置文件就知道了 UsernamePasswordAuthenticationFilter的验证过程如下： 首先过滤器会调用自身的attemptAuthentication方法（646行），该方法规定请求必须为post，并从request中取出authentication，authentication是在SecurityContextPersistenceFilter过滤器中通过捕获用户提交的登录表单中的内容生成的一个Authentication接口实例。 attemptAuthentication方法拿到authentication对象后，在方法中又调用ProviderManager类的authenticate方法并传入authentication对象（由于只能验证用户名、密码的简单信息，所以经常重写以实现复杂的用户验证，并返回包含当前用户所有信息的authentication），验证用户是否能登录，并处理定义登录成败重定向的页面 也就是说attemptAuthentication方法会调用类中的List providers集合中各个AuthenticationProvider接口实现类中的authenticate（Authentication authentication）进行验证 provider的实现类在验证用户时，会调用UserDetailsService的实现类的loadUserByUsername方法获取用户信息。 由此可见，真正的验证逻辑是由各个AuthenticationProvider接口实现类来完成的。DaoAuthenticationProvider类是默认情况下会被注入AuthenticationProvider的接口实现类。 源码分析 AbstractAuthenticationProcessingFilter public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean implements ApplicationEventPublisherAware, MessageSourceAware { // 过滤器doFilter方法 public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; /* * 1、判断当前filter是否可以处理当前请求，若不行，则交给下一个filter去处理。 */ if (!requiresAuthentication(request, response)) { chain.doFilter(request, response); return; } if (logger.isDebugEnabled()) { logger.debug(&quot;Request is to process authentication&quot;); } Authentication authResult; /* * 2、调用子类（UsernamePasswordAuthenticationFilter）attemptAuthentication方法 */ try { authResult = attemptAuthentication(request, response); if (authResult == null) { // return immediately as subclass has indicated that it hasn&apos;t completed // authentication return; } /* * 3、最终认证成功后，会处理一些与session相关的方法 * （比如将认证信息存到session等操作）。 */ sessionStrategy.onAuthentication(authResult, request, response); } /* * 3、认证失败后的一些处理。 */ catch (InternalAuthenticationServiceException failed) { logger.error( &quot;An internal error occurred while trying to authenticate the user.&quot;, failed); unsuccessfulAuthentication(request, response, failed); return; } catch (AuthenticationException failed) { unsuccessfulAuthentication(request, response, failed); return; } /* * 4、认证成功，继续下个请求 */ if (continueChainBeforeSuccessfulAuthentication) { chain.doFilter(request, response); } /* * 5、最终认证成功后的相关回调方法，主要将当前的认证信息放到SecurityContextHolder中 * 并调用认证成功处理器AuthenticationSuccessHandler接口实现类的 * onAuthenticationSuccess()。 */ successfulAuthentication(request, response, chain, authResult); } } UsernamePasswordAuthenticaionFilter，以上AbstractAuthenticationProcessingFilter的子类，主要是重写attemptAuthentication()，规定请求必须为post。 public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter { //实现父类的方法 public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException { // 认证请求的方式必须为POST if (postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) { throw new AuthenticationServiceException( &quot;Authentication method not supported: &quot; + request.getMethod()); } // 获取表单参数 String username = obtainUsername(request); String password = obtainPassword(request); if (username == null) { username = &quot;&quot;; } if (password == null) { password = &quot;&quot;; } username = username.trim(); /* * 封装进Authentication实现类UsernamePasswordAuthenticationToken * public UsernamePasswordAuthenticationToken(Object principal, Object credentials) { super((Collection)null); //设置权限为null this.principal = principal; this.credentials = credentials; this.setAuthenticated(false); } */ UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken( username, password); //一般来说principle是User对象较常见 setDetails(request, authRequest); //Allow subclasses to set the &quot;details&quot; property //调用AuthenticationManager管理下的AuthenticationProvider接口实现类的authenticate() return this.getAuthenticationManager().authenticate(authRequest); } } AuthenticationManager：AuthenticationManager仅仅是一个接口，默认实现类是ProviderManager，ProviderManager不是自己直接对请求进行验证，而是将其委派给一个AuthenticationProvider列表。例如我们要同时使用jdbc认证和ldap认证，那么就可以用这个列表。列表中的每一个AuthenticationProvider将会被一次查询是否需要通过器进行验证。每个provider的验证结果只有两种情况：抛出ProviderNotFoundException异常或者完全填充一个Authentication对象，并存储在SecurityContext中。 ProviderManager public Authentication authenticate(Authentication authentication) throws AuthenticationException { Class toTest = authentication.getClass(); Object lastException = null; Authentication result = null; boolean debug = logger.isDebugEnabled(); // 拿到全部的provider Iterator e = this.getProviders().iterator(); // 遍历provider while(e.hasNext()) { AuthenticationProvider provider = (AuthenticationProvider)e.next(); // 调用provider的supports()校验是否支持当前token if(provider.supports(toTest)) { if(debug) { logger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName()); } try { /* * 找到后直接break，并由当前provider来进行校验工作 * 调用AuthenticationProvider实现类的authenticate() */ result = provider.authenticate(authentication); if(result != null) { this.copyDetails(authentication, result); break; } } catch (AccountStatusException var11) { this.prepareException(var11, authentication); throw var11; } catch (InternalAuthenticationServiceException var12) { this.prepareException(var12, authentication); throw var12; } catch (AuthenticationException var13) { lastException = var13; } } } // 若没有一个支持，则尝试交给父类来执行 if(result == null &amp;&amp; this.parent != null) { try { result = this.parent.authenticate(authentication); } catch (ProviderNotFoundException var9) { ; } catch (AuthenticationException var10) { lastException = var10; } } .......................... } DaoAuthenticationProvider:AuthenticationProvider默认实现类,实现了父类主要方法authenticate()要用到的查找用户方法retrieveUser() public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider { //重现用户的方法 protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { UserDetails loadedUser; try { /* * 调用UserDetailsService接口的loadUserByUsername方法。 */ loadedUser = this.getUserDetailsService().loadUserByUsername(username); } catch (UsernameNotFoundException var6) { if(authentication.getCredentials() != null) { String presentedPassword = authentication.getCredentials().toString(); this.passwordEncoder.isPasswordValid(this.userNotFoundEncodedPassword, presentedPassword, (Object)null); } throw var6; } catch (Exception var7) { throw new InternalAuthenticationServiceException(var7.getMessage(), var7); } if(loadedUser == null) { throw new InternalAuthenticationServiceException(&quot;UserDetailsService returned null, which is an interface contract violation&quot;); } else { return loadedUser; } } } AbstractUserDetailsAuthenticationProvider：以上DaoAuthenticationProvider的父类，定义了authenticate(),调用子类retrieveUser()查找用户all信息，可以从db查找，并进行用户验证。 public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware { // 用户验证方法 public Authentication authenticate(Authentication authentication) throws AuthenticationException { Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider .onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;)); String username = authentication.getPrincipal() == null? &quot;NONE_PROVIDED&quot;:authentication.getName(); boolean cacheWasUsed = true; UserDetails user = this.userCache.getUserFromCache(username); if(user == null) { cacheWasUsed = false; try { // 调用子类retrieveUser() user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); } catch (UsernameNotFoundException var6) { this.logger.debug(&quot;User \\&apos;&quot; + username + &quot;\\&apos; not found&quot;); if(this.hideUserNotFoundExceptions) { throw new BadCredentialsException(this.messages .getMessage(&quot;AbstractUserDetailsAuthenticationProvider .badCredentials&quot;, &quot;Bad credentials&quot;)); } throw var6; } Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;); } try { /* * 前检查由DefaultPreAuthenticationChecks类实现 * （主要判断当前用户是否锁定，有效，过期） */ this.preAuthenticationChecks.check(user); // 子类具体实现 this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); } catch (AuthenticationException var7) { if(!cacheWasUsed) { throw var7; } cacheWasUsed = false; user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication); this.preAuthenticationChecks.check(user); this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication); } // 检测用户密码是否过期 this.postAuthenticationChecks.check(user); if(!cacheWasUsed) { this.userCache.putUserInCache(user); } Object principalToReturn = user; if(this.forcePrincipalAsString) { principalToReturn = user.getUsername(); } //进行授权成功，主要是将认证信息的一块内容放到Authentication对象中返回 return this.createSuccessAuthentication(principalToReturn, authentication, user); } // 成功授权 protected Authentication createSuccessAuthentication(Object principal, Authentication authentication, UserDetails user) { /* * 回调UsernamePasswordAuthenticationToken的构造器，这里调用的是授权成功的构造器 * public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) { // 不再是null，而是传来的权限，由UserDetailsService类返回，可以从db查 super(authorities); this.principal = principal; this.credentials = credentials; // 这里是true，不再是false。 super.setAuthenticated(true); } UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities())); // 将认证信息的一块内容放到details result.setDetails(authentication.getDetails()); return result; } } 用户验证走完后回到起点，AbstractAuthenticationProcessingFilter.doFilter()，执行session存储和认证成功处理器。 总结：类之间的调用顺序 UsernamePasswordAuthenticationFilter Authentication AuthenticationManager AuthenticationProvider UserDetailsService UsernamePasswordAuthenticationFilter回到起点进行后续操作 用户验证调用链自定义用户验证 我们要做的工作主要是实现几个接口：用户信息UserDetails、用户信息获取服务UserDetailsService（自定义用户获取方式是从数据库还是别的地方）、而需要自定义验证方式（不只用户名、密码，增加验证码等）的时候还要实现验证工具AuthenticationProvider。 否则默认使用authenticate方法来验证，只能验证username和密码，不够灵活 不是通过java注册spring security的话要添加以下配置 &lt;!--还要在http中添加--&gt; &lt;security:custom-filter ref=&quot;passcard_filter&quot; after=&quot;SECURITY_CONTEXT_FILTER&quot;/&gt; &lt;!--注入authentication-provider--&gt; &lt;security:authentication-manager alias=&quot;authenticationManager&quot;&gt; //起别名，方便被下面filter的bean注入 &lt;!-- 注意，这里仅仅是系统默认的认证机制，请在正式系统中明确知道其功能再使用 --&gt; &lt;security:authentication-provider ref=&quot;acocunt_defaultAnthentiactionProvider&quot;/&gt; //默认的 &lt;security:authentication-provider ref=&quot;registrationService&quot;/&gt; //注册的 &lt;security:authentication-provider ref=&quot;enrollmentService&quot;/&gt; //不知干嘛的 &lt;security:authentication-provider ref=&quot;userService&quot;/&gt; //登录的 &lt;/security:authentication-manager&gt; &lt;!--注入自定义的PasscardAuthenticationProcessingFilter，获取登录时提交的表单--&gt; &lt;bean id=&quot;passcard_filter&quot; class=&quot;cn.edu.jszg.cert.security.PasscardAuthenticationProcessingFilter&quot;&gt; &lt;property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot;/&gt; &lt;property name=&quot;useVerifyCode&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;failurePage&quot; value=&quot;/portal/home/auth/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;config&quot; ref=&quot;webAppConfig&quot;/&gt; &lt;property name=&quot;userLogService&quot; ref=&quot;userLogService&quot; /&gt; &lt;property name=&quot;certLoginUrl&quot; value=&quot;${cert.login.url}&quot;/&gt; &lt;/bean&gt; 自定义Authentication（包含着当前登录用户的信息）实现类PassCardAuthenticationToken（默认实现类为UsernamePasswordAuthenticationToken），用于保存authentication中用得到的参数，主要是重写以下方法 /** * 凭证，用户密码 */ @Override public Object getCredentials() { return password; } /** * 当事人，登录名 用户Id */ @Override public Object getPrincipal() { return userID; } Authentication类包含 principle：其实就是实现了UserDetails的User类，它包含User类的所有属性，User中的字段和表单匹配的就会被赋值 details：包含remoteAddress（ip地址），sessionId … Authentication来源 Authentication auth=SecurityContextHolder.getContext().getAuthentication(); spring security获取（所有）登录用户的信息 需要UserDetails实现类User增加一些支持authenticate()的方法 /*首先增加一些支持authenticate()的方法*/ /** * 返回用户所属权限 */ @Override public Collection&lt;GrantedAuthority&gt; getAuthorities() { return this.accesses; } @Override public Object getCredentials() { return null; } @Override public Object getDetails() { return null; } /** * 登录名称 */ @Override public Object getPrincipal() { return loginName; } /** * 是否已认证 */ @Override public boolean isAuthenticated() { return this.authenticated; } /** * 设置是否已认证字段 */ @Override public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException { this.authenticated=isAuthenticated; } 创建AuthenticationProvider实现类，重写authenticate()。如果只是简单的用户名、密码比对的话，那有用户服务就够了，不需要这一步。 @Component public class MyAuthenticationProvider implements AuthenticationProvider { @Autowired private MyUserDetailsService userService; //如果重定义了可以用这个 /** * 自定义的用户验证：判断该用户是否能登录，是则返回包含所有信息的user对象，否则返回null */ @SuppressWarnings(&quot;unchecked&quot;) @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { //自定义类，继承自Authentication相同父类，用于保存authentication中用得到的参数 PassCardAuthenticationToken token=(PassCardAuthenticationToken)authentication; if(token.getUserID()!=null&amp;&amp;token.getPassword()!=null){ //否则直接返回null，登录失败 /* userID：当前用户名作id * 根据用户id查询数据库找到整个user信息 * 这里进行逻辑认证操作，可以获取token中的属性来自定义验证逻辑 */ User user=(User)this.getDao().executeQueryUnique(&quot;User.loadByLoginName&quot;, QueryCmdType.QUERY_NAME, token.getUserID()); /*当然最好是用重定义的UserDetailsService User user=userService.loadUserByUsername(username)*/ String password=token.getPassword(); //用户登录上传的密码 if(this.passwordEncoder!=null){ //将用户提交的密码加密后再与数据库比对 //在第2点那里加了自定义加密器之后这里就不需要再加密 password=this.passwordEncoder.encodePassword(password, null); } if(!password.equalsIgnoreCase(user.getPassword())){ token.setErrCode(&quot;2&quot;); return null; } //如果开启了额外的验证方式的话，进行验证，否则直接判为登录成功 //不过验证码之类的一般是用前端js当场解决，不会传到后台来解决 if( token.isEnablePasscard() &amp;&amp; usePassCard ){ //token中激活密码卡且系统使用密码卡 int position1=((token.getRow1()-1)*7)+token.getColumn1(); int position2=((token.getRow2()-1)*7)+token.getColumn2(); if(user.getPassCardId()==null){ token.setErrCode(&quot;10&quot;); return null; } PassCard passcard=this.passCardDao.findById(user.getPassCardId(), false); if(passcard==null||passcard.getStatus()==PassCardHelper.STATUS_CANCEL ){ token.setErrCode(&quot;10&quot;); return null; } if(passcard.getConfusedContent()==null || passcard.getConfusedContent().length()&lt;7*7*32 ){ token.setErrCode(&quot;10&quot;); return null; } String content=passcard.getConfusedContent(); int perLen=content.length()/49; String str1=content.substring((position1-1)*perLen, position1*perLen); String str2=content.substring((position2-1)*perLen, position2*perLen); String inputStr1=token.getCard1(); String inputStr2=token.getCard2(); if(this.passwordEncoder!=null){ inputStr1 = md5.getMD5ofStr(md5.getMD5ofStr(inputStr1)); inputStr2 = md5.getMD5ofStr(md5.getMD5ofStr(inputStr2)); } if((!str1.equalsIgnoreCase(inputStr1))||(!str2.equalsIgnoreCase(inputStr2))){ token.setErrCode(&quot;10&quot;); return null; } } //可登陆情况 user.setLastIp(token.getIp()); user.setLastLogin(new Date()); this.getDao().saveOrUpdate(user); //更新用户的最近登录时间和ip地址 user.setAuthenticated(true); //设置为已认证，表示可登陆 /* * 导入当前用户角色，并且把权限set到User中， * 用于spring验证用户权限(getAuthorities方法) */ List&lt;UserRole&gt; userRoles=(List&lt;UserRole&gt;)this.getDao(). executeQueryList(&quot;UserRole.listRoleByUserID&quot;, QueryCmdType.QUERY_NAME, -1, -1, user.getId()); Set&lt;GrantedAuthority&gt; accesses=new HashSet&lt;GrantedAuthority&gt;(); for(UserRole ur:userRoles){ accesses.add(ur.getRole()); } user.getOrg().getOrgName(); if(user.getOrg().getCertTypes()!=null) user.getOrg().getCertTypes().size();//延迟载入一下 user.setAccesses(accesses); //导入角色 return user; } return null; } /** * 如果此处验证不通过，是不会执行authentication方法的 */ @Override public boolean supports(Class&lt;? extends Object&gt; authentication) { // AuthenticationProvider内置实现类只支持UsernamePasswordAuthenticationToken return authentication.equals(PassCardAuthenticationToken.class); } } 定义AbstractAuthenticationProcessingFilter实现类，重写attempAuthentication()，用于获取在登录时提交的参数，否则默认只获取j_username,j_password import java.io.IOException; import java.util.Date; import javax.servlet.ServletException; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import org.apache.log4j.Logger; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter; import org.springframework.util.StringUtils; import cn.edu.jszg.cert.user.UserLog; import cn.edu.jszg.cert.user.UserLogService; import cn.edu.jszg.cert.web.WebApplicationConfiguration; import cn.edu.jszg.cert.web.controller.portal.auth.RemoteDataValidator; import com.google.code.kaptcha.servlet.KaptchaServlet; public class PasscardAuthenticationProcessingFilter extends AbstractAuthenticationProcessingFilter { private String successPage = &quot;/home/admin/index&quot;; private String failurePage = &quot;/public/adminLoginEntry&quot;; private boolean forward = false; private boolean useVerifyCode=true; private String certLoginUrl; static Logger logger = Logger.getLogger(PasscardAuthenticationProcessingFilter.class); private WebApplicationConfiguration config; private UserLogService userLogService; public void setConfig(WebApplicationConfiguration config) { this.config = config; } /** * 实现AbstractAuthenticationProcessingFilter的有参构造 * 没记错的话，相当于该filter的访问路径 */ protected PasscardAuthenticationProcessingFilter() { super(&quot;/adminLoginCheck&quot;); //那表单提交应该是提交到这里 } public void setUseVerifyCode(boolean useVerifyCode) { this.useVerifyCode = useVerifyCode; } public void setUserLogService(UserLogService userLogService) { this.userLogService = userLogService; } public boolean validate(HttpServletRequest request) { String userId = request.getParameter(&quot;username&quot;); String md2 = request.getParameter(&quot;m&quot;); String l = request.getParameter(&quot;l&quot;); if (userId == null || md2 == null || l == null) { return false; } long longTime = Long.parseLong(l); if (longTime &lt; new Date().getTime()) { //获取时间秒制 return false; } try { String md1 = RemoteDataValidator.genExamMd5Digest(userId, longTime); if (md1.equals(md2)) return true; } catch (Exception e) { //e.printStackTrace(); } return false; } /** * 可以通过request获取页面传递过来的参数，并且set到相应的token中 */ @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException { // logger.warn(&quot;-----------------start证书登录用户----------&quot;); HttpSession s = request.getSession(true); //Authentication子类，自动获取表单信息 PassCardAuthenticationToken token = new PassCardAuthenticationToken(); String verifyCode = request.getParameter(&quot;verifyCode&quot;); String userID = request.getParameter(&quot;username&quot;); //....此处省略获取参数，并且验证、赋值的逻辑 Authentication auth = null; try { //此处调用getAuthenticationManager的authenticate方法，验证用户是否能登录 auth = this.getAuthenticationManager().authenticate(token); //当supports方法返回true时执行authenticate方法 //此处为登录失败后，相应的处理逻辑 if (auth == null || !auth.isAuthenticated()) { s.setAttribute(&quot;__login_error&quot;, token.getErrCode()); } else { s.removeAttribute(&quot;__login_error&quot;); s.removeAttribute(&quot;__login_username&quot;); s.removeAttribute(&quot;__cert_userid&quot;); if( token.isEnablePasscard()) { s.removeAttribute(&quot;__passcard_row1&quot;); s.removeAttribute(&quot;__passcard_row2&quot;); s.removeAttribute(&quot;__passcard_column1&quot;); s.removeAttribute(&quot;__passcard_column2&quot;); } } } catch (AuthenticationException e) { s.setAttribute(&quot;__login_error&quot;, token.getErrCode()); throw e; } return auth; } public void setSuccessPage(String successPage) { this.successPage = successPage; } public void setFailurePage(String failurePage) { this.failurePage = failurePage; } public void setForward(boolean forward) { this.forward = forward; } public void setCertLoginUrl(String certLoginUrl) { this.certLoginUrl = certLoginUrl; } @Override public void afterPropertiesSet() { super.afterPropertiesSet(); /* *该处理器实现了AuthenticationSuccessHandler, AuthenticationFailureHandler *用于处理登录成功或者失败后，跳转的界面 */ AuthenticationResultHandler handler = new AuthenticationResultHandler(); handler.setForward(forward); handler.setLoginFailurePage(failurePage); handler.setLoginSuccessPage(successPage); handler.setCertLoginUrl(certLoginUrl); //设置父类中的处理器 this.setAuthenticationSuccessHandler(handler); this.setAuthenticationFailureHandler(handler); } } 代码实例 D:/ideaprojects/thz/thz-parent/thz-manager-web 自定义认证成功处理器 详解过滤链版 简单版 我们要自定义的类的被调用链：AbstractAuthenticationProcessingFilter.doFilter(调用自己的successfulAuthentication(调用AuthenticationSuccessHandler接口的onAuthenticationFailure())) 我们要做的就是自定义AuthenticationSuccessHandler实现类，重写onAuthenticationFailure()，来处理登录成功后要做的事情，比如保存用户到session、更新用户最近登录时间到数据库等。 import com.thz.pojo.User; import com.thz.service.UserService; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.security.core.Authentication; import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler; import org.springframework.security.web.authentication.WebAuthenticationDetails; import org.springframework.stereotype.Component; import javax.annotation.Resource; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Date; /** * @Author haien * @Description 自定义认证成功处理器 * 为什么不实现接口而是继承SavedRequestAwareAuthenticationSuccessHandler类， * 因为这个类记住了上次请求路径，如果你是请求其他页面被拦截到登录页的， * 这时候输入用户名和密码点击登录，还会自动跳转到该页面，而不是默认主页。 * @Date 2019/1/31 **/ @Component public class MyAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler { private static final Logger logger=LoggerFactory .getLogger(MyAuthenticationSuccessHandler.class); @Resource private UserService userService; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws ServletException, IOException { logger.info(&quot;----登录成功，username=&quot;+request.getParameter(&quot;username&quot;)+&quot;----&quot;); //获取当前用户 User user=(User)authentication.getPrincipal(); //获取authentication中的details中的remoteAddress WebAuthenticationDetails wauth=(WebAuthenticationDetails)authentication.getDetails(); user=userService.findUserByName(user.getUsername()); user.setLoginTime(new Date()); user.setLoginIp(wauth.getRemoteAddress()); //存入session request.getSession().setAttribute(&quot;user&quot;,user); //更新数据库 userService.updateUser(user); //执行父类重定向到原访问路径的方法 super.onAuthenticationSuccess(request,response,authentication); } } 自定义认证失败处理器 默认处理器就只能跳转登录失败页面，自定义的话可以将用户提交的用户名保存到request，带回登录页面。 @Component(&quot;ctwAuthenticationFailureHandler&quot;) public class CtwAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler{ private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private SecurityProperties securityProperties; @Override public void onAuthenticationFailure(HttpServletRequest request , HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { logger.info(&quot;登录失败！&quot;); //根据配置loginType是否是json而定返回形式，JSON返回json if (Objects.equals(securityProperties.getBrowser().getLoginType(), LoginType.JSON)) { response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.getWriter().write(JSON .toJSONString(new SimpleResponse(HttpStatus.INTERNAL_SERVER_ERROR.value() , exception.getMessage(), null))); } //REDIRECT跳转前面定义的页面：.failureUrl(&quot;/login.jsp?error=1&quot;) else { //存值带回 String username=request.getParameter(&quot;username&quot;); request.setAttribute(&quot;username&quot;,username); response.setContentType(&quot;text/html;charset=UTF-8&quot;); //设置登录失败后要重定向的url super.setDefaultFailureUrl(&quot;/login.jsp?error=1&amp;username=&quot;+username); //重定向，request丢失 super.onAuthenticationFailure(request, response, exception); /*不然就自己转发，request就不会丢失 request.getRequestDispatcher(&quot;/login?error=1&quot;) .forward(request, response);*/ } } } 或者能确定值返回json的话，直接往客户端写json字符串 @Component public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler { private static final Logger logger=LoggerFactory .getLogger(MyAuthenticationSuccessHandler.class); @Override public void onAuthenticationFailure(HttpServletRequest request , HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException { logger.info(&quot;----登录失败----&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;application/json&quot;); JSONObject result=new JSONObject(); result.put(&quot;message&quot;,&quot;用户名或密码错误&quot;); PrintWriter printWriter=null; String jsonString=&quot;&quot;; try { //必须捕获，不能抛出，因为要保证资源被关闭 printWriter=response.getWriter(); jsonString = JSONObject.toJSONString(result); printWriter.write(jsonString); printWriter.flush(); } catch (IOException e) { logger.error(&quot;Get response writer failed!&quot;,e); //不用再抛出，因为抛出了就要再生成一次报文，但既然getWrite都出错了生成的报文又怎么打印到前端呢 }finally { if(null!=printWriter) printWriter.close(); } } } 代码实例 thz-manager-web/config","categories":[],"tags":[]},{"title":"","slug":"Spring Security之Java Configuration方式","date":"2019-04-30T08:25:45.795Z","updated":"2019-02-14T03:39:04.917Z","comments":true,"path":"2019/04/30/Spring Security之Java Configuration方式/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring Security之Java Configuration方式/","excerpt":"","text":"java configuration方式 上面是以xml文件的方式配置，接下来介绍以自定义java类的方式来配置spring security 可先在719行：自定义过滤器一节了解认证流程。 1. 注册DelegatingFilterProxypackage com.study.config; import org.springframework.security.web.context.*; public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer { @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[] { WebSecurityConfig.class }; } } 继承该类相当于在web.xml中： &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; 重写getRootConfigClasses()相当于把下一步Spring Security的配置加载到程序中。 2. Spring Security安全配置package com.study.config; import javax.annotation.Resource; import org.springframework.context.annotation.Configuration; import org.springframework.security.authentication.encoding.Md5PasswordEncoder; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.web.access.intercept.FilterSecurityInterceptor; import org.springframework.security.web.util.matcher.AntPathRequestMatcher; import com.study.security.MyFilterSecurityInterceptor; @Configuration @EnableWebSecurity //启用web安全功能 public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // @Resource // private DataSource dataSource; //配置自定义的用户服务（即选择用户信息的查询方式是从用户库或数据库，怎么查询） @Resource(name=&quot;myUserDetailService&quot;) private UserDetailsService myUserDetailService; //第3点：自定义用户验证 @Resource private AuthenticationProvider myAuthenticationProvider; //自定义认证成功处理器 @Resource private AuthenticationSuccessHandler myAuthenticationSuccessHandler; //第4点：自定义拦截器（自定义权限验证,而不是拦截规则） @Resource private MyFilterSecurityInterceptor myFilterSecurityInterceptor; /** * 密码加密 */ @Bean public BCryptPasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } /** * 自定义认证过程 */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { /* 不重写的话默认为 auth .inMemoryAuthentication() .withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;); //默认准备了一个用户 */ //方式一：内存用户存储 /* auth.inMemoryAuthentication() .withUser(&quot;user1&quot;).password(&quot;123456&quot;).roles(&quot;USER&quot;).and() .withUser(&quot;admin&quot;).password(&quot;admin&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;); */ // //方式二：数据库表认证 /* auth.jdbcAuthentication().dataSource(dataSource) .usersByUsernameQuery(&quot;select username,password,enable from t_user where username=?&quot;) .authoritiesByUsernameQuery(&quot;select username,rolename from t_role where username=?&quot;); */ //方式三：自定义数据库 auth.userDetailsService(myUserDetailService) .passwordEncoder(new Md5PasswordEncoder()); //加后MyAuthenticationProvider里比对密码时能把表单的明文和数据库的密文对应 //自定义用户验证 auth.authenticationProvider(myAuthenticationProvider); } // 暴露默认的authenticationManager // @Override // public AuthenticationManager authenticationManagerBean() throws Exception { // return super.authenticationManagerBean(); // } /** * 配置Spring Security的Filter链 */ @Override public void configure(WebSecurity web)throws Exception { // 设置不拦截规则 web.ignoring().antMatchers(&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/img/**&quot;,&quot;/font-awesome/**&quot;); } /** * 配置如何通过拦截器保护请求：配置了自定义的过滤器、自定义登录登出页面 * 前端请求的时候先经过这里检测请求是否需要验证或权限，不需要的话直接把请求分发给controller去处理，需要就认证过了再分发 */ @Override protected void configure(HttpSecurity http) throws Exception { http .addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class)//在正确的位置添加我们自定义的过滤器 .authorizeRequests() //需要权限，权限符合与否由上面过滤器检查 .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) //以admin开头的url需要admin权限 .antMatchers(&quot;/db/**&quot;).access(&quot;hasRole(&apos;ADMIN&apos;) and hasRole(&apos;DBA&apos;)&quot;) .anyRequest().authenticated() //不与以上匹配的所有请求只需要登录验证 // .and().formLogin().and() //and相当于节点结束 // .httpBasic(); // 自定义登录页面：permitAll，允许all用户访问login页面 //未登录前访问受保护资源被转回login .and() /*直接/jsp/login的话会分配给controller去处理，则需要写controller映射到登录页；请求login.jsp报404 有后缀则直接请求资源，那么url=/login还是由controller处理； 那么最好是加后缀，才不用再走controller*/ .formLogin().loginPage(&quot;/jsp/login.jsp&quot;) .failureUrl(&quot;/jsp/login.jsp?error=1&quot;) //表单提交地址，4.x默认为/login；无需认证，但是请求方式必须post .loginProcessingUrl(&quot;/spring_security_check&quot;) .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .successHandler(myAuthenticationSuccessHandler) //自定义认证成功处理器 //.failureHandler(myAuthenticationFailureHandler) .permitAll() //这里也是，要么配资源路径，要么配有controller处理的url .defaultSuccessUrl(&quot;/index.do&quot;) .and() //配置session管理 .sessionManagement() /*指定了maximumSessions需配合web.xml中HttpSessionEventPublisher 清理掉过期session*/ .maximumSessions(1) .expiredUrl(&quot;/login.jsp?expired=1&quot;); //如果(默认)开启了CSRF，退出则需要使用POST访问，可使用以下方式解决，但不推荐 http.logout().logoutRequestMatcher(new AntPathRequestMatcher(&quot;/logout&quot;)) //登陆成功后跳转的地址，以及删除的cookie名称 .logoutSuccessUrl(&quot;/jsp/login.jsp?error=logout&quot;) .invalidateHttpSession(true); } } 接收到请求，先在spring security中是否有符合的（/login、/logout、/spring_security_check、/**/favicon.ico、…），出现Checking match of request : ‘/login’; against ‘/logout’或Request ‘GET /login’ doesn’t match ‘POST /spring_security_check都表示当前请求与已存在url不匹配，后者指明spring_security_check必须是post形式的，若不匹配，则检测用户是否已认证，未认证，后台报AccessDenyException，前端转回login页面，已认证，分发给controller处理。所以用户请求的资源是他不能访问的就会报AccessDenyException。 未登录时用户为匿名用户 登录后若未给用户设置权限，则用户为无权限 所以给请求设置权限，如果没有指定权限，则至少不能是匿名用户 大致相当于配置 &lt;!-- 获取访问url对应的所有权限 --&gt; &lt;beans:bean id=&quot;secureResourceFilterInvocationDefinitionSource&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecureResourceFilterInvocationDefinitionSource&quot; /&gt; &lt;!-- 校验用户的权限是否足够 --&gt; &lt;beans:bean id=&quot;mesecurityAccessDecisionManager&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecurityAccessDecisionManager&quot; /&gt; &lt;!-- 自定义权限认证 --&gt; &lt;beans:bean id=&quot;securityInterceptor&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecurityInterceptor&quot;&gt; &lt;beans:property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot;/&gt; &lt;beans:property name=&quot;accessDecisionManager&quot; ref=&quot;mesecurityAccessDecisionManager&quot;/&gt; &lt;beans:property name=&quot;securityMetadataSource&quot; ref=&quot;secureResourceFilterInvocationDefinitionSource&quot; /&gt; &lt;/beans:bean&gt; &lt;!-- 用户服务 --&gt; &lt;beans:bean id=&quot;myUserDetailsService&quot; class=&quot;com.ultrapower.me.util.security.support.myUserDetailsService&quot;&gt;&lt;/beans:bean&gt; &lt;!-- 自定义用户验证--&gt; &lt;beans:bean id=&quot;myAuthenticationProvider&quot; class=&quot;com.security.MyAuthenticationProvider&quot;&gt; &lt;beans:property name=&quot;userDetailsService&quot; ref=&quot;myUserDetailsService&quot; /&gt; &lt;/beans:bean&gt; &lt;!-- 1、自定义权限认证:依赖上面的bean --&gt; &lt;http auto-config=&quot;true&quot; use-expressions=&quot;false&quot;&gt; &lt;intercept-url pattern=&quot;/login.jsp*&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;ROLE_USER&quot;/&gt; &lt;form-login login-page=&quot;/login.jsp&quot; default-target-url=&quot;/jsp/index/main.jsp&quot; authentication-failure-url=&quot;/login.jsp?error=true&quot;/&gt; &lt;custom-filter before=&quot;FILTER_SECURITY_INTERCEPTOR&quot; ref=&quot;securityInterceptor&quot;/&gt; &lt;/http&gt; &lt;!-- 2、自定义用户验证：依赖上面的bean--&gt; &lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; //起别名，方便被下面自定义拦截器依赖 &lt;!--自定义用户验证--&gt; &lt;authentication-provider ref=&quot;myAuthenticationProvider&quot; /&gt; &lt;!--只自定义用户服务而不需要自定义用户验证的话 &lt;authentication-provider user-service-ref=&quot;myUserDetailsService&quot;&gt;--&gt; &lt;password-encoder ref=&quot;myPasswordEncoder&quot;/&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; 一些自定义方式 简单的自定义登录页面对比 protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .and() .httpBasic(); } 相当于 &lt;http&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;authenticated&quot;/&gt; &lt;form-login /&gt; &lt;http-basic /&gt; &lt;/http&gt; 自定义权限 protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() //需要权限 .antMatchers(&quot;/resources/**&quot;, &quot;/signup&quot;, &quot;/about&quot;).permitAll() .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) //使用hasRole()可以不写ROLE_前缀，但实际上我们指定的权限还是ROLE_ADMIN .antMatchers(&quot;/db/**&quot;).access(&quot;hasRole(&apos;ADMIN&apos;) and hasRole(&apos;DBA&apos;)&quot;) /*按照顺序匹配，下面是对的*/ //.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) //.antMatchers(&quot;/**&quot;).hasRole(&quot;USER&quot;) /*下面是错的，因为满足第一个规则后将不会检查第二条，所以要从精确到广泛配置*/ //.antMatchers(&quot;/**&quot;).hasRole(&quot;USER&quot;) //.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) .anyRequest().authenticated() //需要验证 .and() // ... .formLogin(); } 自定义登出页面 protected void configure(HttpSecurity http) throws Exception { http .logout() .logoutUrl(&quot;/my/logout&quot;) .logoutSuccessUrl(&quot;/my/index&quot;) .logoutSuccessHandler(logoutSuccessHandler) //自定义登出成功后的操作，上一行失效 .invalidateHttpSession(true) //添加一个自定义登出处理器，SecurityContextLogoutHandler默认是最后一个处理器 .addLogoutHandler(logoutHandler) .deleteCookies(cookieNamesToClear) .and() ... } 一般前面两步都是直接用配置文件实现，然后注入自定义UserDetailServiceImpl，也就这个要用java写而已 自定义用户服务 如果是要用数据库的话那肯定是要的，首先是用户实体类UserDetails必须改为符合数据库的字段，默认的也就用户名、密码加权限列表了，其次获取用户信息UserDetialsService的方式也要改成从数据库获取. 首先是UserDetailsService，主要是根据用户名从数据库找出用户all信息，主要是用户名、密码和权限列表 package com.study.security; import java.util.HashSet; import java.util.List; import java.util.Set; import javax.annotation.Resource; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Component; import com.study.model.Resources; import com.study.model.User; import com.study.service.ResourcesService; import com.study.service.UserService; @Component(&quot;myUserDetailService&quot;) public class MyUserDetailServiceImpl implements UserDetailsService{ //这里可以来个日志 @Resource private UserService userService; @Resource private ResourcesService resourcesService; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //通过用户名查询用户信息 User user = userService.findUserByName(username); //系统实体类User implement UsersService,系统service类userService if(user ==null) throw new UsernameNotFoundException(username+&quot; not exist!&quot;); //存放角色名的集合 Set&lt;GrantedAuthority&gt; authSet = new HashSet&lt;GrantedAuthority&gt;(); //系统实体类Resources，即各个url Resources resources = new Resources(); resources.setUsername(username); //找到特定用户名能访问的url集合 List&lt;Resources&gt; list = resourcesService.loadMenu(resources); for (Resources r : list) { //根据资源找到角色名，添加到角色名集合 authSet.add(new SimpleGrantedAuthority(&quot;ROLE_&quot; +r.getResKey())); //resKey:资源名，拼成角色名 } /* username()：登录用户名 password()：从数据库查出来的密码 enable: 用户状态，true为有效，false无效 accoutNonExpired,credentialsNonExpired,accountNonLocked roles: Collections集合，当前登录用户的角色列表 */ return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), user.getEnable()==1?true:false, true, true, true, authSet); //返回的user不为空，则验证通过 } } 系统实体类User实现UserDetails，主要是查询数据库所有权限，返回权限列表 public class User implements UserDetails { private static final long serialVersionUID = 8026813053768023527L; private String name; private String password; private Set&lt;Role&gt; roles; //可以不写 //其他属性，随便，自定义 /** * 返回系统所有角色 */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { //根据自定义逻辑来返回用户权限，如果用户权限返回空或者和拦截路径对应权限不同，验证不通过 if(!roles.isEmpty()){ List&lt;GrantedAuthority&gt; list = new ArrayList&lt;GrantedAuthority&gt;(); GrantedAuthority au = new SimpleGrantedAuthority(role.getrName()); list.add(au); return list; } return null; } /** * 默认有一个方法返回当前用户的角色列表，后面介绍了它的重写；可选的 */ @Override public String getPassword() { return this.password; } @Override public String getUsername() { return this.username; } /* *帐号是否不过期，false则验证不通过 */ @Override public boolean isAccountNonExpired() { return true; } /* * 帐号是否不锁定，false则验证不通过 */ @Override public boolean isAccountNonLocked() { return true; } /* * 凭证是否不过期，false则验证不通过 */ @Override public boolean isCredentialsNonExpired() { return true; } /* * 该帐号是否启用，false则验证不通过 */ @Override public boolean isEnabled() { return true; } } User类代码实例：llcweb/domain/models/ 数据库表介绍：五张表————用户表、角色表、资源表、用户角色表、角色资源表。给用户分配角色，给角色分配资源（即权限）。一个用户可以对应多个角色，一个角色可以对应多个资源。 其中资源表t_resources包含了后台系统的所有url resKey即角色名 自定义过滤器 首先整理spring security的步骤： 在spring security中每一个url都是一个资源，系统启动时，spring security第一个拦截器FilterSecurityInterceptor调用SecurityMetadataSource将所有url与其权限对应。 当用户发起请求时，spring security检查该请求是否需要特定权限（需不需要都在WebSecurityConfigurerAdapter中指定了），不需要的话直接访问，连是否登录都不验证。 需要权限，AbstractAuthenticationProcessingFilter先验证当前用户是否已登录，否则跳转登录页面。 已登录，FilterSecurityInterceptor判断该用户是否拥有当前请求所需的权限，有则允许访问，没有则给出提示信息。 我们这一节说的过滤器特指这个FilterSecurityInterceptor。基于数据库的权限验证必须要自定义过滤器，因为它主要就是做权限验证的，包括资源与权限对应关系的查询、当前用户是否持有请求资源所需权限的判断。 前面不是用java注册spring security的话就需要以下配置 &lt;!--还要在http中添加&lt;custom-filter before=&quot;FILTER_SECURITY_INTERCEPTOR&quot; ref=&quot;securityInterceptor&quot;/&gt;--&gt; &lt;!--ProviderManager类的实例注入authenticationManager--&gt; &lt;authentication-manager alias=&quot;authenticationManager&quot;&gt; &lt;!-- 获取访问url对应的所有权限 --&gt; &lt;beans:bean id=&quot;secureResourceFilterInvocationDefinitionSource&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecureResourceFilterInvocationDefinitionSource&quot; /&gt; &lt;!-- 校验用户的权限是否足够 --&gt; &lt;beans:bean id=&quot;mesecurityAccessDecisionManager&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecurityAccessDecisionManager&quot; /&gt; &lt;!-- 自定义拦截器:依赖上面的bean --&gt; &lt;beans:bean id=&quot;securityInterceptor&quot; class=&quot;com.ultrapower.me.util.security.interceptor.SecurityInterceptor&quot;&gt; &lt;beans:property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot;/&gt; &lt;beans:property name=&quot;accessDecisionManager&quot; ref=&quot;mesecurityAccessDecisionManager&quot;/&gt; &lt;beans:property name=&quot;securityMetadataSource&quot; ref=&quot;secureResourceFilterInvocationDefinitionSource&quot; /&gt; &lt;/beans:bean&gt; 开始自定义过滤器 package com.study.security; import java.io.IOException; import javax.annotation.PostConstruct; import javax.annotation.Resource; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.access.SecurityMetadataSource; import org.springframework.security.access.intercept.AbstractSecurityInterceptor; import org.springframework.security.access.intercept.InterceptorStatusToken; import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration; import org.springframework.security.web.FilterInvocation; import org.springframework.stereotype.Component; @Component public class MyFilterSecurityInterceptor extends AbstractSecurityInterceptor implements Filter { //所有资源与权限的关系（需要在外面自定义）：获取请求资源的权限 @Autowired private MySecurityMetadataSource securityMetadataSource; //用户是否拥有所请求资源的权限（需要在外面自定义）：判断是否拥有请求资源所需的权限 @Autowired private MyAccessDecisionManager accessDecisionManager; /* 默认装配够用了 @Resource(name=&quot;myAuthenticationManager&quot;) private AuthenticationManager authenticationManager; */ @Resource private AuthenticationConfiguration authenticationConfiguration; // @Autowired // public void setAuthenticationConfiguration(AuthenticationConfiguration authenticationConfiguration) { // this.authenticationConfiguration = authenticationConfiguration; // } @PostConstruct public void init() throws Exception{ super.setAccessDecisionManager(accessDecisionManager); super.setAuthenticationManager(authenticationConfiguration.getAuthenticationManager()); } @Override public SecurityMetadataSource obtainSecurityMetadataSource() { return this.securityMetadataSource; } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { FilterInvocation fi = new FilterInvocation(request, response, chain); /*beforeInvocation做的事*/ //super.beforeInvocation(fi);源码 //获取请求资源的权限 //执行Collection&lt;ConfigAttribute&gt; attributes = SecurityMetadataSource.getAttributes(object); //object为FilterInvocation对象 //是否拥有权限；authentication：封装了用户拥有的权限 //this.accessDecisionManager.decide(authenticated, object, attributes); InterceptorStatusToken token = super.beforeInvocation(fi); try { //执行下一个拦截器 fi.getChain().doFilter(fi.getRequest(), fi.getResponse()); } finally { super.afterInvocation(token, null); } } @Override public void init(FilterConfig arg0) throws ServletException { } @Override public void destroy() { } @Override public Class&lt;? extends Object&gt; getSecureObjectClass() { //下面的MyAccessDecisionManager的supports方法必须返回true,否则会提醒类型错误 return FilterInvocation.class; } } 自定义过滤器需要用到的用户是否拥有所请求资源的权限：MyAccessDecisionManager。默认使用AbstractAccessDecisionManager，具体是继承了AbstractAccessDecisionManager的AffirmativeBased，还有其他其他的决策管理器，不过不知道怎么启用，只是投票方式不同而已，有的是只要有赞成票就通过权限验证，有的是只要有反对票就不通过。但是看不懂底层是根据什么投赞成票和反对票的，反正不通过就抛AccessDenyException，一层层向上抛出，由ExceptionTranslationFilter打印异常日志。 package com.study.security; import java.util.Collection; import java.util.Iterator; import org.springframework.security.access.AccessDecisionManager; import org.springframework.security.access.AccessDeniedException; import org.springframework.security.access.ConfigAttribute; import org.springframework.security.authentication.InsufficientAuthenticationException; import org.springframework.security.core.Authentication; import org.springframework.security.core.GrantedAuthority; import org.springframework.stereotype.Component; @Component public class MyAccessDecisionManager implements AccessDecisionManager { /** * 决定authentication拥有的权限中有没有指定资源的权限 * object：受保护对象，其可以是一个MethodInvocation、JoinPoint或FilterInvocation * authentication：封装了用户拥有的权限 * configAttributes：受保护对象的相关配置属性，主要是访问资源需要的权限 */ public void decide(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes) throws AccessDeniedException, InsufficientAuthenticationException { if(configAttributes == null) { return; } //所请求的资源需要的权限(一个资源对多个权限) Iterator&lt;ConfigAttribute&gt; iterator = configAttributes.iterator(); while(iterator.hasNext()) { ConfigAttribute configAttribute = iterator.next(); //访问所请求资源所需要的权限 String Permission = configAttribute.getAttribute(); System.out.println(&quot;needPermission is &quot; + Permission); //用户所拥有的权限authentication for(GrantedAuthority ga : authentication.getAuthorities()) { if(Permission.equals(ga.getAuthority())) { return; } } } //没有权限，后台抛异常而前端显示access-denied-page页面 throw new AccessDeniedException(&quot; 没有权限访问或未重新登录！ &quot;); } /** * 判断AccessDecisionManager是否能够处理对应的ConfigAttribute */ public boolean supports(ConfigAttribute attribute) { // TODO Auto-generated method stub return true; } /** * 判断AccessDecisionManager是否支持对应的受保护对象类型 */ public boolean supports(Class&lt;?&gt; clazz) { // TODO Auto-generated method stub return true; } } 自定义过滤器需要用到的获取资源权限（即查询t_resources表中所有resKey与resUrl的关系）：MySecurityMetadataSource package com.study.security; import java.util.ArrayList; import java.util.Collection; import java.util.HashMap; import java.util.List; import java.util.Map; import javax.annotation.PostConstruct; import javax.annotation.Resource; import org.springframework.security.access.ConfigAttribute; import org.springframework.security.access.SecurityConfig; import org.springframework.security.web.FilterInvocation; import org.springframework.security.web.access.intercept.FilterInvocationSecurityMetadataSource; import org.springframework.stereotype.Component; import com.study.dao.ResourcesDao; import com.study.model.Resources; @Component public class MySecurityMetadataSource implements FilterInvocationSecurityMetadataSource { @Resource private ResourcesDao resourcesDao; private static Map&lt;String, Collection&lt;ConfigAttribute&gt;&gt; resourceMap = null; public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { return null; } public boolean supports(Class&lt;?&gt; clazz) { return true; } /** * @PostConstruct是Java EE 5引入的注解， * Spring允许开发者在受管Bean中使用它。当DI容器实例化当前受管Bean时， * @PostConstruct注解的方法会被自动触发，从而完成一些初始化工作 */ @PostConstruct private void loadResourceDefine() { //加载所有资源与权限的关系 if (resourceMap == null) { resourceMap = new HashMap&lt;String, Collection&lt;ConfigAttribute&gt;&gt;(); //数据库查询所有资源 List&lt;Resources&gt; list = resourcesDao.queryAll(new Resources()); //Resources:本项目自定义的实体 for (Resources resources : list) { Collection&lt;ConfigAttribute&gt; configAttributes = new ArrayList&lt;ConfigAttribute&gt;(); // 通过资源名称来表示具体的权限 注意：必须&quot;ROLE_&quot;开头 /*SecurityConfig：ConfigAttribute实现类； 只有一个成员，是个常量，构造函数传入string赋予此常量， configAttribute.getAttribute()返回此常量*/ ConfigAttribute configAttribute = new SecurityConfig(&quot;ROLE_&quot; + resources.getResKey()); configAttributes.add(configAttribute); resourceMap.put(resources.getResUrl(), configAttributes); } } } //返回所请求资源所需要的权限 public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException { //从过滤链中获取当前请求 String requestUrl = ((FilterInvocation) object).getRequestUrl(); //如果资源角色库为空的话说明还未初始化 if(resourceMap == null) { loadResourceDefine(); //强制初始化 } //System.err.println(&quot;resourceMap.get(requestUrl); &quot;+resourceMap.get(requestUrl)); //如果是get请求的话去掉后面参数 if(requestUrl.indexOf(&quot;?&quot;)&gt;-1){ requestUrl=requestUrl.substring(0,requestUrl.indexOf(&quot;?&quot;)); } //获取该请求对应权限，url作为key Collection&lt;ConfigAttribute&gt; configAttributes = resourceMap.get(requestUrl); return configAttributes; } } ExceptionTranslationFilter处理AuthenticationException和AccessDeniedException两种异常。 private void handleSpringSecurityException(HttpServletRequest request, HttpServletResponse response, FilterChain chain, RuntimeException exception) throws IOException, ServletException { //如果异常是AuthenticationException（未登录即访问受保护资源） if (exception instanceof AuthenticationException) { //打印异常 this.logger.debug(&quot;Authentication exception occurred; redirecting to authentication entry point&quot;, exception); /*传入此方法后主要是调用AuthenticationEntryPoint的默认实现类 LoginUrlAuthenticationEntryPoint中的commence方法重定向到登录页*/ this.sendStartAuthentication(request, response, chain, (AuthenticationException)exception); /* sendStartAuthentication源码 protected void sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, AuthenticationException reason) throws ServletException, IOException { SecurityContextHolder.getContext().setAuthentication((Authentication)null); this.requestCache.saveRequest(request, response); this.logger.debug(&quot;Calling Authentication entry point.&quot;); this.authenticationEntryPoint.commence(request, response, reason); } */ } //如果是AccessDeniedException else if (exception instanceof AccessDeniedException) { //且是匿名用户(未登录即访问受保护资源;一般是该异常，少为AuthenticationException) if (this.authenticationTrustResolver.isAnonymous(SecurityContextHolder .getContext().getAuthentication())) { this.logger.debug(&quot;Access is denied (user is anonymous); redirecting to authentication entry point&quot;, exception); //重定向到登录页，且把AccessDeniedException包装成AuthenticationException this.sendStartAuthentication(request, response, chain, new InsufficientAuthenticationException(&quot;Full authentication is required to access this resource&quot;)); } //非匿名用户（已登录但权限不足） else { this.logger.debug(&quot;Access is denied (user is not anonymous); delegating to AccessDeniedHandler&quot;, exception); //重定向到403页面；AccessDeniedHandler默认实现类：AccessDeniedHandlerImpl this.accessDeniedHandler.handle(request, response ,(AccessDeniedException)exception); } } } 参考文章 SSM整合SpringSecurity实现权限管理实例 javaconfig配置方式:做到了完全不用web.xml等任何配置文件，连bean的装载都全靠java类和注解完成。 spring官方手册（从第6点看起） 在springboot中整合spring security并自定义验证代码 SpringMVC + security模块 框架整合详解 SpringSecurity——基于Spring、SpringMVC和MyBatis自定义SpringSecurity权限认证规则 自定义过滤器中有关AccessDecisionManager决策管理器的部分 有关ExceptionTranslationFilter代码实例 thz-manager-web/config","categories":[],"tags":[]},{"title":"","slug":"Spring Security全局方法安全注解","date":"2019-04-30T08:25:45.781Z","updated":"2019-02-15T04:12:34.899Z","comments":true,"path":"2019/04/30/Spring Security全局方法安全注解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring Security全局方法安全注解/","excerpt":"","text":"@EnableGlobalMethodSecurity 在方法上增加Spring Security注解，主要是为了判断当前用户是否有资格执行该方法，如是否拥有某权限、是否为当前登录用户。 spring security默认禁用注解，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为bean。 提供了三种注解。JSR-250注解 @DenyAll:拒绝所有访问。 @RolesAllowed({“USER”,”ADMIN”})：该方法只要具有USER、ADMIN任意一种权限即可访问。这里省略前缀ROLE_，实际权限可能是ROLE_ADMIN。 @PermitAll:允许所有访问。prePostEnable注解 开启此注解方法：@EnableGlobalMethodSecurity(prePostEnabled = true) @PreAuthorize：在方法执行前判断，可以调用方法参数，主要利用Java8的参数名反射特性，如果没用Java8也可以使用spring security的@P标注参数，或者Spring Data的@Param标注参数。 //判断用户是否为当前登录用户或拥有ROLE_ADMIN权限 @PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;) public void changePassword(@P(&quot;userId&quot;) long userId ){} @PostAuthorize：在方法执行后判断，可以调用参数。如果EL为false，虽然方法已经执行完了也可能会回滚，EL变量returnObject表示返回的对象。 @PostAuthorize User getUser(&quot;returnObject.userId == authentication.principal.userId or hasPermission(returnObject, &apos;ADMIN&apos;)&quot;); @PreFilter:在方法执行前判断，可以调用方法参数，对参数值进行过滤、处理或修改。EL变量filterObject表示参数，如有多个参数则用filterTarget注解参数，那么参数必须是集合或数组才行（很少用到，与分页技术不兼容）。securedEnable注解 @Secured:是否有权限访问 @Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;) public Account readAccount(Long id); @Secured(&quot;ROLE_TELLER&quot;)","categories":[],"tags":[]},{"title":"","slug":"Spring Security","date":"2019-04-30T08:25:45.775Z","updated":"2019-02-28T01:29:43.592Z","comments":true,"path":"2019/04/30/Spring Security/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring Security/","excerpt":"","text":"简介 基于Spring的应用程序提供声明式安全保护的安全性框架，提供了完整的安全性解决方案，能够在web请求级别和方法调用级别处理身份验证和授权，充分使用了依赖注入和面向切面的技术。 主要从两个方面解决安全性问题 web请求级别：使用servlet过滤器保护web请求并限制url的访问 方法调用级别：使用Spring AOP保护方法调用，确保具有适当权限的用户才能访问 总结：访问url时首先判断是否登录，其次用户是否具有权限访问。SpringMvc整合Spring Security pom.xml添加依赖 &lt;!--版本管理，只需管理这个依赖即可使所有spring security的依赖版本统一--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-bom&lt;/artifactId&gt; &lt;version&gt;5.2.0.BUILD-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--最少的版本--&gt; &lt;dependencies&gt; &lt;!--过滤器：身份验证与url接入控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--包含命名空间，springMVC整合时需要在配置文件中配置spring security，所以这个必须要--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;!--版本是n.n则命名空间也得一样--&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 还有一个单点登录，有时也需要 &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-cas&lt;/artifactId&gt; &lt;/dependency&gt; 整合方法： 配置文件实现：在配置文件中指定拦截的url、所需权限、配置userDetailsService指定用户名密码对应权限即可 Java Configuration：以下可以只选一个部分来用java实现，其他可由配置文件代替，毕竟不是所有的模块都需要自定义。 实现UserDetailsService，重写loadUserByUsername(String userName)，根据username来实现自己的业务逻辑，返回UserDetails的实现类，还需要自定义实体类User implement UserDetails（顺便作为系统的用户类使用了），主要重写getAuthorities()返回该用户所拥有的权限 自定义filter重写Spring Security拦截器，实现动态过滤用户权限 自定义filter重写Spring Security拦截器，实现自定义参数来检验用户，并且过滤权限配置文件实现 web.xml中声明代理servlet过滤器。原本的实现是配置一系列相关的，使得配置文件臃肿难以阅读，而Spring security提供的代理servlet过滤器功能可以解决该问题。 &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.DelegatingFilterProxy &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 其中，DelegatingFilterProxy是一个代理的servlet过滤器，它主要负责将工作委托给javax.servlet.Filter实现类，这个实现类作为一个已经注册在Spring上下文中，其id便是上面的名字。也即它会自动到Spring容器查找名为filter-name的bean并把所有Filter的操作委托给它，所以如果不是默认注入到Spring容器的bean，就需要手动注入。 applicationContext.xml中配置拦截请求 //添加命名空间 xmlns:sec=&quot;http://www.springframework.org/schema/security&quot; xsi:http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-4.0.xsd&quot; //对应版本是5.2.xsd才对 &lt;!-- 配置为none的不经过任何spring的过滤器，主要是静态资源，我们不需要经过过滤器 --&gt; &lt;http pattern=&quot;/resources/**&quot; security=&quot;none&quot; /&gt; &lt;http pattern=&quot;/sitemap.xml&quot; security=&quot;none&quot; /&gt; &lt;http pattern=&quot;/favicon.ico&quot; security=&quot;none&quot; /&gt; &lt;!--或者--&gt; &lt;security:http use-expressions=&quot;true&quot;&gt; &lt;!-- 顺序不能乱 ，按照从上往下依次过滤 --&gt; &lt;security:intercept-url pattern=&quot;/ps_service/index.jsp&quot; access=&quot;permitAll&quot;/&gt; &lt;security:intercept-url pattern=&quot;/ps_service/login.do&quot; access=&quot;permitAll&quot;/&gt; &lt;security:intercept-url pattern=&quot;/ps_service/loginfailed.do&quot; access=&quot;permitAll&quot;/&gt; &lt;security:intercept-url pattern=&quot;/cs/404.html&quot; access=&quot;permitAll&quot;/&gt; &lt;!--过滤浏览器自动发起的链接--&gt; &lt;security:intercept-url pattern=&quot;/favicon.ico&quot;access=&quot;permitAll&quot;/&gt; &lt;/security:http&gt; &lt;!-- auto-config: true自动加载，自动生成一个默认登陆页面，url:localhost:8080/project/login； 如果不使用该属性 则默认为http-basic(没有session).；一般都是true了 lowercase-comparisons：表示URL比较前先转为小写。 path-type：表示使用Apache Ant的匹配模式。 access-denied-page：访问拒绝时转向的页面。 access-decision-manager-ref：指定了自定义的访问策略管理器。当系统角色名的前缀不是默认的ROLE_时，需要自定义访问策略管理器。 --&gt; &lt;sec:http auto-config=&quot;true&quot; servlet-api-provision=&quot;false&quot; lowercase-comparisons=&quot;false&quot; access-denied-page=&quot;/html/error_page_access_denied.html&quot; path-type=&quot;ant&quot; access-decision-manager-ref=&quot;accessDecisionManager&quot;&gt; &lt;!-- login-page：指定登录页面。 login-processing-url：指定了客户在登录页面中按下 Sign In 按钮时要访问的 URL。与登录页面form的action一致。其默认值为：/j_spring_security_check。 authentication-failure-url：登录的用户没有指定权限时跳转到的页面；指定权限在第120行 default-target-url：登录成功呈现给用户的页面。 always-use-default-target：指定了是否在身份验证通过后总是跳转到default-target-url属性指定的URL。 --&gt; &lt;sec:form-login login-page=&quot;/admin/page!login.action&quot; login-processing-url=&quot;/admin/login&quot; default-target-url=&quot;/admin/page!main.action&quot; authentication-failure-url=&quot;/admin/page!login.action&quot; authentication-success-handler-ref=&quot;myAuthenticationSuccessHandler&quot; always-use-default-target=&quot;true&quot; /&gt; &lt;!-- &quot;记住我&quot;功能，采用持久化策略（将用户的登录信息存放在数据库表中） --&gt; &lt;sec:remember-me data-source-ref=&quot;dataSource&quot; key=&quot;e37f8888-0ooo-22dd-bd0b-9900211c9a66&quot; /&gt; &lt;!-- logout-url：指定了用于响应退出系统请求的URL，即注销页面。其默认值为：/j_spring_security_logout。下例与与 &lt;a href=&quot;&lt;c:url value=&quot;/admin/logout&quot; /&gt;&quot;&gt;注销&lt;/a&gt; 配合使用 logout-success-url：退出系统后转向的URL，即注销成功后跳转到的页面。 invalidate-session：指定在退出系统时是否要销毁Session。 --&gt; &lt;sec:logout invalidate-session=&quot;true&quot; logout-success-url=&quot;/admin/page!login.action&quot; logout-url=&quot;/admin/logout&quot; /&gt; &lt;!-- max-sessions:允许用户帐号登录的次数。范例限制用户只能登录一次。 exception-if-maximum-exceeded: 默认为false，此值表示：用户第二次登录时，前一次的登录信息都被清空。 当exception-if-maximum-exceeded=&quot;true&quot;时系统会拒绝第二次登录。 --&gt; &lt;sec:concurrent-session-control max-sessions=&quot;1&quot; exception-if-maximum-exceeded=&quot;false&quot; /&gt; &lt;!-- 后台登录 --&gt; &lt;!--intercept-url:拦截器,可以设定哪些路径需要哪些权限来访问. filters=none 不使用过滤,也可以理解为忽略--&gt; &lt;sec:intercept-url pattern=&quot;/admin/page!login.action&quot; filters=&quot;none&quot; /&gt; &lt;!-- 商品管理 --&gt; &lt;!--限制具有ROLE_GOODS权限的用户才能访问 （4.0后版本只能用hasRole(&quot;ROLE_GOODS&quot;)--&gt; &lt;sec:intercept-url pattern=&quot;/admin/goods!**&quot; access=&quot;ROLE_GOODS&quot; /&gt; &lt;!-- 基础管理权限 --&gt; &lt;!--拦截/admin下的所有请求--&gt; &lt;sec:intercept-url pattern=&quot;/admin/**&quot; access=&quot;ROLE_BASE&quot; /&gt; &lt;/sec:http&gt; &lt;sec:http auto-config=&quot;true&quot; use-expressions=&quot;true&quot;&gt; &lt;!-- 配置为permitAll允许所有已登录或者未登录用户访问，但依然经过过滤器处理。除此之外所有的页面都需要登录访问 --&gt; &lt;sec:intercept-url pattern=&quot;/&quot; access=&quot;permitAll&quot; /&gt; &lt;sec:intercept-url pattern=&quot;/index*&quot; access=&quot;permitAll&quot; /&gt; &lt;sec:intercept-url pattern=&quot;/signin*&quot; access=&quot;permitAll&quot; /&gt; &lt;sec:intercept-url pattern=&quot;/login*&quot; access=&quot;permitAll&quot; /&gt; &lt;sec:intercept-url pattern=&quot;/register*&quot; access=&quot;permitAll&quot; /&gt; &lt;sec:intercept-url pattern=&quot;/invalidsession*&quot; access=&quot;permitAll&quot; /&gt; &lt;sec:intercept-url pattern=&quot;/404*&quot; access=&quot;none&quot; /&gt; &lt;sec:access-denied-handler error-page=&quot;/403&quot; /&gt; &lt;!-- 关闭跨域请求,默认开启，最好关闭 --&gt; &lt;security:csrf disabled=&quot;true&quot;/&gt; &lt;/sec:http&gt; &lt;!--角色继承--&gt; &lt;bean id=&quot;roleHierarchy&quot; class=&quot;org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl&quot;&gt; &lt;property name=&quot;hierarchy&quot;&gt;&lt;!-- 角色继承关系 --&gt; &lt;value&gt; ROLE_ADMIN &gt; ROLE_USER //ADMIN继承USER的所有权限，后者能访问的资源它也可以 ROLE_A &gt; ROLE_B ROLE_B &gt; ROLE_C ROLE_C &gt; ROLE_D &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; http元素将创建一个FilterChainProxy以及链中的所有过滤器的bean，同时会将FilterChainProxy的bean托管给配置在web.xml中的DelegatingFilterProxy。 登录验证 auto-config=”true”自动加载的同时生成默认登录页面，相当于如下配置： &lt;http&gt; &lt;form-login/&gt; &lt;!--HTTP 基本认证 --&gt; &lt;http-basic/&gt; &lt;!-- 可以通过logout-url属性设置用户退出的url--&gt; &lt;logout /&gt; &lt;intercept pattern=&quot;/**&quot; access=&quot;ROLE_DEMO&quot; /&gt; &lt;/http&gt; 登录请求提交地址还是登录页面的地址，但是过滤器（不管是否自定义）会把参数获取过去验证。 一个简单的例子 &lt;!--过滤器,拦截/admin下的所有请求，限制具有admin权限的用户才能访问--&gt; &lt;sec:http auto-config=&quot;true&quot;&gt; &lt;!--true则自动生成一个登陆页面，url:localhost:8080/project/login--&gt; &lt;sec:intercept-url pattern=&quot;/**&quot; access=&quot;authenticated&quot; /&gt; &lt;!--访问任何页面都跳转登录界面--&gt; &lt;/sec:http&gt; &lt;!-- 安全认证管理，先写个简单的后面再改--&gt; &lt;sec:authentication-manager&gt; &lt;sec:authentication-provider&gt; &lt;sec:user-service&gt; &lt;!--设置用户库中的用户；用此用户登录才能成功--&gt; &lt;sec:user name=&quot;admin&quot; password=&quot;123456&quot; authorities=&quot;ROLE_USER&quot;/&gt; &lt;/sec:user-service&gt; &lt;/sec:authentication-provider&gt; &lt;/sec:authentication-manager&gt; 登录页面 登录失败转回登录页面 登录成功则进入原本要访问的页面或默认主页 虽然设置auto-config=”true”可以自动生成登录页面，但是一般都是使用自定义的登录页面 &lt;http auto-config=&quot;true&quot;&gt; &lt;!-- 设置登录页配置 login-page指定了登录界面的视图，authentication-failure-url则设置失败后的重定向到相同的登录页面--&gt; &lt;from-login login-processing-url=&quot;/static/j_spring_security_check&quot; login-page=&quot;/login&quot; authentication-failure-url=&quot;/login?login_error=t&quot; username-parameter=&quot;sescs_username&quot; password-parameter=&quot;sescs_password&quot;&gt; &lt;/http&gt; 在自定义的登录页面中将表单提交地址定为“/static/j_spring_security_check”（3.x默认路径，而4.x则是/login），未定义username和password参数名的话将用户名和密码输入框的name分别设置为j_username和j_password。（4.x已定义为username、password） 自定义时应设表单提交路径与登录页面路径不同，应为相同的话万一前面配置了不拦截对登录页面的请求，那就相当于也不拦截白哦单提交请求了，那还怎么获取表单来验证。 实现记住密码功能 &lt;!--key设置cookie的秘钥的值，默认是SpringSecured。后一个属性指定有效期 --&gt; &lt;remember-me key=&quot;spitterKey&quot; token-validity-seconds=&quot;2419200&quot;/&gt; 则前端页面相应要有记住密码勾选框 &lt;input name=&quot;_spring_security_rember_me&quot; type=&quot;checkbox&quot;/&gt; 强制使用https:保证每次对指定url请求都会自动重定向为https请求，不管用户访问时是否加入https &lt;intercept pattern=&quot;/admin/**&quot; access=&quot;ROLE_DEMO&quot; requires-channel=&quot;https&quot; /&gt; form-login属性详解 使用SpEL&lt;!--use-expressions=&quot;true&quot;:声明使用表达式--&gt; &lt;http auto-config=&quot;true&quot; use-expressions=&quot;true&quot;&gt; &lt;!--需要ROLE_ADMIN权限才能访问--&gt; &lt;intercept-url pattern=&quot;/admin/**&quot; access=&quot;hasRole(&apos;ROLE_ADMIN&apos;)&quot;&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasAnyRole(&apos;ROLE_ADMIN&apos;,&apos;ROLE_USER&apos;)&quot; /&gt; &lt;/http&gt; 所支持的SpEL如下 补充一个authenticated，应该和第一个一样 isAuthenticated():是否认证过jsp标签 Spring Security提供jsp标签库，包含三个标签 security:accesscontrollist :如果认证用户具有权限列表中的某一个权限，那么这个标签范围的内容将显示 security:authentication: 访问当前用户认证对象的属性。一般用户显示当前用户的用户名之类的。具有的用户认证信息有: authorities:一组用于用户所授予的GrantedAuthority对象 credentials：核实用户的凭据 detail:认证的附加信息(IP地址，会话ID等) principal:用户的主要信息对象 security:authorize: 如果当前用户满足特定权限，则显示标签范围的内容 &lt;!-- 显示用户信息, 并将信息复制给var变量，该变量的使用范围为scope的范围--&gt; Hello &lt;security:authentication property=&quot;principal.usrname&quot; var=&quot;loginId&quot; scope=&quot;request&quot;&gt; &lt;security:authorize access=&quot;hasRole(&apos;ROLE_ADMIN&apos;)&quot;&gt; 如果当前用户有ROLE_ADMIN权限，则显示这部分内容 &lt;/security:authorize&gt; &lt;!--或者--&gt; &lt;security:authorize url=&quot;/admin/**&quot;&gt; 如果当前用户有/admin/**对应的权限，则显示这部分内容 &lt;/security:authorize&gt; 认证用户 前面提到很多用户权限的问题，那么如何获取用户的权限呢？最常用的方式是查询数据库中相应用户的权限，前面登录验证的例子使用了内存用户存储库，参考文章也介绍了内存用户存储库的配置。 &lt;jdbc-user-service id=&quot;userService&quot; data-source-ref=&quot;dataSource&quot; users-by-username=&quot;select username,password,true from user where username=?&quot; authories-by-username-query=&quot;select username,role from user_role where username=?&quot; /&gt; &lt;authentication-manager&gt; &lt;!--ref:直接注入bean；user-service-ref:先将bean注入一个叫DaoAuthenticationProvider的bean 的变量userDetailsService中，再将DaoAuthenticationProvider注authentication-provider入--&gt; &lt;authentication-provider user-service-ref=&quot;userService&quot;/&gt; &lt;/authentication-manager&gt; &lt;!--或者--&gt; &lt;authentication-manager erase-credentials=&quot;false&quot;&gt; &lt;authentication-provider&gt; &lt;!--如果想用传统的md5或sha的话 &lt;password-encoder hash=&quot;sha&quot; /&gt; --&gt; &lt;password-encoder ref=&quot;bcryptEncoder&quot; /&gt; &lt;jdbc-user-service data-source-ref=&quot;dataSource&quot; users-by-username-query=&quot;select username,password from user where username=?&quot; authorities-by-username-query=&quot;select username,role from user_role where username=?&quot;/&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; &lt;!-- 配置加密的算法，表明在登录或密码需要加密验证； 生成的密文有60位，且每次都不同，所以数据库密码字段至少60位 --&gt; &lt;beans:bean name=&quot;bcryptEncoder&quot; class=&quot;org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder&quot; /&gt; 不写sql语句的话，Spring Security会自动生成sql语句从数据库中查找用户和权限，但一般情况下提供的查询语句并不能和我们的数据库对上，所以我们需要自己写，主要包括以下属性： users-by-username-query：根据用户名查询用户名，密码以及是否可用状态 authorities-by-username-query:根据用户名查询用户被用户名和授权的权限。 group-authorities-by-username-query:根据用户名查询用户组的权限保护方法 提供方法级别的保护，基于Spring AOP.首先需要applicationContext.xml中加入以下配置 &lt;!--使spring Security保护那些带相关注解的方法--&gt; &lt;global-method-security secured-annotations=&quot;enabled&quot; /&gt; 支持4种方法级别安全性的保护方式： 使用@Secured注解方法，这是spring自带的注解方法。@Secured（””）内部的字符串不具有SpEL特性，只能是具体的权限。 使用@JSR-250 @RelosAllowed注解的方法。作用和使用方法与@Secured一样，不同在于它不是spring框架的，所以可以做到和spring框架的解耦。 使用Spring 方法调用前和调用后注解方法。这些方法支持SpEL. 匹配一个或多个明确声明的切点方法。 @Secured(&quot;ROLE_ADMIN&quot;) public void addUser(User user){ ... } @RolesAllowed(&quot;ROLE_ADMIN&quot;) public void updateUser(User user){ ... } //匹配一个或多个明确声明的切点方法 &lt;global-method-security secured-annotations=&quot;enabled&quot; &gt; &lt;protect-pointcut access=&quot;ROLE_ADMIN&quot; expression=&quot;execution(@com.securitytest.service.UserService**.*(String)&quot; &lt;/global-method-security&gt; 处理方法调用前和调用后的Spring注解（可以使用SpEL） @PreAuthorize： 在方法调用前，基于表达式计算结果来限制方法访问 @PostAuthorize: 允许方法调用，但是如果表达式结果为fasle则抛出异常 @PostFilter :允许方法调用，但必须按表达式过滤方法结果。 @PreFilter:允许方法调用，但必须在进入方法前过滤输入值 @PreAuthorize(&quot;hasRole(&apos;ROLE_ADMIN&apos;)&quot;) public void addUser(User user){ //如果具有权限 ROLE_ADMIN 访问该方法 .... } //returnObject可以获取返回对象user，判断user属性username是否和访问该方法的用户对象的用户名一样。不一样则抛出异常。 @PostAuthorize(&quot;returnObject.user.username==principal.username&quot;) public User getUser(int userId){ //允许进入 ... return user; } //将结果过滤，即选出性别为男的用户 @PostFilter(&quot;returnObject.user.sex==&apos;男&apos; &quot;) public List&lt;User&gt; getUserList(){ //允许进入 ... return user; } 参考文章 Spring Security入门 SpringMvc整合Spring Security web.xml是最好的 SpringMVC+Spring Security实现登录认证的简单功能代码实例 D:/ideaprojects/thz/thz-parent/thz-manager-webJava Configuration方式参见笔记：Spring Security之Java Configuration方式","categories":[],"tags":[]},{"title":"","slug":"Spring Cache一之CacheManager的创建","date":"2019-04-30T08:25:45.764Z","updated":"2019-03-23T11:55:09.044Z","comments":true,"path":"2019/04/30/Spring Cache一之CacheManager的创建/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring Cache一之CacheManager的创建/","excerpt":"","text":"简介 自Spring 3.1起，提供了基于注解的Cache支持（之前是用aop实现的），且提供了Cache抽象。 Spring Cache优点： 提供基本的cache抽象，方便切换各种底层cache。 通过注解Cache可以实现逻辑代码透明缓存。 支持事故回滚时也自动回滚缓存。 支持复杂的缓存逻辑。 API及默认实现 Cache接口：主要是缓存的增删查功能。 package org.springframework.cache; public interface Cache { String getName(); //缓存的名字 Object getNativeCache(); //得到底层使用的缓存，如Ehcache ValueWrapper get(Object key); //根据key得到一个ValueWrapper， 然后调用其get方法获取值 &lt;T&gt; T get(Object key, Class&lt;T&gt; type);//根据key，和value的类型直接获取value void put(Object key, Object value);//往缓存放数据 void evict(Object key);//从缓存中移除key对应的缓存 void clear(); //清空缓存 interface ValueWrapper { //缓存值的Wrapper Object get(); //得到真实的value } } 由此可见，缓存的对象就是键值对。 默认实现： ConCurrentMapCache：使用java.util.concurrentHashMap实现的Cache。 GuavaCache: 对Gguava com.google.common.cache.Cache进行的Wrapper，需要Google Guava 12.0或更高版本。 EhCacheCache: 使用Ehcache实现。 JCacheCache：对javax.cache.Cache进行的Wrapper。 CacheManager：Spring提供的缓存管理器，便于管理程序中的多个cache。 package org.springframework.cache; import java.util.Collection; public interface CacheManager { Cache getCache(String name); //根据Cache名字获取Cache Collection&lt;String&gt; getCacheNames(); //得到所有Cache的名字 } 默认实现： SimpleCacheManager NoOpCacheManager ConcurrentMapCacheManager CompositeCacheManager EhCacheCacheManager RedisCacheManager: 来自spring data redis项目 GemfireCacheManager：来自spring data gemfire项目 具体要选择哪个取决于要使用的底层缓存。 另外还提供了CompositeCacheManager用于组合CacheManager，即可以从多个CacheManager轮询得到相应的cache。 &lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.CompositeCacheManager&quot;&gt; &lt;!--注入多个CacheManager--&gt; &lt;property name=&quot;cacheManagers&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;ehcacheManager&quot;/&gt; &lt;ref bean=&quot;jcacheManager&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;fallbackToNoOpCache&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; 除了多出cacheManagers属性外，其他方法应该和CacheManager差不多，比如，当调用cacheManager.getCache（cacheName）时，会先从第一CacheManager找起，找到为止，最终找不到的话，因为fallbackToNoOpCache=true，将返回一个NOP的cache，否则返回null。 事务回滚：除了GuavaCacheManager之外，其他Cache都支持Spring事务，即如果事务回滚了，C阿策划的数据也会移除掉。 Spring不进行cache的定义，也不进行Cache的缓存策略的维护。这些都是由底层cache自己实现，然后外部创建一个cache注入进来的。Spring只是提供了一个Wrapper，提供一套对外一致的API。 示例 采用Ehcache，依赖： &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt; &lt;/dependency&gt; 配置底层ehcache： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache name=&quot;es&quot;&gt; &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt; &lt;!--这个好像可有可无--&gt; &lt;defaultCache maxEntriesLocalHeap=&quot;1000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;3600&quot; timeToLiveSeconds=&quot;3600&quot; overflowToDisk=&quot;false&quot;&gt; &lt;/defaultCache&gt; &lt;!--定义一个Cache，名为user，CacheManager维护一个CacheMap,以下name属性为key， cache实例为value，调用getCache(&quot;user&quot;)即执行cacheMap.get(&quot;user&quot;), 返回cache实例--&gt; &lt;cache name=&quot;user&quot; maxEntriesLocalHeap=&quot;2000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;600&quot; timeToLiveSeconds=&quot;600&quot; overflowToDisk=&quot;false&quot; statistics=&quot;true&quot;&gt; &lt;/cache&gt; &lt;!--可以继续定义多个Cache--&gt; &lt;/ehcache&gt; 创建CacheManager：一般Spring的CacheManager的实现都是不会添加setCache()的方法，但会添加setCacheManager()，把其他框架的CacheManager设置进来，而其他框架的CacheManager（比如net.sf.ehcache的CacheManager）则可以设置cache，设置进去之后spring的CacheManager会自动把其中的Cache集合获取到自己维护的CacheMap中。 所以创建CacheManager分三步，先做个测试： @Test public void test() throws IOException{ //2. 把底层cache设置到底层CacheManager；这里使用net.sf.ehcache的CacheManager CacheManager ehcacheManager=new CacheManager( new ClassPathResource(&quot;ehcache.xml&quot;).getInputStream()); //1. 创建 底层cache //3. 把底层CacheManager设置到spring的CacheManager EhCacheCacheManager cacheCacheManager=new EhCacheCacheManager(); cacheCacheManager.setCacheManager(ehcacheManager); //根据缓存名字获取缓存;使用spring的cache;“user”cache定义在ehcache.xml中 Cache cache=cacheCacheManager.getCache(&quot;user&quot;); //往缓存写数据 Long id=1L; User user=new User(id,&quot;zhang&quot;,&quot;zhang@gmail.com&quot;); cache.put(id,user); //id为键，user等下被转为json作值 //从缓冲读数据 Assert.assertNotNull(cache.get(id,User.class)); //根据id找值，再根据User类信息转json为类 } 上面三步用配置文件实现更快： &lt;!--2. 创建底层CacheManager；Spring提供EhCacheManagerFactoryBean来简化 外部依赖ehcache的CacheManager的创建；指定configuration路径比编码方式简单多了--&gt; &lt;bean id=&quot;ehcacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt; &lt;!--1. 创建底层cache--&gt; &lt;property name=&quot;configuration&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;/bean&gt; &lt;!--3. 创建spring的CacheManager--&gt; &lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; value=&quot;ehcacheManager&quot;/&gt; &lt;!--是否支持事务，是则事务回滚，缓存也回滚，默认false--&gt; &lt;property name=&quot;transactionAware&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; 上面测试其实就是使用Java configure方式，我们把它写成个配置类来代替上述xml配置： @Configuration //配置spring容器 @EnableCaching(proxyTargetClass = true) public class CacheConfig { @Bean //往容器注册bean实例 public CacheManager cacheManager() { try { //2. 创建底层CacheManager net.sf.ehcache.CacheManager ehcacheCacheManager= new net.sf.ehcache.CacheManager( //1. 创建底层cache new ClassPathResource(&quot;ehcache.xml&quot;).getInputStream() ); //3. 创建spring的CacheManager EhCacheCacheManager cacheCacheManager= new EhCacheCacheManager(ehcacheCacheManager); return cacheCacheManager; } catch (IOException e) { //getInputStream()抛出的 throw new RuntimeException(e); } } }","categories":[],"tags":[]},{"title":"","slug":"Spring Cache二之Cache注解","date":"2019-04-30T08:25:45.760Z","updated":"2019-03-24T04:11:25.860Z","comments":true,"path":"2019/04/30/Spring Cache二之Cache注解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Spring Cache二之Cache注解/","excerpt":"","text":"Cache注解 开启注解，以后再方法上加个注解就可以自动把查询到的数据放到缓存中。 如果是用xml配置文件创建CacheManager的话，添加以下配置即开启cache注解： &lt;!--假设上面注册了spring的CacheManager，id为cacheManager--&gt; &lt;cache:annotation-driven cache-manager=&quot;cacheManager&quot; proxy-target-class=&quot;true&quot;/&gt; &lt;!--还有一个属性key-generator，即key生成策略，默认是SimpleKeyGenerator--&gt; 如果是Java configuration的话： @Configuration @ComponentScan(basePackages = &quot;com.haien.sping.cache.service&quot;) @EnableCaching(proxyTargetClass = true) //效果同&lt;cache:annotation-driven/&gt;，开启注解 public class AnnotationCacheConfig { @Bean public CacheManager cacheManager(){ try { //2. net.sf.ehcache.CacheManager ehcacheCacheManager=new net.sf.ehcache.CacheManager( new ClassPathResource(&quot;ehcache.xml&quot;).getInputStream()); //1. //3. EhCacheCacheManager cacheCacheManager=new EhCacheCacheManager(ehcacheCacheManager); return cacheCacheManager; } catch (IOException e) { //getInputStream()抛出的 throw new RuntimeException(e); } } } 如果想要设置KeyGenerator的话，可以实现CachingConfigurer： @Configuration @ComponentScan(basePackages = &quot;com.haien.sping.cache.service&quot;) @EnableCaching(proxyTargetClass = true) public class AnnotCacheConfWithKeyGenertor implements CachingConfigurer { @Bean public CacheManager cacheManager() { try { net.sf.ehcache.CacheManager ehcacheCacheManager=new net.sf.ehcache.CacheManager( new ClassPathResource(&quot;ehcache.xml&quot;).getInputStream() ); EhCacheCacheManager cacheCacheManager=new EhCacheCacheManager(ehcacheCacheManager); return cacheCacheManager; } catch (IOException e) { throw new RuntimeException(e); } } //默认为此 @Bean public KeyGenerator keyGenerator() { return new SimpleKeyGenerator(); } } 然后使用cache注解：所有注解都可以放在类或方法上，如果放在类上则会应用到所有方法上；并且，如果将注解放在接口类的方法上，则所有实现类在重写方法时都会继承这个注解。 @Service public class UserService { //假设这是数据库 Set&lt;User&gt; users=new HashSet&lt;User&gt;(); //调用该方法时，会把user.id作为key，放入value指定的缓存，可以指定多个缓存， 如,value={&quot;user1&quot;,&quot;user2&quot;}；#表示调用参数 @CachePut(value = &quot;user&quot;,key = &quot;#user.id&quot;) public User save(User user){ users.add(user); return user; } //调用方法前先从缓存中读取，没有再调用方法并把数据放进缓存 @Cacheable(value = &quot;user&quot;,key=&quot;#id&quot;) public User findById(final Long id){ System.out.println(&quot;cache miss,invoke find by id,id=&quot;+id); for(User user:users){ if(user.getId().equals(id)) return user; } return null; } @CacheEvict(value = &quot;user&quot;,key = &quot;#user.id&quot;) //移除指定key的数据 public void delete(User user){ users.remove(user); } @CacheEvict(value = &quot;user&quot;,allEntries = true) //移除所有数据 public void deleteAll(){ users.clear(); } } @CachePut：应用在写数据的方法上，在调用方法前并不会先检查缓存中是否已有该值，即有也会被覆盖。 public @interface CachePut { String[] value(); //缓存的名字，可以把数据放入多个缓存；支持SpEL表达式 String key() default &quot;&quot;; //缓存key，不指定将使用默认的KeyGenerator生成；SpEL String condition() default &quot;&quot;; //能否放入缓存的条件，在方法调用前后都会判断； SpEL String unless() default &quot;&quot;; //返回false则能放入缓存；SpEL } @Cacheable: 应用在读数据的方法上，即可缓存的方法上，如查找；调用前会先从缓存读取，没有再调用方法，并把数据放入缓存。 public @interface Cacheable { String[] value(); //同@CachePut String key() default &quot;&quot;; //同@CachePut String condition() default &quot;&quot;; //方法调用前判断是否能从缓存拿； 执行方法后是否能把数据放入缓存的条件 String unless() default &quot;&quot;; //返回false则能放入缓存 } @CacheEvict：应用在移除数据的方法上。 public @interface CacheEvict { String[] value(); //同@CachePut String key() default &quot;&quot;; //同@CachePut String condition() default &quot;&quot;; //调用前还是调用后判断取决于beforeInvocation boolean allEntries() default false; //是否移除所有数据 boolean beforeInvocation() default false;//是调用方法前还是调用后移除 } 注解参数所用的SpEL target：被注解方法所在的类 通过这些数据我们可以实现比较复杂的缓存逻辑了。 条件缓存 利用注解的condition或unless属性，进行有条件的缓存。 @Cacheable：在方法调用前判断condition，返回true则先从缓存中拿： @Cacheable(value = &quot;user&quot;, key = &quot;#id&quot;, condition = &quot;#id lt 10&quot;) //id&lt;10？ public User conditionFindById(final Long id) //condition示例：以下代码位于UserService类中 //判断执行前是否要先删缓存 @CacheEvict(value = &quot;user&quot;,key = &quot;#user.id&quot;, condition = &quot;#root.target.canEvict(#root.caches[0],#user.id,#user.username)&quot;, beforeInvocation = true) public void conditionalUpdate(User user){ users.remove(user); users.add(user); } /** * @Author haien * @Description 判断是否需要删除缓存 * @Date 2019/3/24 * @Param [userCache名为“user”的cache, id, username] * @return boolean **/ public boolean canEvict(Cache userCache,Long id,String username) { //根据id查出条目 User user=userCache.get(id,User.class); //查不到则不用删缓存 if(user==null) return false; //查到了但username不是指定的那个也不用删除 return !user.getUsername().equals(username); } 以上方法缺点在于需要将缓存判断方法也暴露出去，而且缓存代码和业务代码混在一起，所以把canEvict()移到一个Helper静态类中更好(不过代码中没实现）： @CacheEvict(value = &quot;user&quot;, key = &quot;#user.id&quot;, condition = &quot;T(com.haien.service.UserCacheHelper) .canEvict(#root.caches[0], #user.id, #user.username)&quot;, beforeInvocation = true) public void conditionUpdate(User user){} @CachePut：以下condition需要result值，所以只在方法执行后才判断，返回true则放入缓存： //ne：应该是not equal的意思 @CachePut(value = &quot;user&quot;, key = &quot;#id&quot;, condition = &quot;#result.username ne &apos;zhang&apos;&quot;) public User conditionSave(final User user) 如下注解只在方法执行后才判断unless，返回false才放入缓存： @CachePut(value = &quot;user&quot;, key = &quot;#user.id&quot;, unless = &quot;#result.username eq &apos;zhang&apos;&quot;) public User conditionSave2(final User user) //message是result的属性，contains是SpEL的方法 @Cacheable(value = &quot;spittleCache&quot;, unless = &quot;#result.message.contains(&apos;NoCache&apos;)&quot;) Spittle findOne(long id); @CacheEvict：beforeInvocation=false表示在方法执行后才删除缓存，且condition要返回true才删除： @CacheEvict(value = &quot;user&quot;, key = &quot;#user.id&quot;, beforeInvocation = false, condition = &quot;#result.username ne &apos;zhang&apos;&quot;) public User conditionDelete(final User user) @Caching 用于组合多个注解使用。 public @interface Caching { Cacheable[] cacheable() default {}; //声明多个@Cacheable CachePut[] put() default {}; //声明多个@CachePut CacheEvict[] evict() default {}; //声明多个@CacheEvict } 比如，新增用户成功后，我们要分别以id、username和email为key同时存储value都为user实例的三条数据，这时可以使用该注解： @Caching( put = { @CachePut(value = &quot;user&quot;, key = &quot;#user.id&quot;), @CachePut(value = &quot;user&quot;, key = &quot;#user.username&quot;), @CachePut(value = &quot;user&quot;, key = &quot;#user.email&quot;) } ) public User save(User user) {} 其实最好是id-user，然后username-id、email-id，保证user只存一份。 运行流程 使用@Caching组合多个注解或在同个方法加多个注解时，运行流程如下： 首先执行@CacheEvict清空缓存（如果beforeInvocation=true且condition通过）。 接着收集@Cacheable（如果condition通过，即方法执行后允许写入缓存，且key对应的数据不在缓存）； 然后收集@CachePut（如果condition通过）。 全部收集到cachePutRequests（表示缓存中缺失数据，有放入缓存的需求）。 如果cachePutRequests为空，那么@Cacheable时将先查找缓存，否则直接开始执行方法。 如果缓存中找不到数据，那么开始执行方法，把结果放入result。 执行cachePutRequests，把result中的数据写入缓存（如果unless返回false）。 执行@CacheEvict（如果beforeInvocation=false 且 condition 通过）。 其实也就是有beforeInvocation或condition这种需要在方法执行前先检查的注解先被处理，然后再执行方法，最后再处理有beforeInvocation或condition的注解。 由以上2、3步，只要注解中有@CachePut，cachePutRequests就不可能为空，@Cacheable就不会去缓存中取。 解决@Cacheable和@CachePut不能同时用的问题 只要有@CachePut在，@Cacheable就不会从缓存拿的问题其实只要改掉spring中CacheAspectSupport类某个方法的判断条件即可。 我们在自己的test包下建包：org.springframework.cache.intercepter(CacheAspectSupport原本就在spring框架中的该包下)，自己一模一样的CacheAspectSupport类，只修改其中判断能否从缓存查东西的条件（本来是只要有@CachePut就不查，现在改成只要有2Cacheable就查）： package org.springframework.cache.interceptor public abstract class CacheAspectSupport implements InitializingBean { private Object execute(Invoker invoker, CacheOperationContexts contexts) { ... Collection&lt;CacheOperationContext&gt; cacheOperationContexts = contexts.get(CacheableOperation.class); /* 原代码要求cacheOperationContexts为空且cachePutRequests也为空，即没有@CachePut时才从缓存拿 if (cachePutRequests.isEmpty() &amp;&amp; cacheOperationContexts.isEmpty()) { result = findCachedResult(cacheOperationContexts); }*/ //现在只查cacheOperationContexts，且相反，不为空才查缓存，也就是只要有@Cacheable就查缓存 if (!cacheOperationContexts.isEmpty()) { result = findCachedResult(cacheOperationContexts); } ... } } 但是只改上面这个类只是做了第一步，后面还要做什么配置就不知道了。 自定义组合注解 上面那个@Caching用在方法上会显得有点乱，此时我们可以把它定义成一个简洁的注解： @Caching( put = { @CachePut(value = &quot;user&quot;, key = &quot;#user.id&quot;), @CachePut(value = &quot;user&quot;, key = &quot;#user.username&quot;), @CachePut(value = &quot;user&quot;, key = &quot;#user.email&quot;) } ) @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface UserSaveCache { } KeyGenerator KeyGenerator接口：如果在Cache注解上没有指定key的话，如@CachePut(value=”user”)，会调用KeyGenerator自动生成一个key。 public interface KeyGenerator { Object generate(Object target, Method method, Object... params); } 默认实现： DefaultKeyGenerator： @Override public Object generate(Object target, Method method, Object... params) { //如果参数为空，就不知道key是个什么特定值了 if (params.length == 0) { return SimpleKey.EMPTY; } //如果只有一个参数，就使用参数作为key，即传入User实例名为User参数 的方法，key默认为“user” if (params.length == 1 &amp;&amp; params[0] != null) { return params[0]; } return new SimpleKey(params); } SimpleKeyGenerator：Spring4之后默认使用的。 自定义KeyGenerator：然后用&lt;cache:annotation-driven key-generator=””/&gt;指定，或实现CachingConfiguration接口时重写方法设置进去。 使用xml代替缓存注解 提供元素如下： 具体参考文章 缓存模糊匹配 使用Spring 3.1注解缓存模糊匹配Evict 《Spring Cache抽象详解》 代码示例：ideaProjects/spring-cache","categories":[],"tags":[]},{"title":"","slug":"SpEL表达式","date":"2019-04-30T08:25:45.756Z","updated":"2019-01-19T06:30:45.219Z","comments":true,"path":"2019/04/30/SpEL表达式/","link":"","permalink":"http://47.107.237.149/2019/04/30/SpEL表达式/","excerpt":"","text":"简介 Spring表达式语言，简称SpEL，是一个支持运行时查询和操作对象图的强大表达式语言。 语法：使用#{…}作为定界符，为bean的属性进行动态赋值。 代码示例&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;car&quot; class=&quot;com.itdjx.spring.spel.Car&quot;&gt; &lt;!--直接value=&quot;玛莎拉蒂&quot;也可以--&gt; &lt;property name=&quot;brand&quot; value=&quot;#{&apos;玛莎拉蒂&apos;}&quot;&gt;&lt;/property&gt; &lt;!-- 或者 &lt;property name=&quot;brand&quot; value=&apos;#{&quot;玛莎拉蒂&quot;}&apos;&gt;&lt;/property&gt; --&gt; &lt;!--直接value=&quot;32000.78&quot;也可以--&gt; &lt;property name=&quot;price&quot; value=&quot;#{32000.78}&quot;&gt;&lt;/property&gt; &lt;!--调用静态方法的属性--&gt; &lt;property name=&quot;perimeter&quot; value=&quot;#{T(java.lang.Math).PI * 75.8f}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.itdjx.spring.spel.Person&quot;&gt; &lt;!--调用对象的方法或属性，判断表达式#{true}/#{false}，marriage为Boolean型--&gt; &lt;property name=&quot;marriage&quot; value=&quot;#{car.price &gt; 400000 and age &gt; 30}&quot;&gt;&lt;/property&gt; &lt;!--引用bean，之前为：&lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;--&gt; &lt;property name=&quot;car&quot; value=&quot;#{car}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;socialStatus&quot; value=&quot;#{car.price &gt; 30000 ? &apos;金领&apos; : &apos;白领&apos;}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;#{address.province + &apos;省&apos; + address.city + &apos;市&apos; + address.area + &apos;区&apos;}&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;address&quot; class=&quot;com.itdjx.spring.spel.Address&quot;&gt; &lt;property name=&quot;province&quot; value=&quot;#{&apos;辽宁&apos;}&quot;/&gt; &lt;property name=&quot;city&quot; value=&quot;#{&apos;大连&apos;}&quot;/&gt; &lt;property name=&quot;area&quot; value=&quot;#{&apos;沙河口&apos;}&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; SpEL 整数：#{8} 小数：#{8.8} 科学计数法：#{1e4} String：使用单或双引号作为字符串的定界符 Boolean：#{true} 引用对象：#{car} 引用对象属性：#{car.brand} 调用对象方法：#{car.toString()},还可以链式操作 调用静态方法静态属性、静态方法：#{T(java.lang.Math).PI}，#{T(java.lang.Math).random()}使用T()调用类作用域的方法和常量 支持算术运算符：+，-，*，/，%，^(加号还可以用作字符串连接) 比较运算符：/gt , ==/eq , &gt;=/ge , &lt;=/le 逻辑运算符：and , or , not , | 三目运算符：? : 正则表达式：#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}’} 避免抛出空指针异常：加个?，它会确保在左边项为null时不调用后面方法 &lt;property name=&quot;song&quot; value=&quot;#{songSelector.selectSong()?.toUpperCase()}&quot; /&gt;","categories":[],"tags":[]},{"title":"","slug":"servlet、request和response","date":"2019-04-30T08:25:45.752Z","updated":"2019-04-12T07:00:04.616Z","comments":true,"path":"2019/04/30/servlet、request和response/","link":"","permalink":"http://47.107.237.149/2019/04/30/servlet、request和response/","excerpt":"","text":"Servlet server + let，运行在服务器端的小程序。 Servlet实际就是一个接口，广义上我们认为凡是实现Servlet接口的类，我们都称他是一个Servlet。 要继承HttpServlet类，必须检查项目-&gt;构建路径-&gt;库里里面有没有tomcat的jar包。 作用：接收用户发送的请求；调用其他的java程序来处理请求；返回一个页面给用户。 实现步骤： 创建一个类并实现Servlet接口。 重写doGet()和doPost()，doGet交给doPost处理，第一句：改编码(utf-8不行就gbk)。 在web.xml中配置servlet，否则请求和处理无法关联： &lt;servlet&gt; &lt;!--Servlet的别名，以后通过别名查询该Servlet--&gt; &lt;servlet-name&gt;唯一别名&lt;/servlet-name&gt; &lt;!--服务器通过全类名创建Servlet的实例--&gt; &lt;servlet-class&gt;全类名&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;别名&lt;/servlet-name&gt; &lt;!--Servlet映射的请求地址，用户通过该地址访问Servlet--&gt; &lt;url-pattern&gt;需要servlet处理的请求地址&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 入门项目：HeadFirstServletChap05 Servlet的生命周期 构造器 启动的时候就会加载Servlet类，第一次处理请求的时候就会实例化，即调用构造器；且只会调用一次，因为Servlet是单例模式，以多线程的方式调用service()，但Servlet不是线程安全的，所以尽量不要在service()中操作全局变量。 init() 构造器调用后马上调用init(),init只执行一次，里面可以写一些初始化的东西，然后你请求的话它就会有doGet、doPost的服务。 service() Servlet每次处理请求时都会调用service()，用于处理请求，会调用多次。 destroy() Servlet对象销毁前（web项目卸载时）调用，用来做一些收尾工作，释放资源等。 销毁情况有好几种：长时间不用（等半天）servlet，自动销毁；关闭的时候也销毁（即释放内存，销毁掉之后再访问则重新调用init） servlet是单实例多线程，使用时要注意安全性。 代码实例：HeadFirstServletChap05-&gt;com.java1234.web包-&gt;LifeServlet.java ServletConfig 每一个servlet都有一个唯一的ServletConfig对象，表示当前servlet的配置信息。 由tomcat服务器创建，最终作为参数传递到init()中，可以在init()中直接使用。 当我们通过继承HttpServlet创建servlet实现类时，父类已经实现ServletConfig接口，所以我们可以直接在类中调用ServletConfig的方法。 作用：获取Servlet的别名；获取servlet的初始化参数；获取当前web应用的ServletContext对象。 &lt;servlet&gt; &lt;servlet-name&gt;AServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.AServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;root&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;123123&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; ServletContext 一个web应用对应唯一的ServletContext对象，表示当前的web应用。 项目启动时创建，卸载时销毁。 ServletConfig.getServletContext()：获取ServletContext对象。 作用：获取整个web应用的初始化参数，如 &lt;context-param&gt; &lt;param-name&gt;phone&lt;/param-name&gt; &lt;param-value&gt;1388888888&lt;/param-value&gt; &lt;/context-param&gt; 获取资源的真实路径（主要用于文件上传、下载）；可以作为一个域对象再不同的web资源之间共享数据。 GenericServlet 实现了Servlet接口，是通用的servlet父类。 HttpServlet 继承自GenericServlet。 重写了service()： 将入参ServletRequest和ServletResponse强转为Http 一般继承HttpServlet来实现自定义Servlet。 客户端跳转的话request里存放的数据不会被传过去，但是session、application可以。 代码实例：HeadFirstServletChap05-&gt;com.java1234.web包-&gt;RedirectServlet.java 服务器跳转是内部转发的，跟客户端的唯一不同是：不是调用重定向，而是调用getRequestDispatcher(“target.jsp”).forward(request, response);其他存值什么的操作都一样 服务器跳转能获取request值 代码实例：HeadFirstServletChap05-&gt;com.java1234.web包-&gt;ForwardServlet.java HttpServletRequest和ServletRequest的区别 servlet可以处理多种形式的请求响应，而http只是其中一种，所以HttpServletRequest是ServletRequest的子接口，它多了一些针对HTTP协议的方法： getHeader(String name) getMethod() getSession() ... request与response简介 当web服务器收到客户端的一次HTTP请求时，会创建一个代表请求的request对象和代表响应的response对象。所以我们要获取客户机提交过来的数据，找request，要向客户端输出数据，找response。 request获取当前请求/*当前页面请求:http://localhost:8080/thz-manager-web/forgetPwd_check(无参数)*/ String path = request.getContextPath(); // 一般是项目名：/thz-manager-web //根路径 String basePath = request.getScheme()+&quot;://&quot; //协议：http +request.getServerName()+&quot;:&quot; //服务主机:localhost +request.getServerPort() //端口号:8080 +path+&quot;/&quot;; String remoteAddress=request.getRemoteAddr(); //发起请求的客户端ip--0:0:0:0:0:0:0:1 String servletPath=request.getServletPath(); //请求路径：/forgetPwd_check /**虚拟目录映射为实际目录*/ //String realPath=request.getRealPath(&quot;/&quot;); //不推荐使用 //推荐使用：request.getSession().getServletContext().getRealPath(&quot;url&quot;) //得到工程文件在服务器中的实际路径，即绝对路径 String realPath=request.getSession().getServletContext().getRealPath(&quot;/&quot;); //映射/为实际目录 //D:\\ideaProjects\\thz\\thz-parent\\thz-manager-web\\src\\main\\webapp\\ String pagePath=request.getSession().getServletContext().getRealPath(&quot;./&quot;); //网页所在目录：D:\\ideaProjects\\thz\\thz-parent\\thz-manager-web\\src\\main\\webapp\\. //（放在后台不是很合适，应该是写在前端脚本） String remoteUser=request.getRemoteUser(); //一般得到null //得到相对路径的url：/thz-manager-web/forgetPwd_check String requestURI=request.getRequestURI(); //完整路径:http://localhost:8080/thz-manager-web/forgetPwd_check StringBuffer requestURL=request.getRequestURL(); String queryString=request.getQueryString(); //获取请求参数串，无则为null //完整请求:http://localhost:8080/thz-manager-web/forgetPwd_checknull String fullPath=requestURL+queryString; String method=request.getMethod(); //获取请求方法，POST/GET等 response.getwriter()和response.getOutputStream() getWriter()：向客户端输出字符型数据，是字符流。 getOutputStream(): 向客户端输出二进制数据，是字节流，返回ServletOutputStream对象，提供一个二进制输出流给客户端。 使用OutputStream输出中文数据：在服务端，输出数据的编码要和客户端使用的编码一致，如，客户端浏览器使用utf-8，则 outputStream.write(&quot;中文&quot;.getBytes(&quot;UTF-8&quot;)); //getBytes()返回byte[] 那么在服务端如何控制客户端以utf-8解码数据呢？可以设置响应头控制浏览器的行为，如： response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); 完整示例： String str=&quot;我心自在&quot;; response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;); OutputStream os=response.getOutputStream(); //字符转字节；编码默认根据系统环境获取 byte[]b=str.getBytes(&quot;utf-8&quot;); os.write(b); 使用getWriter()输出中文数据：推荐，比前者节省了字符转字节这一步骤。 String str=&quot;我心自在&quot;; //1. 设置字符以何种编码输出到浏览器 response.setCharacterEncoding(&quot;utf-8&quot;); //2. 获取PrintWriter输出流 PrintWriter pw=response.getWriter(); pw.write(str); pw.close(); 上述两个步骤不能颠倒，一定要在获取输出流前设置编码，否则设置将无效，浏览器乱码。","categories":[],"tags":[]},{"title":"","slug":"Serializable","date":"2019-04-30T08:25:45.737Z","updated":"2019-04-02T09:15:08.003Z","comments":true,"path":"2019/04/30/Serializable/","link":"","permalink":"http://47.107.237.149/2019/04/30/Serializable/","excerpt":"","text":"简介 序列化即对象的持久化。对象的生存时间并不取决于程序是否正在执行，而是存在于或生存于程序的每一次调用之间。通过序列化一个对象，将其写入磁盘，以后再程序再次调用时重新恢复那个对象，就能完美实现“持久”的效果。 Serializable 对象的序列化只需实现Serializable接口即可，该接口仅仅是一个标记，没有方法。 序列化的对象包裹基本数据类型、集合类、Class对象和其他许多东西。 对象序列化不仅保存了对象的“全景图”，而且能追踪对象内包含的所有句柄并保存那些对象，接着又能对每个对象内包含的句柄进行追踪。 transient：使用该关键字修饰的变量不会被序列化。","categories":[],"tags":[]},{"title":"","slug":"Scanner输入","date":"2019-04-30T08:25:45.733Z","updated":"2018-11-20T13:10:32.478Z","comments":true,"path":"2019/04/30/Scanner输入/","link":"","permalink":"http://47.107.237.149/2019/04/30/Scanner输入/","excerpt":"","text":"创建输入对象 Scanner in=new Scanner(System.in); //从标准输入流读入 Scanner in=new Scanner(File file); //从指定文件读入 Scanner in=new Scanner(Path path); //指定文件 Scanner in=new Scanner(InputStream inputStream); //指定流 Scanner in=new Scanner(File file,String charsetName); //Path/InputStream也可指定字符集 Scanner in=new Scanner(String str); //直接读一个字符串也行 读取一个整数 int a=in.nextInt(); 允许有正负号，但是不能出现字符和小数形式，否则抛异常。 因此这种方法不常用，一般采用读取字符串然后正则验证是否符合要求。","categories":[],"tags":[]},{"title":"","slug":"salt值","date":"2019-04-30T08:25:45.729Z","updated":"2019-01-31T07:49:08.119Z","comments":true,"path":"2019/04/30/salt值/","link":"","permalink":"http://47.107.237.149/2019/04/30/salt值/","excerpt":"","text":"SALT值属于随机值。用户注册时，系统用来和用户密码进行组合而生成的随机数值，称作salt值，通称为加盐值。背景：系统通常把用户的密码如MD5加密后，以密文形式保存在数据库中，来防止黑客偷窥。 产生：随着对MD5密文查询工具的出现，而很多用户的密码又设置简单，单纯的对用户密码进行MD5加密后保存，用密文很容易就能反查询得到某用户的密码。 原理：为用户密码添加Salt值，使得加密的得到的密文更加冷僻，不宜查询。即使黑客有密文查询到的值，也是加了salt值的密码，而非用户设置的密码。salt值是随机生成的一组字符串，可以包括随机的大小写字母、数字、字符，位数可以根据要求而不一样。 用途：当用户首次提供密码时（通常是注册时），由系统自动添加随机生成的salt值，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的加盐值，然后散列，再比较散列值，已确定密码是否正确。 其它：经过添加salt值处理的密码，即使用户设置的原密码是相同的，数据库中的密文却是不同的。","categories":[],"tags":[]},{"title":"","slug":"RestTemplate和ResponseEntity","date":"2019-04-30T08:25:45.726Z","updated":"2019-03-25T06:57:14.833Z","comments":true,"path":"2019/04/30/RestTemplate和ResponseEntity/","link":"","permalink":"http://47.107.237.149/2019/04/30/RestTemplate和ResponseEntity/","excerpt":"","text":"ResponseEntity 简介：继承自HttPEntity类，封装了请求后返回的响应头、响应体和响应状态。 作用：用于controller层向前端返回数据和状态码。 构造器： new ResponseEntity(HttpStatus.OK): http状态码。 new ResponseEntity(new User(),HttpStatus.OK): 泛型对象的数据和http状态码。 new ResponseEntity(MultiValueMap&lt;String, String&gt; headers, HttpStatus statusCode)：http首部（如，HttpHeaders类）和状态码。 new ResponseEntity(new User(), MultiValueMap&lt;String, String&gt; headers, HttpStatus statusCode) 示例： @RequestMapping(value=&quot;/response/entity/status&quot;, method=RequestMethod.GET) public ResponseEntity&lt;String&gt; responseEntityStatusCode() { return new ResponseEntity&lt;String&gt;(&quot;The String ResponseBody with custom status code (403 Forbidden)&quot;, HttpStatus.FORBIDDEN); } 以上方法相当于以下@ResponseBody+@ResponseStatus，它会返回@RequestMapping原页面，显示字符串，并带回一个状态码： @RequestMapping(value=&quot;/response/entity/status&quot;, method=RequestMethod.GET) @ResponseStatus(HttpStatus.FORBIDDEN) public String responseEntityStatusCode() { return &quot;The String ResponseBody with custom status code (403 Forbidden)&quot;, } 虽然这里将状态码设为HttpStatus.FORBIDDEN，但是字符串仍能正常显示在页面上，那么HttpStatus.FORBIDDEN起什么作用呢？ 我们配合RestTemplate写个例子，对该url发起访问，运行结果显示，发起请求失败，后台抛出402异常，但前端照常显示字符串： public static void main(String[] args) { RestTemplate template = new RestTemplate(); //调用getForEntity抛出异常 ResponseEntity&lt;String&gt; entity = template.getForEntity( &quot;http://localhost:8080/web/response/entity/status&quot;, String.class); String body = entity.getBody(); MediaType contentType = entity.getHeaders().getContentType(); HttpStatus statusCode = entity.getStatusCode(); System.out.println(&quot;statusCode:[&quot; + statusCode + &quot;]&quot;); } 异常日志： Exception in thread &quot;main&quot; org.springframework.web.client.HttpClientErrorException: 403 Forbidden at org.springframework.web.client.DefaultResponseErrorHandler .handleError(DefaultResponseErrorHandler.java:76) at org.springframework.web.client.RestTemplate.handleResponseError( RestTemplate.java:486) at org.springframework.web.client.RestTemplate.doExecute( RestTemplate.java:443) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:401) at org.springframework.web.client.RestTemplate.getForEntity( RestTemplate.java:221) at org.springframework.samples.mvc.response.ResponseControllerTest.main( ResponseControllerTest.java:12) 回到ResponseEntity构造器的测试，以下代码进一步指定返回内容的content-type为text/plain。 @RequestMapping(value=&quot;/response/entity/headers&quot;, method=RequestMethod.GET) public ResponseEntity&lt;String&gt; responseEntityCustomHeaders() { HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.TEXT_PLAIN); return new ResponseEntity&lt;String&gt;(&quot;The String ResponseBody with custom header Content-Type=text/plain&quot;, headers, //指定content-type HttpStatus.OK); } 参考文章 代码示例：ideaProjects/shiro-cahpter17/web/AuthorizeController RestTemplate Spring提供的用于访问Rest服务器的客户端。通常用于模拟请求，分析返回的响应数据。 方法： getForEntity():发送get请求，返回ResponseEntity类，包含了响应体所映射成的对象，比如，响应体数据为一个由User转化的json，那么它被封装进ResponseEntity时将转回User对象。我们用一个ResponseEntity对象接收该方法返回值后，可取出其中的响应体对象、响应头和响应状态。 getForObject():同上，不过只返回User对象。 postForEntity():post请求。 postForObject():post请求。 delete()：在特定的URL上对资源执行HTTP DELETE操作。 exchange()：在URL上执行特定的HTTP方法，返回包含对象的ResponseEntity，这个对象是从响应体中映射得到的。 execute()：在URL上执行特定的HTTP方法，返回一个从响应体映射得到的对象。 headForHeaders()：发送HTTP HEAD请求，返回包含特定资源URL的HTTP头。 optionsForAllow()：发送HTTP OPTIONS请求，返回对特定URL的Allow头信息。 postForLocation()：POST 数据到一个URL，返回新创建资源的URL。 put()：PUT 资源到特定的URL。 getForEntity() getForEntity(String url,Class responseType,Map&lt;String,?&gt; uriVariables/Object… uriVariables):目标url，响应体映射的对象，url参数(0个或多个）。 /** * 将要被请求的controller **/ @RestController public class UserController { @Autowired private UserService userService; @RequestMapping(value = &quot;getAll&quot;) public List&lt;UserEntity&gt; getUser() { List&lt;UserEntity&gt; list = userService.getAll(); return list; } } /** * 模拟请求的controller **/ @RestController public class UserController { @RequestMapping(&quot;getForEntity&quot;) public List&lt;UserEntity&gt; getAll2() { //模拟请求并获取响应数据 ResponseEntity&lt;List&gt; responseEntity = restTemplate.getForEntity(&quot;http://localhost/getAll&quot;, List.class); //获取响应头 HttpHeaders headers = responseEntity.getHeaders(); //响应状态 HttpStatus statusCode = responseEntity.getStatusCode(); int code = statusCode.value(); //响应体 List&lt;UserEntity&gt; list = responseEntity.getBody(); System.out.println(list.toString()); return list; } } 有参数的getForEntity()，可以使用{}先在url中占位，然后在方法最后一位参数补上此url参数： //待请求的controller类中 @RequestMapping(&quot;get/{id}&quot;) public UserEntity getById(@PathVariable(name = &quot;id&quot;) String id) { return userService.getById(id); } //模拟请求的controller @RequestMapping(&quot;getForEntity/{id}&quot;) public UserEntity getById2(@PathVariable(name = &quot;id&quot;) String id) { //模拟带参数的get请求 ResponseEntity&lt;UserEntity&gt; responseEntity = restTemplate.getForEntity( &quot;http://localhost/get/{id}&quot;, UserEntity.class, id); //Object...形式的参数 /*也可采用Map形式的参数 * HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); * map.put(&quot;id&quot;,id); * ResponseEntity&lt;UserEntity&gt; responseEntity = restTemplate.getForEntity( * &quot;http://localhost/get/{id}&quot;, UserEntity.class, map); */ UserEntity userEntity = responseEntity.getBody(); return userEntity; } getForEntity(URI uri,Class responseType): 不做测试了。 getForObject() 有的时候不需要全部的响应数据，只要响应体就足够了。 getForObject(URI uri,Class responseType)。 getForObject(String url.Class responseType,Map&lt;String,?&gt;/Object… uriVariables)： //无参数的 getForObject 请求 @RequestMapping(&quot;getAll2&quot;) public List&lt;UserEntity&gt; getAll() { List&lt;UserEntity&gt; list = restTemplate.getForObject(&quot;http://localhost/getAll&quot;, List.class); System.out.println(list.toString()); return list; } //有参数的 getForObject 请求 @RequestMapping(&quot;get2/{id}&quot;) public UserEntity getById(@PathVariable(name = &quot;id&quot;) String id) { //使用Object...形式的参数 UserEntity userEntity = restTemplate.getForObject( &quot;http://localhost/get/{id}&quot;, UserEntity.class, id); /*也可使用Map形式 * HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); * map.put(&quot;id&quot;,id); * UserEntity userEntity = * restTemplate.getForObject( * &quot;http://localhost/get/{id}&quot;, UserEntity.class, map); */ return userEntity; } postForEntity() postForEntity(String url,Object request,Class responseType,Map&lt;String,?&gt;/Object… uriVariables): url,request:要放在post报体中的参数；响应体映射的实体，url参数。 @RequestMapping(value = &quot;save&quot;) public String save(UserEntity userEntity) { return &quot;保存成功&quot;; } //post 请求,提交 UserEntity 对象 @RequestMapping(&quot;saveUser&quot;) public String save(UserEntity userEntity) { ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity( &quot;http://localhost/save&quot;, userEntity, String.class); String body = responseEntity.getBody(); return body; } 浏览器访问http://localhost/saveUser?username=itguang&amp;password=123456&amp;age=20&amp;email=123@123.com，后面参数将被自动封装到UserEntity中传入方法。提交的数据和请求后返回的ResponseEntity如下： 有参数的postForEntity(): @RequestMapping(value = &quot;saveByType/{type}&quot;) //type实际并非参数，而是url的一部分 public String saveByType(UserEntity userEntity, @PathVariable(&quot;type&quot;)String type) { //但是它要作为参数传给方法使用 return &quot;保存成功,type=&quot;+type; } @RequestMapping(&quot;saveUserByType/{type}&quot;) public String save2(UserEntity userEntity,@PathVariable(&quot;type&quot;)String type) { //使用Object...形式传参，也可使用Map ResponseEntity&lt;String&gt; responseEntity = restTemplate.postForEntity( &quot;http://localhost/saveByType/{type}&quot;, userEntity, String.class, type); String body = responseEntity.getBody(); return body; } 浏览器访问localhost/saveUserByType/120?username=itguang&amp;password=123456&amp;age=20&amp;email=123@123.com，返回：保存成功，type=120. 参考文章 HttpStatus.FORBIDDEN起什么作用呢 前面ResponseEntity第一个例子将状态码设为HttpStatus.FORBIDDEN，但是字符串仍能正常显示在页面上，那么HttpStatus.FORBIDDEN起什么作用呢？ 我们配合RestTemplate写个例子，对该url发起访问，运行结果显示，发起请求失败，后台抛出402异常，但前端照常显示字符串： public static void main(String[] args) { RestTemplate template = new RestTemplate(); //调用getForEntity抛出异常 ResponseEntity&lt;String&gt; entity = template.getForEntity( &quot;http://localhost:8080/web/response/entity/status&quot;, String.class); String body = entity.getBody(); MediaType contentType = entity.getHeaders().getContentType(); HttpStatus statusCode = entity.getStatusCode(); System.out.println(&quot;statusCode:[&quot; + statusCode + &quot;]&quot;); } 异常日志： Exception in thread &quot;main&quot; org.springframework.web.client.HttpClientErrorException: 403 Forbidden at org.springframework.web.client.DefaultResponseErrorHandler .handleError(DefaultResponseErrorHandler.java:76) at org.springframework.web.client.RestTemplate.handleResponseError( RestTemplate.java:486) at org.springframework.web.client.RestTemplate.doExecute( RestTemplate.java:443) at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:401) at org.springframework.web.client.RestTemplate.getForEntity( RestTemplate.java:221) at org.springframework.samples.mvc.response.ResponseControllerTest.main( ResponseControllerTest.java:12)","categories":[],"tags":[]},{"title":"","slug":"REST","date":"2019-04-30T08:25:45.713Z","updated":"2018-08-07T08:42:55.866Z","comments":true,"path":"2019/04/30/REST/","link":"","permalink":"http://47.107.237.149/2019/04/30/REST/","excerpt":"","text":"参考文章 特点：没有后缀 表述性状态传递，一种命名规范。REST定义了web的使用标准，主要是http和url。 例如资源标识符url，能对无论图片，Word文档还是视频文件，甚至只是一种虚拟的服务，都可以通过url进行唯一标识。 url决不包含动词，一定是对资源描述的抽象。 对资源使用一致的命名规则最主要的好处就是易于被其他人理解。 例子： 基本术语 Resource（资源）：单个实例对象，例如animal（一只动物）；[逍遥子笔记：Roy ThomasFielding（REST风格的提出者）如此解释资源的含义：一个资源可以是一份文档、一张图片、一个与时间相关的服务（例如：洛杉矶今天的天气）等等，资源是实体的概念性映射，而不是实体本身；个人理解：一张图片是一个资源，但是在我本机中有一个的名字叫做“jason.txt”的、实实在在的文件实体，就不能称作资源，它是资源实体，简单而言：“资源”与“资源实体”之间犹如类和对象的关系。] Collection（集合）：集合是一组同类的实例对象，例如animals（一群动物）。 HTTP：一种在网络上传输的通信协议； Consumer（使用方、用户）：能够发送http请求的客户端程序；[逍遥子笔记：这里Consumer实际是指API的调用方，如果直译成消费者更让人困惑] Third Party Developer（第三方开发人员）：不是你项目项目团队的成员，但希望使用你的服务的那些开发人员； Server（服务器）：能够被Consumer通过网络访问的HTTP服务器/程序； Endpoint（端点）：服务器提供的一个URL，它标识了一个资源（Resource）或者集合（Collection）；[逍遥子笔记：这里理解为URL最后面的那个字段更合适，例如URL: https://api.example.com/vi/zoos的端点就是:/zoos；] Idempotent（幂等）：多次重复操作得到的结果一样； URL Segment（URL片段）：从某个URL中取出的一小部分片段HTTP动词 GET（SELECT）：从服务器获取一个指定资源或一个资源集合； POST（CREATE）：在服务器上创建一个资源； PUT（UPDATE）：更新服务器上的一个资源，需要提供整个资源； PATCH（UPDATE）：更新服务器上的一个资源，只提供资源中改变的那部分属性； DELETE（DELETE）：移除服务器上的一个资源；为url增加版本号 在url中加入版本号是一个优秀的API设计。 例如下面一个通信项目IM包含很多级别的资源，那么版本号应该加在url哪里好呢？ 资源树状图如下： 假设我的URL根（在本文后面将会介绍URL的根）为：https：//test.jason.com/im/*，那么上述资源对应的URL为： （1）https：//test.jason.com/im/user_info/public/self_info 该URL表示资源：用户个人简介的二维码信息； （2）https：//test.jason.com/im/user_info/private/lock 该URL表示资源：用户的应用锁信息； （3）https：//test.jason.com/im/user_rel/friends 该URL表示资源：用户的好友信息 （4）https：//test.jason.com/im/user_rel/groups/member 该URL表示资源：群组的群成员 （5）https：//test.jason.com/im/user_rel/groups/info 该URL表示资源：群组的信息 （6）https：//test.jason.com/im/message/new 该URL表示资源：用户新聊天消息 （7）https：//test.jason.com/im/message/history 该URL表示资源：用户的历史聊天消息 问题是：在这种情况下版本号应该放在URL的那个地方？ 如果版本号是针对IM整个项目，例如这里的IM项目整体分为v1和v2两个大版本，此时的URL首部就能改成：https：//test.jason.com/im/v1/，https：//test.jason.com/im/v2/，实际的URL资源将变成：https：//test.jason.com/im/v1/message/new。 如果版本号是针对IM项目中的某个子类，例如这里的message类型分为v1和v2两个版本，那么消息类的URL根就会变成：https：//test.jason.com/im/message/v1/，https：//test.jason.com/im/message/v2/，实际的URL资源将会变成：https：//test.jason.com/im/message/v1/new。 为API增加计数器 为跟踪各版本的API被调用的情况，以便第三方开发人员及时优化API，可以通过在数据库中为每个API增加一个计数器来实现，来一个请求就将对应的使用计数加1，优化API的根url API的根url应该尽量简单。 这里有两个普通的url根： https//example.org/api/vi/* https//example.com/vi/* 如果你的应用程序不会变得那么大，或者你想简化程序的使用，就把你的API放在url的根域（/api/）之后。 设计url时也应尽量把所表示的资源分层级。 最好让你的API的根也包含内容。例如，访问githubAPI的根就会得到一个端点（资源）列表。端点 端点是url中用于标识一个特定资源或资源集合的那部分url片段。 例如，http://api.example.com/v1/zoos中的zoos。 假如你想构建用于表示多个动物园资源的API，其中，每个动物园都包含很多动物、雇员，并且需要跟踪每个动物的详细信息，那么这些API的端点可能如下所示：（最后即为端点） https://api.example.com/v1/zoos https://api.example.com/v1/animals https://api.example.com/v1/animal_types https://api.example.com/v1/employees 在介绍这些端点的时候，你需要给出这些端点以及操作它们的HTTP动作。例如： GET /zoos：列出所有的动物园（包括动物园的ID、名称以及简介）； POST /zoos: 创建一个新的动物园； GET /zoos/ZID：获取一个完整的动物园对象；[逍遥子笔记：这里的动物园对象仅仅指“动物园”，例如“动物园”的ID、名称、介绍等信息，而不包含该动物园中的动物、雇员等下辖类型的信息] PUT /zoos/ZID：更新一个动物对象（包含全部信息）； PATCH /zoos/ZID：更新一个动物对象（包含部分信息）； DELETE /zoos/ZID: 删除一个动物园对象； GET /zoos/ZID/animals：获取指定动物园的全部动物信息（包括动物的ID和名称）； GET /animals：是指列出所有动物信息； POST /animals: 创建一个新的动物； GET /animals/AID: 获取某个动物的对象信息； PUT /animals/AID：更新一个动物的对象信息（提供对象的全部内容）； PATCH /animals/AID：更新一个动物的对象信息（提供对象的部分内容）； GET /animal_types: 获取所有的动物类型信息； GET /animal_types/ATID: 获取指定动物类型的类型描述信息； GET /employees：获取所有的雇员列表； GET /employees/EID：获取一个指定雇员的信息； GET /zoos/ZID/employees：获取指定动物园的全部雇员列表； POST /employees：创建一个新雇员； POST /zoos/ZID/employees：为指定动物园增加一个雇员； DELETE /zoos/ZID/employees/EID：解雇指定动物园的某个雇员；HTTP包 请求包：当用户发送一个HTTP请求到服务器时，在请求包里提供了一个key/value集合，叫做HTTP首部，紧随其后的是两个空行（一个回车符一个换行符），最后是请求包体。 响应包：服务器对请求的响应也是以key/valu格式的首部，紧接着是两个空行，然后是响应包体。","categories":[],"tags":[]},{"title":"","slug":"response.getWriter().print()和response.getWriter().writer()","date":"2019-04-30T08:25:45.709Z","updated":"2018-11-04T07:01:18.516Z","comments":true,"path":"2019/04/30/response.getWriter().print()和response.getWriter().writer()/","link":"","permalink":"http://47.107.237.149/2019/04/30/response.getWriter().print()和response.getWriter().writer()/","excerpt":"","text":"response.getWriter().print()：打印输出文本格式，可以将一个对象以默认编码方式转换为二进制字节输出 response.getWriter().writer()：只能打印输出文本格式，不可以打印对象 它们都可以识别HTML标签，都可以直接在客户端输出。 举个栗子 在普通url中会生成一个新的页面来显示内容，在ajax中会在alert中显示内容。","categories":[],"tags":[]},{"title":"","slug":"Repository的继承关系","date":"2019-04-30T08:25:45.706Z","updated":"2018-09-15T01:45:15.737Z","comments":true,"path":"2019/04/30/Repository的继承关系/","link":"","permalink":"http://47.107.237.149/2019/04/30/Repository的继承关系/","excerpt":"","text":"Repository：空接口，表名任何继承它的均为仓库接口类 CrudRepository：继承Repository，实现了一组CRUD相关的方法 PagingAndSortingRepository：继承CrudRepository，实现了一组分页、排序相关的方法 JpaRepository：继承PagingAndSortRepository，实现一组JPA规范相关的方法 自定义的XxxRepository需要继承JpaRepository，这样该接口就具备了通用的数据访问控制层的能力。","categories":[],"tags":[]},{"title":"","slug":"repositoryAutowire为null","date":"2019-04-30T08:25:45.702Z","updated":"2018-10-06T08:51:27.816Z","comments":true,"path":"2019/04/30/repositoryAutowire为null/","link":"","permalink":"http://47.107.237.149/2019/04/30/repositoryAutowire为null/","excerpt":"","text":"repository不能在非String容器中装配，比如main方法和非组件化的类。 main方法是因为启动的时候并没有启动Spring容器，所以根本扫描不到repository来装配；而未注释为组件的类是因为扫描不到所以找不到repository来装配。","categories":[],"tags":[]},{"title":"","slug":"Redis","date":"2019-04-30T08:25:45.698Z","updated":"2018-11-12T12:25:43.238Z","comments":true,"path":"2019/04/30/Redis/","link":"","permalink":"http://47.107.237.149/2019/04/30/Redis/","excerpt":"","text":"Redis是一个key-value存储系统。和Memcached（一个高性能的分布式内存对象缓存系统，用于动态web应用以减轻数据库负载。 它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态数据库驱动网站的速度。Memcached基于一个存储键值对的HashMap。 类似，它支持存储的value类型相对更多，包括string、list、set、zset（sorted set–有序集合）和hash（哈希类型）。这些数据类型都支持push/pop\\add/remove及取交集和差集及更丰富的操作，而且这些操作都是原子性的。 在此基础上，Redis支持各种不同方式的排序。 和Memcached一样，为了保证效率，数据都是缓存在内存中。 Redis是一个高性能的key-value数据库。Redis的出现，很大程度上不长了Memcached这类key-value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。 我们在碰到需要执行耗时特别久，但是结果不频繁变动的sql，就适合把结果放入Redis（缓存）中。","categories":[],"tags":[]},{"title":"","slug":"RandomAccessFile任意访问文件","date":"2019-04-30T08:25:45.693Z","updated":"2018-11-24T03:24:37.951Z","comments":true,"path":"2019/04/30/RandomAccessFile任意访问文件/","link":"","permalink":"http://47.107.237.149/2019/04/30/RandomAccessFile任意访问文件/","excerpt":"","text":"简介 其父类为Object，并没有继承字符流或字节流的任一个类 实现了DataInput、DataOutput接口，意味着这个类即可读又可写。 是io体系中功能最丰富的文件访问类，它提供了众多的方法来访问文件内容 可以通过设置游标来自由访问文件的任意位置，使用于访问文件部分内容的情况。 可以用来访问保存数据记录的文件，但是必须知道这些数据的类型和位置写入文件 保存一个类的各个域到文件 public class RandomAccessFileTest { class Person { int id; String name; double height; public Person(){ } public Person(int id, String name, double height) { this.id = id; this.name = name; this.height = height; } //把属性写进去 public void write(RandomAccessFile raf) throws IOException { raf.write(id); //int型的怎么写都不会出错了 raf.writeUTF(name); //可能含中文，指定下编码，不过写到文件里打开看可能还是会乱码，因为这个只能保证读回来的时候不乱 raf.writeDouble(height); } } public static void main(String[] args) throws IOException { RandomAccessFile raf = new RandomAccessFile(&quot;d:/data.txt&quot;,&quot;rw&quot;); Person p = new Person(1001,&quot;xiaoming&quot;,1.80d); p.write(raf); } } 指定方式打开 读取文件 我们把刚才那个文件读回来，先给Person类加个read方法。注意：读取的时候一定要严格按照写入的顺序，用相应的数据类型读取方式来读 public void read(RandomAccessFile raf) throws IOException { this.id = raf.readInt(); this.name = raf.readUTF(); this.height = raf.readDouble(); } 注意，读的时候保证指针在开头 public static void main(String[] args) throws IOException { RandomAccessFile raf = new RandomAccessFile(&quot;d:/data.txt&quot;, &quot;rw&quot;); Person p = new Person(1001, &quot;xiaoming&quot;, 1.80d); p.write(raf);// 写入文件后，任意访问文件的指针在文件的结尾 raf.seek(0);// 读取时，将指针重置到文件的开始位置。 Person p2 = new Person(); //等着接收文件内容 p2.read(raf); System.out.println(&quot;id=&quot; + p2.getId() + &quot;;name=&quot; + p2.getName() + &quot;;height=&quot; + p2.getHeight()); } 结果 id=1001;name=xiaoming;height=1.8 追加内容 直接把游标设置到末尾就可以了 public static void main(String[] args) throws IOException { RandomAccessFile raf = new RandomAccessFile(&quot;D:/out.txt&quot;,&quot;rw&quot;); raf.seek(raf.length()); raf.write(&quot;\\r\\n中国移动阅读基地&quot;.getBytes()); } 结果 插入内容 插入的话需要先把目标位置后面的内容读入缓存文件，然后追加新内容，最后把原内容写回来 private static void insert(String fileName,long pos,String content) throws IOException { //创建临时空文件 File tempFile = File.createTempFile(&quot;temp&quot;,null); //在虚拟机终止时，请求删除此抽象路径名表示的文件或目录 tempFile.deleteOnExit(); FileOutputStream fos = new FileOutputStream(tempFile); RandomAccessFile raf = new RandomAccessFile(fileName,&quot;rw&quot;); raf.seek(pos); byte[] buffer = new byte[4]; int num = 0; while(-1 != (num = raf.read(buffer))) { fos.write(buffer,0,num); } raf.seek(pos); raf.write(content.getBytes()); FileInputStream fis = new FileInputStream(tempFile); while(-1 != (num = fis.read(buffer))) { raf.write(buffer,0,num); } }","categories":[],"tags":[]},{"title":"","slug":"PreparedStatement","date":"2019-04-30T08:25:45.647Z","updated":"2018-04-18T11:42:06.459Z","comments":true,"path":"2019/04/30/PreparedStatement/","link":"","permalink":"http://47.107.237.149/2019/04/30/PreparedStatement/","excerpt":"","text":"Statement要拼接sql语句，很麻烦","categories":[],"tags":[]},{"title":"","slug":"ppt","date":"2019-04-30T08:25:45.644Z","updated":"2018-05-28T11:19:00.417Z","comments":true,"path":"2019/04/30/ppt/","link":"","permalink":"http://47.107.237.149/2019/04/30/ppt/","excerpt":"","text":"设置图片为背景：右键背景格式 组合文字与图片：框柱就行了","categories":[],"tags":[]},{"title":"","slug":"postman模拟post请求的4中请求体","date":"2019-04-30T08:25:45.640Z","updated":"2019-03-29T09:29:26.847Z","comments":true,"path":"2019/04/30/postman模拟post请求的4中请求体/","link":"","permalink":"http://47.107.237.149/2019/04/30/postman模拟post请求的4中请求体/","excerpt":"","text":"简介 post请求的body中可以存放任意格式的内容格式，浏览器可以根据请求头中的content-type对请求体进行解析。 form-data 即multipart/form-data，它将表单的数据组织为key-value格式，用分隔符boundary（可任意设置）处理成一条信息。 由于有boundary隔离，所以既可以上传参数，也可以上传文件。 例如设置以下参数： 则形成post报文如下： POST HTTP/1.1 Host: test.app.com Cache-Control: no-cache Postman-Token: 59227787-c438-361d-fbe1-75feeb78047e Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW //filekey参数： ------WebKitFormBoundary7MA4YWxkTrZu0gW //分隔符 Content-Disposition: form-data; name=&quot;filekey&quot;; filename=&quot;&quot; Content-Type: ------WebKitFormBoundary7MA4YWxkTrZu0gW //textkey参数： Content-Disposition: form-data; name=&quot;textkey&quot; tttttt ------WebKitFormBoundary7MA4YWxkTrZu0gW-- x-www-form-urlencoded 即application/x-www-form-urlencoded,也是key-value的数据形式，以&amp;连接多个数据。 例如设置以下参数： 形成报文如下： POST HTTP/1.1 Host: test.app.com Content-Type: application/x-www-form-urlencoded Cache-Control: no-cache Postman-Token: e00dbaf5-15e8-3667-6fc5-48ee3cc89758 key1=value1&amp;key2=value2 raw 可以上传任意格式的文本，如text、json、xml、html。 例如设置参数如下： 形成post报文如下： POST HTTP/1.1 Host: test.app.com Content-Type: application/json Cache-Control: no-cache Postman-Token: 05a064d2-fa79-10c0-caba-15ca5d1a940f {&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;} binary 即content_type:application/octet-stream。只支持二进制数据，通常用于上传文件。由于没有键值，所以一次只能上传一个文件。 例如上传文件如下: 形成post如下： POST HTTP/1.1 Host: test.app.com Cache-Control: no-cache Postman-Token: 5ad66f08-6faa-aba0-744a-ca958b1a0fc2 undefined 参考文章","categories":[],"tags":[]},{"title":"","slug":"postman测试普通接口","date":"2019-04-30T08:25:45.636Z","updated":"2019-03-29T07:09:40.726Z","comments":true,"path":"2019/04/30/postman测试普通接口/","link":"","permalink":"http://47.107.237.149/2019/04/30/postman测试普通接口/","excerpt":"","text":"如果需要登录验证的话，可以先在浏览器打开登录页面和开发人员工具-&gt;network，勾选Preserve log，键入登录信息后，获取Cookie 或者（好像是这个方法通用） 将cookie加入请求参数中 输入url，post请求则将参数加在body中，get则加在url后面。一般来说controller的请求很少指定请求方式，任何请求方式都是可以的（实际好像就是get） 带文件的接口则是这样加文件参数","categories":[],"tags":[]},{"title":"","slug":"postman测试登录接口","date":"2019-04-30T08:25:45.633Z","updated":"2019-03-29T07:14:32.537Z","comments":true,"path":"2019/04/30/postman测试登录接口/","link":"","permalink":"http://47.107.237.149/2019/04/30/postman测试登录接口/","excerpt":"","text":"首先在浏览器访问，输入账号密码登录后打开开发人员工具获取登录信息 打开postman选择get/post,输入访问地址，Authorization（授权）选择No Auth 选择Body-&gt;form-data设置登录信息.注意，键要与前面截图中的键完全一致。 点击send发送即可登录成功","categories":[],"tags":[]},{"title":"","slug":"Path类、Files类","date":"2019-04-30T08:25:45.620Z","updated":"2018-11-24T02:19:56.938Z","comments":true,"path":"2019/04/30/Path类、Files类/","link":"","permalink":"http://47.107.237.149/2019/04/30/Path类、Files类/","excerpt":"","text":"简介 java7中文件IO发生了很大的变化，专门引入了很多新的类 import java.nio.file.DirectoryStream; import java.nio.file.FileSystem; import java.nio.file.FileSystems; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.attribute.FileAttribute; import java.nio.file.attribute.PosixFilePermission; import java.nio.file.attribute.PosixFilePermissions; 等等，来取代原来的基于java.io.File的文件IO操作方式 其中Path就是用来取代File的，我们以前用File包装文件路径、构建文件，现在用Path则可以使用java7中的新特性来表示一个文件路径或者一个文件。 //以当前路径作为Path对象 Path p = Paths.get(&quot;.&quot;); //使用get来从一个路径字符串构造Path对象 //使用传入的字符串返回一个Path对象 Path p2 = Paths.get(&quot;D&quot;,&quot;ReviewIO&quot;,&quot;URL&quot;); //等同于 Path p2 = Paths.get(&quot;D:\\\\ReviewIO\\\\URL&quot;); //对应的路径 System.out.println(&quot;p对象的对应路径：&quot; + p.toString()); System.out.println(&quot;p2对象的对应路径：&quot; + p2.toString()); //路径数量是以路径名的数量作为标准 System.out.println(&quot;p路径数量：&quot; + p.getNameCount()); System.out.println(&quot;p2路径数量：&quot; + p2.getNameCount()); //获取绝对路径 System.out.println(&quot;p绝对路径：&quot; + p.toAbsolutePath()); System.out.println(&quot;p2绝对路径：&quot; + p2.toAbsolutePath()); //获取父路径 System.out.println(&quot;p父路径：&quot; + p.getParent()); System.out.println(&quot;p2父路径：&quot; + p2.getParent()); //获取p2对象的文件名或者文件目录名 System.out.println(p2.getFileName()); //通过Path对象返回一个分隔符对象 Spliterator&lt;Path&gt; split = p2.spliterator(); 与File、URI的转换 URI u = URI.create(&quot;file://C:/Xmp/dd&quot;); Path p = Paths.get(u); File file = new File(&quot;C:/my.ini&quot;); Path p1 = file.toPath(); p1.toFile(); file.toURI(); 检测文件是否存在 Path target2 = Paths.get(&quot;C://mystuff.txt&quot;); try { if(!Files.exists(target2)) Files.createFile(target2); } catch (IOException e) { e.printStackTrace(); } 读取字符文件 BufferedReader reader=Files.newBufferedReader(Paths.get(&quot;D://test4.txt&quot;),StandardCharsets.UTF_8); //比原来的FileInputStream，然后BufferedReader包装，等操作简单的多了 char[] buffer=new char[20]; String info=null; int len=0; while ((info=reader.readLine())!=null){ //因为reader读的只能是纯文本，纯文本大多都有分行 System.out.println(info); } reader.close(); 写字符到文件 BufferedWriter writer=Files.newBufferedWriter(Paths.get(&quot;D://test4e.txt&quot;)); //不指定编码也可以 writer.write(&quot;测试文件写操作&quot;); writer.flush(); writer.close(); Files类 里面的读写、创建文件夹之类的静态方法比File要快 Files.createDirectory(Path path) Path path = Paths.get(&quot;data/subdir&quot;); try { Path newDir = Files.createDirectory(path); } catch(FileAlreadyExistsException e){ // the directory already exists. } catch (IOException e) { //something else went wrong like the parent doesn`t exsit e.printStackTrace(); } File.copy() Path sourcePath = Paths.get(&quot;data/logging.properties&quot;); Path destinationPath = Paths.get(&quot;data/logging-copy.properties&quot;); try { Files.copy(sourcePath, destinationPath); //把一个文件拷贝到另一个位置 } catch(FileAlreadyExistsException e) { //destination file already exists //如果补上第三个参数：StandardCopyOption.REPLACE_EXISTING则可以强制覆盖已存在的文件 } catch (IOException e) { //something else went wrong e.printStackTrace(); } Files.move()：移动文件也有重命名的效果 Path sourcePath = Paths.get(&quot;data/logging-copy.properties&quot;); Path destinationPath = Paths.get(&quot;data/subdir/logging-moved.properties&quot;); try { Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING); } catch (IOException e) { //moving file failed. e.printStackTrace(); } 指定强制覆盖还是报FileAlreadyExistsException的话可能是destinationPath开了流忘记关了 Files.delete(path)：删除文件或目录，注意，目录也可以","categories":[],"tags":[]},{"title":"","slug":"Optional类","date":"2019-04-30T08:25:45.609Z","updated":"2018-10-01T11:47:04.971Z","comments":true,"path":"2019/04/30/Optional类/","link":"","permalink":"http://47.107.237.149/2019/04/30/Optional类/","excerpt":"","text":"为了解决空指针异常 //Pre-Java 8 if(str!=null){ System.out.println(str); } //Java 8 Optional.ofNullable(str).ifPresent(System.out::println); Optional实际上是一个容器，可以保存任意类型的值，或者仅保存null。Optional提供很多有用的方法，这样我们就不用显示进行空指针检测。 它比if语句好在代码可读性更好，而且它提供的是编译时检测，能极大的降低NPF。 Optional.of()或者Optional.ofNullable()：创建Optional对象，差别在于of不允许参数是null，返回一个包含参数的Optional对象；而ofNullable则无限制，为null则返回一个不包含值的Optional对象（底层是根据参数为null否来选择调用of()/empty()。 // 参数不能是null Optional&lt;Integer&gt; optional1 = Optional.of(1); // 参数可以是null Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); //返回null // 参数可以是非null Optional&lt;Integer&gt; optional3 = Optional.ofNullable(2); Optional.empty()：返回一个不包含值的Optional对象： Optional&lt;Integer&gt; optional1 = Optional.ofNullable(null); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); System.out.println(optional1 == optional2);// true System.out.println(optional1 == Optional.&lt;Integer&gt;empty());// true Object o1 = Optional.&lt;Integer&gt;empty(); Object o2 = Optional.&lt;String&gt;empty(); System.out.println(o1 == o2);// true isPresent()：判断值是否存在 Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); // isPresent判断值是否存在 System.out.println(optional1.isPresent() == true); System.out.println(optional2.isPresent() == false); ifPresent(Consumer consumer)：如果option对象保存的值不是null，则调用consumer对象，否则不调用（调用指的是重写Consumer接口的方法，重写了什么内容就照着执行） Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); // 如果不是null,调用Consumer optional1.ifPresent(new Consumer&lt;Integer&gt;() { @Override public void accept(Integer t) { System.out.println(&quot;value is &quot; + t); } }); // null,不调用Consumer optional2.ifPresent(new Consumer&lt;Integer&gt;() { @Override public void accept(Integer t) { System.out.println(&quot;value is &quot; + t); } }); orElse(value)：如果optional对象保存的值不是null，则返回原来的值，否则返回value Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); // orElse System.out.println(optional1.orElse(1000) == 1);// true System.out.println(optional2.orElse(1000) == 1000);// true orElseGet(Supplier supplier)：功能与orElse一样，只不过orElseGet参数是一个对象 Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); System.out.println(optional1.orElseGet(() -&gt; { return 1000; }) == 1);//true System.out.println(optional2.orElseGet(() -&gt; { return 1000; }) == 1000);//true orElseGet(Supplier supplier)：功能与orElse区别在于，orElseGet()传入的参数为一个Supplier接口的方法重写，当Optional中有值时，返回值；否则返回从Supplier获得的值。 Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); System.out.println(optional1.orElseGet(() -&gt; { return 1000; }) == 1);//true System.out.println(optional2.orElseGet(() -&gt; { return 1000; }) == 1000);//true orElseThrow()：值不存在则抛出异常，存在则什么不做。好处在于我们可以决定抛出什么样的异常，而不总是NPE。用途举例：查询某个实体时，如果数据库中不存在该记录就可以抛出EntityNotFoundException，处理EntityNotFoundException的方法中我们可以给客户端返回404状态码和异常信息。 Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); optional1.orElseThrow(()-&gt;{throw new IllegalStateException();}); try { // 抛出异常 optional2.orElseThrow(()-&gt;{throw new IllegalStateException();}); } catch(IllegalStateException e ) { e.printStackTrace(); } filter(Predicate)：判断Optional对象中保存的值是否满足Predicate，是则返回原来的Optional对象，否则返回空的Optional。 Optional&lt;Integer&gt; optional1 = Optional.ofNullable(1); Optional&lt;Integer&gt; optional2 = Optional.ofNullable(null); Optional&lt;Integer&gt; filter1 = optional1.filter((a) -&gt; a == null); Optional&lt;Integer&gt; filter2 = optional1.filter((a) -&gt; a == 1); Optional&lt;Integer&gt; filter3 = optional2.filter((a) -&gt; a == null); System.out.println(filter1.isPresent());// false System.out.println(filter2.isPresent());// true System.out.println(filter2.get().intValue() == 1);// true System.out.println(filter3.isPresent());// false get()：从Optional实例中取回实际值对象,实例不存在抛出NPE String name=&quot;John&quot;; Optional&lt;String&gt; opt=Optional.ofNullable(name); assertEquals(&quot;John&quot;,opt.get()); map()：返回一个Optional对象，它包含的是函数式接口的返回值，如果返回值为null则这个Optional就是一个空Optional对象 源码 应用 User user=new User(&quot;anna@gmaiil.com&quot;,&quot;1234&quot;); String email=Optional.ofNullable(user); .map(u -&gt; u.getEmail()) .orElse(&quot;default@gmail.com&quot;); assertEquals(email,user.getEmail()); flatMap()：用法上和map()相同，但参数要求必须是Optional对象 Optional&lt;String&gt; username=Optional.ofNullable(getUserById()) .flatMap(user -&gt; Optional.of(user.getUsername())) .flatMap(name -&gt; Optional.of(name.toLowerCase())); 用法 假设有一个Person类，含有Address属性，Address属性包含code字段 //Person类 public class Person { private Address address; public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } } //Address类 public class Address { private String code; public String getCode() { return code; } public void setCode(String code) { this.code = code; } } //检查这些属性是否是valid的，可以看到，篇幅很长 private boolean validAddress(Person person){ if(person!=null){ //第一层判断 if(person.getAddress()!=null){ //第二层 String code=person.getAddress().getCode(); return code!=null; //第三层 }else{ return false; } }else{ return false; } } 但如果预先就将这些属性设置为Optional（或者在判断时构造为Optional），那么看起来会稍微舒服一点 //Person类 public class Person { private Optional&lt;Address&gt; address; public Optional&lt;Address&gt; getAddress() { return address; } public void setAddress(Optional&lt;Address&gt; address) { this.address = address; } } //Address类 public class Address { private Optional&lt;String&gt; code; public Optional&lt;String&gt; getCode() { return code; } public void setCode(Optional&lt;String&gt; code) { this.code = code; } } //判断 private boolean validAddress2(Person person2){ Optional&lt;Person&gt; person=Optional.ofNullable(person2); return person.flatMap(Person::getAddress) .flatMap(Address::getCode) .filter(x -&gt; x.length()&gt;6) .isPresent(); } 代码实例：SpringMvc02/Test1、Person、Address","categories":[],"tags":[]},{"title":"","slug":"Object泛型数组转化为具体类型数组与泛型擦除","date":"2019-04-30T08:25:45.605Z","updated":"2018-10-24T04:10:34.921Z","comments":true,"path":"2019/04/30/Object泛型数组转化为具体类型数组与泛型擦除/","link":"","permalink":"http://47.107.237.149/2019/04/30/Object泛型数组转化为具体类型数组与泛型擦除/","excerpt":"","text":"举个栗子，ArrayList的toArray方法 list.toArray()：将list直接转为Object[]数组，要想转回原类型必须一个元素一个元素强转 list.toArray(T[] a)：将list转化为与入参数组类型一致的数组 用第一个方法 ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++){ list.add(&quot;&quot;+i); } String[] array=(String[])list.toArray(); //报错:[Ljava.lang.Object; cannot be cast to [Ljava.lang.String 不能把Object[]转为任意类型数组，只能一个一个转 那为什么编译不报错呢？这是因为编译期间认为任何转型都是正确的 运行时报错也不是一定的，如果这个数组中的所有父类元素原本就是由子类对象转换来的，那么要将这些父类对象转回子类就没问题 Object[] arr=list.toArray(); for(int i=0;i&lt;arr.length;i++){ String e=(String)arr[i]; } 第二个方法虽然不用强转但是需要自定义一个对应类型的数组传进去 String[] arr=list.toArray(new String[list.size()]); for(String a:arr){ System.out.println(a); } 可不可以直接把链表传进去然后判断它的类型再转为对应数组呢？ public static&lt;T&gt; T[] toArray(List&lt;T&gt; list){ //由于泛型擦除，即使在运行的时候虚拟机也不知道T是什么，只把他当成Object一样处理，所以即使运行时也不报错 T[] t=(T[])new Object[list.size()]; for(int i=0;i&lt;list.size();i++){ t[i]=list.get(i); } //所以返回的其实还是Object数组 return t; } 调用它还是要先用Object数组接收再一个个转为String","categories":[],"tags":[]},{"title":"","slug":"OAuth2","date":"2019-04-30T08:25:45.601Z","updated":"2019-03-19T12:59:00.071Z","comments":true,"path":"2019/04/30/OAuth2/","link":"","permalink":"http://47.107.237.149/2019/04/30/OAuth2/","excerpt":"","text":"是什么 开放授权，令牌token代替密码访问。 其实就是授权登录，允许通过其他平台的账号去登录另一平台，比如用QQ登录豆瓣。 OAuth实际是一种授权的协议，只要授权方和被授权方遵守这个协议去写代码提供服务，那双方就是实现了OAuth模式。 允许用户让第三方应用反问该用户在另一平台上存储的资源（如照片、视频。联系人列表），而无需向第三方应用透露用户名和密码。 举个栗子，你不曾在豆瓣注册账号，但是又想登录豆瓣，那么你可以把你的QQ号授权给豆瓣登录。 在豆瓣点击QQ登录： 跳转到QQ登录页面输入信息，点击授权并登录： 跳回豆瓣页面，登录成功： 上述例子中的豆瓣就是客户端，QQ就是认证服务器，OAuth2.0就是客户端和认证服务器之间由于相互不信任而产生的一个授权协议。（要是信任的话QQ岂不是要把数据库整个交给豆瓣去做用户验证。） 参考文章 为什么不直接在豆瓣输入账号密码然后去QQ哪里获取用户数据呢？因为这样做有很多严重的缺点，其中一点就是豆瓣需要明文保存用户的账号和密码，这样很不安全，而且只要有一个类似豆瓣的平台被破解，就会导致用户信息泄露。 OAuth2角色 资源所有者Resource Owner 资源服务器Resource Server 授权服务器Authorization Server 客户端Client 资源所有者 代表授权给客户端来访问本身资源信息的用户，也就是以上例子中要登录豆瓣的用户。 资源/授权服务器 资源服务器托管了受保护用户的账号信息，而授权服务器验证用户身份然后为客户端派发访问令牌Token。 在上述例子中，QQ既是资源服务器（个人信息和通讯录等即为资源），也是授权服务器。而实际上不同服务器往往独立部署。协同保护用户账户信息资源。 客户端 意图访问受限资源的第三方应用。在访问之前，它必须先经过用户授权，获取授权凭证Grant，进一步由授权服务器进行验证。 授权流程 第一步中的Grant有4中type： Authorization Code：授权码模式，功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与验证服务器进行互动。 implicit grant type：简化模式。 Resource Owner Password Credentials Grant：密码模式。 Client Credentials Grant：客户端模式。 以授权码模式具体到上述例子流程为： 在豆瓣官网点击用QQ登录的小图标时，实际上是向豆瓣的服务器发起了一个http://www.douban.com/leadToAuthorize的请求。 豆瓣服务器响应一个重定向地址http://www.qq.com/authorize?client_id=123050457758183callback=www.douban.com/callback，指向QQ授权登录，其中client_id参数为豆瓣事先在QQ注册的应用id，callback参数则是QQ登录成功后浏览器能找到原始要访问的地址。 浏览器接收到这个重定向地址后向qq服务器发起授权请求。 蓝色箭头：QQ服务器接收到豆瓣发来的authorize，响应以qq登录页面，要求浏览器提供用户许可。 黄色箭头：用户输入信息后提交表单给QQ服务器。 QQ服务器验证成功后会响应浏览器一个重定向地址，并附带一个授权码code。 浏览器接收到重定向地址，发起请求http://www.douban.com/callback?code=2559200ecd7ea433f067a2cf67d6ce6c。 豆瓣服务器收到请求后，用拿到的code模拟浏览器向qq服务器索取token。获取token十分重要，一般采用post，请求token的url为POST https://api.qq.com/oauth2/getToken,包含如下参数： client_id:应用id。 client_secret：在应用OAuth2之前，必须在授权方服务中注册你的应用，QQ就是一个OAuth实现平台，开发者向它提供应用名称（豆瓣）、应用网站和回调url。注册成功后，授权方服务将以client_id和client_secret的形式为应用发布client credentials（客户端凭证）。client_id是公开的、用于识别应用程序的唯一标识，client_secret用于验证应用身份，并且在客户端和服务之间保持私有性。 grant_type: 值为“authorization_code”,即许可类型。 code：上一步获得的code。 redirect_url:回调地址。 QQ服务器返回token： //参数用json返回，且头信息中会明确指定不许缓存 { &quot;access_token&quot;: &quot;ACCESS_TOKEN&quot;,//Token 的值 &quot;expires_in&quot;: 1234,//过期时间；过期后需重新授权登录， 或使用refresh_token重新申请（一般用在不间断连续在线） &quot;uid&quot;:&quot;12341234&quot;//当前授权用户的账号id。 } 再用拿到的token索取用户信息，如获取用户昵称和头像：GET https://api.weibo.com/2/users/show.json?access_token&amp;uid qq服务器返回用户信息。 最后将用户信息存储起来，返回给浏览器首页。到此OAuth2.0授权结束。 参考文章 参考了OAuth2角色的介绍 实现 现有的Java版的对OAuth2协议的实现有： 资料较多的是Apache oltu和spring security aouth,因为是开源的。 oltu更轻量、更简单，是对OAuth2的简单实现，很多后续校验的事情都需要我们自己去做，但这也是它灵活的一面。","categories":[],"tags":[]},{"title":"","slug":"Nosql","date":"2019-04-30T08:25:45.597Z","updated":"2019-03-21T09:31:58.515Z","comments":true,"path":"2019/04/30/Nosql/","link":"","permalink":"http://47.107.237.149/2019/04/30/Nosql/","excerpt":"","text":"简介 Not Only Sql，指非关系型数据库。 我们常用的mysql、sqlserver都是关系型数据库，这些数据库一般都用来存储重要信息，应对普通的业务是没有问题的。但是，随着互联网的高速发展，传统的关系型数据库在应该超大规模、超大流量和高并发时力不从心，此时，Nosql则得到了高速的发展。 存储方式：关系型数据库是表格式的，存储在表的行列中，各表之间很容易关联协作存储，提取数据也方便。而Nosql则是大块的组合在一起，通常存储在数据集中，包括文档、键值对和图结构。 存储结构：关系型数据库对应的是结构化数据，数据表先定义好结构，描述好数据的形式和内容。虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。而Nosql基于动态结构，使用非结构化数据，可以很容易地适应数据类型和结构的变化。 存储规范：关系型数据库为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作涉及到多张表时。就显得很麻烦。而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分开，而是存储成一个整体，这样整块数据更便于读写。 参考文章 Nosql代表 MongoDB、Redis、Memcache。 适用场景 数据库表schema经常变化。比如在线商城，产品的属性经常要添加字段，这就意味着ORmapping（object relation mapping，对象关系映射）层的代码和配置要更改，如果该表的数据量过百万，新增这段就会带来额外的开销（重建索引等）。Nosql应用在这种场景，可以极大地提升db的可伸缩性。 数据表字段是复杂数据类型。比如xml类型的字段，不管是查询还是更改，效率都非常一般。主要是db层对xml字段很难建高效索引，应用层又要做从字符流到dom节点的解析转换。Nosql以json方式存储，提供了原生态的支持，在效率方面元高于关系型数据库。 高并发数据库请求。关系型数据库的事务以及大表join反而成了性能杀手。大多数情况下，用Nosql会更快。 海量数据的分布式存储。海量数据的存储如果选用大型商用数据库，如Oracle，成本将非常高。而Nosql分布式存储，可以部署在廉价的硬件上，性价比非常高。 Nosql和sql的结合 实际上Nosql只是sql在性能、扩展上的一个弥补，单从功能上讲，sql能实现其所有功能。 所以我们一般会把Nosql和sql结合起来使用，需要关系特性时我们使用关系型数据库，而需要Nosql特性时我们才使用Nosql。 比如用户评论的存储，字段大概有主键id、评论对象aid、内容content和用户uid等字段。我们能确定的是评论内容content肯定不会在数据库中用where content = ‘’查询，因为这是一个大文本字段。 那么我们可以把id、aid和uid存储在sql，content存储在Nosql，这样数据库就节省了存储content占用的磁盘空间，从而节省大量io，对content也更容易做cache。 查询content时，先从mysql中查询主键id集合：commentIds=DB.query(“SELECT id FROM comments where aid=’评论对象id’ LIMIT 0,20”)；然后根据主键id集合从Nosql取出评论内容CommentsList=NoSQL.get(commentIds)。 列入一些配置的关系键值对映射、用户名和密码、session会话存储等等，用Nosql完全可以代替sql。","categories":[],"tags":[]},{"title":"","slug":"NIO","date":"2019-04-30T08:25:45.592Z","updated":"2018-11-25T07:31:51.791Z","comments":true,"path":"2019/04/30/NIO/","link":"","permalink":"http://47.107.237.149/2019/04/30/NIO/","excerpt":"","text":"设计目的 NIO的设计目的是为了让Java程序员可以少些很多代码而实现高速的IO。NIO自动实现填充和提取缓冲区的转移工作。我们只要写一个循环将数据写入一个指定容量的缓冲区，需要写入到外部文件则一次性写入即可。 缓冲区通常是一个字节数组，但也可以指定任何类型的数组。 在不加字节数组循环读取文件的时候，IO实际是一个字节一个字节地读取的，输出也是一个字节一个字节地输出，这很耗费时间。而一个数组一个数组地读取无疑要快得多。数据流动过程 任何来源地的数据都要先通过一个channel对象，然后读取到Buffer（缓冲区）中； 去到任何目的地的数据都要先读取到缓冲区中，然后写入通道。 也就是说，你永远不会讲字节直接写入通道中，而是将它们写入一个缓冲区。同样，你不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这些字节。 若果一个Channel类实现了ReadableByteChannel接口，说明它是可读的，WritableByteChannel则可写，都实现了则可读可写。 两种获取channel对象的方法 使用Channels抽象类：ReadableByteChannel newChannel(InputStream in) 通过经典的io类来获取实践 读文件： FileInputStream关联文件 从FileInputStream获取channel对象 创建Buffer缓冲区 从channel循环读取数据到缓冲区 关闭通道 FileInputStream fin=new FileInputStream(&quot;d://test4.txt&quot;); //从FileInputStream获取通道 FileChannel fc=fin.getChannel(); //创建缓冲区 ByteBuffer buffer=ByteBuffer.allocate(1024); //allocate：分配 //将数据从通道读到缓冲区中 int len=0; while ((len = fc.read(buffer))!=-1){ //初始化游标 buffer.flip(); byte[] bytes=buffer.array(); String info=new String(bytes); System.out.println(info); //sout:每执行一次会把光标置于下一行首位，下一次执行会在这个位置打印，否则就会在文本后面多出一个空行 //清空数组 buffer.clear(); } fc.close(); 写文件 关联目标文件 获取通道 创建Buffer 循环读取数据到缓冲区 写入通道 关闭通道 FileOutputStream fout=new FileOutputStream(&quot;d://test4b.txt&quot;); //从FileOutputStream中获取一个通道 FileChannel foutc=fout.getChannel(); //创建一个缓冲区 ByteBuffer buffer1=ByteBuffer.allocate(1024); //单位是B，1024B=1KB //数据源 String message=&quot;Pigpig is my sister!&quot;; //将数据读取到缓冲区 buffer1.put(message.getBytes()); //缓冲区自动为message分配空间 //或者这样准备数据源 /* ByteBuffer buffer3=Charset.forName(&quot;utf-8&quot;).encode(&quot;你好 你好 你好 你好 你好！&quot;); */ //初始化游标 buffer1.flip(); //从缓冲区写入通道 foutc.write(buffer1); foutc.close(); flip()：把position游标（指向下一个要读取获取存入的位置）置于数组首位，读取的时候会从游标位置开始读取，否则游标还在末位，所以必须刷出 拷贝文件：循环读取数据源到缓冲区，一次性写入目标文件 FileInputStream fin2=new FileInputStream(&quot;d://test4.txt&quot;); FileOutputStream fout2=new FileOutputStream(&quot;d://test4c.txt&quot;); FileChannel finc2=fin2.getChannel(); FileChannel foutc2=fout2.getChannel(); ByteBuffer buffer2=ByteBuffer.allocate(1024); int len=0; while ((len = finc2.read(buffer2))!=-1){ //初始化游标 buffer2.flip(); foutc2.write(buffer2); //清空数组 buffer2.clear(); } fout2.close(); finc2.close(); clear()：将游标置为0，limit（还能存多少）置为容量，但数组内容并没有真正清空；否则上个循环的数据还在里面，导致数组不可用；不过上面还是需要flip()，因为read之后游标会跑到最后去 ByteBuffer：最常用的缓冲区类型；不只是一个数组，还提供了对数据的结构化访问，可以跟踪系统的读写进程。 Java提供的缓冲区类型，它们实现了Buffer接口： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer阻塞和非阻塞 阻塞： Scanner sc=new Scanner(System.in); int i=sc.nextInt(); 在返回之前，当前线程会被挂起，一直处于等待状态 阻塞IO：一旦输入、输出工作没有完成，则程序阻塞，知道输入、输出完成为止。 非阻塞：非阻塞IO并非完全非阻塞，只是设置了超时来读取数据，未超时之前程序阻塞，超时之后，程序结束 传统的IO都是阻塞的，当一个线程被read()或write()时，该线程被阻塞，知道有数据被请求到，否则该线程不能执行其他任务。所以，万一请求资源被占用，整个程序就相当于卡死了。比如当缓冲区里没有数据的时候，线程会一直等待。属于同步阻塞IO。 NIO是非阻塞模式的，请求不到资源的时候线程可以执行其他任务。但是线程需要是不是去询问是否能请求到资源，从而引起不必要的CPU资源浪费当缓冲区没有数据的时候，线程一直返回0，直到有了再返回读到的数据。NIO属于同步非阻塞IO。 不过启用非阻塞模式是需要额外的代码的，好像不是默认的。 异步阻塞IO：程序发起一个IO操作后，就去做其他事情了，不等待IO操作完成，等内核完成IO操作后会通知程序。那为什么说是阻塞的呢？因为它是通过select系统调用来实现的，而select函数本身的实现方式是阻塞的。而采用select函数的好处就是它可以同时监听多个文件句柄，从而提高系统的并发性。 异步非阻塞：好像和异步阻塞也差不多，看不出有什么区别Selector 实现监听的效果，通过一个线程管理多个channel，从而实现管理多个网络连接的目的。它是NIO核心组件中的一个，用于检查一个或者多个channel的状态是否处于非阻塞（可读|可写），我们可以将channel注册到selector中，以实现selector对其管理的目的。 NIO写大文件直接用channel+ByteBuffer分块写入/** * @Author haien * @Description nio分块写大文件,耗时近30秒 * @Date 2018/11/24 **/ public class WriteBigFile { //待写入内容总大小 private static final long LEN=2L*1024*1024*1024; //2G //每次写多少进去 private static final int DATA_CHUNK=128*1024*1024; //128M;chunk：块 public static void writeWithFileChannel() throws IOException { File file=new File(&quot;e:/fc.dat&quot;); if(file.exists()){ file.delete(); } //用任意访问的方式打开文件，指定要来读写它 RandomAccessFile raf=new RandomAccessFile(file,&quot;rw&quot;); FileChannel fileChannel=raf.getChannel(); //存储待写入内容 byte[] data=null; //缓冲数组 ByteBuffer buf=ByteBuffer.allocate(DATA_CHUNK); //单位转换，128*1024*1024B-&gt;128M int dataChunk=DATA_CHUNK/1024/1024; //未写入的内容大小 long len; for(len=LEN;len&gt;DATA_CHUNK;len-=DATA_CHUNK){ System.out.println(&quot;Write a data chunk: &quot;+dataChunk+&quot;MB&quot;); buf.clear(); data=new byte[DATA_CHUNK]; //省略数据准备 for(int i=0;i&lt;DATA_CHUNK;i++){ //把数据放到缓冲区里来 buf.put(data[i]); } //清空数据存储区 data=null; buf.flip(); //从缓冲区写入通道 fileChannel.write(buf); //把通道里的内容强制刷出 fileChannel.force(true); } //最后一次可能不足DATA_CHUNK if(len&gt;0){ System.out.println(&quot;Write rest data chunk: &quot;+len/1024/1024+&quot;MB&quot;); //剩下的比较少，可以从本地内存中分配 buf=ByteBuffer.allocateDirect((int)len); data=new byte[(int)len]; for(int i=0;i&lt;len;i++){ buf.put(data[i]); } buf.flip(); fileChannel.write(buf); fileChannel.force(true); data=null; } fileChannel.close(); raf.close(); } } channel.force(true)：将通道里的数据强制刷出 ByteBuffer.allocateDirect(): 在本地内存中分配缓冲区 ByteBuffer.allocate()：在jvm堆中分配 本地缓冲区又叫直接缓冲区，相对堆缓冲区性能较高，但是本地的内存不能被jvm垃圾回收机制回收，而是自动调用JNI方法回收。 由于垃圾回收成本较高，堆内存未耗尽时，jvm不会回收垃圾。如果为堆分配过大的内存（也即是使用allocateDirect），本地内存就会相应减少。堆缓冲区的性能已经相当高，只有确实需要再提高性能时才考虑使用本地缓冲区。 本例即是最后只剩一点没写才使用本地缓冲区。channel.map()+MappedByteBuffer 一般操作系统的内存分为两部分：物理内存和虚拟内存。虚拟内存一把指使用的是页面映像文件，即硬盘中的某些特殊的文件。操作系统负责页面文件内容的读写，这个过程叫页面中断/借还。 MapppedByteBuffer也是类似的，，它直接将文件映射到内存（虚拟内存）。通常可以映射整个文件，如果文件比较大的话可以进行分段映射。 channel.map(int mod,long start,long size): 把文件从start开始的size大小的部分映射为内存映射文件,返回MappedByteBuffer，mode指定该内存映像文件的访问方式： READ_ONLY READ_WRITE: 对返回的缓冲区的更改将传播到文件 PRIVATE：对返回的缓冲区的更改不会传播到文件 相比ByteBuffer，它读写更快，而且可以随时随地写入。 内含的缓冲区是直接缓冲区，所以被它打开的文件只有在垃圾收集时才会被关闭，而这个点是不确定的，在此之前MapppedByteBuffer的对象一直持有文件的句柄。 channel把MapppedByteBuffer map出来但却不提供unmap方法，所以我们自己实现一个来释放文件的句柄。 //48s public static void wirteWithMappedByteBuffer() throws IOException { File file=new File(&quot;e:/mb.dat&quot;); if(file.exists()){ file.delete(); }else{ file.createNewFile(); } RandomAccessFile raf=new RandomAccessFile(file,&quot;rw&quot;); FileChannel fileChannel=raf.getChannel(); byte[] data=null; int start; MappedByteBuffer mbb=null; long len; int dataChunk=DATA_CHUNK/1024/1024; for(start=0,len=LEN;len&gt;=DATA_CHUNK;len-=DATA_CHUNK,start+=DATA_CHUNK){ System.out.println(&quot;Write a data chunk: &quot;+dataChunk+&quot;MB&quot;); mbb=fileChannel.map(FileChannel.MapMode.READ_WRITE,start,DATA_CHUNK); data=new byte[DATA_CHUNK]; mbb.put(data); data=null; } if(len&gt;0){ mbb=fileChannel.map(FileChannel.MapMode.READ_WRITE,start,DATA_CHUNK); data=new byte[DATA_CHUNK]; mbb.put(data); data=null; } //release MappedByteBuffer unmap(mbb); fileChannel.close(); } /** * @Author haien * @Description 一般用了MappedByteBuffer之后都是这样释放资源的，淡单单channel.close()是不够的 * @Date 2018/11/24 * @Param [mappedByteBuffer] * @return void **/ public static void unmap(final MappedByteBuffer mappedByteBuffer){ try { if (mappedByteBuffer == null) { return; } //把残留的内容强制刷出 mappedByteBuffer.force(); AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override @SuppressWarnings(&quot;restriction&quot;) public Object run() { try { Method getCleanerMethod = mappedByteBuffer.getClass() .getMethod(&quot;cleaner&quot;, new Class[0]); getCleanerMethod.setAccessible(true); sun.misc.Cleaner cleaner = (sun.misc.Cleaner) getCleanerMethod .invoke(mappedByteBuffer, new Object[0]); cleaner.clean(); } catch (Exception e) { e.printStackTrace(); } return null; } }); }catch (Exception e){ e.printStackTrace(); } } ByteArrayINputstream+channel/** * @Author haien * @Description 中间转换成字节数组再写入文件 19s * @Date 2018/11/25 * @Param [] * @return void **/ public static void writeWithByteArray() throws IOException { File file=new File(&quot;e:/ba.dat&quot;); if(file.exists()){ file.delete(); }else{ file.createNewFile(); } RandomAccessFile raf=new RandomAccessFile(file,&quot;rw&quot;); FileChannel fileChannel=raf.getChannel(); //数据准备 byte[] data=null; //把数据包装为字节数组 ByteArrayInputStream bis=null; //把字节数组转化为流 ReadableByteChannel byteChannel=null; long len=0; long start=0; //单位转换 int dataChunk=DATA_CHUNK/1024/1024; for(len=LEN;len&gt;=DATA_CHUNK;len-=DATA_CHUNK,start+=DATA_CHUNK){ System.out.println(&quot;Write a data chunk: &quot;+dataChunk+&quot;MB&quot;); //数据准备 data=new byte[DATA_CHUNK]; //包装成字节数组输入流 bis=new ByteArrayInputStream(data); //获取通道 byteChannel =Channels.newChannel(bis); //写到目标文件的channel中 fileChannel.transferFrom(byteChannel,start,DATA_CHUNK); //transferFrom:将其他通道从start字节开始写指定字节数到文件通道中 data=null; } if(len&gt;0){ System.out.println(&quot;Write rest data chunk: &quot;+len/1024/1024+&quot;MB&quot;); data=new byte[(int)len]; bis=new ByteArrayInputStream(data); byteChannel=Channels.newChannel(bis); fileChannel.transferFrom(fileChannel,start,len); data=null; } fileChannel.close(); byteChannel.close(); } 参考文章","categories":[],"tags":[]},{"title":"","slug":"Nginx负载均衡服务器","date":"2019-04-30T08:25:45.588Z","updated":"2019-04-27T06:19:47.214Z","comments":true,"path":"2019/04/30/Nginx负载均衡服务器/","link":"","permalink":"http://47.107.237.149/2019/04/30/Nginx负载均衡服务器/","excerpt":"","text":"简介 Engine X，一种web服务器，和Apache是同行。 Apache是一个重量级的、不支持高并发的服务器。 Nginx是一个轻量级高并发的服务器。 Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器。Nginx可以作为一个HTTP服务器进行网站的发布处理，也可以作为反向代理进行负载均衡的实现。 正向代理（forward proxy） 位于国外的某些网站通过浏览器是没有办法直接访问的，此时可以用一个操作FQ进行访问。FQ的方式主要是找到一个可以访问国外网站的代理服务器，将请求发送给代理服务器，它会去访问国外的网站，然后将访问到的数据返回给我们。 简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 这样的代理模式称为正向代理，其特点是客户端非常明确要访问的服务器地址；而服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端。正向代理模式屏蔽或者隐藏了真实客户端信息。 此外，使用代理服务器还有以下好处： 提高访问速度：由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对热门网站能明显提高访问速度。 防火墙作用：由于所有客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中用户可以隐藏自己的ip，免受攻击。 突破访问限制：也就是上面说的访问外网。互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点。通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。 反向代理 例如某宝网站由于访问量爆表，单个服务器远远不能满足需求，此时就会采用分布式部署，也就是通过部署多台服务器来解决访问人数限制的问题。 多个客户端给服务器发送请求，Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时，请求的来源也就是客户端是明确的，但是请求具体是由那台服务器处理的并不明确，Nginx扮演的就是一个反向代理的觉得。 简单地说，A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 反向代理，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。 区别 位置不同 正向代理，架设在客户机和目标主机之间。 反向代理，架设在服务器端。 代理对象不同 正向代理，代理客户端，服务端不知道实际发起请求的客户端 反向代理，代理服务端，客户端不知道实际提供服务的服务端 负载均衡 实际项目中，反向代理和正向代理一般是存在于一个应用场景的。正向代理客户端请求访问目标服务器，目标服务器是一个反向代理服务器，反向代理了多台真实的业务处理服务器。 而将接收到的请求按照一定的规则分发的过程，称为负载均衡。 参考文章 安装教程 安装目录：E:/nginx 使用nginx实现负载均衡 nginx只负责拦截并转发客户端发起的请求，并不做页面的解析工作等，因为它没有处理servlet请求的能力，这些必须交给tomcat等servlet容器实现。所以在nginx上部署web项目必须配合tomcat实现，除非这个项目只有前端页面。 通过修改配置文件nginx.conf（其注释符号为#）达到访问nginx代理服务器时跳转到指定服务器的目的。 用proxy_pass配置请求的转发地址，当我们输入指定请求时将会跳转到该服务器。 upstream tomcat_server{ server localhost:8080; /*配置多个服务器则：其中weight表示权重，即被访问几率； 当第一个server挂掉时，自动访问第二个。 server localhost:8080 weight=2; server 192.168.101.9:8080 weight=1; */ } server{ #监听端口 listen 80; #主机名 server_name localhost; #路径“/”表示默认的http://localhost:80，需要替换成应用的路径，如/chapter23-server location / { #跳转到http://localhost:8080，即部署在tomcat的域名:端口号 proxy_pass http://tomcat_server #配置静态资源（jpg|png|css|js...）,浏览器访问http://localhost:80/1.png时， 自动到服务器F:/nginx-1.12.2/static目录下找1.png图片 root F:/nginx/static; index index.html index.htm; } } 修改后需在nginx目录下执行nginx -s reload令改变生效。 将应用部署到tomcat后，访问localhost/chapter23-server，即访问到该项目（地址栏不会改变）。 参考文章","categories":[],"tags":[]},{"title":"","slug":"nexus","date":"2019-04-30T08:25:45.580Z","updated":"2019-04-19T06:19:17.709Z","comments":true,"path":"2019/04/30/nexus/","link":"","permalink":"http://47.107.237.149/2019/04/30/nexus/","excerpt":"","text":"简介 maven的私服，其实有三种专门的maven仓库管理软件可以帮助我们创建私服，这里重点介绍nexus。 说是私服，其实就是maven的一个远程仓库。 我们知道maven有本地仓库和中央仓库，那么nexus是什么样的仓库呢？ 一个项目需要插件的时候回先去本地仓库找，没有再去中央找，找到后下载到本地后再使用。 nexus实际是架设在局域网内的仓库服务，它代理广域网上的所有的中央仓库，供局域网内的maven用户使用。 就好比外部所有的“中央仓库”是一个大的油库，自己家里有个油壶，家里的这个小油壶就是“本地仓库”，nexus就是在中间建立的一个小的中转站——商店。这样，外部的所有油库都可以把油放到商店中，我们根据需要把油打到油壶里面。 maven访问中央是需要外网支持的，在不提供外网或者网速很慢的情况下，很有必要在局域网内搭建nexus私服，让它代理广域网上的中央仓库。 所以，当项目中需要某些插件的时候，它会先去本地仓库查找，没有就从nexus请求，如果私服nexus也没有，则从外部的中央仓库下载，缓存到nexus中，再下载到本地仓库中供项目使用。此外，一些无法在中央仓库下载的插件也能从本地上传到nexus中供使用。 安装 目前安装在E盘。 访问官网点击Products下拉Nexus Repository OSS 点击红色按钮 下载2.x版本比较好，拉到最下面 这个就行了 以管理员身份运行start.dat，记住一定要管理员 浏览器访问http://localhost:8081/nexus，看到以下页面则安装成功 点击右上角log in，默认用户名：admin，密码：admin123 然后开始下载nexus索引的更新 我们不在这个网站上直接下载，我们自己找安装包下载 首先下载indexer-cli-5.1.1.jar包 然后到[这个网址]拉到最后下载这个 都下载到同一个目录下，然后在cmd中进入此目录运行： java -jar indexer-cli-5.1.1.jar -u nexus-maven-repository-index.gz -d indexer 需要较久时间，运行完后会出现一个indexer文件夹，把它copy到E:\\nexus-2.10.0-02-bundle\\sonatype-work\\nexus\\indexer\\central-ctx，全部覆盖，然后重启nexus，到刚才那个网站上就可以看到 接下来我们整合maven和nexus 到maven的安装目录下找到settings.xml（应该有两个，一个是原本的，一个是自己的仓库的，两个都要） 添加私服仓库 *的意思是所有的请求都走这个镜像 上面的url相当于下面第一个的Path 配置 idea端如果还是有一些依赖找不到的话，点击settings,把两个仓库都给update了，remoteupdate不了也没关系 上面setting.xml修改之后，在idea中运行maven install或其他指令，如果日志显示jar包是通过我们配置的url来下载的话，那么配置就算成功 否则直接把setting.xml替换成下面这样： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;E:/java/maven/maven-dependcies&lt;/localRepository&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public&lt;/url&gt; &lt;!--这一行如果注释掉的话则默认直接从远程仓库下载，而不经过私服--&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;/id&gt; &lt;url&gt;http://central&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/settings&gt; 参考文章1 参考文章2 非中央仓库的jar包无法获取到 有些jar包由于版权问题，中央仓库中没有，比如Oracle JDBC驱动、一些比较老的开源jar包等，我们需要手动把它们上传到私服。 自己公司开发的jar包并不开源，也需要手动上传 到Maven Repository查找该jar并下载以下4个文件到本地仓库即可（不过放在哪个文件夹下要自己搞清楚） 私服的数据源 初始情况下，数据源都是中央仓库，但直接从中央仓库https://repo1.maven.org/maven2/（目前配置的就是这个）下载的话实在是太慢了（其实就目前的体验来说还好），不考虑。 国内稳定的镜像有http://maven.oschina.net/content/groups/public/和http://mirrors.ibiblio.org/maven2/，还有http://maven.aliyun.com/nexus/content/groups/public，缺点是更新中央某些新版jar包要慢一些，其中oschina较快。 设置数据源Remote Storage Location： 配置完不知道要不要重启动的说 lastUpdate文件 maven下载jar包失败会生成这样一个文件，这个需要删掉，maven才会重新尝试下载jar包 删掉之后在idea中reimport，如果多次尝试都像上面一样失败的话，大多是出于网络原因，可以直接把setting.xml的url注释掉，这样就会直接取到相应的远程中央仓库下载，应该就能成功。最后再取消注释即可。","categories":[],"tags":[]},{"title":"","slug":"MySQL之一","date":"2019-04-30T08:25:45.576Z","updated":"2019-03-13T03:41:00.625Z","comments":true,"path":"2019/04/30/MySQL之一/","link":"","permalink":"http://47.107.237.149/2019/04/30/MySQL之一/","excerpt":"","text":"sql格式 String sql=”select * from t_shop where user_id=”+user.getUserId()+” and id=”+goods.getShopId()+””; String sql=”select * from t_goods where name like ‘%”+search+”%’and status!=’已下架’ order by sale DESC,id DESC”; String sql = “update t_user set userName=’”+user.getUserName()+”‘,email=’”+user.getEmail()+”‘,number=’”+user.getNumber()+”‘ where id=”+user.getUserId()+””; String sql = “insert into t_order (status,user_id,totalPrice) values(“+order.getStatus()+”,”+user.getUserId()+”,”+order.getTotalPrice()+”)”; String sql=”delete from t_cart where user_id=”+userId+””; String sql2 = “update t_user set password=SUBSTRING(md5(‘“+user.getPassword()+”‘),1,16) where userName=’”+user.getUserName()+”‘“; //截取第一位到第16位共16位密文存入数据库，否则长度32位太长无法插入 String status=”已下架”;String sql = &quot;update t_goods set status=&apos;&quot;+status+&quot;&apos; where id=&quot;+goodsId+&quot;&quot;; 获取刚插入记录的id sql = &quot;insert into t_role (name) values(&apos;&quot;+role+&quot;&apos;)&quot;; pstmt = con.prepareStatement(sql); //获取插入后生成的角色ID，但只能是mysql自增长的 pstmt.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS); rs = pstmt.getGeneratedKeys(); if(rs.next()) { roleId=rs.getInt(1); //第一个就是刚生成的id } //代码实例：market2/AdminDao/417行 /** * @Author haien * @Description 获取刚添加用户的id（根据上下文，不会因并发而出错） * @Date 2019/1/17 * @Param [] * @return int **/ @Query(&quot;select last_insert_id from users&quot;) int getLastInsertId(); MySQL代码操作 直接插入格式： String sql=”insert into t_book value(null,’java牛逼’,888,’B哥’,1)”; String sql = “insert into t_book value(null,’”+bookName+”‘,”+price+”,’”+author+”‘,”+bookTypeId+”)”;sql语句注意点 where前面不要加“,” 表名和字段名不要用关键字，通常在表名之前加t_是为了防止用到关键字。MySQL关键字 where column=’直接写值而不是变量’：注意要加个单引号MySQL将查找结果按时间降序排序sql=”select * from t_order where user_id=”+userId+” and status=1 order by orderTime DESC,id DESC”;sql的一些功能 用IN指定范围(NOT IN 不在该范围内的) 以上可用BETWEEN 21 AND 23代替（NOT BETWEEN AND）则表示不在范围内的 查询字段为空或不为空的 去重复，相同字段不显示，比如，都是一年级就只显示一次一年级 concat 聚合 查询每个年级人数 查询年级人数大于3的年级 with rollup 加一个总计，数字的话直接累加，字符的话全部显示 从第一条开始查询5条数据使用占位符? String sql2 = “insert into t_user values(null,?,?)”; //id值要设好，写(?,?)第一坑变成id pstmt = con.prepareStatement(sql2); pstmt.setString(1, user.getUserName());//给第一个问号设值 pstmt.setString(2, user.getPassword()); pstmt.executeUpdate(); //括号里不能有sql 检索某个数据是否已存在//验证用户是否已存在 String sql=&quot;select * from t_user where userName=?&quot;; PreparedStatement pstmt =null; pstmt=con.prepareStatement(sql); //检索用户名 pstmt.setString(1, user.getUserName()); User resultUser=null; ResultSet rs=pstmt.executeQuery(); if(rs.next()){ resultUser=new User(); resultUser.setUserName(rs.getString(&quot;userName&quot;)); resultUser.setPassword(rs.getString(&quot;password&quot;)); } //若用户已存在 if(resultUser!=null) { return false; } 完整sql语句请点击 执行mysql语句返回的int值，是指当前执行的sql语句所影响的行数n。如果执行的是update语句，那么就说明有n行被update了；若是删除操作，那么就说明有n条记录被删除了。 MySQL语句where=后面这个东西如果是个字符串一定要写好格式啊，写好了字符串会变成黑色，格式是’”+字符串+”‘’查询结果按中文姓名顺序排序 要把数据库查询到的记录按照人名排序，通常是按姓氏的拼音排序，可以采用MySQL的排序方式 @Query(value = &quot;select * from user order by convert(name using gbk) asc&quot;,nativeQuery = true) public List&lt;T&gt; find(); 注意：nativeQuery = true一定要写，否则sql的一些符号Spring认不出 name是排序的依据，using gbk是因为数据库已经被认为指定采用utf-8编码，但是只有gbk编码本身采用的是按拼音排序的方式（只有一级汉字是这样，二级汉字不是，但二级是生僻字也没事） 代码实例：JpaDemo/entity/Identity、Task、Project,repository/GenericDao/ProjectRepository,test/ProjectRepositoryTestMySQL快捷键 命令行：上下键切换命令 图形工具：f5刷新MySQL数据类型 char(10)，存放2位，但实际分配10位空间 varchar(10),存多少分配多少空间 函数 concat(str1,str2)：拼接字符串 select concat(str1,str2) from t_user; //str1、2为表字段 有一个str为null则函数返回null ifnull：判断是否为null并赋予一个默认值 select concat(ifnull(str1,&quot;defaultValue&quot;),str2) from t_user; //str1为null则用defaultValue代替str1 由于concat只能传入二个参数，且返回的依旧是str，所以当需要拼接多个字符串时可以嵌套使用 substring(str,startIndex,len)：字符串截取，len可省略，首位为1，从第startIndex位开始取，为负数则从倒数开始往右取。 substring_index(str,delim,count)：从第count个字符串delim开始截取之前所有字符。 //从第2个.开始截取之前all字符：www.example substring_index(&apos;www.example.com&apos;, &apos;.&apos;, 2); //从倒数第2个.开始截取之后all字符:example.com substring_index(&apos;www.example.com&apos;, &apos;.&apos;, -2); //找不到delim则返回all字符串: www.example.com substring_index(&apos;www.example.com&apos;, &apos;.coc&apos;, 1); left(str, length): 从左边开始截取length位字符串。 //exa left(&apos;example.com&apos;, 3); right(str, length): 从右边开始。 //com right(&apos;example.com&apos;, 3); mysql字符串截取 新建用户并设置权限 cmd直接在根目录运行mysql -uroot -p密码,登录mysql. 新建thz用户，密码111111，指定它只能访问thz数据库的所有表，但拥有所有访问权限 grant all privileges on thz.* to thz@&quot;%&quot; identified by &quot;111111&quot;; // %表示允许远程登录，只许本机登录的话这里换成localhost或127的那个 不想给所有权限的话all privileges可以替换成select,insert,update,delete这样用逗号连接，表示只能对表数据进行增删查改，不能改变表结构（删表、建表等） 对表结构进行更改的话是用create,drop等权限，还有几个权限自查吧！ 程序配置了该账户则拥有了这些权限： &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/shiro&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; 计算时间差 看个例子，将查询结果按给定时间从近到远排序 &lt;select id=&quot;findAllOrderByTime&quot; resultMap=&quot;GoodsResult&quot;&gt; select *,ABS(TIMESTAMPDIFF(second,#{_parameter},Report_Date_Time)) as diffTime from goods order by diffTime ASC &lt;/select&gt; ABS()：计算绝对值 TIMESTAMPDIFF(day/our/minute/… , str , str)：计算按时间格式输入的字符串的时间差 datediff(now(), ‘2015-04-20 00:00:00’): 计算时间差，返回结果以天为单位，不超过一天返回0 字符串与时间互转jdbc.url连接数据库 用localhost:3306固然可以，但实际数据库需要解析localhost，会比较耗时，最好用127.0.0.1，这是本地ip，会比较快。 远程连接 spring.datasource.url=jdbc:mysql://120.77.144.151/llcweb 这是师兄的服务器的数据库地址，省略了3306连接阿里云服务器上的远程数据库 默认情况下，CentOS的MySQL数据库是不允许被远程访问的，所以我们需要开启权限 登录数据库，使用MySQL系统自带的mysql数据库，它带有用户表 use mysql; 更新用户，允许所有ip访问，当然也可以设置特定的ip(一般是本地计算机的公网ip，不过不是127.0.0.1那个)，然后host就要改成特定的ip update user set host=&apos;%&apos; where user=&apos;root&apos;; ERRER 1062(23000): Duplicate entry &apos;%-root&apos; for key 1 //报错不要紧的 查询我们是否创建访问的host成功了 select host,user,password fron user; enum MySQL建表语句//选择一个数据库 drop database if exists shiro; create database shiro; use shiro; //开始建表 CREATE TABLE `award` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户id&apos;, `aty_id` varchar(100) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;活动场景id&apos;, `is_awarded` tinyint(1) NOT NULL DEFAULT 0 COMMENT &apos;用户是否领奖&apos;, `award_time` int(11) NOT NULL DEFAULT 0 COMMENT &apos;领奖时间&apos;, `password` char(32) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;密码&apos;, `created_time` int(11) NOT NULL DEFAULT 0 COMMENT &apos;创建时间&apos;, available bool default false, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&apos;获奖信息表&apos;; 约束 constraint：约束，主要是给约束取一个别名，否则系统会默认随机一个约束名 CREATE TABLE `users` ( `id` BIGINT(20) NOT NULL primary key AUTO_INCREMENT, //在这里声明主键 PRIMARY KEY (`id`), //或在这里 constraint pk_users primary key(id) //或这里，用constraint起别名，便于删除或修改此约束 ) //声明外键时也可以用constraint CONSTRAINT FK_post_author FOREIGN KEY (author_id) REFERENCES tbl_user (id) ON DELETE CASCADE ON UPDATE RESTRICT //简单形式 FOREIGN KEY (author_id)REFERENCES tbl_user (id) ON DELETE CASCADE ON UPDATE RESTRICT 代码实例：ideaProjects/shiroHelloWorld/shiro.sql 起别名select 字段1 as 字段1别名，字段2 as 字段2别名 from 表名 as 表别名","categories":[],"tags":[]},{"title":"","slug":"MySQL之二","date":"2019-04-30T08:25:45.572Z","updated":"2019-03-20T02:46:08.286Z","comments":true,"path":"2019/04/30/MySQL之二/","link":"","permalink":"http://47.107.237.149/2019/04/30/MySQL之二/","excerpt":"","text":"索引 索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。 索引包含表中所有记录的引用指针。通俗地说，数据库索引就好比是一本书前面的目录，能加快数据库的查询速度。在没有索引的情况下，数据库会遍历全部数据后选择符合条件的；而有了相应的索引后，数据库查找的对象就不是字段具体的值了，而是直接在索引中查找符合条件的选项。 比如，SELECT * FROM article WHERE id=2000000，没有索引的话数据库会按照顺序读完全部可能百万行数据后再给你结果，而有了索引则可以直接在索引中定位。 MySQL的索引分为单列索引：主键索引、唯一索引、普通索引；组合索引。 单列索引：一个索引只包含一个列，一个表可以有多个单列索引。 组合索引：一个索引包含两个或以上的列。 普通索引 //在创建表后添加索引 create index indexName on &apos;tableName&apos;(&apos;columnName&apos;(length)); //长度可省略 //char,varchar型字段，length可小于字段实际长度，blob，text型则必须指定长度 //or alter table tableName add index indexName(&apos;columnName&apos;(length)); //or:创建表时同时创建索引；其他索引也可以这样写 CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(50) NOT NULL, PRIMARY KEY (`id`), INDEX index_name (title) //columnName不需要引号;包含到title列的查询都会使用此索引 ) 唯一索引：与普通索引类似，但要求字段值唯一，这一点和主键索引一样，但是它允许有空值。如果程序插入一个重复的值进来将抛异常。 CREATE UNIQUE INDEX IndexName ON `TableName`(`ColumnName`(length)); //or ALTER TABLE TableName ADD UNIQUE (column_list); //or CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(50) NOT NULL, PRIMARY KEY (`id`), UNIQUE index_name (title) //columnName不需要引号 ) 主键索引：不允许空值。 组合索引：一个表中含有多个单列索引不代表是组合索引；组合索引包含多个字段但是只有索引名称。 CREATE INDEX IndexName On `TableName`(`字段名`(length),`字段名`(length),...); 以下相当于分别建立了两组组合索引 title,time title ALTER TABLE article ADD INDEX index_title_time (title(50),time(10)); 为什么没有time这个组合呢？这是因为MySQL组合索引的“最左前缀”。简单的理解就是所有的排列组合必须包含最左边的字段，所以并不是包含了这两列的查询都会用到该组合索引。 //使用到上面索引 SELECT * FROM article WHREE title=&apos;测试&apos; AND time=1234567890; SELECT * FROM article WHREE title=&apos;测试&apos;; //未使用 SELECT * FROM article WHREE time=1234567890; 索引的删除 DORP INDEX IndexName ON `TableName` 索引的查看 show index from tableName 参考文章 索引的缺点：索引本身也是表，占用的空间是数据表的1.5倍，虽然大大提高了查询速度，同时也会降低更新表的速度。如对表进行insert、update和delete时，MySQL不仅要保存数据，还要保存一下索引文件，不过一般情况下这个问题不太严重。 索引不会包含有null值的列：值要列中含有null值，那么这一列的索引将会失效。所以在设计数据库是尽量不要让字段的默认值为null。 不要再列上进行运算：例如，select from users where YEAR(adddate)&lt;2007，将对每一行进行运算，这将导致索引失效而进行全表扫描，可以改成：select from users where adddate&lt;’2007-01-01′。 只对以下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形) 参考文章 参考文章 获取新增记录的主键GeneratedKeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException { //第二个参数必须加，否则不会有字段返回 PreparedStatement psst = connection.prepareStatement(sql, new String[] { &quot;id&quot; }); return psst; } }, keyHolder); long id=(keyHolder.getKey().longValue()); //id是int型则intValue() 返回新增记录主键的主要方法 int update(PreparedStatementcreator psc,KeyHolder generatedKeyHolder) 其中，org.springframework.jdbc.support.KeyHolder是一个回调接口，使用它可保存新增记录对应的主键，方法有 //适用于返回的主键是能有一个，故复合主键、插入多条记录导致有多个主键返回的情况都抛异常 int update(PreparedStatementCreator psc,KeyHolder generatedKeyHolder) //适用于返回一个复合主键，故插入多条记录导致返回多个复合主键抛异常； //底层将此主键的字段名和字段值作为一个键值对保存到Map中，故返回的Map中至少有两个键值对 Map&lt;String,Object&gt; getKeys() throws InvalidDataAccessApiUsageException //返回多个（复合）主键，即插入了多条记录，每条记录对应一个Map，多个Map对应一个List List&lt;Map&lt;String ,Object&gt;&gt; getKeyList() 包含其他获取方法 prepareStatement(sql, new String[] { “id” })：指定新增后要返回的某个自动生成的值，如果该sql不是insert语句则忽略此数组。前提是DataBaseMetaData.supportGetGeneratedKeys()返回true的话，即jdbc驱动程序支持insert之后返回自动生成的值。第二个参数可以是String[] columnNames(自动生成值的字段名)、int[] columnINdexes(自动生成值的字段索引)。 原生jdbc String sql=&quot;insert into deptliu values(seq_dept_id.nextval,?,?)&quot;; PreparedStatement ps=conn.prepareStatement(sql,new String[]{&quot;deptno&quot;}); ps.setString(1,dname); ps.setString(2,loc); ps.executeUpdate(); //获取自动生成的字段 ResultSet rs=ps.getGeneratedKeys(); //获取deptno字段 rs.next(); int deptno=rs.getInt(1); 如果报错：java.sql.SQLException: 不支持的特性，则可能是jdbc版本太低，升级即可 关联表建立与否 如，用户表和角色表之间是多对多的关系，我们可能会想到建立一张中间关联表来映射两者关系，但其实简单来讲，只要在用户表中增加“角色id列表”字段role_ids，列出所有角色即可,如role_ids=1,2,3. 如要查询拥有某角色的用户时，才建议建立关联表，否则没有必要。 菜单树形结构 表字段包含父id和祖先ids分别指出该记录中该实体的父亲和祖先们分别是谁。 总公司没有父亲，parent_id和parent_ids都指向不存在的0号id记录，也就是说根结点为0； 山东分公司父亲为总公司parent_id=1，parent_ids=0/1； 济南分公司父亲为山东分公司parent_id=2。 命名规则 数据库所有命名都应该用小写，多个单词用”_”分隔。 同一数据库，不同表要有统一的命名前缀。","categories":[],"tags":[]},{"title":"","slug":"MySQL语句","date":"2019-04-30T08:25:45.557Z","updated":"2018-11-08T08:14:36.414Z","comments":true,"path":"2019/04/30/MySQL语句/","link":"","permalink":"http://47.107.237.149/2019/04/30/MySQL语句/","excerpt":"","text":"t_student：每个学生都有个年龄、姓名、性别字段 t_grade：每个学生都出现三次，分别对应他们考试的科目和分数 //查询特定属性出来 select id,name from t_student; //跟等于同效 select * from t_student where name like &apos;张三&apos;; //当然还有not like //以“张三”开头的 select * from t_student where name like &apos;张三%&apos;; //以“张三”开头且后面只有两位的 select * from t_student where name like &apos;张三__&apos; //注意是两根下划线 //范围，包括首尾 select * from t_student where age in(21,23); //当然还有not in select * from t_student where age between 21 and 23; //not between //is null select * from t_student where sex is null; //not null //分组 select * from group By gradeName; //只能查出每个年级第一个出现的那个学生 //分组+聚合 select gradeName,group_concat(stuName) from t_student group by gradeName; //group_concat：把每个年级的所有学生都列出来，用逗号分隔 select gradeName,count(stuName) from t_student group by gradeName; //把每个年级的所有学生姓名统计出来（重复不算） //不超过3个不查出来 select gradeName,count(stuName) from t_student group by gradeName having count(stuName) &gt;3; //在查出来的记录后面多加一行总计 select gradeName,count(stuName) from t_student group by gradeName with rollup; //如果是文本的话则多加一行把所有的名字都打印出来 select gradeName,group_concat(stuName) from t_student group by gradeName with rollup; //从第几条开始查多少条出来 select * fron t_student limit 0,5; //统计 select count(*) from t_grade; //统计每个学生出现了几次（这样就可以知道每个学生参加了几门课程） select count(*) from t_grade group_by stuName; //求张三的总分(换成avg就是求平均分了) select stuName sum(score) from t_grade where stuName=&quot;张三&quot;; //求每个人的总分 select stuName,sum(score) from t_grade group by stuName; //找出张三的哪一科分数最高，最高多少 select stuName,course,max(score) from t_grade where stuName=&apos;张三&apos;; //找出每个学生的最高分 select stuName,max(score) from t_grade group by stuName; //不能加course，因为group by要求查出来的字段必须是group by后面的字段，它按什么来分组的就只能出现什么字段 连接查询：将两个或两个以上的表按照某个条件连接起来 select * from t_book,t_bookType; //t_book中有一个类型字段引用的是第二张表的id，不过它不是外键；尽管两张表没有关联，但是类型有几个，书就要重复出现几次，每次对应一个类型，符合笛卡尔乘积的结果 内连接查询是最常用的一种连接查询 select * from t_book,t_bookType where t_book.bookTypeId=t_bookType.id; //书有基本，查出来就有几条，而且连带着它们对应的类型也查出来 //起别名 select tb.bookName,tb.author,tby.bookTypeName from t_book tb,t_bookType tby where tb.bookTypeId=tby.id; 外连接 //左连接：查出第一张表的所有数据，第二张表的匹配数据 select * from t_book left join t_booktype on t_book.bookTypeId=t_bookType.id; //把所有书都列出来，如果有的书没有设置类型的话那就用默认值（null之类）代替 //右连接 select * from t_book right join t_booktype on t_book.bookTypeId=t_bookType.id; 子查询 select* from t_book where booktypeId in (select id from t_booktype); //查出来的类型id必须在书本类型的范围内 select * from t_book where price&gt;=(select from t_pricelevel where pricelevel =1); //如果子查询有结果则继续外层查询，否则外层查询不执行 select * from t_book where exist (select * from t_booktype); //not exist //满足任意一个条件 select * from t_book where price&gt;=any (select price from t_pricelevel); //满足所有条件(其实就是必须大于最大的) select * from t_book where price&gt;=all (select price from t_pricelevel); union //把两张表的id字段都合并 select id from t_book union select id from t_booktype; //比如第一张表有1,2,3，第二张有1,2,6，则结果为1,2,3,6 //不去重 select id from t_book where all select id from t_booktype;","categories":[],"tags":[]},{"title":"","slug":"MySQL下载、建库与导入文件命令","date":"2019-04-30T08:25:45.553Z","updated":"2019-03-20T02:42:45.755Z","comments":true,"path":"2019/04/30/MySQL下载、建库与导入文件命令/","link":"","permalink":"http://47.107.237.149/2019/04/30/MySQL下载、建库与导入文件命令/","excerpt":"","text":"最好是用TopView师兄给的安装包和说明书安装，安装好了如果不需要控制台操作的话好像不用配置环境变量。 顺便下载师兄给的安装包里面图形工具就能链接数据库了。 再不济还有参考文章 环境变量配置（配置了才能在cmd用mysql -u root -p登录，否则只能在图形界面登录） 初始状态下，mysql是MySQL自带的数据库，带有用户表，我们可以添加用户并授权 命令 登录 mysql -u账号(一般是root) -p密码（一般是123456） //首次登录-p后直接回车，提示输入m密码也直接回车即可登录 使用不同的账号与密码相当于选择了不同的会话连接： 退出（三种） mysql &gt; exit; //分号记得 mysql &gt; quit; mysql &gt; \\q; 查看 show databases; //查看所有数据库 use database; //选择数据库 show tables; //展示库中all表 desc table_name; //查看表结构 show table status from db like 条件; //查看engine数据库引擎、version、row、index等信息 /*查询数据库运行状态*/ show full processlist; show status like &apos;%Max_used_connections%&apos;; show status like &apos;%Threads_connected%&apos;;#当前连接数 show status like &apos;%table_lock%&apos;;#表锁定 show status like &apos;innodb_row_lock%&apos;;#行锁定 show status like &apos;%qcache%&apos;; #查询缓存情况 show variables like &quot;%query_cache%&quot;; SHOW STATUS LIKE &apos;Qcache%&apos;; show variables like &quot;%binlog%&quot;; show status like &apos;Aborted_clients&apos;;#由于客户没有正确关闭连接已经死掉，已经放弃的连接数量 show variables like &apos;%max_connections%&apos;;//查看最大连接数量 show variables like &apos;%timeout%&apos;;#查看超时时间 show variables like &apos;log_%&apos;; #查看日志是否启动 创建数据库 create database baseName; //不知道为什么就是不能包含- create database shiro-aaa; //创建失败，但是在图形界面中创建却成功了 导入sql文件 source d:/dbname.sql 插入中文报错ERROR 1366 报错：ERROR 1366 (HY000): Incorrect string value: ‘\\xE7\\x8E\\x9E\\x97’ for column。 原因：字符集错误。 可以直接修改整个mysql的字符集： mysql&gt; set character_set_client=utf8; mysql&gt; set character_set_connection=utf8; mysql&gt; set character_set_database=utf8; mysql&gt; set character_set_results=utf8; mysql&gt; set character_set_server=utf8; mysql&gt; set character_set_system=utf8; //最后collation的这几条好像会报错，不过没事 mysql&gt; set collation_connection=utf8; mysql&gt; set collation_database=utf8; mysql&gt; set collation_server=utf8; 或者单独修改库、表乃至字段的字符集","categories":[],"tags":[]},{"title":"","slug":"MySQL数据类型","date":"2019-04-30T08:25:45.542Z","updated":"2019-02-25T04:10:25.791Z","comments":true,"path":"2019/04/30/MySQL数据类型/","link":"","permalink":"http://47.107.237.149/2019/04/30/MySQL数据类型/","excerpt":"","text":"整数类型 tinyInt：MySQL没有boolean类，但是建表语句中：locked boolean，却可以创建成功。原因是mysql最终把locked字段替换成tinyInt，用1表示true，0表示false。 integer：跟int一毛一样 int：21亿，跟Java的int一样大 bigint：跟Java的long一样大 一般都是直接默认有符号的，确定自己的数据都是非负数要用无符号的话需要特别声明 小数 日期与时间 中间三个最常用，date是日期，time是时间，datetime是日期+时间 timestamp：1970年开始，2038年终止字符 enum：定义了只能放哪几个数据进来就只能放着几个，否则报错；很少用，一般都是在程序里控制 set：类似枚举，但是他能同时放多个指定的数据进来二进制类型 一般都是把二进制文件存在别的地方，然后只存一个路径到数据库，除非这个文件是机密性的，因为存到数据库会影响性能。 可变长指根据实际的数据长度分配空间","categories":[],"tags":[]},{"title":"","slug":"Mybatis与Spring、SpringMvc整合一之配置文件详解","date":"2019-04-30T08:25:45.539Z","updated":"2019-03-31T07:19:52.247Z","comments":true,"path":"2019/04/30/Mybatis与Spring、SpringMvc整合一之配置文件详解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Mybatis与Spring、SpringMvc整合一之配置文件详解/","excerpt":"","text":"说是整合，其实就是Spring把SqlSession给管理了 WEB-INF下web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;MyBatisPro05&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--idea版文件头--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app&gt; &lt;display-name&gt;thzWeb&lt;/display-name&gt; &lt;!--idea会在webapp下自动生成index.jsp，而且不用声明为欢迎首页， 自动默认为首页--&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置文件位置，也可以是.properties文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;!--默认加载路径：/WEB-INF/applicationContext.xml。 classpath即resources，一般会在resources下建config包， 则写为classpath:config/applicationContext.xml--&gt; &lt;!--连同spring-mvc.xml一起声明了， 加*主要是当配置比较多的时候可能要拆成很多个配置文件， 比如单独一个数据源的、spring security的； 只能像下面这么写，不能拆成两个context-param节点写，会报错 &lt;param-value&gt;/WEB-INF/spring*.xml /WEB-INF/applicationContext*.xml&lt;/param-value&gt; 比如写了一个spring-security.xml，但是不想在这里引入， 也可以在applicationContext.xml中引入： &lt;beans:import resource=&quot;spring-security.xml&quot;/&gt; --&gt; &lt;/context-param&gt; &lt;!-- Spring监听器：启动时会注册一些事件，然后监控系统的请求情况 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- SpringMvc DispatcherServlet前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;!--上面配置文件位置用*声明的话就不用该节点了--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!--rest风格的url一般都没有后缀了，可以写成:/*或/表示拦截all--&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- session监听--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.security.web.session.HttpSessionEventPublisher &lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- session过期时间 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;1800&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;/web-app&gt; 参考文章 src下配置文件- applicationContext.xml：整个项目的Spring配置文件。配置要扫描的包、数据源、SqlSession、事务管理和切面等，代替Spring中的bean.xml，因为bean的注入工作交给注解了，但是以上的配置依然不可或缺，所以就搬到这个文件来，但是文件名继续叫bean.xml就不恰当了。applicationContext，顾名思义也就是应用的上下文，像切面啦事务都是穿插在逻辑中的，都像上下文。 - 其中：&lt;context:component-scan base-package=&quot;XX&quot; /&gt; 表示扫描包，可以用通配符*和**，*表示扫描任意包下，**表示扫描任意包下或任意类 - 比如我在com.thz.各个层下开始写类，那么要扫描到这些类就应该这么写： &lt;context:component-scan base-package=&quot;com.thz.*.**&quot; /&gt; 也可以再声明一个节点: &lt;context:component-scan base-package=&quot;com.java1234.dao&quot; /&gt; &lt;!--扫描dao包及子包--&gt; &lt;context:component-scan base-package=&quot;com.java1234.service&quot; /&gt;/&gt; - 因为service下可能是impl包或者类 &lt;!--使用注解的包，包括子集--&gt; &lt;context:component-scan base-package=&quot;com.thz.controller&quot;/&gt; &lt;!-- 引用各模块的spring配置文件,只能是xml文件 --&gt; &lt;import resource=&quot;classpath:conf/partner/partner-spring.xml&quot; /&gt; &lt;!-- 指定Spring加载资源文件；在src下则用calsspath, 在WEB-INF下则用/WEB-INF/filename --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/bean&gt; &lt;!--数据源配置齐全版--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot;&gt; &lt;value&gt;jdbc:mysql://127.0.0.1:3306/Enterprise&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;username&quot;&gt;&lt;value&gt;root&lt;/value&gt;&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;&lt;value&gt;11111111&lt;/value&gt;&lt;/property&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;/bean&gt; 其中，context:component-scan还有一个属性use-default-filters,默认为true，表示使用默认过滤器，扫描包含@Service、@Component、@Repository、@Controller注解的类；为false则需用子标签include-filter指定扫描哪些类。 &lt;context:component-scan base-package=&quot;com.haien.shirochapter12.web&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--指定只扫描base-package下有@Controller的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--指定只扫描base-package下有@ControllerAdvice的类--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot;/&gt; &lt;/context:component-scan&gt; type和expression选值如下： 注：regex中./表示.；如： //以controller和service结束的类 &lt;context:include-filter type=&quot;regex&quot; expression=&quot;com\\.sparta\\.trans\\.[^.]+(Controller|Service)&quot;/&gt; 还有一个子标签context:exclude-filter,表示不扫描的类。 参考文章 spring-mvc.xml：配置要扫描的controller包和视图解析器，也就是处理接收请求和重定向。视图根目录是webapp，用./、../或classpath都找不到resources目录的，所以页面只能写在webapp下。 &lt;bean id=&quot;defaultViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--这个不写好像也没事--&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;!--默认为此--&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--启动SpringMvc注解功能，完成请求和注解Controller层的映射； 启用Flash属性，发送属性到重定向的页面--&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;!-- 配置Fastjson支持，否则controller返回值无法被解析为jsono传回前端 --&gt; &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;features&quot;&gt; &lt;list&gt; &lt;value&gt;WriteMapNullValue&lt;/value&gt; &lt;value&gt;QuoteFieldNames&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--如果用的是Jackson的话就换成这个--&gt; &lt;bean class=&quot;org.springframework.http.converter .json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; &lt;!--url映射视图，无需通过控制器--&gt; &lt;!-- 静态资源:因为在web.xml中拦截所有请求，但静态资源其实不需要被拦截的， 因此这里使用以下标签指定静态资源路径，凡是到指定路径下的文件，都不会被拦截--&gt; &lt;mvc:resources location=&quot;/WEB-INF/js/&quot; mapping=&quot;/js/**&quot;/&gt; &lt;mvc:resources location=&quot;/WEB-INF/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/WEB-INF/image/&quot; mapping=&quot;/image/**&quot;/&gt; mybatis-config.xml：给类起别名，方便映射文件引用实体类 log4j.properties：日志配置文件。因为applicationContext.xml中并没有引用此文件，所以在idea中只能放在resources根路径下才能识别到，而不能是根目录下的子目录里面 #输出级别最低为debug级别，后面为输出器名称 log4j.rootLogger=DEBUG, Console, Tofile, Exception #看网上命名好像都喜欢大写开头 #Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout # 可以灵活地指定布局模式 log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n # 灵活指定布局模式 #不是很懂，应该是打印sql语句吧 log4j.logger.java.sql.ResultSet=INFO log4j.logger.org.apache=INFO log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG #File log4j.appender.Tofile=org.apache.log4j.DailyRollingFileAppender #每天产生一个日志文件 log4j.appender.Tofile.layout=org.apache.log4j.PatternLayout log4j.appender.Tofile.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n log4j.appender.Tofile.File=logFile-%d{yyyy/MM/dd}.txt #路径，不能在前面加/，识别不了的；这么写就表示项目 #还可以单独打印个异常日志出来 log4j.appender.Exception = org.apache.log4j.DailyRollingFileAppender #当前目录的上一级目录，如果此配置文件在resources下，则当前目录为项目 log4j.appender.Exception.File = ../logs/springmvc-mybatis-demo_error.log log4j.appender.Exception.Append = true log4j.appender.Exception.Threshold = ERROR log4j.appender.Exception.layout = org.apache.log4j.PatternLayout log4j.appender.Exception.layout.ConversionPattern = [sspringmvc_mybatis_demo][%p] [%-d{yyyy-MM-dd HH:mm:ss}] %C.%M(%L) | %m%n 语法： log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN 其中，Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台）， org.apache.log4j.FileAppender（文件）， org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）， org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）， org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） ③配置日志信息的格式（布局），其语法为： log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.option = valueN 其中，Log4j提供的layout有以下几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局）， org.apache.log4j.PatternLayout（可以灵活地指定布局模式）， org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）， org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息 %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符，Windows平台为“ ”，Unix平台为“ ” %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) src下分包 其中dao层即mappers层，定义数据层接口 UserMapper.xml即其实现 //出现&lt;、&amp;符号都会报错，因为xml会把这两个符号解析回其他信息 &lt;if test=&quot;reportDateTime2!=null&quot;&gt;and Report_Date_Time &lt;= #{reportDateTime2}&lt;/if&gt; //把这种符号加到&lt;![CDATA[ ... ]]&gt;里面，指明不需要解析 &lt;if test=&quot;reportDateTime2!=null&quot;&gt;and Report_Date_Time &lt;![CDATA[ &lt;= ]]&gt; #{reportDateTime2}&lt;/if&gt; service.impl层对service层的实现一般是直接调用dao层定义的方法 代码实例：eclipse/SSM 集成tomcat 添加插件 &lt;build&gt; &lt;finalName&gt;${project.artifactId}&lt;/finalName&gt; &lt;!--默认是项目名-版本名--&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!--指定war文件名，在那么访问就要用这个来访问了； 不过不知道为什么这个属性在idea一直飘红--&gt; &lt;warName&gt;${project.build.finalName}&lt;/warName&gt; &lt;!-- 用默认的就可以 &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;server&gt;tomcat7&lt;/server&gt; --&gt; &lt;path&gt;/${project.build.finalName}&lt;/path&gt; &lt;!--一般是项目名称--&gt; &lt;/configuration&gt; &lt;!-- 用默认的就可以 &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;/execution&gt; &lt;/executions&gt; --&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 然后就可以使用mvn tomcat7:run运行webapp了 也可以在run config设置运行命令","categories":[],"tags":[]},{"title":"","slug":"Mybatis","date":"2019-04-30T08:25:45.530Z","updated":"2019-02-08T03:11:28.356Z","comments":true,"path":"2019/04/30/Mybatis/","link":"","permalink":"http://47.107.237.149/2019/04/30/Mybatis/","excerpt":"","text":"简介 一个orm框架，与Spring Data Jpa分庭抗礼。 项目整合Mybatis框架的话大部分公司使用mappers层代替dao层，定义一些增删查改的接口。代码实例 举个栗子，实现学生的增操作 先贴jar包：mybatis的jar包、MySQL的驱动包、log4j的jar包 写model包实体类； public class Student { private Integer id; private String name; private Integer age; //getter、setter } 配置mybatis-config.xml文件引入jdbc资源文件（待写）以配置数据源、给实体类起别名、配置映射器引入数据层接口的映射文件（待写）等； &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 引入资源文件，推荐 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 直接配置 --&gt; &lt;!-- &lt;properties&gt; &lt;property name=&quot;jdbc.driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; ... &lt;/properties&gt; --&gt; &lt;!-- 给类起别名 --&gt; &lt;typeAliases&gt; &lt;typeAlias alias=&quot;Student&quot; type=&quot;com.java1234.model.Student&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 推荐，扫描包，全部起类名为别名，不能自定义 --&gt; &lt;!-- &lt;typeAliases&gt; &lt;package name=&quot;com.java1234.model&quot;/&gt; &lt;/typeAliases&gt; --&gt; &lt;!-- 创建环境 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!-- 默认环境定义为开发环境，与下面的id对应 --&gt; &lt;!-- 创建一个名为development的环境 --&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 由jdbc实现事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据源为连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driverClassName}&quot; /&gt; &lt;!-- value取的是jdbc配置文件里的属性 --&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;!-- 一般还会创建生产、测试等环境 --&gt; &lt;/environments&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt; &lt;!-- 直接找到实体类的映射文件 --&gt; &lt;mapper resource=&quot;com/java1234/mappers/StudentMapper.xml&quot; /&gt; &lt;!-- 通过实体类找其配置文件，不要求配置文件也不用和实体类命名相同 --&gt; &lt;mapper class=&quot;com.java1234.mappers.StudentMapper&quot;/&gt; &lt;!-- 扫描包下所有配置文件，推荐 --&gt; &lt;package name=&quot;com.java1234.mappers&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; //jdbc.properties jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/db_mybatis jdbc.username=root jdbc.password=123456 dataSource UNPOOLED：没有连接池，每次数据库操作，mybatis都会创建一个新的连接，用完后关闭；适合小并发项目 POOLED：常用，可以定连接个数，每次都从连接池里拿一个连接，用完后放回去 JNDI：使用应用服务器配置JNDI数据源获取数据库连接 util包写session工厂类 /** * session工厂 * @author 14103 */ public class SqlSessionFactoryUtil { //静态域，类的所有实例共享一个sqlSessionFactory，一个对象对其修改则所有对象的该域都被修改 private static SqlSessionFactory sqlSessionFactory; //单例模式：获取session工厂 private static SqlSessionFactory getSqlSessionFactory() { if(sqlSessionFactory==null) { InputStream inputStream=null; try { //把mybatis的配置文件搞成输入流 inputStream=Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //用这个输入流来创建session工厂 sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); }catch(Exception e) { e.printStackTrace(); } } return sqlSessionFactory; } //打开一个session，相当于打开一个数据库连接 public static SqlSession openSession() { return getSqlSessionFactory().openSession(); //用返回的session工厂打开 } } mappers包写数据层接口（定义增删查改等接口方法） /** * 操作数据库的接口 * @author 14103 */ public interface StudentMapper { //返回影响的记录数,默认会返回影响行数的，不用在配置文件定义返回类型 public int add(Student student); public int update(Student student); public int delete(Integer id); public Student findById(Integer id); public List&lt;Student&gt; find(); } StudentMapper.xml实现这些接口 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 为指定接口中的方法配置sql语句 --&gt; &lt;mapper namespace=&quot;com.java1234.mappers.StudentMapper&quot;&gt; &lt;!-- 对应接口的完整路径 --&gt; &lt;!-- 定义一个集合，名为StudentResult --&gt; &lt;resultMap type=&quot;Student&quot; id=&quot;StudentResult&quot;&gt; &lt;!-- 定义主键 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;!-- 类属性与表字段对应 --&gt; &lt;!-- 定义普通字段 --&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findStudentWithAddress&quot; resultMap=&quot;StudentResult&quot; parameterType=&quot;Integer&quot;&gt; select * from t_student t1,t_address t2 where t1.id=#{id} and t2.id=t1.addressId &lt;!-- t2.id=t1.addressId，等号左右调换也一样;去掉t_address的查询也可以； 中括号内是属性而非字段名--&gt; &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Student&quot;&gt; &lt;!-- id是方法名，后面是入参类型（用的是mybatis配置文件的别名 --&gt; insert into t_student values(#{id},#{name},#{age}) &lt;!-- sql，大括号内是字段;id想要数据库自增的话可以只设置着占位（或者写个null） ，不传值，即实体类可以不setId,但是底层还是会调用占位的所有字段的getter， 所以实体类必须有它们的getter；不想占位可以写成： insert into t_student(name,age) values(#{name},#{age}) --&gt; &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Student&quot;&gt; update t_student set name=#{name},age=#{age} where id=#{id} &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;Integer&quot;&gt; delete from t_student where id=#{id} &lt;/delete&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultType=&quot;Student&quot;&gt; select * from t_student where id=#{id} &lt;/select&gt; &lt;select id=&quot;find&quot; resultMap=&quot;StudentResult&quot;&gt; &lt;!-- 返回类型为集合 --&gt; select * from t_student &lt;/select&gt; &lt;/mapper&gt; 如果parameterType(入参类型)是String的话，那么不能用#{xxx}（抛异常：there is no getter for property xxx)，而要用#{_parameter}. &lt;select id=&quot;fuzzySearch&quot; resultMap=&quot;GoodsResult&quot;&gt; //fuzzySearch只有一个参数且为string类 select * from goods where number=#{_parameter} or name like &apos;%${_parameter}%&apos; or type=#{_parameter} order by Report_Date_Time desc &lt;/select&gt; 配置log4j日志 &lt;!--根节点，指定日志等级及输出目标--&gt; log4j.rootLogger=info,appender1,appender2 log4j.appender.appender1=org.apache.log4j.ConsoleAppender log4j.appender.appender2=org.apache.log4j.FileAppender log4j.appender.appender2.File=C:/logFile.txt &lt;!--指定日志输出的布局模式--&gt; log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout log4j.appender.appender2.layout=org.apache.log4j.TTCCLayout 写测试类 /** * 用main做个测试 * @author 14103 */ public class StudentTest { private static Logger logger=Logger.getLogger(StudentTest.class); public static void main(String[] args) { //打开一个数据库连接 SqlSession sqlSession = SqlSessionFactoryUtil.openSession(); //传入一个含有数据库操作的接口，mybatis会把它和配置了sql的xml文件捆绑起来 StudentMapper studentMapper=sqlSession.getMapper(StudentMapper.class); Student student=new Student(3,&quot;李四&quot;,11); //然后这个接口的方法就能用了 int result=studentMapper.add(student); //直接传入对象，mybatis自动获取属性传入占位符 //提交事务 sqlSession.commit(); if(result&gt;0) { logger.info(&quot;添加成功！&quot;); } } } 一对一表关联 学生与地址之间的一对一关联 分别创建学生类、地址类 写学生类的数据层接口 public interface AddressMapper { public Address findById(Integer id); } 配置映射文件 &lt;mapper namespace=&quot;com.java1234.mappers.StudentMapper&quot;&gt; &lt;!-- 对应接口的完整路径 --&gt; &lt;!-- 定义一个返回结果集合，名为StudentResult --&gt; &lt;resultMap type=&quot;Student&quot; id=&quot;StudentResult&quot;&gt; &lt;!-- 定义主键 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;!-- 类属性与表字段对应 --&gt; &lt;!-- 定义普通字段 --&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;!-- 表关联，推荐；后面三种不推荐 --&gt; &lt;association property=&quot;address&quot; column=&quot;addressId&quot; select=&quot;com.java1234.mappers.AddressMapper.findById&quot;&gt; &lt;!-- 查到目标记录发现addressId字段时，会传入这个select方法中，从而查找到关联的地址并赋给address属性--&gt; &lt;/association&gt; &lt;association property=&quot;grade&quot; column=&quot;gradeId&quot; select=&quot;com.java1234.mappers.GradeMapper.findById&quot;&gt; &lt;/association&gt; &lt;!-- //对象级联 &lt;result property=&quot;address.id&quot; column=&quot;addressId&quot;/&gt; //要用主表的外键字段 &lt;result property=&quot;address.sheng&quot; column=&quot;sheng&quot;/&gt; //要用关联表的字段 &lt;result property=&quot;address.shi&quot; column=&quot;shi&quot;/&gt; &lt;result property=&quot;address.qu&quot; column=&quot;qu&quot;/&gt; --&gt; &lt;!-- //嵌套 &lt;association property=&quot;address&quot; javaType=&quot;Address&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sheng&quot; column=&quot;sheng&quot;/&gt; &lt;result property=&quot;shi&quot; column=&quot;shi&quot;/&gt; &lt;result property=&quot;qu&quot; column=&quot;qu&quot;/&gt; &lt;/association&gt; --&gt; &lt;!-- //直接关联，需要另外为Address定义一个结果集合（虽然是一对一，但是集合里面只有一个地址也没事的 &lt;association property=&quot;address&quot; resultMap=&quot;AddressResult&quot;/&gt; --&gt; &lt;/resultMap&gt; &lt;!-- &lt;resultMap type=&quot;Address&quot; id=&quot;AddressResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sheng&quot; column=&quot;sheng&quot;/&gt; &lt;result property=&quot;shi&quot; column=&quot;shi&quot;/&gt; &lt;result property=&quot;qu&quot; column=&quot;qu&quot;/&gt; &lt;/resultMap&gt; --&gt; &lt;select id=&quot;findStudentWithAddress&quot; resultMap=&quot;StudentResult&quot; parameterType=&quot;Integer&quot;&gt; select * from t_student t1,t_address t2 where t1.addressId=t2.id and t1.id=#{id} &lt;/select&gt; &lt;/mapper&gt; 在学生类的数据层接口中写个查询方法 /** * 操作数据库的接口 * @author 14103 */ public interface StudentMapper { public Student findStudentWithAddress(Integer id); } 在学生类的数据层接口映射文件中绑定sql、配置关联关系 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 为指定接口中的方法配置sql语句 --&gt; &lt;mapper namespace=&quot;com.java1234.mappers.StudentMapper&quot;&gt; &lt;!-- 对应接口的完整路径 --&gt; &lt;!-- 定义一个返回结果集合，名为StudentResult --&gt; &lt;resultMap type=&quot;Student&quot; id=&quot;StudentResult&quot;&gt; &lt;!-- 定义主键 --&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;!-- 类属性与表字段对应 --&gt; &lt;!-- 定义普通字段 --&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;/&gt; &lt;!-- 表关联，需要另外实现Address的数据层接口和映射文件，推荐；后面三种不推荐 --&gt; &lt;association property=&quot;address&quot; column=&quot;id&quot; select=&quot;com.java1234.mappers.AddressMapper.findById&quot;&gt; &lt;!-- column指明子表中与父表关联的字段，查到目标记录发现addressId字段时，会作为下面select方法绑定的t_address表的指定column——id传入方法中，从而查找到关联的地址 --&gt; &lt;/association&gt; &lt;!-- //对象级联 &lt;result property=&quot;address.id&quot; column=&quot;addressId&quot;/&gt; //要用主表的外键字段 &lt;result property=&quot;address.sheng&quot; column=&quot;sheng&quot;/&gt; //要用关联表的字段 &lt;result property=&quot;address.shi&quot; column=&quot;shi&quot;/&gt; &lt;result property=&quot;address.qu&quot; column=&quot;qu&quot;/&gt; --&gt; &lt;!-- //嵌套 &lt;association property=&quot;address&quot; javaType=&quot;Address&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sheng&quot; column=&quot;sheng&quot;/&gt; &lt;result property=&quot;shi&quot; column=&quot;shi&quot;/&gt; &lt;result property=&quot;qu&quot; column=&quot;qu&quot;/&gt; &lt;/association&gt; --&gt; &lt;!-- //直接关联，需要另外为Address定义一个结果集合（虽然是一对一，但是集合里面只有一个地址也没事的 &lt;association property=&quot;address&quot; resultMap=&quot;AddressResult&quot;/&gt; --&gt; &lt;/resultMap&gt; &lt;!-- &lt;resultMap type=&quot;Address&quot; id=&quot;AddressResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;sheng&quot; column=&quot;sheng&quot;/&gt; &lt;result property=&quot;shi&quot; column=&quot;shi&quot;/&gt; &lt;result property=&quot;qu&quot; column=&quot;qu&quot;/&gt; &lt;/resultMap&gt; --&gt; &lt;select id=&quot;findStudentWithAddress&quot; resultMap=&quot;StudentResult&quot; parameterType=&quot;Integer&quot;&gt; select * from t_student t1,t_address t2 where t1.addressId=t2.id and t1.id=#{id} &lt;/select&gt; &lt;/mappers&gt; 一对多映射 写个年级类，年级与学生一对多（数据库的话要不要定义成外键都没关系） public class Grade { private Integer id; private String gradeName; private List&lt;Student&gt; students; //getter、setter @Override public String toString() { return &quot;Grade [id=&quot; + id + &quot;, gradeName=&quot; + gradeName + &quot;, students=&quot; + students + &quot;]&quot;; } } 给年级类写个数据层接口 public interface GradeMapper { public Grade findById(Integer gradeId); } 配置年级类映射文件 &lt;mapper namespace=&quot;com.java1234.mappers.GradeMapper&quot;&gt; &lt;!-- 对应接口的完整路径 --&gt; &lt;resultMap type=&quot;Grade&quot; id=&quot;GradeResult&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;gradeName&quot; column=&quot;gradeName&quot;/&gt; &lt;collection property=&quot;students&quot; column=&quot;id&quot; select=&quot;com.java1234.mappers.StudentMapper.findByGradeId&quot;&gt; &lt;!-- 调用下面findById查到年级表的id时传入这个学生表的方法中，查到学生并赋给students属性 --&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;Integer&quot; resultMap=&quot;GradeResult&quot;&gt; select * from t_grade where id=#{id} &lt;/select&gt; &lt;/mapper&gt; 给学生类数据层接口加个findByGradeId方法，然后到映射文件中实现该方法 &lt;select id=&quot;findByGradeId&quot; resultMap=&quot;StudentResult&quot; parameterType=&quot;Integer&quot;&gt; select * from t_student where gradeId=#{gradeId} &lt;/select&gt; 写个测试 @Test public void testFindGradeWithStudents() { logger.info(&quot;查询年级（带学生）&quot;); Grade grade=gradeMapper.findById(1); System.out.println(grade); } 目前我们还不能通过学生来获取年级信息，下面我们在学生端也添加年级的获取方式，实现双向关联 学生类加个grade属性，toString加个年级 /*这里要是加个打印grade属性的话，会调用grade类的tostring方法， * 而其中又包含打印students属性，如此往复循环将会报错：StackOverflowError */ @Override public String toString() { return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;, address=&quot; + address + &quot;, grade=&quot; + grade.getGradeName() +&quot;]&quot;; } 给学生类映射文件中定义的返回类型StudentResult加个grade属性及其获取方式，这样只要返回类型是StudentResult的查询方法都会获取到grade信息 &lt;association property=&quot;grade&quot; column=&quot;gradeId&quot; select=&quot;com.java1234.mappers.GradeMapper.findById&quot;&gt; &lt;!-- 就算设置了外键也必须写这个方法，否则mybatis是不会自动去查t_grade表的 --&gt; &lt;/association&gt; 写个测试 @Test public void testFindStudentWithGrade() { logger.info(&quot;查询学生及其地址、年级&quot;); /*借用findStudentWithAddress就能查到年级了， * 但是用findById是查不到的， * 因为映射文件中它的返回类型指定为Student而非StudentResult */ Student student=studentMapper.findStudentWithAddress(2); System.out.println(student); } 代码实例：MybatisHelloWorld动态sql if标签：检测不为空的字段进行条件拼接 choose标签：指定搜索字段，指定了之后就算还有其他字段传进来也不起作用 where标签：拼接条件时自动把第一个子句的and|or去掉 trim：提供前后缀、前后缀覆盖方案 foreach：遍历条件集合 set：自动把参数放进update的坑位里 &lt;select id=&quot;searchStudent&quot; parameterType=&quot;Map&quot; resultMap=&quot;StudentResult&quot;&gt; &lt;!-- 也可以是HashMap之类;传入自定义的类，属性的获取方式也跟下面一样，直接写属性名，而不用调用getter --&gt; select * from t_student where gradeId=#{gradeId} &lt;if test=&quot;name!=null&quot;&gt;and name like #{name}&lt;/if&gt; &lt;!-- like的话等下传进来的name两边要加个% --&gt; &lt;if test=&quot;age!=null&quot;&gt;and age=#{age}&lt;/if&gt; &lt;/select&gt; &lt;!-- 淘宝搜索有个下拉框可以指定按照宝贝或店铺来查询 --&gt; &lt;select id=&quot;searchStudent2&quot; parameterType=&quot;Map&quot; resultMap=&quot;StudentResult&quot;&gt; &lt;!-- 也可以是HashMap之类 --&gt; select * from t_student &lt;choose&gt; &lt;when test=&quot;searchBy==&apos;gradeId&apos;&quot;&gt;where gradeId=#{gradeId}&lt;/when&gt; &lt;when test=&quot;searchBy==&apos;name&apos;&quot;&gt;where name like #{name}&lt;/when&gt; &lt;otherwise&gt;where age=#{age}&lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; &lt;select id=&quot;searchStudent3&quot; parameterType=&quot;Map&quot; resultMap=&quot;StudentResult&quot;&gt; &lt;!-- 也可以是HashMap之类 --&gt; select * from t_student &lt;where&gt; &lt;!-- 拼接的时候自动把第一个子句的and去掉 --&gt; &lt;if test=&quot;gradeId!=null&quot;&gt;gradeId=#{gradeId}&lt;/if&gt; &lt;!-- 加不加and随意 --&gt; &lt;if test=&quot;name!=null&quot;&gt;and name like #{name}&lt;/if&gt; &lt;!-- 从第二个if开始就要加and了 --&gt; &lt;if test=&quot;age!=null&quot;&gt;and age=#{age}&lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=&quot;searchStudent4&quot; parameterType=&quot;Map&quot; resultMap=&quot;StudentResult&quot;&gt; &lt;!-- 也可以是HashMap之类 --&gt; select * from t_student &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and|or&quot;&gt; &lt;!-- 覆盖掉子句的前缀and|or;这样就跟where标签一样了 --&gt; &lt;if test=&quot;gradeId!=null&quot;&gt;gradeId=#{gradeId}&lt;/if&gt; &lt;if test=&quot;name!=null&quot;&gt;and name like #{name}或者and name like &apos;%${suthor}%&apos;&lt;/if&gt; &lt;if test=&quot;age!=null&quot;&gt;and age=#{age}&lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!-- 在某段年级范围内查找学生 --&gt; &lt;select id=&quot;searchStudent5&quot; parameterType=&quot;Map&quot; resultMap=&quot;StudentResult&quot;&gt; &lt;!-- 也可以是HashMap之类 --&gt; select * from t_student &lt;if test=&quot;gradeIds!=null&quot;&gt; &lt;where&gt; gradeId in &lt;!-- 把所有元素搞成(?,?,?) --&gt; &lt;foreach collection=&quot;gradeIds&quot; item=&quot;gradeId&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{gradeId} &lt;/foreach&gt; &lt;/where&gt; &lt;/if&gt; &lt;/select&gt; &lt;update id=&quot;updateStudent&quot; parameterType=&quot;Student&quot;&gt; update t_student &lt;set&gt; &lt;!-- set能自动把最后一个逗号去掉 --&gt; &lt;if test=&quot;name!=null&quot;&gt;name=#{name},&lt;/if&gt; &lt;!-- 记得加逗号 --&gt; &lt;if test=&quot;age!=null&quot;&gt;age=#{age},&lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt; 字符串型时间的比较、不同类型的判空操作、特殊符号的写法 &lt;!--查询在一下时间段内的记录--&gt; &lt;if test=&quot;reportDateTime1!=null&quot;&gt;and Report_Date_Time&gt;=#{reportDateTime1}&lt;/if&gt; &lt;!--字符型的时间可以直接这样比--&gt; &lt;if test=&quot;reportDateTime2!=null&quot;&gt;and Report_Date_Time &lt;![CDATA[ &lt;= ]]&gt; #{reportDateTime2}&lt;/if&gt; &lt;if test=&quot;number!=null&quot;&gt;and number=#{number}&lt;/if&gt; &lt;!--包装在类中，则number!=0(Goods把number定义为long型，默认值为0,；包装在Map中，则number!=null（Map把它定义为Object,默认值为null）--&gt; 代码实例：MybatisActiveSql处理clog、blob 数据库字段对应为longtext、longblob（准确来说是blog，但是它有点小），类属性对应为byte[]、String 给Student类加俩属性 public class Student { private Integer id; private String name; private Integer age; //blob对应为字节数组 private byte[] pic; //clog则是String private String remark; } 数据层接口写个保存和获取数据的方法 &lt;insert id=&quot;insert&quot; parameterType=&quot;Student&quot;&gt; insert into t_student values(#{id},#{name},#{age},null,null,#{pic},#{remark}) &lt;/insert&gt; &lt;select id=&quot;getStudentById&quot; parameterType=&quot;Integer&quot; resultType=&quot;Student&quot;&gt; select * from t_student where id=#{id} &lt;/select&gt; 测试方法 @Test public void testInsert() throws IOException { logger.info(&quot;添加学生&quot;); Student student=new Student(4,&quot;张三4&quot;,14); student.setRemark(&quot;很长的文本…&quot;); //插入图片 File file=new File(&quot;d://puchijun.jpg&quot;); InputStream bis=new BufferedInputStream(new FileInputStream(file)); //创建数组 byte[] pic=new byte[bis.available()]; //available()是bis的字节长度 //把图片读取到数组 bis.read(pic); bis.close(); student.setPic(pic); //最终放进去的是字节数组 studentMapper.insert(student); sqlSession.commit(); } @Test public void testGetStudentById() throws IOException { logger.info(&quot;通过id查找学生&quot;); Student student=studentMapper.getStudentById(4); System.out.println(student); byte[] pic=student.getPic(); //获取到的原始类型是字节数组 File file=new File(&quot;d://puchijun2.jpg&quot;); OutputStream outputStream=new BufferedOutputStream(new FileOutputStream(file)); outputStream.write(pic); outputStream.close(); } Mybatis杂项分页 逻辑分页：把所有记录都查询出来，然后取出指定数目，并不是真正的分页 数据层接口 /** * 操作数据库的接口 * @author 14103 */ public interface StudentMapper { //逻辑分页 public List&lt;Student&gt; findStudent(RowBounds rowBounds); } 映射文件 &lt;select id=&quot;findStudent&quot; resultMap=&quot;StudentResult&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot;&gt; &lt;!-- 入参类型是RowBounds，定义不了 --&gt; &lt;!--select 默认不清掉缓存、要使用缓存，这俩配置是一样的;其他操作默认清掉缓存--&gt; select * from t_student &lt;/select&gt; 测试 @Test public void testFindStudent() { logger.info(&quot;逻辑分页查询学生&quot;); //offset就是start,起始下标 int offset=0,limit=3; //Mybatis的逻辑分页：全部查出来放在内存里，然后只读三条，性能差 RowBounds rowBounds=new RowBounds(offset,limit); List&lt;Student&gt; studentList=studentMapper.findStudent(rowBounds); for(Student student:studentList) { System.out.println(student); } } 物理分页：真正的分页 /** * 操作数据库的接口 * @author 14103 */ public interface StudentMapper { //物理分页 public List&lt;Student&gt; findStudent2(Map&lt;String, Object&gt; map); } &lt;!-- sql原生物理分页 --&gt; &lt;select id=&quot;findStudent2&quot; parameterType=&quot;Map&quot; resultMap=&quot;StudentResult&quot;&gt; select * from t_student &lt;if test=&quot;start!=null and size!=null&quot;&gt; limit #{start},#{size} &lt;/if&gt; &lt;/select&gt; @Test public void testFindStudent2() { logger.info(&quot;物理分页查询学生&quot;); Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(&quot;start&quot;, 3); map.put(&quot;size&quot;, 3); List&lt;Student&gt; studentList=studentMapper.findStudent2(map); for(Student student:studentList) { System.out.println(student); } } 缓存 用于并发量很大的查询操作，但要求服务器内存要高。这样可以减轻数据库压力，提高性能。 Mybatis默认情况下启用一级缓存，即同一个SqlSession接口对象调用了相同的select语句，会直接从缓存中返回结果，而不是再查询一次数据库。 在映射文件中配置缓存 &lt;!-- 配置缓存： 1、size:表示缓存cache中能容纳的最大元素数。默认是1024； 2、flushInterval:定义缓存刷新周期，以毫秒计； 3、eviction:定义缓存的移除机制；默认是LRU(least recently userd，最近最少使用),还有FIFO(first in first out，先进先出)；这俩是Mybatis的算法，推荐前者 4、readOnly:默认值是false，假如是true的话，缓存只能读（select是读，其他是写，但实际也只有select需要用到缓存）。 --&gt; &lt;cache size=&quot;1024&quot; flushInterval=&quot;60000&quot; eviction=&quot;LRU&quot; readOnly=&quot;false&quot;/&gt; &lt;select id=&quot;findStudent&quot; resultMap=&quot;StudentResult&quot; flushCache=&quot;false&quot; useCache=&quot;true&quot;&gt; &lt;!-- 入参类型是RowBounds，定义不了 --&gt; &lt;!--select 默认不清掉缓存、要使用缓存，这俩配置是一样的;其他操作默认清掉缓存--&gt; select * from t_student &lt;/select&gt; sql注解CRUD 使用注解方便灵活，但支持的功能较xml要少，而且代码重用性不高，所以目前还是xml比较常用 直接在数据库接口用注解绑定sql语句，不需要在映射文件绑定 /** * 操作数据库的接口 * @author 14103 */ public interface StudentMapper { @Insert(&quot;insert into t_student values(#{id},#{name},#{age},null,null,null,null)&quot;) public int insert(Student student); @Update(&quot;update t_student set name=#{name},age=#{age} where id=#{id}&quot;) public int update(Student student); @Delete(&quot;delete from t_student where id=#{id}&quot;) public int delete(int id); @Select(&quot;select * from t_student where id=#{id}&quot;) public Student getStudentById(Integer id); @Select(&quot;select * from t_student&quot;) //结果集合映射 @Results( { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;name&quot;,property=&quot;name&quot;), @Result(column=&quot;age&quot;,property=&quot;age&quot;) } ) public List&lt;Student&gt; findStudent(); } 一对一 在地址类的数据层接口写个查找地址的方法 @Select(&quot;select * from t_address where id=#{id}&quot;) public Address findById(Integer id); 在学生类的数据层接口写个查找学生带地址的方法 @Select(&quot;select * from t_student where id=#{id}&quot;) @Results( { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;name&quot;,property=&quot;name&quot;), @Result(column=&quot;age&quot;,property=&quot;age&quot;), @Result(column=&quot;addressId&quot;,property=&quot;address&quot;,one=@One(select=&quot;com.java1234.mappers.AddressMapper.findById&quot;)) } ) public Student selectStudentWithAddress(int id); 一对多 在年级类的数据层接口里写个查询年级带学生的方法 @Select(&quot;select * from t_grade where id=#{id}&quot;) @Results( { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;gradeName&quot;,property=&quot;gradeName&quot;), @Result(column=&quot;id&quot;,property=&quot;students&quot;,many=@Many(select=&quot;com.java1234.mappers.StudentMapper.selectStudentByGradeId&quot;)) } ) public Grade findById(Integer id); 在学生类的数据层接口里写个根据年级查找学生的方法 @Select(&quot;select * from t_student where gradeId=#{gradeId}&quot;) @Results( { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;name&quot;,property=&quot;name&quot;), @Result(column=&quot;age&quot;,property=&quot;age&quot;), @Result(column=&quot;addressId&quot;,property=&quot;address&quot;,one=@One(select=&quot;com.java1234.mappers.AddressMapper.findById&quot;)) } ) public Student selectStudentByGradeId(int gradeId); 现在查询年级就能带学生了，再实现查询学生带年级的双向关联 在学生类的数据层接口写个查询学生带年级的方法 @Select(&quot;select * from t_student where id=#{id}&quot;) @Results( { @Result(id=true,column=&quot;id&quot;,property=&quot;id&quot;), @Result(column=&quot;name&quot;,property=&quot;name&quot;), @Result(column=&quot;age&quot;,property=&quot;age&quot;), @Result(column=&quot;addressId&quot;,property=&quot;address&quot;,one=@One(select=&quot;com.java1234.mappers.AddressMapper.findById&quot;)), @Result(column=&quot;gradeId&quot;,property=&quot;grade&quot;,one=@One(select=&quot;com.java1234.mappers.GradeMapper.findById&quot;)) } ) public Student selectStudentWithAddressAndGrade(int id); 代码实例：MybatisSqlAnnotation动态sql 需要对数据层接口进行实现，但不是通过xml映射文件，而是写一个实现类 首先是数据层接口 public interface StudentMapper { @InsertProvider(type=StudentDynaSqlProvider.class,method=&quot;insertStudent&quot;) //调用了insertStudent方法就会自动把参数传进去，无论insertStudent有无定义入参 public int insertStudent(Student student); @UpdateProvider(type=StudentDynaSqlProvider.class,method=&quot;updateStudent&quot;) public int updateStudent(Student student); @DeleteProvider(type=StudentDynaSqlProvider.class,method=&quot;deleteStudent&quot;) public int deleteStudent(int id); @SelectProvider(type=StudentDynaSqlProvider.class,method=&quot;getStudentById&quot;) public Student getStudentById(Integer id); @SelectProvider(type=StudentDynaSqlProvider.class,method=&quot;findStudents&quot;) public List&lt;Student&gt; findStudents(Map&lt;String,Object&gt; map); } 实现类（和接口在同在mappers包下） public class StudentDynaSqlProvider { //类名一般都这样取 public String insertStudent(final Student student){ //就是得final，这个入参可以写可以不写，但如果是要直接用student.getName()而不是占位符的话就要写 //返回一个动态拼接完的sql return new SQL(){ { INSERT_INTO(&quot;t_student&quot;); if(student.getName()!=null){ VALUES(&quot;name&quot;, &quot;#{name}&quot;); //也可以直接写student.getName()，但是这样写比较好 } if(student.getAge()!=null){ VALUES(&quot;age&quot;, &quot;#{age}&quot;); } } }.toString(); } public String updateStudent(final Student student){ return new SQL(){ { UPDATE(&quot;t_student&quot;); if(student.getName()!=null){ SET(&quot;name=#{name}&quot;); } if(student.getAge()!=null){ SET(&quot;age=#{age}&quot;); } WHERE(&quot;id=#{id}&quot;); } }.toString(); } public String deleteStudent(){ return new SQL(){ { DELETE_FROM(&quot;t_student&quot;); WHERE(&quot;id=#{id}&quot;); } }.toString(); } public String getStudentById(){ return new SQL(){ { SELECT(&quot;*&quot;); FROM(&quot;t_student&quot;); WHERE(&quot;id=#{id}&quot;); } }.toString(); } public String findStudents(final Map&lt;String,Object&gt; map){ return new SQL(){ { SELECT(&quot;*&quot;); FROM(&quot;t_student&quot;); StringBuffer sb=new StringBuffer(); if(map.get(&quot;name&quot;)!=null){ sb.append(&quot; and name like &apos;&quot;+map.get(&quot;name&quot;)+&quot;&apos;&quot;); //name属性就要自己带上俩%；注：+两边从内到外是一个双引号一个单引号 } if(map.get(&quot;age&quot;)!=null){ sb.append(&quot; and age=&quot;+map.get(&quot;age&quot;)); } //什么条件都没有就不要拼where语句了 if(!sb.toString().equals(&quot;&quot;)){ //去掉第一个子句的and WHERE(sb.toString().replaceFirst(&quot;and&quot;, &quot;&quot;)); } } }.toString(); } } 这种用得也是比较少","categories":[],"tags":[]},{"title":"","slug":"MVC","date":"2019-04-30T08:25:45.511Z","updated":"2019-03-02T02:31:05.348Z","comments":true,"path":"2019/04/30/MVC/","link":"","permalink":"http://47.107.237.149/2019/04/30/MVC/","excerpt":"","text":"util包：放连接数据库的类 model包：放实体类，比如用户类 dao包：data Access object，专门处理数据库操作的，如登录判断用户名是否存在 web包：放servlet类，即处理用户请求springboot中的MVC controller层：接收前台传来的参数，操作数据库后将操作结果封装成一个model，再把该类返回给前台进行展示。 service层：调用dao层组织数据 dao层：操作数据库 dao层实现数据的通信，夹在业务逻辑与数据库资源中间，service通常为业务逻辑层，dao定义接口后，DaoImpl是dao的实现类，而service也有接口，其实现类一般谢伟ServiceImpl，就是业务逻辑的实现类，一般用户通过请求之后，controller（service），然后逻辑组件请求dao，之后dao返回dao的接口实例给业务逻辑组件，然后controller就把相应的结果返回给用户。","categories":[],"tags":[]},{"title":"","slug":"MutipartFile","date":"2019-04-30T08:25:45.507Z","updated":"2018-09-08T08:33:34.805Z","comments":true,"path":"2019/04/30/MutipartFile/","link":"","permalink":"http://47.107.237.149/2019/04/30/MutipartFile/","excerpt":"","text":"MultipartFile是spring里定义的接口，它封装了用户在上传文件时所包含的所有信息。 有四个构造函数 MockMultipartFile(String name,byte[] content) MockMultipartFile(String name, InputStream contentStream) MockMultipartFile(String name, String originalFilename, String contentType, byte[] content) MockMultipartFile(String name, String originalFilename, String contentType, InputStream contentStream) *name文件名 *originalFilename原文件名 *contentStream输入流 *content byte数组 解析MultipartFile参见笔记：Apache POI 另一个代码实例：LLCWEB/ImageServiceImpl、ImageController","categories":[],"tags":[]},{"title":"","slug":"MultiValueMap","date":"2019-04-30T08:25:45.504Z","updated":"2019-04-09T08:10:13.854Z","comments":true,"path":"2019/04/30/MultiValueMap/","link":"","permalink":"http://47.107.237.149/2019/04/30/MultiValueMap/","excerpt":"","text":"一个键对应多个值的Map，是一个接口。 LinkedMultiValueMap&lt;K,V&gt;：常用实现，底层维护一个LinkHashMap&lt;K,List&gt;,值存储在链表中，键相同的值存在同一个链表中。 参考文章 代码示例：ideaProjects/shiro-chapter20/test/ClientTest","categories":[],"tags":[]},{"title":"","slug":"Model、ModelMap和ModelAndView","date":"2019-04-30T08:25:45.500Z","updated":"2019-03-15T11:32:57.743Z","comments":true,"path":"2019/04/30/Model、ModelMap和ModelAndView/","link":"","permalink":"http://47.107.237.149/2019/04/30/Model、ModelMap和ModelAndView/","excerpt":"","text":"Model Model是一个接口，包含addAttribute()，其实现类是ExtendedModelMap，它集成了ModelMap，而ModelMap实现了Map接口。 public class ExtendedModelMap extends ModelMap implements Model Model只能传输数据，不能业务寻址，也就是不能跳转页面。 @RequestMapping(&quot;/helloWorld&quot;) public String helloWorld(Model model){ model.addAttribute(&quot;message&quot;,&quot;SpringMvc大爷你好！&quot;); return &quot;helloWorld&quot;; } Model每一次请求都可以被自动创建， 但是ModelAndView需要我们自己new。 ModelMap和Model其实差不多，也是只能传输数据，把数据放到request中，而且也是被SpringMVC自动创建的。 public ModelMap addAttribute(String attributeName, Object attributeValue){...} public ModelMap addAttribute(Object attributeValue){...} public ModelMap addAllAttributes(Collection&lt;?&gt; attributeValues) {...} public ModelMap addAllAttributes(Map&lt;String, ?&gt; attributes){...} 示例： public String xxxxmethod(String someparam,ModelMap model) { //将数据放置到ModelMap对象model中,第二个参数可以是任何java类型 model.addAttribute(&quot;key&quot;,someparam); //返回跳转地址 return &quot;path:handleok&quot;; } ModelAndView ModelAndView既能传输数据，又能进行业务寻址，找到页面跳转过去。 添加模型数据用addObject(),设置视图用setViewName()或调用构造器。 参考文章","categories":[],"tags":[]},{"title":"","slug":"MIME与Content-Type","date":"2019-04-30T08:25:45.490Z","updated":"2019-03-29T07:37:13.198Z","comments":true,"path":"2019/04/30/MIME与Content-Type/","link":"","permalink":"http://47.107.237.149/2019/04/30/MIME与Content-Type/","excerpt":"","text":"MIME MIME(Multipurpose Internet Mail Extensions) 多功能网际邮件扩充服务。 在把输出结果响应到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过MIME来完成。在HTTP中，MIME类型被定义在Content-Type header中。 假设你要传送一个Microsoft Excel文件到客户端。那么这时的MIME类型是“application/vnd.mx-excel”。在大多数情况下，这个文件将传送给Excel来处理（假设我们设定Excel为处理特殊MIME类型的应用程序）。 每个MIME类型由两部分组成，前面是数据的大类别，例如神恶鬼因audio、图像image等，后面定义具体的种类。 常见的MIME类型： 超文本标记语言文本.html text/html 普通文本.txt text/plain RTF文本.rtf application/rtf GIF图形.gif image/gif JPEG图形.ipeg,.jpg image/jpeg au声音文件.au audio/basic MIDI音乐文件mid,.midi audio/midi,audio/x-midi RealAudio音乐文件.ra,.ram audio/x-pn-realaudio MPEG文件.mpg,.mpeg video/mpeg AVI文件.avi video/x-msvideo GZIP文件.gz application/x-gzip TAR文件.tar application/x-tar 按照文件扩展名排列的MIME类型列表","categories":[],"tags":[]},{"title":"","slug":"maven中的profiles","date":"2019-04-30T08:25:45.479Z","updated":"2018-07-18T01:09:05.014Z","comments":true,"path":"2019/04/30/maven中的profiles/","link":"","permalink":"http://47.107.237.149/2019/04/30/maven中的profiles/","excerpt":"","text":"参考文章大致思路 一、先在pom.xml中声明一下我有三个（或者其他）运行环境（profile），给它们取好名字（id），由于这里有resources（指明路径，当所在profile被激活后，系统会在resource的directory下找id目录中的配置文件），所以filter属性写什么都不起作用了。 二、在resources目录下新建三个目录，对应上面三个id，在其中写相应配置文件。当公用的配置文件中存在与各环境的配置文件同名的变量时，公用中的将被覆盖。 三、配置活动的profile.active：在resources中排除各个目录，防止程序一运行系统就把resources下的所有配置文件都搜出来加载了；排除完了就配置个活动的目录，可以传入不同的参数来指定profile。当程序运行在不同环境（通过maven命令的-p指定不同profile的id来构建不同的运行环境（可参见第五点）），激活不同的profile。 四、修改访问地址：url属性其实就是修改访问地址，使每种运行环境都对应一个网址，输入不同的网址进入不同的运行环境。不过这个deploy.url之前定义在哪里了文中好像没有体现。 五、用maven命令运行程序，-p定义id值，通过id值找到resources下以id值为名的目录，加载里面的配置文件。作用 我们的软件会面对不同的运行环境，比如开发环境、测试环境、生产环境，而我们的软件在不同的环境中，有的配置可能会不一样，比如数据源配置、日志文件配置、以及一些软件运行过程中的基本配置，那每次我们将软件部署到不同的环境时，都需要修改相应的配置文件，这样来回修改，是个很麻烦的事情。有没有一种方法能够让我们不用修改配置就能发布到不同的环境中呢？当然有，这就是maven中的Profiles能做到的事。代码实例 SpringMvc02/controller/TaskController、domain/impl/DevDBConnector、TestDBConnector、inter/DBConnector","categories":[],"tags":[]},{"title":"","slug":"maven之build标签","date":"2019-04-30T08:25:45.471Z","updated":"2019-03-06T09:40:20.728Z","comments":true,"path":"2019/04/30/maven之build标签/","link":"","permalink":"http://47.107.237.149/2019/04/30/maven之build标签/","excerpt":"","text":"作用 使用maven构建的项目可以直接使用maven build完成项目的编译、测试、打包，无需额外配置。 build标签描述了如何编译及打包项目，具体的编译和打包工作是通过其中的plugin配置来实现的。当然，plugin不是必须的，即使不添加默认也会引入以下插件： 如果有需要可以另外进行配置,以下配置了编译时使用的jdk版本。 build 分类：一种是直接写在下，即project build。另一种是直接写在下，即profile build。 前者包含了build的基本元素和&lt;…Directory&gt;和，后者指包括基本元素。 三个基本元素 defaultGoal：执行构建（即编译或打包吧）时默认的goal或phase，如jar:jar或者package。 directory：构建的结果所在的路径，默认为${basedir}/target目录。 finalName：打包文件名。 resources元素：资源往往不是代码，而是properties或xml文件，无需编译，构建过程中往往会将资源文件从源路径复制到指定的目标路径，resources则给出各个资源在maven项目中的具体路径。 targetPath：资源文件的目标路径。 filtering：构建过程中是否对资源进行过滤，默认false。 directory：资源文件源路径，默认位于${basedir}/src/main/resources/目录下。 includes：一组文件名的匹配模式，被匹配的资源文件将被构建过程处理。 excludes：一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时也被includes的文件依然被忽略。 filters：给出对资源文件进行过滤的属性文件的路径，默认位于${basedir}/src/main/filters/目录下。属性文件中定义若干了键值对，用于在构建过程中将资源文件中出现的变量（键）替换为对应的值。 testResources：test过程中涉及的资源文件，默认位于${basedir}/src/test/resources/目录下，它们不会被构建到目标构件中。 plugins：设置构建过程中需要的插件。 extensions：是否加载该插件的扩展，默认false。 inherited: 该插件的configuration中的配置是否可以被继承（继承该pom中的其他maven项目），默认true。 configuration：该插件所需要的特殊配置，在父子项目之间可以覆盖或合并。 dependencies: 该插件所需要的依赖类库。 executions: 该插件的某个goal的执行方式。一个executions有如下属性： id: 唯一标识。 goals：要执行的插件的goal，如run phase: 插件的goal要嵌入到Maven的phase中执行，如verify inherited: 该execution是否可被子项目继承 configuration：该execution的其他配置参数 …Directory: 往往配置在父项目中，供所有父子项目使用。目录可以使用绝对路径，如下图所示，若使用相对路径，则都是在${basedir}目录下。 extensions：执行构建过程中可能用到的其他工具，在执行过程中被加入到classpath中；也可以激活构建插件，从而改变构建的过程。通常通过它给出通用插件的一个具体实现，用于构建过程。 编译后文件的存放目录 即maven默认的输入输出目录。 src/main/java和src/test/java：这两个目录中的所有*.java文件会分别在comile和test-comiple阶段被编译，编译结果分别放到了target/classes和targe/test-classes目录中，但是这两个目录中的其他文件都会被忽略掉。 src/main/resouces和src/test/resources：这两个目录中的文件也会分别被复制到target/classes和target/test-classes目录中。 当是web项目时，会在target下生成myproject目录，myproject是你的项目名。 src/main/webapps：这个目录中的文件会被复制到target/myProject目录中. target/classes：默认会把这个目录中的所有内容复制到target/myProject/WEB-INF/classes目录中. dependency: 默认会将项目的依赖复制到target/myProject/WEB-INF/lib. 参考文章","categories":[],"tags":[]},{"title":"","slug":"maven安装","date":"2019-04-30T08:25:45.466Z","updated":"2018-11-28T09:42:45.958Z","comments":true,"path":"2019/04/30/maven安装/","link":"","permalink":"http://47.107.237.149/2019/04/30/maven安装/","excerpt":"","text":"参考文章 然后修改本地仓库位置 再到idea设置maven","categories":[],"tags":[]},{"title":"","slug":"maven","date":"2019-04-30T08:25:45.450Z","updated":"2019-04-28T06:04:23.664Z","comments":true,"path":"2019/04/30/maven/","link":"","permalink":"http://47.107.237.149/2019/04/30/maven/","excerpt":"","text":"是什么如果在A项目中需要用到B项目的类，那么就必须把B项目打成jar包，然后引到lib下。我们称A依赖于B。引入jar包的方法十分繁琐，而maven就是用来管理这种依赖关系的。 Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具。通俗点讲，就是通过pom.xml文件的配置获取jar包，而不用手动去添加jar包。 总之，maven可以帮你构建工程、管理jar包、编译代码、自动运行单元测试、打包、生成报表、部署项目。 怎么做如果需要使用pom.xml来获取jar包，那么首先该项目就必须为maven项目，maven项目可以这样去想，就是在java项目和web项目的上面包裹了一层maven，本质上java项目还是java项目，web项目还是web项目，但是包裹了maven之后，就可以使用maven提供的一些功能了。具体操作，看一、二、四、七就行了,其中七是基本操作 添加外部依赖plugin插件maven本质上是一个插件框架，它的核心并不是执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由maven-complier-plugin完成的。进一步说，每个插件会有一个或者多个目标，例如maven-complier-plugin的complie目标用来编译位于src/main/java目录下的主源码，testComplier目标用来编译位于src/test/java目录下的测试源码。 plugins和pluginManagement的区别plugins和pluginManagement的区别，和我们前面研究过的dependencies和dependencyManagement的区别是非常类似的。plugins下的plugin是真实使用的，而pluginManagement下的plugins下的plugin则仅仅是一种声明，子项目中可以对pluginManagement下的plugin进行信息的选择、集成和覆盖等。 dependencyManagement 在父项目中统一管理依赖的版本号，可保证子模块中依赖的版本号一致，若子模块想不一致的话可以另外声明版本号 只是管理而不会引入依赖，所以子模块还需写dependency project下的属性 modelVersion：声明项目描述符遵循哪一个pom模型版本，通常是4.0.0。 name：项目的名称。maven产生的文档用。 url：项目主页的url，maven产生的文档用。 developers：项目开发者列表。 maven标签大全 dependency下的属性 groupId、artifactId、version是依赖的基本坐标，缺一不可。这三个可以不用讲，都知道。重要的是除了这三个之外的配置属性需要我们理解 type：依赖的类型，比如是jar包还是war包等。 默认为jar，表示依赖的jar包 注意：pom.lastUpdated 这个我们在上面添加servlet-jar的时候就遇到过，看到lastUpdated的意思是表示使用更新描述信息，占位符作用，通俗点讲，选择该类型，jar包不会被加载进来，只是将该jar包的一些描述信息加载进来，使别的jar包在引用他时，能够看到一些相关的提示信息，仅此而已，所以说他是个占位符，只要记住他的jar包不会被加载进来。 optional：标记依赖是否可选。 默认值false 比如struts2中内置了log4j这个记录日志的功能，就是将log4j内嵌入struts2的jar包中，而struts2有没有log4j这个东西都没关系，有它，提示的信息更多，没它，也能够运行，只是提示的信息就相对而言少一些，所以这个时候，就可以对它进行可选操作，想要它就要，不想要，就设置为false。 exclusions：排除传递依赖，解决jar冲突问题 依赖传递的意思就是，A项目 依赖 B项目，B项目 依赖 C项目，当使用A项目时，就会把B也给加载进来，这是传递依赖，依次类推，C也会因此给加载进来。这个有依赖传递有好处，也有坏处，坏处就是jar包的冲突问题，比如，A 依赖 B(B的版本为1)，C 依赖 B(B的版本为2)，如果一个项目同时需要A和C，那么A,C都会传递依赖将B给加载进来，问题就在这里，两个B的版本不一样，将两个都加载进去就会引起冲突，这时候就需要使用exclusions这个属性配置了。maven也会有一个机制避免两个都加载进去，maven 默认配置在前面的优先使用，但是我们还是需要使用exclusions来配置更合理。 scope：依赖范围，意思就是通过pom.xml加载进来的jar包，来什么范围内使用生效，范围包括编译时，运行时，测试时。 compile：默认值，如果选择此值，表示编译、测试和运行都使用当前jar test：表示只在测试时当前jar生效，在别的范围内就不能使用该jar包。例如：junit ,测试只能写在test/java包下。此处不写也不报错，因为默认是compile，compile包括了测试。 runtime，表示测试和运行时使用当前jar，编译时不用该jar包。例如：JDBC驱动。JDBC驱动，在编译时(也就是我们写代码的时候都是采用接口编程，压根就没使用到JDBC驱动包内任何东西，只有在运行时才用的到，所以这个是典型的使用runtime这个值的例子)，此处不写也不报错，理由同上。 provided，表示编译和测试时使用当前jar，运行时不在使用该jar了。例如：servlet-api、jsp-api等。【必须填写】 import:搭配pom，表示引用外部的pom文件。由于maven的继承和java一样，无法实现多继承，如果一个父模块包含10个、20个甚至更多个子模块，那么这个父模块的pom的dependencyManagement会包含大量的依赖。为了将这些依赖分类以更清晰地管理，我们需要把dependencyManagement放到单独的专门用来管理依赖的pom汇总，然后在需要使用依赖的模块中通过import来引入。 例如可以写一个管理依赖的pom &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.test.sample&lt;/groupId&gt; &lt;!--官方的管理文档一般命名后缀为-bom(bill of material)--&gt; &lt;artifactId&gt;base-parent1&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactid&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactid&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; - 然后通过非继承的方式来引入这段依赖管理配置 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--下面三行是上面pom的信息--&gt; &lt;groupId&gt;com.test.sample&lt;/groupId&gt; &lt;artifactid&gt;base-parent1&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--不需要定义版本了--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactid&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactid&gt;log4j&lt;/artifactId&gt; &lt;/dependency&gt; repositories和repository 构件可以分成两类，一类是被其他构件依赖的构件（dependencies），这也是maven库中的主要构件；另一种是插件（plugins），这是一种特殊的构件。由于插件的特殊性，插件库独立于依赖库，使用单独设置，但是和中的设置基本一致。 &lt;!--查找依赖和扩展的远程仓库列表；仅限本项目--&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt; &lt;id&gt;spring-snapshot&lt;/id&gt; &lt;!--远程仓库名称--&gt; &lt;name&gt;Spring Snapshot Repository&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; maven中要配置库，可以直接在项目pom.xml中通过配置，但仅限于当前项目；也可以通过中的配置在特定环境下的库，这可以在pom.xml中，也可以在setting.xml中配置。如果哦都不设置的话则会到下面这个默认库区获取： &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt; &lt;/repository&gt; packaging 打包方式：pom/jar/war，默认是jar。父项目必须是pom，并且使用module指定子项目。 &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;simple-weather&lt;/module&gt; //项目的子模块 &lt;module&gt;simple-webapp&lt;/module&gt; &lt;/modules&gt; pom指的是项目不像之前的项目那样创建一个jar或war，它仅仅是引用其他maven项目的POM。 maven知道要去这些子模块的目录中寻找pom.xml文件。 子模块中也需要配置父项目的关联 &lt;parent&gt; &lt;groupId&gt;org.sonatype.mavenbook.ch06&lt;/groupId&gt; &lt;artifactId&gt;simple-parent&lt;/artifactId&gt; //刚才的父项目名 &lt;version&gt;1.0&lt;/version&gt; &lt;!-- &lt;relativePath&gt;../simple-parent/pom.xml&lt;/relativePath&gt; --&gt; //如果子项目不是标准地建在父项目的子模块里，而是跟父项目同级了的话，可以先到它们的上一级目录找到父项目，再找其pom文件；标准情况下不用该属性 &lt;/parent&gt; 子模块的packaging默认是jar，可以改成war。 这样，子模块会自动继承父模块的依赖。 子项目的groupId和version如果和父项目的一样可以省略不写，会自动继承父项目的。 但是子项目之间的互相引用必须注明版本号，比如dao模块引用实体类模块的依赖，必须指明实体类模块的版本号，尽管实体类自己没有显式声明自己的版本号，只是继承父类的。 当maven执行一个带有子模块的项目时，maven首先载入父pom，然后定位所有子模块的pom（子模块的文件和父pom同级，也就是子pom必须在父pom的下一级文件中），随后将这些pom放入一个maven反应堆（reactor）的东西中，这个反应堆处理组件的排序，以确保相互独立的模块能以适当的顺序被编译和安装。 maven命令 mvn compile 编译，没什么用了，现在都是自动编译 mvn clean 清空target目录 mvn test 测试，测试依赖能否找到，单元测试成功与否 mvn package 打包，把项目打jar包或war包。 mvn install 把项目安装到本地仓库，运行之后本地仓库就会有这个依赖 子模块编辑完后应该install安装到本地仓库，才能被其他模块引入。子模块修改了应该重新clean再install（除此之外不用其他操作），引入它的模块才能接收到更新。 有的时候你中有我我中有你，一起更新之后要重新install会出错，最好就是先解开一方对另一方的新内容的引用，不然谁也install不了 运行父模块发现总是失败可以重新install一下（先clean，否则异名旧包不会被清除），可能是最近的代码修改没有被识别到。 执行maven命令异常 Plugin org.apache.maven.plugins:maven-resources-plugin:3.0.2 or one of its dependencies… 就是说它找不到这个依赖，在本地仓库下这个依赖下载失败，肯定有很多lastupdate文件在里面，而且这还不是个依赖，是个plugin，插件，一般来说我们创建maven项目都不会去添加什么插件的，但是有的时候他就是会自动添加插件，比如thz-parent项目的thz-manage-web模块下pom文件就有自动添加过插件 &lt;build&gt; &lt;!--war包名--&gt; &lt;finalName&gt;thz-manager-web&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 以上这些代码是某一次查看pom文件时突然多出来的，直接删去，再mvn test，问题解决 Failed to execute goal org.apache.maven.plugins maven-surefire-plugin 看报错日志，可能是子模块忘记引入某个依赖了。 eclipse创建maven项目 不要用eclipse吧，没有成功过。 创建单纯的maven项目，不是web项目，也不整合任何框架 将项目转为web项目 多模块maven项目 代码实例：ideaProjects/thz。 运行子模块之前，先把父模块install一下。 被其他模块引用的模块改动之后要重新install，引用它的模块才能检索到它的更新。 创建单元测试时跨模块引用配置文件： @ContextConfiguration(locations={&quot;classpath*:config/applicationContext.xml&quot;}) //classpath:在当前项目查找；classpath*：在所有依赖的jar包的classpath下找 在父模块执行maven命令，将对所有的子模块起作用。 如果是Spring的多模块maven项目，最好把配置文件集中写在dao模块，反正不要在web/controller这种被打包成war的模块中，否则在其他模块写单元测试时引入配置文件失败。原因是配置文件写在了war包中，而war包不能被当成依赖引入这个要建立单元测试的模块，因此配置文件无法引入，从而只能把测试类写在配置文件所在模块了。 可参见代码示例service模块下测试和web模块下相同测试。 如果同时有多个子模块都是web应用，它们需要同时运行协同测试，那么可以在debug configuration中添加两个maven命令，命令行都设为tomcat7:run，作用目录则分别选择相应的目录，然后两个都debug起来就行。 若父模块的pom中依赖都写在dependencyManager中，则子模块依然需要引入依赖；若写在dependencies中，则子模块不需要再引入。 父项目如果负责引入依赖而不只是管理依赖的话，那么子项目虽然继承了这些依赖，但是一开始写代码是检测不到这些依赖的，有时alt+enter可以直接把依赖add to classpath，但有时代码却只是飘下划线而不能直接add to classpath，此时可以手动import，就能在飘红的包名那里alt+enter把依赖add to classpath了。 网上推荐把.iml文件删除，然后点击以下图标重新生成，如此几次即可： 参考文章 代码示例：ideaProjects/shiro-chapter23/shiro-chapter23-client/ClirntShiroFilterFactoryBean/setApplicationContext(){this.applicationContext}，这一段在未添加spring-beans依赖并将其add to classpath时飘红线。","categories":[],"tags":[]},{"title":"","slug":"Map转json","date":"2019-04-30T08:25:45.435Z","updated":"2018-09-03T12:07:50.343Z","comments":true,"path":"2019/04/30/Map转json/","link":"","permalink":"http://47.107.237.149/2019/04/30/Map转json/","excerpt":"","text":"Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(&quot;key&quot;,&quot;value&quot;); JASONObject.toJSONString(map);","categories":[],"tags":[]},{"title":"","slug":"longValue( )和Long.valueOf( )","date":"2019-04-30T08:25:45.429Z","updated":"2018-08-18T10:13:23.164Z","comments":true,"path":"2019/04/30/longValue( )和Long.valueOf( )/","link":"","permalink":"http://47.107.237.149/2019/04/30/longValue( )和Long.valueOf( )/","excerpt":"","text":"longValue()是Long类的一个方法，用来得到Long类中的数值；也就是将包装类中的数据拆箱成基本数据类型。 Long.valueOf(参数)是将参数转换成long的包装类——Long；也就是把基本数据类型转换成包装类。","categories":[],"tags":[]},{"title":"","slug":"Linux下载mysql","date":"2019-04-30T08:25:45.424Z","updated":"2019-03-12T08:52:36.805Z","comments":true,"path":"2019/04/30/Linux下载mysql/","link":"","permalink":"http://47.107.237.149/2019/04/30/Linux下载mysql/","excerpt":"","text":"下载yum install -y mysql-server mysql mysql-devel 但下载后不能查看版本也不能启动mysql 原因是mysql已被MariaDB代替，它是mysql的一个分支，开发原因之一是甲骨文公司收购了MySQL户，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开此风险。所以我们需要安装MariaDB。 yum install mariadb-server -y MariaDB配置systemctl start mariadb.service //启动服务 systemctl enable mariadb.service //开机启动 mysql_secure_installation //设置密码 提示输入现在密码则回车 新密码定的是123456 //设置新密码过程 Set root password? [Y/n] y New passsword:123456 Re-enter new password:123456 Password updated successfully! Reloading priviledge tables.. ... Success! 设置成功后跳出一系列配置，全部回车即可 测试登录 mysql -uroot -p123456 添加用户，授予权限 比如说我要部署thz-parent项目上去，这个项目一个用户来管理数据库 grant all privileges on thz.* to thz@&quot;%&quot; identified by &quot;111111&quot;; //thz.*表示此用户用户拥有访问thz这个数据库的所有所有权限，thz为新用户名，%表示允许远程连接，6个1即为连接密码 数据库的迁移 将本地数据库thzdb导出为thzdb.sql文件，并传输到Linux根目录下mydocument里 登录mysql，创建一个相同数据库thzdb create database thzdb; use thzdb; 导入表和数据 source /mydocument/thzdb.sql 查看 show tables; 重命名表名 rename table tb_user to user; //把tb_user改为user","categories":[],"tags":[]},{"title":"","slug":"Linux下载git","date":"2019-04-30T08:25:45.404Z","updated":"2019-01-17T01:16:13.391Z","comments":true,"path":"2019/04/30/Linux下载git/","link":"","permalink":"http://47.107.237.149/2019/04/30/Linux下载git/","excerpt":"","text":"参考文章 执行make prefix=/usr/local/git all后可能出现error：openssl/ssl.h: No such file or directory；这说明执行make编译项目的时候缺少openssl库下的ssl.h头文件 解决方法：不需要切换目录直接输入命令：yum install openssl-devel，网上可能较多教程是教sudo apt-get install libssl-dev的，但是apt-get是Ubuntu的命令，CentOS应该是用yum来安装某个东西，而libssl-dev是Ubuntu系统的库，CentOS系统对应的是openssl-devel。 也可能可出现error：curl/curl.h: No such file or directory 无需切换目录可以直接输入命令： wget https://curl.haxx.se/download/curl-7.51.0.tar.gz tar -zvxf curl-7.51.0.tar.gz cd curl-7.51.0/ ./configure -prefix=/usr/local/curl make make install export PATH=$PATH:/usr/local/curl/bin 测试curl是否可用：curl http://www.baidu.com //出现网页源码说明可以 然后继续make编译项目，如果还是报相同错误，那么输入命令：cp -r /usr/local/curl/include/curl/ /usr/include/将库复制到/usr/include下 回到git的下载过程，两个make命令执行完后，不要像文章第5步一样直接查找git版本，没有的，要先配置环境变量 第6步里面，只要我们执行两个make时指定的目录跟教程一样，那么这里的path路径也就跟教程一致。 第4点最后一行命令是chmod +x post-update.sample //赋予post-update.sample可执行权限 本地配置下的第1点编辑config文件需要把中文注释全都去掉，否则执行ssh hexo时报错：/c/Users/14103/.ssh/config line 2: garbage at end of line；就是说有语法错误的意思 安装目录：usr/src/git-2.8.3","categories":[],"tags":[]},{"title":"","slug":"Linux命令","date":"2019-04-30T08:25:45.385Z","updated":"2019-01-17T03:45:44.699Z","comments":true,"path":"2019/04/30/Linux命令/","link":"","permalink":"http://47.107.237.149/2019/04/30/Linux命令/","excerpt":"","text":"编辑 vim/vi Insert //开始编辑 Esc :wq //保存退出 Esc :x //同上 Esc :q //未改动的情况下退出 Esc :q! //不保存退出 Esc :dd //删除当前行ssh连接远程主机 ssh root(用户名就对了)@主机ip Ctrl+D //结束连接 exit //结束连接sshd服务重启 service sshd restart //好像也是系统重启cd命令 cd 某个路径 //进入某个目录 cd .. //回到上一级目录 cd ../.. //返回上两级 cd - //返回上次的目录 cd / //返回根目录 Ctrl+Insert //复制 Shift+Insert //粘粘 退出尖角&gt;模式 误输入cd `进入以下模式后按Ctrl+C即可退出 sudo sudo是一种权限管理机制，管理员可以授权于一些普通用户去执行一些root执行的操作，而不需要知道root的密码。查看yum把软件下载到哪里去了 如果之前用yum下载了一个redis yum install redis 不管你是在哪个目录下执行这个命令的，yum都是我行我素地把东西下到不知道哪里去了，以下是它的一些默认路径 要查找位置的话我们先查找redis安装包 [root@iZbp1eem925ojwyx17ao9kZ ~]# rpm -qa|grep redis redis-3.2.10-2.el7.x86_64 [root@iZbp1eem925ojwyx17ao9kZ ~]# 再查找安装包的路径 [root@iZbp1eem925ojwyx17ao9kZ ~]# rpm -ql redis-3.2.10-2.el7.x86_64 /etc/logrotate.d/redis /etc/redis-sentinel.conf /etc/redis.conf /etc/systemd/system/redis-sentinel.service.d /etc/systemd/system/redis-sentinel.service.d/limit.conf /etc/systemd/system/redis.service.d /etc/systemd/system/redis.service.d/limit.conf /usr/bin/redis-benchmark /usr/bin/redis-check-aof /usr/bin/redis-check-rdb /usr/bin/redis-cli 这就查出来了 我们可以自定义安装路径，但不推荐，因为这样会额外安装很多实际已经安装过的依赖包，不过还是说一下 yum -c /etc/yum.conf --installroot=/usr/local --releasever=/ install love -c /etc/yum.conf：指定yum配置文件的地址 –installroot=/usr/local：指定自定义安装目录重命名文件（夹） 进入待命名文件的上级目录 mv A B //将A命名为B mv /a /b/c //是的这个命令还可以移动目录，这里表示将/a目录移动到 删除文件 rm [参数] 文件名 可选参数： -f:force,忽略不存在的文件，强制删除 -i:interactive,进行交互式的删除，应该就是遇到某些特殊情况出个提示吧 -r或-R,recursive,递归地删除指定目录下的所有目录和文件 -v,verbose，详细显示进行的步骤 关闭防火墙 systemctl stop firewalld.service //一般关闭一个服务的命令都是这样 systemctl disable firewalld.service //一般在开机时禁用一个服务的命令都是这样 systemctl status firewalld.service //一般查看一个服务的命令都是这样","categories":[],"tags":[]},{"title":"","slug":"Libero设计流程","date":"2019-04-30T08:25:45.371Z","updated":"2018-11-23T11:59:18.540Z","comments":true,"path":"2019/04/30/Libero设计流程/","link":"","permalink":"http://47.107.237.149/2019/04/30/Libero设计流程/","excerpt":"","text":"HDL源文件 // 3217005109_BasGate.v module gates_1(A,B,Y1,Y2,Y3,Y4,Y5); input A,B; output Y1,Y2,Y3,Y4,Y5; assign Y1=A&amp;B; //为输出信号赋值；可以使用三目运算符：y = (s == 0) ? a : b; s为0时y=a,否则y=b assign Y2=A|B; assign Y3=~(A&amp;B); assign Y4=~(A|B); assign Y5=A^B; endmodule module gates_2(A,Y); input [1:6]A; output [1:6]Y; assign Y=~A; endmodule //3输入、1输入的举重裁判表决电路 module gates_3(A,B,C,Y); input A,B,C; output Y; assign Y=A&amp;B|B&amp;C|A&amp;C; endmodule //3输入、1输入的交通灯故障检测电路 module gates_4(R,Y,G,Z); input R,Y,G; output Z; assign ~(R|Y|G)|RY|RG|YG; endmodule 按hdl editor旁边那个按钮新建测试文件 // test_BasGate.v `timescale 1ns/1ns module testBasGate_1(); reg A,B; //输入信号：reg表示需要保存 wire Y1,Y2,Y3,Y4,Y5; //wire：默认类型，不保存值 gates_1 v1(A,B,Y1,Y2,Y3,Y4,Y5); //实例化了一个gates_1模块，名为v1；后面有很多个同名的，其实应该不同才对，这样就可以不注释掉模块二通过指定options来对特定模块进行仿真 initial begin A=0;B=0; #10 B=1; //信号翻转；10ns后B变为1 #10 A=1; #10 B=0; #10; end endmodule module testBasGate_2(); reg [1:6]A; wire [1:6]Y; gates_2 v2(A,Y); initial begin A=000001; #10 A=A&lt;&lt;1; #10 A=A&lt;&lt;1; #10 A=A&lt;&lt;1; #10 A=A&lt;&lt;1; #10 A=A&lt;&lt;1; end endmodule //举重电路 module testBasGate_3(); reg A,B,C; //输入信号：reg表示需要保存 wire Y; //wire：默认类型，不保存值 gates_3 v1(A,B,C,Y); //实例化了一个gates_1模块，名为v1 initial begin #10 A=0;B=0;C=0; //信号翻转；10ns后B变为1 #10 A=0;B=0;C=1; #10 A=0;B=1;C=0; #10 A=0;B=1;C=1; #10 A=1;B=0;C=0; #10 A=1;B=0;C=1; #10 A=1;B=1;C=0; #10 A=1;B=1;C=1; end endmodule //交通灯故障电路 module testBasGate_4(); reg R,Y,G; //输入信号：reg表示需要保存 wire Z; //wire：默认类型，不保存值 gates_4 v1(R,Y,G,Z); //实例化了一个gates_1模块，名为v1 initial begin #10 R=0;Y=0;G=0; //信号翻转；10ns后B变为1 #10 R=0;Y=0;G=1; #10 R=0;Y=1;G=0; #10 R=0;Y=1;G=1; #10 R=1;Y=0;G=0; #10 R=1;Y=0;G=1; #10 R=1;Y=1;G=0; #10 R=1;Y=1;G=1; end endmodule 按M开头那个按钮进行第一次仿真，先进行options配置 1000ns：随便设置都可以 testBasGate_3：测试文件中的module名 v1: 实例化模块名 然后按sy开头那个按钮运行综合结果 进行第二次仿真按最下面那个按钮，把所有模块都点绿（一路按默认值） 进行第三次仿真 点最后一行第二个按钮，接烧录器，开箱子电源，点最后一个模块，pass之后拔下烧录器，点开主界面最后一行的按钮，查看io引脚，开始接线。","categories":[],"tags":[]},{"title":"","slug":"Lambda表达式","date":"2019-04-30T08:25:45.366Z","updated":"2018-09-30T03:44:23.854Z","comments":true,"path":"2019/04/30/Lambda表达式/","link":"","permalink":"http://47.107.237.149/2019/04/30/Lambda表达式/","excerpt":"","text":"应用于匿名内部类 首先，匿名内部类一般都作为某个方法的参数实现某种功能，且多数是接口，需要重写某个方法 没有使用Lambda的老方法 button.addActionListener(new ActionListener(){ //重写唯一方法 public void actionPerformed(ActionEvent actionEvent){ System.out.println(&quot;Action detected&quot;); } }); 以上的括号中大段代码里，只有第8行是真正起作用的，如果我们使用Lambda，那么只需要考虑这唯一起作用的一行 button.addActionListener( ()-&gt;{ System.out.println(&quot;Action detected&quot;); }) 让我们来看一个更明显的例子： 不采用Lambda的老方法 //重写方法 Runable runable=new Runable(){ @Override public void run(){ System.out.println(&quot;Running without Lambda&quot;); } } //调用方法 runnable.run(); 使用Lambda //重写方法 Runnable runnable=() -&gt; { System.out.println(&quot;Running from Lambda&quot;); }; //调用方法 runnable.run(); 说白了Lambda语法就是用来代替实例化一个接口并重写其抽象方法的。语法 下面是一些Lambda表达式： (int x,int y) -&gt; x+y //接收x和y两个参数并返回它们的和 () -&gt; 42 //不接收参数，返回42 (String s) -&gt; {System.out.println(s);} //接收一个字符串并打印，不返回值 Lambda表达式的语法由参数列表、箭头符号-&gt;和函数体组成。函数体既可以是一个表达式，也可以是一个语句块： 表达式：表达式会被执行并返回执行结果；适合小型的Lambda表达式，它消除了return关键字，使得语句更加简洁。 语句块：语句块中的语句会被依次执行，就像方法中的语句一样 FileFilter java=(File f) -&gt; f.getName().endsWith(“*.java”); String user=doPrivileged(() -&gt; System.getProperty(“user.name”); new Thread() -&gt; { connectToService(); sendNotification(); }).start(); 对于上面的代码，FileFilter必须是接口，而且该接口只能有一个未实现的方法，即函数式接口。在定义接口时加上@FunctionalInterface即可限制该接口只能有一个方法。 对于给定的Lambda表达式，它的类型是又其上下文推导而来的,不过它对目标类型也是有要求的，当且仅当下面的所有条件均满足时，Lambda表达式才可以被赋予目标类型T： T是一个函数式接口 lambda表达式的参数和T的方法参数在数量和类型上一一对应 lambda表达式的返回值和T的方法返回值相兼容（Compatible） lambda表达式内所抛出的异常和T的方法throws类型相兼容 当Lambda的参数只有一个而且它的类型可以被推导得之，该参数列表外面的括号可以省略 FileFilter java=f -&gt; f.getName.endsWith(&quot;.java&quot;); button.addActionListener(e -&gt; ui.dazzle(e.getModifiers())); 完整例子 //定义一个接口，注意，只能有一个未实现的方法 public interface Formula&lt;F,T&gt; { T convert(F form); } //调用 /*Lambda*/ Formula&lt;String,Integer&gt; formula=(from) -&gt; Integer.valueOf(from); Integer converted=formula.convert(&quot;123&quot;); System.out.println(converted+1); //124 /*简写*/ Formula&lt;String,Integer&gt; formula=Integer::valueOf; Integer converted=formula.convert(&quot;123&quot;); System.out.println(converted+1); //124 Button button=new Button(); button.addActionListener((e) -&gt; {System.out.println(&quot;Action detected&quot;+e);}); 简写 范式 类名::（静态|普通）方法名 对象::（普通）方法名 方法调用 x -&gt; System.out.println(x)简写为System.out::println（out是一个PrintStream类的对象，println是该类的方法,依据x的类型来重载方法，至于要打印的这个x是谁，应该是根据上下文推断而来的） person -&gt; person.getAge()简写为Person::getAge() 创建对象 () -&gt; new ArrayList&lt;&gt;()简写为ArrayList::new(new关键字实际是调用ArrayList的构造方法)","categories":[],"tags":[]},{"title":"","slug":"Junit4","date":"2019-04-30T08:25:45.362Z","updated":"2019-02-18T01:01:46.544Z","comments":true,"path":"2019/04/30/Junit4/","link":"","permalink":"http://47.107.237.149/2019/04/30/Junit4/","excerpt":"","text":"只能对public方法进行测试 eclipse创建测试类的话是右键类-&gt;junit测试用例，然后下一步选中要测试的方法，然后把整个方法体搬到对应的测试方法中，要测试哪个方法直接在侧边栏该方法上右击选择Junit方法测试即可，不用写main方法。 以下为测试保存一个学生到数据库的类 public class StudentTestTest { private SessionFactory sessionFactory=HibernateUtil.getSessionFactory(); @Test public void testAdd() { Session session=sessionFactory.openSession(); // 生成一个session session.beginTransaction(); // 开启事务 Student s=new Student(); s.setName(&quot;张三&quot;); session.save(s); session.getTransaction().commit(); // 提交事务 session.close(); // 关闭session } } 代码实例：eclipse-&gt;HibernateCrud 一般我们会在测试类中加上测试前方法和测试后方法。以下为测试多对一的学生类和班级类，分别保存同一班的两名学生的方法。 public class StudentTestTest { //因为下面两个方法都要用到这俩属性，所以实例化在外面 private SessionFactory sessionFactory=HibernateUtil.getSessionFactory(); private Session session; @Before //测试前调用 public void setUp() throws Exception { session=sessionFactory.openSession(); session.beginTransaction(); } @After //测试后调用 public void tearDown() throws Exception { session.getTransaction().commit(); session.close(); } @Test public void testSaveClassAndStudent() { Class c=new Class(); c.setName(&quot;08计本&quot;); session.save(c); Student s1=new Student(); s1.setName(&quot;张三&quot;); s1.setC(c); Student s2=new Student(); s2.setName(&quot;李四&quot;); s2.setC(c); session.save(s1); session.save(s2); } } 多个@Test方法同时执行的话顺序是随机且每次都不确定的 junit-4.11开始可以用@FixMethodOrder来指定顺序，但就是不能指定按方法定义的顺序执行，所以最好就是一个方法一个方法单独执行 //@FixMethodOrder(MethodSorters.JVM) //按JVM顺序，随机不确定，默认按此方式 @FixMethodOrder(MethodSorters.DEFAULT) //随机确定 //@FixMethodOrder(MethodSorters.NAME_ASCENDING) //按命名顺序 public class StudentTest2 { private static final Logger logger=Logger.getLogger(StudentTest2.class); private SqlSession sqlSession; private StudentMapper studentMapper; /** * 方法执行前打开一个连接 * setUp方法可以用于初始化变量 * @throws Exception */ @Before public void setUp() throws Exception { sqlSession=SqlSessionFactoryUtil.openSession(); studentMapper=sqlSession.getMapper(StudentMapper.class); } /** * 方法执行后回收连接 * @throws Exception */ @After public void tearDown() throws Exception { sqlSession.close(); } @Test public void testAdd() { logger.info(&quot;添加学生&quot;); Student student=new Student(4,&quot;李四&quot;,14); studentMapper.add(student); sqlSession.commit(); } @Test public void testUpdate() { logger.info(&quot;修改学生&quot;); Student student=new Student(3,&quot;张三&quot;,13); studentMapper.update(student); sqlSession.commit(); } } 贴4.11及以上的jar包要同时贴上hamcrest-core的jar包，不然报java.lang.NoClassDefFoundError@After、@Before注解 Junit4开始使用Java5的注解，常用的： @BeforeClass:针对一个类的all测试，只执行一次，被注解方法必须为static void。 @Before：初始化方法。 @Test：测试方法。 @After：测试后执行的方法，通常是释放资源的。 @AfterClass：针对all测试，只执行一次，必须为static void。 @Ignore：忽略的测试方法。 一个单元测试用例的执行顺序：@BeforeClass-&gt;@Before-&gt;@Test-&gt;@After-&gt;@AfterClass 每个测试方法的执行顺序：@Before-&gt;@Test-&gt;@After","categories":[],"tags":[]},{"title":"","slug":"js函数老是进不去","date":"2019-04-30T08:25:45.358Z","updated":"2018-05-10T13:02:23.947Z","comments":true,"path":"2019/04/30/js函数老是进不去/","link":"","permalink":"http://47.107.237.149/2019/04/30/js函数老是进不去/","excerpt":"","text":"用浏览器开发工具看下控制台是否报错，因为js出错eclipse是不会报错的","categories":[],"tags":[]},{"title":"","slug":"js方法用el传参","date":"2019-04-30T08:25:45.355Z","updated":"2018-05-11T08:48:11.300Z","comments":true,"path":"2019/04/30/js方法用el传参/","link":"","permalink":"http://47.107.237.149/2019/04/30/js方法用el传参/","excerpt":"","text":"onclick=”addRole2(‘${user.getUserName() }’,’${user.getRole()}’)” 然后方法里： function addRole2(obj1,obj2){ var role=obj2; var userName=obj1;","categories":[],"tags":[]},{"title":"","slug":"js传参解决中文乱码问题","date":"2019-04-30T08:25:45.350Z","updated":"2018-05-14T15:29:09.268Z","comments":true,"path":"2019/04/30/js传参解决中文乱码问题/","link":"","permalink":"http://47.107.237.149/2019/04/30/js传参解决中文乱码问题/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"jsp自定义标签","date":"2019-04-30T08:25:45.346Z","updated":"2018-05-03T07:09:07.490Z","comments":true,"path":"2019/04/30/jsp自定义标签/","link":"","permalink":"http://47.107.237.149/2019/04/30/jsp自定义标签/","excerpt":"","text":"jsp自定义标签，类似JavaBean，把一段代码封装起来，提高重用性；分离了jsp页面的内容与逻辑 要写这个必须保证：项目-&gt;构建路径 -&gt;配置构建路径-&gt;库里必须有Tomcat包 tld ；taglib description 标签描述文件，类似于web.xml，通过tld文件可以找到相应的标签来执行 代码示例：HeadFirstJspServletChap07-&gt;java1234.jsp 以上空标签的执行顺序为： 以上，记得在page后面引入tld文件： &lt;%@taglib prefix=”java1234” uri=”/WEB-INF/java1234.tld”%&gt; 我们上面写的是空标签，现在来写一个有属性的标签","categories":[],"tags":[]},{"title":"","slug":"jsp","date":"2019-04-30T08:25:45.339Z","updated":"2018-04-27T16:22:04.578Z","comments":true,"path":"2019/04/30/jsp/","link":"","permalink":"http://47.107.237.149/2019/04/30/jsp/","excerpt":"","text":"post:封装进一个数据包：HTML HEADER B/S系统：浏览器/服务器 瘦客户端 运行原理：用户发出请求，服务器返回信息 lib放jar包 九大内置对象 四大作用域 request只在一次请求里保存数据，重定向之后，request里的数据不会传过去： 请求作用域是同一个请求之内，在页面跳转时，如果通过forward方式跳转，则forward目标页面仍然可以拿到request中的属性值。如果通过redirect方式进行页面跳转，由于redirect相当于重新发出的请求，此种场景下，request中的属性值会丢失。 session只需浏览器不关闭（电话不挂断），就能取到值，半小时内有效）（单个用户值单个浏览器）（数据存服务器上） cookie：将信息存客户端：记住密码等 session：存服务器：购物车 javabean: 导包格式：&lt;%@ page import=”com.java1234.model.Student” %&gt;","categories":[],"tags":[]},{"title":"","slug":"Json","date":"2019-04-30T08:25:45.335Z","updated":"2018-11-05T02:57:29.037Z","comments":true,"path":"2019/04/30/Json/","link":"","permalink":"http://47.107.237.149/2019/04/30/Json/","excerpt":"","text":"存储：key-value；key必须用引号引起来 格式：”key”:”value”(value是字符串就要引号) JSONObject.fromObject(object)：将任意Object对象转为json对象。底层是调用对象的getter，所以如果在类中写了非属性的getter，那么返回的json中就会有这个属性 List转json JSONArray jsonArray=JSONArray.fromObject(list); Map转json JSONObject json = JSONObject.fromObject(map); Bean转json JSONObject jsonObject = JSONObject.fromObject(new JsonBean()); 数组转json JSONArray jsonArray1 = JSONArray.fromObject(boolArray); String转json JSONArray jsonArray3 = JSONArray.fromObject(&quot;[&apos;json&apos;,&apos;is&apos;,&apos;easy&apos;]&quot; );","categories":[],"tags":[]},{"title":"","slug":"JS","date":"2019-04-30T08:25:45.330Z","updated":"2018-05-10T06:37:58.620Z","comments":true,"path":"2019/04/30/JS/","link":"","permalink":"http://47.107.237.149/2019/04/30/JS/","excerpt":"","text":"函数调用不成功的话：检查下函数名是不是保留字、有没有设置id、name设置正确了吗、pattern有没有错误 保存js文件弹框报错：什么文件名必须是什么java扩展名结尾之类直接新建一个js文件，把内容拷贝过去，否则修改后不能保存的话修改不生效 统一用var来定义变量 alert(“头部”);; 运行此HTML直接弹框提示“头部”；写多少个都会执行，顺序执行的 document.write(“a=”+a+”“);//字符串连接方式和Java一样，可以加标签 var a=1;//数值类型 var b=true;alert(d);//打印true var c;//打印undefined var d=”hhh”;d=null;//变量置空，打印null js获取后台request：var a = ‘&lt;%=request.getAttribute(“error”)%&gt;’;","categories":[],"tags":[]},{"title":"","slug":"Jquery","date":"2019-04-30T08:25:45.326Z","updated":"2018-05-09T15:53:34.444Z","comments":true,"path":"2019/04/30/Jquery/","link":"","permalink":"http://47.107.237.149/2019/04/30/Jquery/","excerpt":"","text":"模板：e-&gt;js 代码实例：HeadFirstAjaxJsonChap02-&gt;jqAjax.jsp","categories":[],"tags":[]},{"title":"","slug":"JPEG与jpg的区别","date":"2019-04-30T08:25:45.323Z","updated":"2018-11-10T03:09:09.312Z","comments":true,"path":"2019/04/30/JPEG与jpg的区别/","link":"","permalink":"http://47.107.237.149/2019/04/30/JPEG与jpg的区别/","excerpt":"","text":"jpg全名是JPEG JPEG：一种有损的图像压缩的标准方法，描述如何将一个图像转换为字节的数据流。压缩后图像扩展名为.jpg/.jpeg/.jpe/.jfif/.jif。 MPEG：长得和JPEG很像，但它是视音频压缩标准。","categories":[],"tags":[]},{"title":"","slug":"JPA、@Transactional、Spring Data JPA","date":"2019-04-30T08:25:45.311Z","updated":"2019-04-02T08:56:42.604Z","comments":true,"path":"2019/04/30/JPA、@Transactional、Spring Data JPA/","link":"","permalink":"http://47.107.237.149/2019/04/30/JPA、@Transactional、Spring Data JPA/","excerpt":"","text":"一种标准，本质上是一种ORM规范，注意不是ORM框架，因为它只是提供了一些接口，至于如何实现则由服务厂商来提供。它是是JDK5.0注解或XML描述对象-关系表的映射关系，并将运行期的实体对象持久化到数据库中。 持久化：持久化是将程序数据再持久状态和瞬间状态转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中），能够持久保存。 持久化是一种对象服务，就是把内存中的对象保存到外存中，让它以后能够取回。 为什么需要持久化服务呢？那是由于内存本身的缺陷引起的： 内存掉电后数据会丢失 内存过于昂贵，与硬盘、磁带、光盘等外存相比，内存的价格要搞2~3个数量级，而且维持成本也高，至少需要一直供电；而且容量有限制。 实现jpa标准的框架有Hibernate等。 JpaRepository的一些接口 里面有一张表 其中save方法：记录不存在则插入，存在则更新。 @Query自定义查询语句 用@Query直接在方法上定义查询语句 public interface TaskDao extends JpaRepository&lt;Task,Long&gt;{ @Query(&quot;select t from Task t where t.taskName=?1&quot;)//1表示这是第一个参数 Task findByTaskName(String taskName); } 除了写hql，我们还可以写sql语句 public interface TaskDao extends JpaRepository&lt;Task, Long&gt; { @Query(&quot;select * from tb_task t where t.task_name = ?1&quot;, nativeQuery = true) Task findByTaskName(String taskName); } 传参也可以这样传： public interface TaskDao extends JpaRepository&lt;Task, Long&gt; { @Query(&quot;select t from Task t where t.taskName = ? and t.createTime = ?&quot;) Task findByTaskName(String taskName, Date createTime); } 还可以这样传： public interface TaskDao extends JpaRepository&lt;Task, Long&gt; { @Query(&quot;select t from Task t where t.taskName = :taskName and t.createTime = :createTime&quot;) Task findByTaskName(@Param(&quot;taskName&quot;)String taskName,@Param(&quot;createTime&quot;) Date createTime); } 自定义查询语句+分页效果 /** * 模糊查询 **/ @Query(&quot;from Document d where d.author like %?1% or content like %?1% or title like %?1%&quot;) Page&lt;Document&gt; findByOneKey(String key,Pageable pageable); //测试方法 Page&lt;Document&gt; documents=documentRepository.findByOneKey(&quot;haien&quot;,new PageRequest(0,10, Sort.Direction.DESC,&quot;createDate&quot;)); 我们可以利用SqEL表达式，把实体类写成动态的： public interface TaskDao extends JpaRepository&lt;Task, Long&gt; { @Query(&quot;select t from #{#entityName} t where t.taskName = ? and t.createTime = ?&quot;) Task findByTaskName(String taskName, Date createTime); } - 其中#{#entityName}表示获取entityName的值，即实体类的名称。 - 实体类Task在使用@Entity注释后，Spring会将它纳入管理，若未指定表名，则entityName的值为Task，指定了则为指定值。 - Spring管理着多个实体类，谁调用了这个方法entityName就等于哪个实体类。 它的作用是，当两个实体类都有共同的父类时，可以抽取出一个通用repository 首先定义一个父类 // JPA 基类的标识 @MappedSuperclass //被注释的实体类不映射到数据库，但其子类会 @SuppressWarnings(&quot;serial&quot;) //抑制编译器的警告（比如不要飘波浪线、小灯泡），括号里的值表示警告类型；可以设为unchecked来逃避异常处理 public abstract class IdEntity implements Serializable{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) protected Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } 两个子类 @Entity public class Task extends IdEntity{ } @Entity public class Project extends IdEntity{ } 然后有一个通用的接口： @NoRepositoryBean //此接口无对应的数据库，不能暴露为repository public interface GenericDao&lt;T&gt; extends JpaRepository&lt;T, ID&gt; { @Query(&quot;select t from #{#entityName} t where t.id= ?1&quot;) //entityName是个特有名词，传进来什么实体就用什么代替 public T findById(Long id); } 然后由taskDao和projectDao来继承这个接口。这样，把公用的方法放在通用接口上，就不用重写方法了。 public interface TaskRepository extends GenericDao&lt;Task&gt; { } public interface ProjectRepository extends GenericDao&lt;Project&gt;{ } 测试 @Test public void findByIdTest(){ Project project=new Project(); project.setId(1); projectRepository.save(project); project=projectRepository.findById(1); Assert.assertThat(project.getId(),is(1)); } 携带分页信息 //dao层 @Query(&quot;select u from User u where u.name=?1&quot;) public List&lt;User&gt; findByName(String name, Pageable pageable); //service层调用 @RequestMapping(value = &quot;/params&quot;, method= RequestMethod.GET) @ResponseBody public String getEntryByParams(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;林志强&quot;) String name, @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) Integer page, @RequestParam(value = &quot;size&quot;, defaultValue = &quot;15&quot;) Integer size) { Sort sort = new Sort(Sort.Direction.DESC, &quot;id&quot;); Pageable pageable = new PageRequest(page, size, sort); Page&lt;User&gt; pages=userDao.findByName(name,pageable); Iterator&lt;User&gt; it=pages.iterator(); while(it.hasNext()){ System.out.println(&quot;value:&quot;+((User)it.next()).getId()); } return &quot;success...login....&quot;; } @Modifying标识自定义更新语句@Modifying //表明是更新语句 @Transactional //一定要有事务，不是在这里就是在service层，反正那个会被直接调用那个就必须带事务 @Query(&quot;update Task t set t.taskName = ?1 where t.id = ?2&quot;) int updateTask(String taskName, Long id); @Modifying @Transactional @Query(&quot;delete from Score where model = ?1 and year = ?2&quot;) void deleteByModelAndYear(String model,int year); @Modifying @Transactional @Query(value = &quot;insert into users(username,password,update_time,people_id) value(?1,SUBSTRING(md5(?2),1,16),?3,?4)&quot;,nativeQuery = true) int saveUsers(String username, String password, Date update_time, int peopleId); 返回值只能是int或void jpa要求更新、删除和插入操作必须有事务支持 自定义数据库操作语句汇总 反正宗旨就是利用原生sql命令来实现那些复杂的关联查询 @Transactional事务 操作数据库过程中可能发生异常，导致后续操作无法完成。此时需要进行回滚。 Spring默认会对没有被捕获（unchecked）的RunTimeException进行事务回滚，如果异常已经被catch也即是遇到的事checked异常的话则不回滚。 改变默认规则的话： 让原本不能回滚的checked回滚：在方法前加@Transaction(rollbackFor=Exception.class/rollbackForClassName=Exception) 让原本会回滚的unchecked不回滚：@Transaction(notRollbackFor=RunTimeException.class/notRollbackForClassName=Exception) PS：如果原本能回滚的异常被try/catch了还想让它回滚，那就必须再抛出一个异常。 但实践证明，在测试中使用事务，无论是否出现异常，都会自动回滚，数据库会保持和测试前一致。 jpa那些默认的接口都没有默认开启事务的，只是支持事务。 要开启事务的话，可以在service类前加@Transactional，声明这个service的所有方法都需要事务管理。 或者是在测试类的测试方法前加@Transactional，声明这个方法里调用到的操作数据库的方法需要事务管理。加了的话测试类无论抛异常与否都会自动回滚，防止数据库污染。 如果加了该注解后，测试类没有自动回滚，可查看数据库引擎是否为Innodb，因为其他数据库引擎不支持事务。 也可以在dao层的Repository接口里创建操作数据库的方法前加上@Transactional，声明此方法开启事务管理（不过这种情况应该是很少的，因为查询方法一般都是单操作，没什么意义，可以参考HPScore/ScoreRepository）。 该注解只能加在public方法上，加在其他方法上无效。 代码实例：HPScore/test/controller/ResolveExcelControllerTest value参数 以上使用的是默认的事务配置，可以满足一些基本的事务需求，但是当我们项目较大较复杂时（比如，有多个数据源等），这时候需要在声明事务时，指定不同的事务管理器。在声明事务时，只需要通过value属性指定配置的事务管理器名即可，例如： @Transactional(value=”transactionManagerPrimary”) 。 另一种自定义查询、构建通用dao的方法 这种自定义查询方法是自己写一个类似JpaRepository的仓库来被实体类的仓库继承 我们先创建一个将被继承的BaseRepository //repository 基类，封装自定义查询方法 @NoRepositoryBean //该注解表示 spring 容器不会创建该对象 public interface BaseRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt;,JpaRepository&lt;T,ID&gt; { Page&lt;Map&gt; findPageByParams(String sql, Pageable pageable, Object... args); } 创建BaseRepositoryImpl类，实现BaseRepository接口 public class BaseRepositoryImpl&lt;T, ID extends Serializable&gt; extends SimpleJpaRepository&lt;T, ID&gt; implements BaseRepository&lt;T, ID&gt; { //实体管理类，对持久化实体做增删改查，自动义sq操作模板所需要的核心类 public final EntityManager entityManager; public BaseRepositoryImpl(JpaEntityInformation&lt;T, ID&gt; entityInformation, EntityManager entityManager) { super(entityInformation, entityManager); this.entityManager = entityManager; } @Override @Transactional(rollbackFor = Exception.class) public Page&lt;Map&gt; findPageByParams(String sql, Pageable pageable, Object... args) { Session session = (Session) entityManager.getDelegate(); org.hibernate.Query q = session.createSQLQuery(sql); q.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP); int i = 0; for (Object arg : args ) { q.setParameter(i++, arg); } List&lt;Map&gt; totalCount = q.list(); //如果不需要分页的话这样就可以返回去了 //每页第一个 q.setFirstResult(pageable.getPageSize() * (pageable.getPageNumber() - 1)); q.setMaxResults(pageable.getPageSize()); //每页容量 List&lt;Map&gt; pageCount = q.list(); Page&lt;Map&gt; pages = new PageImpl&lt;&gt;(pageCount, pageable, totalCount.size()); return pages; } } 创建一个PersonRepositroy 继承BaseRepository，就可以直接使用定义的查询方法了 public interface PersonRepository extends BaseRepository&lt;Person, Integer&gt; { } TestController @RestController public class TestController { @Resource private PersonRepository personRepository; @GetMapping(value = &quot;/test&quot;) public String test( ){ //订单表与用户表关联，通过用户ID查询该用户的所有订单，只获取订单编号和订单详情。 String sql=&quot;select o.no,o.detail from person as p inner join order as o on o.personid=p.id and p.id= ? &quot; Integer userId=11; Page&lt;Map&gt; orderLists = personRepository.findPageByParams(sql, new PageRequest(1,10),userId); return orderLists; } } 最后，在项目启动类上加一个注解，告诉springboot，我要使用JPA，请到repository包下去扫描我创建的repository 类，我的repository基类是BaseRepositoryImpl @EnableJpaRepositories(basePackages = {&quot;com.repository&quot;}, repositoryBaseClass = BaseRepositoryImpl.class) public class MybootApplication { public static void main(String[] args) { SpringApplication.run(MybootApplication.class, args); } } 还有一种自定义查询、构建通用dao的方法 先构建一个通用dao接口 public interface BaseAppDAO&lt;T,ID extends Serializable&gt; { /** * 保存数据对象 * @param entity * @return */ boolean save(T entity); /** * 根据id查询 * @param id * @param t * @return */ T findByid(T t,Long id); /** * 根据表名，字段，参数查询，拼接sql语句 * @param tablename 表名 * @param filed 字段名 * @param o 字段参数 * @return */ List&lt;T&gt; findBysql(String tablename,String filed,Object o); Object findObjiectBysql(String tablename,String filed,Object o); /** * 多个字段的查询 * @param tablename 表名 * @param map 将你的字段传入map中 * @return */ List&lt;T&gt; findByMoreFiled(String tablename,LinkedHashMap&lt;String,Object&gt; map); /** * 多字段查询分页 * @param tablename 表名 * @param map 以map存储key,value * @param start 第几页 * @param pageNumer 一个页面的条数 * @return */ List&lt;T&gt; findByMoreFiledpages(String tablename, LinkedHashMap&lt;String,Object&gt; map, int start, int pageNumer); /** * 一个字段的分页 * @param tablename 表名 * @param filed 字段名 * @param o 字段参数 * @param start 第几页 * @param pageNumer 一个页面多少条数据 * @return */ List&lt;T&gt; findpages(String tablename,String filed,Object o,int start,int pageNumer); /** * 根据表的id删除数据 * @param entity */ boolean delete(T entity); /** * 更新对象 * @param e * @return */ boolean update(T e); /** * 根据传入的map遍历key,value拼接字符串，以id为条件更新 * @param tablename 表名 * @param map 传入参数放入map中 * @return */ Integer updateMoreFiled(String tablename,LinkedHashMap&lt;String,Object&gt; map); /** * 根据条件查询总条数返回object类型 * @param tablename 表名 * @param map 传入参数放入map中 * @return */ Object findCount(String tablename, LinkedHashMap&lt;String,Object&gt; map); } 实现dao接口 @Repository public class BaseAppDAOimpl&lt;T,ID extends Serializable&gt; implements BaseAppDAO&lt;T,ID&gt; { @PersistenceContext //由EJB容器动态注入EntityManager对象 private EntityManager entityManager; @Transactional @Override public boolean save(T entity){ boolean flag=false; try { entityManager.persist(entity); //persist()：保存实体bean flag=true; }catch (Exception e){ System.out.println(&quot;---------------保存出错---------------&quot;); throw e; } return flag; } @Transactional @Override public Object findByid(Object o,Long id) { return entityManager.find(o.getClass(),id); //查找方法，传入实体类型和主键 } @Transactional @Override public List&lt;T&gt; findBysql(String tablename, String filed, Object object ) { String sql=&quot;from &quot;+tablename+&quot; u WHERE u.&quot;+filed+&quot;=?&quot;; //动态指定表 System.out.println(sql+&quot;--------sql语句-------------&quot;); Query query=entityManager.createQuery(sql); //执行sql语句，返回Query对象 query.setParameter(1,object); //按坑位设置参数 List&lt;T&gt; list= query.getResultList(); entityManager.close(); return list; } @Override public Object findObjiectBysql(String tablename, String filed, Object o) { String sql=&quot;from &quot;+tablename+&quot; u WHERE u.&quot;+filed+&quot;=?&quot;; System.out.println(sql+&quot;--------sql语句-------------&quot;); Query query=entityManager.createQuery(sql); query.setParameter(1,o); entityManager.close(); return query.getSingleResult(); //获取单个结果，需确保结果一定唯一 } @Transactional @Override public List&lt;T&gt; findByMoreFiled(String tablename,LinkedHashMap&lt;String,Object&gt; map) { String sql=&quot;from &quot;+tablename+&quot; u WHERE &quot;; Set&lt;String&gt; set=null; set=map.keySet(); //获取所有key,即字段名 List&lt;String&gt; list=new ArrayList&lt;&gt;(set); //将字段名转换为有序链表 List&lt;Object&gt; filedlist=new ArrayList&lt;&gt;(); //准备将字段名转移到该数组 for (String filed:list){ sql+=&quot;u.&quot;+filed+&quot;=? and &quot;; //拼接sql语句 filedlist.add(filed); //转移字段名（原因不清） } sql=sql.substring(0,sql.length()-4); //去掉多出的字符 System.out.println(sql+&quot;--------sql语句-------------&quot;); Query query=entityManager.createQuery(sql); for (int i=0;i&lt;filedlist.size();i++){ //设置参数，根据字段名获取值 query.setParameter(i+1,map.get(filedlist.get(i))); } List&lt;T&gt; listRe= query.getResultList(); entityManager.close(); return listRe; } @Transactional @Override public List&lt;T&gt; findByMoreFiledpages(String tablename, LinkedHashMap&lt;String,Object&gt; map,int pageNum,int size) { //分页，每请求一页执行一次 String sql=&quot;from &quot;+tablename+&quot; u WHERE &quot;; Set&lt;String&gt; set=null; set=map.keySet(); List&lt;String&gt; list=new ArrayList&lt;&gt;(set); List&lt;Object&gt; filedlist=new ArrayList&lt;&gt;(); for (String filed:list){ sql+=&quot;u.&quot;+filed+&quot;=? and &quot;; filedlist.add(filed); } sql=sql.substring(0,sql.length()-4); System.out.println(sql+&quot;--------sql语句-------------&quot;); Query query=entityManager.createQuery(sql); for (int i=0;i&lt;filedlist.size();i++){ query.setParameter(i+1,map.get(filedlist.get(i))); } query.setFirstResult((pageNum-1)*size); //设置第一条数据 query.setMaxResults(size); //设置每页容量 List&lt;T&gt; listRe= query.getResultList(); entityManager.close(); return listRe; } @Transactional @Override public List&lt;T&gt; findpages(String tablename, String filed, Object o, int start, int pageNumer) { String sql=&quot;from &quot;+tablename+&quot; u WHERE u.&quot;+filed+&quot;=?&quot;; System.out.println(sql+&quot;--------page--sql语句-------------&quot;); List&lt;T&gt; list=new ArrayList&lt;&gt;(); try { Query query=entityManager.createQuery(sql); query.setParameter(1,o); query.setFirstResult((start-1)*pageNumer); query.setMaxResults(pageNumer); list= query.getResultList(); entityManager.close(); }catch (Exception e){ System.out.println(&quot;------------分页错误---------------&quot;); } return list; } @Transactional @Override public boolean update(T entity) { boolean flag = false; try { entityManager.merge(entity); flag = true; } catch (Exception e) { System.out.println(&quot;---------------更新出错---------------&quot;); } return flag; } @Transactional @Override public Integer updateMoreFiled(String tablename, LinkedHashMap&lt;String, Object&gt; map) { String sql=&quot;UPDATE &quot;+tablename+&quot; AS u SET &quot;; Set&lt;String&gt; set=null; set=map.keySet(); List&lt;String&gt; list=new ArrayList&lt;&gt;(set); for (int i=0;i&lt;list.size()-1;i++){ if (map.get(list.get(i)).getClass().getTypeName()==&quot;java.lang.String&quot;){ System.out.println(&quot;-*****&quot;+map.get(list.get(i))+ &quot;------------&quot;+list.get(i)); sql+=&quot;u.&quot;+list.get(i)+&quot;=&apos;&quot;+map.get(list.get(i))+&quot;&apos; , &quot;; }else { sql+=&quot;u.&quot;+list.get(i)+&quot;=&quot;+map.get(list.get(i))+&quot; , &quot;; } } sql=sql.substring(0,sql.length()-2); sql+=&quot;where u.id=? &quot;; System.out.println(sql+&quot;--------sql语句-------------&quot;); int resurlt=0; try { Query query=entityManager.createQuery(sql); query.setParameter(1,map.get(&quot;id&quot;)); resurlt= query.executeUpdate(); }catch (Exception e){ System.out.println(&quot;更新出错-----------------------&quot;); e.printStackTrace(); } return resurlt; } @Transactional @Override public boolean delete(T entity) { boolean flag=false; try { entityManager.remove(entityManager.merge(entity)); flag=true; }catch (Exception e){ System.out.println(&quot;---------------删除出错---------------&quot;); } return flag; } @Override public Object findCount(String tablename, LinkedHashMap&lt;String, Object&gt; map) { String sql=&quot;select count(u) from &quot;+tablename+&quot; u WHERE &quot;; Set&lt;String&gt; set=null; set=map.keySet(); List&lt;String&gt; list=new ArrayList&lt;&gt;(set); List&lt;Object&gt; filedlist=new ArrayList&lt;&gt;(); for (String filed:list){ sql+=&quot;u.&quot;+filed+&quot;=? and &quot;; filedlist.add(filed); } sql=sql.substring(0,sql.length()-4); System.out.println(sql+&quot;--------sql语句-------------&quot;); Query query=entityManager.createQuery(sql); for (int i=0;i&lt;filedlist.size();i++){ query.setParameter(i+1,map.get(filedlist.get(i))); } return query.getSingleResult(); } } Spring Data JPA 是在JPA规范的基础下提供Repository层的实现，但是具体使用哪一款ORM框架需要你自己决定。也就是说，虽然ORM框架都实现了JPA规范，但是在不同的ORM框架之间切换，编写的代码是有一定差异的，而通过使用Spring Data JPA能够方便大家在不同的ORM框架中间进行切换而不需要更改代码","categories":[],"tags":[]},{"title":"","slug":"JDBC再学习","date":"2019-04-30T08:25:45.306Z","updated":"2018-06-01T13:48:08.070Z","comments":true,"path":"2019/04/30/JDBC再学习/","link":"","permalink":"http://47.107.237.149/2019/04/30/JDBC再学习/","excerpt":"","text":"rs.getxxx()后，可以用rs.wasnull判断获取的值是否为空。 int id = rs.getInt(1); if( rs.wasNull( ) ) { id = 0; }","categories":[],"tags":[]},{"title":"","slug":"JDBC事务","date":"2019-04-30T08:25:45.300Z","updated":"2018-06-01T14:52:48.007Z","comments":true,"path":"2019/04/30/JDBC事务/","link":"","permalink":"http://47.107.237.149/2019/04/30/JDBC事务/","excerpt":"","text":"从jdbc事务机制开始看就行了 其中事务保存点，也就是回滚到保存点所在的那一行就对了。","categories":[],"tags":[]},{"title":"","slug":"JDBC批处理","date":"2019-04-30T08:25:45.296Z","updated":"2018-06-01T23:56:09.061Z","comments":true,"path":"2019/04/30/JDBC批处理/","link":"","permalink":"http://47.107.237.149/2019/04/30/JDBC批处理/","excerpt":"","text":"批量处理sql语句","categories":[],"tags":[]},{"title":"","slug":"jdbc处理大数据","date":"2019-04-30T08:25:45.292Z","updated":"2018-06-13T07:10:45.655Z","comments":true,"path":"2019/04/30/jdbc处理大数据/","link":"","permalink":"http://47.107.237.149/2019/04/30/jdbc处理大数据/","excerpt":"","text":"clob 给一个文件，clob可以把整个文件内容写进去，容量大约几个G 项目实例：idea项目jdbc-&gt;com.java1234-&gt;sixthji2-&gt;Clob 文本类型必须用notepad写，编码设置成utf-8，不要用记事本blog 存二进制文件，容量是好几个G 项目实例：idea项目ideaProjects-&gt;src.main.java.com.haien.MyClob(存取都在里面了)","categories":[],"tags":[]},{"title":"","slug":"JdbcTemplate配置连接池与JdbcDaoSupport","date":"2019-04-30T08:25:45.278Z","updated":"2019-03-13T04:03:46.641Z","comments":true,"path":"2019/04/30/JdbcTemplate配置连接池与JdbcDaoSupport/","link":"","permalink":"http://47.107.237.149/2019/04/30/JdbcTemplate配置连接池与JdbcDaoSupport/","excerpt":"","text":"SpringBoot整合JdbcTemplate参考文章主要内容 JdbcTemplate其实就是用来操作数据库的，是最基本的Spring JDBC模板，是对JDBC很轻的封装，具有较高的执行效率（基于jdbc的数据操作要比hibernate那些效率都高，尤其批量处理），一般用于系统数据库并发操作压力大的项目中。 Spring数据访问模板：在数据库操作过程中，有很多重复工作，如事务控制、资源管理和异常处理等，Spring的模板类封装了这些固定部分。 主要包含以下四类方法： execute()：执行任何sql语句，一般用于执行ddl语句。 update()、batchUpdate()：执行（批量执行新增、修改、删除语句。 query()、queryForXxx()：执行查询语句。 call()：执行存储过程、函数等语句；当然，前面的三种方法其sql语句都可以带函数。 参考文章 首先操作数据库需要添加以下依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 在application.properties中配置数据源 spring.datasource.url = jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.username = root spring.datasource.password = root spring.datasource.driver-class-name = com.mysql.jdbc.Driver spring-boot-starter-jdbc默认使用tomcat-jdbc数据源，推荐使用其他数据源尤其是阿里巴巴的数据池管理，请额外添加以下依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.19&lt;/version&gt; &lt;/dependency&gt; 连接池详情参见笔记：连接池 然后在Application.java配置DataSource，这里介绍两种方式 第一种：application.properties只配置jdbc驱动，数据池配置则全写在入口类 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } //Environment这个类是用来加载application.properties文件中的属性的 @Autowired private Environment env; //destroy-method=&quot;close&quot;的作用是当数据库连接不使用的时候,就把该连接重新放到数据池中,方便下次使用调用. @Bean(destroyMethod = &quot;close&quot;) public DataSource dataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(env.getProperty(&quot;spring.datasource.url&quot;)); //引用配置文件的变量 dataSource.setUsername(env.getProperty(&quot;spring.datasource.username&quot;));//用户名 dataSource.setPassword(env.getProperty(&quot;spring.datasource.password&quot;));//密码 dataSource.setDriverClassName(env.getProperty(&quot;spring.datasource.driver-class-name&quot;)); dataSource.setInitialSize(2);//初始化时建立物理连接的个数 dataSource.setMaxActive(20);//最大连接池数量 dataSource.setMinIdle(0);//最小连接池数量 dataSource.setMaxWait(60000);//获取连接时最大等待时间，单位毫秒。 dataSource.setValidationQuery(&quot;SELECT 1&quot;);//用来检测连接是否有效的sql dataSource.setTestOnBorrow(false);//申请连接时执行validationQuery检测连接是否有效 dataSource.setTestWhileIdle(true);//建议配置为true，不影响性能，并且保证安全性。 dataSource.setPoolPreparedStatements(false);//是否缓存preparedStatement，也就是PSCache return dataSource; } } 第二种：在application.properties中写全部配置，在入口类用@ConfigurationProperties直接把变量封装到类中 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=root spring.datasource.password=123456 #阿里巴巴连接池配置 #最大连接池数量 spring.datasource.max-active=20 #最小连接池数量 spring.datasource.min-idle=8 #获取连接时最大等待时间 spring.datasource.maxWait=60000 #初始化时建立连接的个数 spring.datasource.initialSize=2 #申请连接时执行ValidationQuery检测连接是否有效，建议为false，因为做了这个配置会降低性能；若下面那行括号为null则这一行怎么写都不生效 spring.datasource.testOnBorrow=false #用来检测连接是否有效的sql，要求是一个查询语句 spring.datasource.validationQuery=&quot;SELECT 1&quot; #建议配置为true，不影响性能且保证安全性；作用是在ValidationQuery上加个条件：当空闲时间大于timeBetweenEvictionRunsMillis时才执行连接检测 spring.datasource.testWhileIdle=true #是否缓存preparedStatement spring.datasource.poolPreparedStatements=true 入口类 @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class,args); } @Bean(destroyMethod = &quot;close&quot;) //destroyMethod = &quot;close&quot;：当数据库连接不使用时就把该连接重新放到数据池中，方便下次调用 @ConfigurationProperties(prefix=&quot;spring.datasource&quot;) //直接使用配置文件中前缀为这个的属性来set DataSource的属性 public DataSource dataSource(){ return new DruidDataSource(); } } Springboot会自动选择我们自己配置的这个DataSource实例 在dao层注入jdbcTemplate，它有很多操作数据库的方法 @Repository public class LearnDaoImpl implements LearnDao{ @Autowired private JdbcTemplate jdbcTemplate; @Override public int add(LearnResouce learnResouce) { return jdbcTemplate.update(&quot;insert into learn_resource(author, title,url) values(?, ?, ?)&quot;,learnResouce.getAuthor(),learnResouce.getTitle(),learnResouce.getUrl()); } } 代码实例：SpringMvc02 应该是跑不起来，反正看一看理解原理就是了 Spring整合JdbcTemplate 引入依赖 &lt;dependency&gt; &lt;!--使用JdbcTemplate，方便数据库操作--&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; JdbcTemplateUtils：获取JdbcTemplate对象，单例模式 /** * @Author haien * @Description 获取JdbcTemplate对象，单例模式 * @Date 2019/2/24 **/ public class JdbcTemplateUtils { private static JdbcTemplate jdbcTemplate; /** * @Author haien * @Description 单例模式 * @Date 2019/2/24 * @Param [] * @return org.springframework.jdbc.core.JdbcTemplate **/ public static JdbcTemplate jdbcTemplate(){ if(jdbcTemplate==null) jdbcTemplate=createJdbcTemplate(); return jdbcTemplate; } /** * @Author haien * @Description 配置数据源 * @Date 2019/2/25 * @Param [] * @return org.springframework.jdbc.core.JdbcTemplate **/ private static JdbcTemplate createJdbcTemplate(){ DruidDataSource ds=new DruidDataSource(); ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); ds.setUrl(&quot;jdbc:mysql://127.0.0.1:3306/shiro&quot;); ds.setUsername(&quot;root&quot;); ds.setPassword(&quot;123456&quot;); return new JdbcTemplate(ds); } } UserDaoImpl:使用JdbcTemplate对象 public class UserDaoImpl implements UserDao { private JdbcTemplate jdbcTemplate = JdbcTemplateUtils.jdbcTemplate(); @Override public User createUser(final User user) { final String sql = &quot;insert into sys_users(username, password, salt, locked) &quot; + &quot;values(?,?,?,?)&quot;; GeneratedKeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException { //没有第二个参数应该也能获取到新生id PreparedStatement psst = connection.prepareStatement(sql, new String[] { &quot;id&quot; }); psst.setString(1, user.getUsername()); psst.setString(2, user.getPassword()); psst.setString(3, user.getSalt()); psst.setBoolean(4, user.getLocked()); return psst; } }, keyHolder); user.setId(keyHolder.getKey().longValue()); return user; } @Override public void updateUser(User user) { String sql = &quot;update sys_users set username=?, password=?, salt=?, locked=? where id=?&quot;; jdbcTemplate.update(sql, user.getUsername(), user.getPassword(), user.getSalt(), user.getLocked(), user.getId()); } @Override public void deleteUser(Long userId) { String sql = &quot;delete from sys_users where id=?&quot;; jdbcTemplate.update(sql, userId); } @Override public void correlationRoles(Long userId, Long... roleIds) { if(roleIds == null || roleIds.length == 0) { return; } String sql = &quot;insert into sys_users_roles(user_id, role_id) values(?,?)&quot;; for(Long roleId : roleIds) { if(!exists(userId, roleId)) { jdbcTemplate.update(sql, userId, roleId); } } } @Override public void uncorrelationRoles(Long userId, Long... roleIds) { if(roleIds == null || roleIds.length == 0) { return; } String sql = &quot;delete from sys_users_roles where user_id=? and role_id=?&quot;; for(Long roleId : roleIds) { if(exists(userId, roleId)) { jdbcTemplate.update(sql, userId, roleId); } } } private boolean exists(Long userId, Long roleId) { String sql = &quot;select count(1) from sys_users_roles where user_id=? and role_id=?&quot;; return jdbcTemplate.queryForObject(sql, Integer.class, userId, roleId) != 0; } @Override public User findOne(Long userId) { String sql = &quot;select id, username, password, salt, locked from sys_users where id=?&quot;; List&lt;User&gt; userList = jdbcTemplate.query(sql, new BeanPropertyRowMapper(User.class), userId); if(userList.size() == 0) { return null; } return userList.get(0); } @Override public User findByUsername(String username) { String sql = &quot;select id, username, password, salt, locked from sys_users where username=?&quot;; List&lt;User&gt; userList = jdbcTemplate.query(sql, new BeanPropertyRowMapper(User.class), username); if(userList.size() == 0) { return null; } return userList.get(0); } @Override public Set&lt;String&gt; findRoles(String username) { String sql = &quot;select role from sys_users u, sys_roles r,sys_users_roles ur &quot; + &quot;where u.username=? and u.id=ur.user_id and r.id=ur.role_id&quot;; return new HashSet(jdbcTemplate.queryForList(sql, String.class, username)); } @Override public Set&lt;String&gt; findPermissions(String username) { //TODO 此处可以优化，比如查询到role后，一起获取roleId，然后直接根据roleId获取即可 String sql = &quot;select permission from sys_users u, sys_roles r, sys_permissions p, &quot; + &quot;sys_users_roles ur, sys_roles_permissions rp &quot; + &quot;where u.username=? and u.id=ur.user_id and r.id=ur.role_id &quot; + &quot;and r.id=rp.role_id and p.id=rp.permission_id&quot;; return new HashSet(jdbcTemplate.queryForList(sql, String.class, username)); } } jdbcTemplate.queryForInt() 和 jdbcTemplate.queryForLong()：返回查询结果条数，根据预估数目大小选择int或long String sql=&quot;SELECT count(*) FROM mcp_forum_post&quot;; Integer todayCount=jdbcTemplate.queryForInt(sql); //或 Long todayCount=jdbcTemplate.queryForLong(sql); jdbcTemplate.queryForObject(String sql, Class requiredType, sql语句所需参数): 返回查询sql中指定字段，并用requiredType类型承接。要求结果集只有一条记录，否则抛异常。 String sql=&quot;select account from scpn_user where user_id=&quot;+userAccountId; //sql指明返回account字段，故返回account字段 //account是String类，但即使account是int型，指定为String类也可以，不知是否指定为任何类都可以 String userAccount=(String)jdbcTemplate.queryForObject(sql, String.class); 若sql语句查询所有字段，则无论requiredType是什么，都只返回查询到的记录总数，也就是0或1，常用来判断查询是否成功。 String sql=&quot;select * from scpn_user where user_id=&quot;+userAccountId; String userAccount=(String)jdbcTemplate.queryForObject(sql, String.class); //userAccount=1 jdbcTemplate.queryForMap()：查询一条记录，将各个字段及其值作为键值对封装进Map。 String userAccountSql=&quot;select account,create_time from scpn_user where user_id=&quot;+userAccountId; Map userAccountMap=(Map)jdbcTemplate.queryForMap(userAccountSql); String userAccount= (String)userAccountMap.get(&quot;account&quot;); String createTime= (String)userAccountMap.get(&quot;create_time&quot;).toString(); jdbcTemplate.queryForList()：查询多条记录，一条一个Map，多个Map组成一个List String all=&quot;SELECT * FROM mcp_forum_post&quot;; List scpnPostList = jdbcTemplate.queryForList(all); if (scpnPostList!=null) { for (int i = 0; i &lt; scpnPostList.size(); i++) { Long userAccountId = (Long) scpnPostList.get(i).get(&quot;user_id&quot;); Long lastmodUser = (Long) scpnPostList.get(i).get(&quot;lastmod_user&quot;); } } JdbcTemplate.queryForXxx()总结 jdbcTemplate.query(String sql,RowMapper rowMapper,sql所需参数)：将查询到的结果封装进rowMapper类。 //需定义一个匿名实现类 User user = jdbcTemplate.query(sql,new RowMapper&lt;User&gt;(){ @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setId(rs.getInt(&quot;id&quot;)); user.setUsername(rs.getString(&quot;username&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); return user; } }); //或者放一个自定义实现类进去 user = jdbcTemplate.query(sql, new UserRowMapper()); //实现类 public class UserRowMapper implements RowMapper&lt;User&gt; { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setId(rs.getInt(&quot;id&quot;)); user.setUsername(rs.getString(&quot;username&quot;)); user.setPassword(rs.getString(&quot;password&quot;)); return user; } } 也可以使用Spring提供的RowMapper实现类BeanPropertyRowMapper：org.springframework.jdbc.core.BeanPropertyRowMapper，指定封装的类型即可。 //只能返回List List&lt;User&gt; userList = jdbcTemplate.query(sql, new BeanPropertyRowMapper(User.class)); 实现原理：根据sql列名/别名找对应setter，映射规则就是大写变成”_小写”. //比如role_ids字段，User类中只有setRoleIdsStr(),故要取别名 String sql = &quot;select id, organization_id, username, password, salt, role_ids &quot; + &quot;as roleIdsStr, locked from sys_user where id=?&quot;; List&lt;User&gt; userList = jdbcTemplate.query(sql, new BeanPropertyRowMapper(User.class), userId); 代码实例：ideaProjects/shiroHelloWorld/utils/JdbctemplateUtils、dao/impl/UserDaoImpl；ideaProjects/shirochapter16/dao/impl/UserDaoImpl JdbcDaoSupport 使用了JdbcTemplate后，我们在书写dao层时还要每个dao都引入JdbcTemplate的实例，而继承JdbcDaoSupport后，这个类就会负责处理JdbcTemplate对象，而且会负责数据库的自动关闭。 方法如下： //设置JdbcTemplate public final void setJdbcTemplate(JdbcTemplate jdbcTemplate) //获取JdbcTemplate public final JdbcTemplate getJdbcTemplate() 操作JdbcTemplate： getJdbcTemplate().update(sql); 示例 PermissionDaoImpl：dao实现层，继承JdbcDaoSupport public class PermissionDaoImpl extends JdbcDaoSupport implements PermissionDao { @Override public void deletePermission(Long permissionId) { String sql = &quot;delete from sys_roles_permissions where permission_id=?&quot;; getJdbcTemplate().update(sql, permissionId); } } spring-beans.xml：注册PermissionDaoImpl、注入DataSource以创建JdbcTemplate（不用显式创建JdbcTemplate了） &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/shiro&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/bean&gt; &lt;!-- Base DAO: abstract=&quot;true&quot;即该类不能被实例化，默认false；抽象bean可以不映射任何类 --&gt; &lt;bean id=&quot;baseDao&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- DAO：虽然没有BaseDao这个实际类，PermissionDaoImpl类也不是BaseDao的子类，但它是 JdbcDaoSupport的子类，继承了dataSource属性，现在指明parent为baseDao，则注入了dataSource 属性进来，JdbcDaoSupport会以此创建JdbcTemplate的，所以上面dao层getJdbcTemplate()得到的 就是这个JdbcTemplate--&gt; &lt;bean id=&quot;permissionDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.PermissionDaoImpl&quot; parent=&quot;baseDao&quot;/&gt; &lt;!--之所以定义抽象类是因为有好多个dao需要这个属性--&gt; &lt;bean id=&quot;roleDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.RoleDaoImpl&quot; parent=&quot;baseDao&quot;/&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.haien.shirochapter12.dao.impl.UserDaoImpl&quot; parent=&quot;baseDao&quot;/&gt; 代码实例：ideaProjects/shirochapter12/dao/impl、spring-beans.xml 参考文章","categories":[],"tags":[]},{"title":"","slug":"JDBC","date":"2019-04-30T08:25:45.273Z","updated":"2018-04-16T01:42:51.388Z","comments":true,"path":"2019/04/30/JDBC/","link":"","permalink":"http://47.107.237.149/2019/04/30/JDBC/","excerpt":"","text":"JDBC是Java数据库连接技术，MySql是数据库软件之一，通过JDBC使得我们可以直接使用Java编程来处理数据库。 其中next方法： 建立连接时谨记须指定字符集存储大数据对象","categories":[],"tags":[]},{"title":"","slug":"Java中的正则表达式","date":"2019-04-30T08:25:45.268Z","updated":"2018-12-02T06:10:59.674Z","comments":true,"path":"2019/04/30/Java中的正则表达式/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java中的正则表达式/","excerpt":"","text":"js的转义字符是 \\ java的转义字符是\\ \\ 匹配正则表达式使用matches 如 string qq = 36786256; s.matches(“[1-9]\\ \\d{4,10}”); 也可以用matcher Pattern p = Pattern.compile(“A\\ \\d”);//建立模式对象,可以是某个字符串，可以传多一个参数Pattern.CASE_INSENSITIVE，表示忽略大小写 Matcher m = p.matcher(“gaha”); if(m.matches()) { System.out.println(&quot;完全匹配&quot;) } else { System.out.println(&quot;不完全匹配&quot;) } 正则验证字符串是否时间 public static boolean isTime(String str){ Pattern pattern=Pattern.compile(&quot;[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}&quot;); Matcher matcher=pattern.matcher(str); return matcher.matches(); }","categories":[],"tags":[]},{"title":"","slug":"Java中String、StringBuilder、StringBuffer三者的区别","date":"2019-04-30T08:25:45.263Z","updated":"2018-11-20T14:46:06.180Z","comments":true,"path":"2019/04/30/Java中String、StringBuilder、StringBuffer三者的区别/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java中String、StringBuilder、StringBuffer三者的区别/","excerpt":"","text":"运行速度 就运行速度而言，StringBuilder &gt; StringBuffer &gt; String 原因：String为字符串常量，而StringBuilder和StringBuffer为字符串变量。String对象一经创建之后是不可更改的，但后两者的对象是可以更改的。举例： String str=&quot;abc&quot;; str=str+&quot;de&quot;; str最后是abcde，好像是str这个对象被更改了，其实不然。JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋给str，然后在第二行中，JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了。 str实际上并没有被更改，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 而StringBuilder和StringBuffer的对象时变量，对变量进行操作就是直接对该对象进行修改，而不进行创建和回收，所以速度要比String快很多。 然而，有时我们会这样对字符串进行赋值 String str=&quot;abc&quot;+&quot;de&quot;; StringBuilder stringBuilder=new StringBuilder().append(&quot;abc&quot;).append(&quot;de&quot;); System.out.println(str); System.out.println(stringBuilder.toString()); 这时String的速度却比StringBuilder要快很多，这是因为第一行中的操作和String str = “abcde”是完全一样的，所以会很快，而如果写成下面这种形式： String str1=&quot;abc&quot;; String str2=&quot;de&quot;; String str=str1+str2; 那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了，速度就会很慢。 除了连接之外，StringBuilder的replace（int start,int end,String str)方法实际要比String的重新赋值要慢得多。所以如果是一个变量要被不断地更换字符串的话那用String会更快。线程安全 StringBuilder是线程不安全的，而StringBuffer是线程安全的。 如果一个StringBuffer对象再字符串缓冲区被多个线程使用时，StringBuffer中有很多方法带有synchronized关键字，可以保证线程是安全的。 但是StringBuilder的方法则没有该关键字，有可能会出现一些错误的操作。 所以多线程情况下，应该使用StringBuffer，单线程情况下，建议使用速度较快的StringBuilder。总结 String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用于多线程下在字符缓冲区进行大量操作的情况","categories":[],"tags":[]},{"title":"","slug":"Java项目命名规范","date":"2019-04-30T08:25:45.259Z","updated":"2018-11-19T06:51:20.157Z","comments":true,"path":"2019/04/30/Java项目命名规范/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java项目命名规范/","excerpt":"","text":"项目名全部小写 包名全部小写","categories":[],"tags":[]},{"title":"","slug":"Java随机数生成器-Random类","date":"2019-04-30T08:25:45.246Z","updated":"2019-02-10T02:58:16.338Z","comments":true,"path":"2019/04/30/Java随机数生成器-Random类/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java随机数生成器-Random类/","excerpt":"","text":"两种构造方法 Random(); //创建一个新的随机数生成器，默认使用当前系统时间的毫秒数作为种子，一旦选中即不变，而不是根据时间改变 Random(20); //指定种子，即随机算法的起源数字 生成随机整数 Random rand =new Random(25); int i=rand.nextInt(100); //100是上上限，[0,100) 种子的作用：对于种子相同的Random对象，生成的随机数序列是一样的。 public static void main(String[] args) { Random ran1 = new Random(10); System.out.println(&quot;使用种子为10的Random对象生成[0,10)内随机整数序列: &quot;); for (int i = 0; i &lt; 10; i++) { System.out.print(ran1.nextInt(10) + &quot; &quot;); } Random ran2 = new Random(10); System.out.println(&quot;使用另一个种子为10的Random对象生成[0,10)内随机整数序列: &quot;); for (int i = 0; i &lt; 10; i++) { System.out.print(ran2.nextInt(10) + &quot; &quot;); } /** * 输出结果为： * * 使用种子为10的Random对象生成[0,10)内随机整数序列: * 3 0 3 0 6 6 7 8 1 4 * 使用另一个种子为10的Random对象生成[0,10)内随机整数序列: * 3 0 3 0 6 6 7 8 1 4 * */ } 相同种子的Random对象，相同次数两个对象生成的随机数相同，但同个对象不同次数生成的随机数不同。 只有一个Random对象，上次执行程序与下次产生的随机数不同。 如果想避免出现测试数据相同的情况，则无论需要生成多少个随机数，都只是用一个Random对象即可。 使用时间或自定义种子都很容易生成重复的随机数，可借助数组和集合类剔除重复数 //生成 [0-n) 个不重复的随机数 public ArrayList getDiffNO(int n){ ArrayList list = new ArrayList(); //list 用来保存这些随机数 Random rand = new Random(); boolean[] bool = new boolean[n]; //默认初始值为false int num = 0; //开始产生随机数 for (int i = 0; i &lt; n; i++) { do { //如果产生的数相同继续循环 num = rand.nextInt(n); } while (bool[num]); //第一个肯定是false，不会循环的 bool[num] = true; list.add(num); } return list; } 方法简介 protected int next(int bits)：生成下一个伪随机数（其随机算法实际是有规则的，故称为伪随机）。 boolean nextBoolean()：返回下一个伪随机数，false或true。 void nextBytes(byte[] bytes)：生成随机字节并将其置于用户提供的 byte 数组中。若Random对象时同一个，则每次生成的数组都相同。 public static void main(String[] args) { byte[] bytes=new byte[10]; Random random=new Random(); //加不加种子、加什么种子都一样 random.nextBytes(bytes); System.out.println(bytes); //每次调用生成的数组都一样 //下面这一块产生的数组也和上面一样 Random random2=new Random(); random2.nextBytes(bytes); System.out.println(bytes); } double nextDouble()：[0.0,1.0)之间均匀分布的 double值。 float nextFloat()：[0.0,1.0)之间均匀分布float值。 double nextGaussian()：返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的double值，其平均值是0.0标准差是1.0。即一个double型的Gaussian值。 int nextInt()：随机 int 值，[-2^31,2^31-1]。 int nextInt(int n)：返回指定上限的随机int值。 long nextLong()：随机 long 值。 void setSeed(long seed)：设置种子。 生成[0,5.0)区间的小数：double d2 = r.nextDouble() * 5; 生成[1,2.5)区间的小数：先把左区间减到0，double d3 = r.nextDouble() * 1.5 + 1; 生成[0,10)区间的整数： int n2 = r.nextInt(10);//方法一 n2 = Math.abs(r.nextInt() % 10);//方法二","categories":[],"tags":[]},{"title":"","slug":"Java数据结构之有向图","date":"2019-04-30T08:25:45.242Z","updated":"2018-12-06T03:24:04.266Z","comments":true,"path":"2019/04/30/Java数据结构之有向图/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java数据结构之有向图/","excerpt":"","text":"术语 有向完全图：把所有顶点都用边连起来的图，共n(n-1)条边。 简单有向路径：不含重复顶点。我们讨论的“路径”都是简单的。 简单有向环：除了起终点之外不含重复顶点和边的环。 邻接表中的索引是边的起点，值是边的终点。构造图 基本和无向图相同，其中邻接表存储边的时候只需要存储一次，而addEdge(int v,int w)参数有前后之分，前一个表示起点，后一个为终点。 /** * @Author haien * @Description Direct graph有向图 * @Date 2018/12/4 **/ public class Digraph { //顶点数 private int V; //边数 private int E; //邻接点背包数组 private Bag&lt;Integer&gt;[] adj; public Digraph(int V) { this.V=V; this.E=0; adj=(Bag&lt;Integer&gt;[])new Bag[V]; for(int i=0;i&lt;V;i++) adj[i]=new Bag&lt;Integer&gt;(); } public int V(){ return V(); } public int E(){ return E; } public void addEdge(int v,int w){ adj[v].add(w); E++; } public Iterable&lt;Integer&gt; adj(int v){ return adj[v]; } /** * @Author haien * @Description 将图中所有边的方向逆转 * @Date 2018/12/4 * @Param [] * @return void **/ public Digraph reverse(){ Digraph R=new Digraph(V); for(int v=0;v&lt;V;v++){ for(int w:adj[v]) R.addEdge(w,v); } return R; } } 深度优先搜索 和无向图几乎一样；能够判断从给定的一个点或一组点能到达哪些其他点，即单点可达性和多点可达性。 public class DirectedDFS { private boolean[] marked; /** * @Author haien * @Description 单点可达性：从一个点出发能到达哪些点 * @Date 2018/12/4 * @Param [G, s] **/ public DirectedDFS(Digraph G,int s) { marked=new boolean[G.V()]; dfs(G,s); } /** * @Author haien * @Description 多点可达性：从一组点中任一点触发能到达哪些点 * @Date 11:24 2018/12/4 * @Param [G, sources] **/ public DirectedDFS(Digraph G,Iterable&lt;Integer&gt; sources) { marked=new boolean[G.V()]; for(int s:sources) { if (!marked[s]) dfs(G,s); } } private void dfs(Digraph G,int v){ marked[v]=true; for(int w: G.adj(v)){ if(!marked[w]) dfs(G,w); } } public boolean marked(int v) { return marked[v]; } } 多点可达性的一个应用是在内存管理系统中，一个顶点表示一个对象，一条边则表示一个对象对另一个对象的引用。内存管理系统会周期性地回收不可达的对象。拓扑排序 规定一条路径中起点到终点的优先级依次递减，用这种方法实现的排序叫拓扑排序。 拓扑排序中不可能存在环，因为环中的顶点根本无法分清优先级。 /** * @Author haien * @Description 寻找图中的有向环 * @Date 2018/12/4 **/ public class DirectedCycle { private boolean[] marked; //索引的上一个顶点 private int[] lastVertex; //有向环中的所有顶点 private Stack&lt;Integer&gt; cycle; //递归调用的栈上的所有顶点 private boolean[] onStack; public DirectedCycle(Digraph G) { onStack=new boolean[G.V()]; lastVertex=new int[G.V()]; marked=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++){ if(!marked[v]) dfs(G,v); } } private void dfs(Digraph G,int v){ onStack[v]=true; marked[v]=true; for(int w:G.adj(v)){ if(hasCycle()) return; else if(!marked[w]){ lastVertex[w]=v; dfs(G,w); } else if(onStack[w]){ cycle=new Stack&lt;Integer&gt;(); for(int x=v;x!=w;x=lastVertex[x]) cycle.push(x); cycle.push(w); cycle.push(v); } } //递归出栈后，刚找到的环all元素全变成false，直到遇到还有其他邻接点可遍历的顶点，才保持true onStack[v]=false; } public boolean hasCycle() { return cycle!=null; } public Iterable&lt;Integer&gt; cycle(){ return cycle; } } 然后我们来尝试几种排序方法，从中摸索哪一种符合拓扑排序 /** * @Author haien * @Description 基于深搜的顶点排序 * @Date 2018/12/5 **/ public class DepthFirstOrder { private boolean[] marked; //所有顶点的前序排序 private Queue&lt;Integer&gt; pre; //后序排序 private Queue&lt;Integer&gt; post; //逆后序排序 private Stack&lt;Integer&gt; reversePost; public DepthFirstOrder(Digraph G) { pre=new Queue&lt;Integer&gt;(); post=new Queue&lt;Integer&gt;(); reversePost=new Stack&lt;Integer&gt;(); marked=new boolean[G.V()]; for (int v=0;v&lt;G.V();v++){ if (!marked[v]) dfs(G,v); } } private void dfs(Digraph G,int v){ pre.enQueue(v); marked[v]=true; for(int w:G.adj(v)){ if(!marked[w]) dfs(G,w); } post.enQueue(v); reversePost.push(v); //这种排序即拓扑排序 } public Iterable&lt;Integer&gt; pre(){ return pre; } public Iterable&lt;Integer&gt; post(){ return post; } public Iterable&lt;Integer&gt; reversePost(){ return reversePost; } } 详细过程参考《算法》579页reversePost过程，这就是拓扑排序了 拓扑排序的前提是不存在环，因此实现算法之前必须先检测环","categories":[],"tags":[]},{"title":"","slug":"Java数据结构之无向图","date":"2019-04-30T08:25:45.238Z","updated":"2018-12-06T03:28:51.514Z","comments":true,"path":"2019/04/30/Java数据结构之无向图/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java数据结构之无向图/","excerpt":"","text":"术语 简单图：没有平行边和自环的图。 平行边：连接同一对顶点的两条边。 多重图：含有平行边（连接同一对结点的两条边称为平行边）的图。 二分图：顶点可分为两堆，两堆之间有边相连，但两堆之中没有。 度数：顶点所连接的边数。 子图：只含原图的一部分顶点或边。 无向完全图：把图中所有顶点都用边相连形成的图，共包含n(n-1)/2条边。 带权图和网：带权的图称为带权图或网。 路径：由边顺序连接的一系列顶点。 简单路径：不含重复顶点。 环和回路：至少含有一条边且起终点相同的路径。 简单环：除了起终点不含重复顶点或边的环。 大多数情况下提到路径和环都是指简单路径和简单环。 当允许重复的顶点时，我们指的是一般的路径和环。 连通图：没有割裂的顶点，任何顶点之间可以互达。 非连通图：由若干连通子图构成，每个都是原图的极大连通子图（极大连通分量）。要处理一张非连通图就要一个个地处理其连通子图。 连通图的生成树：首先，无环就叫树，而除去图中那些会构成环的边之后剩下的边和所有顶点就构成了生成树。 非连通图的生成树森林：互不相连的树构成森林。非连通图的每个连通子图都有一棵生成树，它们组成一片森林。无向图 顶点与边的表示方法 邻接矩阵：用一个v*v的布尔矩阵，当顶点v和w有边时，把第v行w列设为true。缺点：浪费空间；同一条边表示两次；不能表示平行边。 边的数组：使用一个Edge类，它含有两个int型变量，即为相连的两个顶点。缺点：要找某个顶点的所有邻接点需要遍历所有边。 邻接点背包数组：也就是下面算法要选择的方式。 我们用0~v-1的连续整数表示v个顶点，并为这v个结点分别创建一个背包，存储它们各自的邻接点，以此来表示两个顶点之间有边相连。 public class Graph { //顶点数目：一旦指定，不允许新增顶点 private final int V; //边数目 private int E; //邻接点背包数组：索引是顶点，背包里的元素时它的所有邻接点 private Bag&lt;Integer&gt;[] adj; /** * @Author haien * @Description 构造指定顶点数目、没有边的图 * @Date 2018/11/27 * @Param [V] * @return **/ public Graph(int V) { this.V=V; this.E=0; //初始化邻接点背包数组 adj=(Bag&lt;Integer&gt;[])new Bag[V]; //不能创建泛型指定类型的泛型数组，只能先创建泛型数组再强转 //这一步省略试试？？？ /*for(int v=0;v&lt;V;v++){ adj[v]=new Bag&lt;Integer&gt;(); }*/ } /** * @Author haien * @Description 从文件读取顶点数目、边数和若干整数对（表示相连两顶点） * @Date 2018/11/27 * @Param [in] * @return **/ public Graph(In in) { //读取顶点数目 this(in.readInt()); //读取边数 this.E=in.readInt(); //连线 for(int e=0;e&lt;E;e++){ //读取顶点对 int v=in.readInt(); int w=in.readInt(); //互相加到彼此的邻接点背包里面 addEdge(v,w); } } //获取顶点数 public int V(){ return V; } //获取边数 public int E(){ return E; } /** * @Author haien * @Description 添加一条边 * @Date 2018/11/27 * @Param [v, w] * @return void **/ public void addEdge(int v,int w){ adj[v].add(w); adj[w].add(v); E++; } /** * @Author haien * @Description 返回指定顶点的邻接点背包，Bag实现了Iterable接口，所以可以用forEach来遍历背包中的整数 * @Date 2018/11/27 * @Param [v] * @return java.lang.Iterable&lt;java.lang.Integer&gt; **/ public Iterable&lt;Integer&gt; adj(int v){ //返回v的背包 return adj[v]; //Bag类实现了Iterable接口，所以可以用Bag类实现了Iterable接口作为返回类型 } } 深度优先搜索 情景之迷宫找出口：在每一个路口都把分岔路走一遍，走到死胡同就返回上一个路口，走另一条岔路。 下面算法实现的是找出以某一顶点为起点的所有路径 /** * @Author haien * @Description 深度优先搜索：遍历每一个顶点，将它标记为已访问，递归地访问它的所有没有被标记的邻接点 * @Date 2018/11/27 **/ public class DepthFirstSearch { //是否已访问 private boolean[] marked; //已访问顶点个数 private int count; /** * @Author haien * @Description 传入图及其起始点 * @Date 2018/11/27 * @Param [G, s] * @return **/ public DepthFirstSearch(Graph G,int s) { marked=new boolean[G.V()]; dfs(G,s); } /** * @Author haien * @Description 实质：以随机路径访问all点，不一定能走到所有的边 * @Date 2018/11/27 * @Param [G, v] * @return void **/ public void dfs(Graph G,int v){ marked[v]=true; count++; for(int w : G.adj(v)){ if(!marked[w]) { //每个顶点只访问一遍 dfs(G, w); } } } /** * @Author haien * @Description 如果仅仅只是迷宫找出口而不需要遍历all点的话，改造一下 * @Date 2018/11/27 * @Param [G, v] * @return void **/ public void dfs(Graph G,int v){ if(找到出口){ flag=1; //新增一个全局属性flag } if(flag==1){ return; } marked[v]=true; count++; for(int w : G.adj(v)){ if(flag==1) break; //其实有上面的if(flag==1)应该就不用这句了 if(!marked[w]) { //每条路径只走一遍，两个顶点之间不会来回走 dfs(G, w); } } } } 应用一：连通性。判断给定的两个顶点是否连通（两点即为迷宫出入口）；计算图中有多少个连通子图（每调用一次dfs，访问到的all点构成一幅连通子图，下一次则对剩下的点调用dfs） /** * @Author haien * @Description 用深度优先搜索统计图中的连通分量 * @Date 2018/12/3 **/ public class ConnectedComponents { private boolean[] marked; //索引：顶点；值：分量标识符（第1个分量为0，第n个分量为n-1） private int[] id; //分量数 private int count; public ConnectedComponents(Graph G) { marked=new boolean[G.V()]; id=new int[G.V()]; //对每个未标记的顶点都进行广搜，把与之连通的点都mark上 for(int v=0;v&lt;G.V();v++){ if(!marked[v]){ dfs(G,v); count++; } } } /** * @Author haien * @Description 深度优先搜索：把跟v连通的顶点都标记上 * @Date 2018/12/3 * @Param [G, v] * @return void **/ private void dfs(Graph G,int v){ marked[v]=true; id[v]=count; for(int w:G.adj(v)){ if(!marked[w]){ dfs(G,w); } } } /** * @Author haien * @Description 判断v、w是否连通 * @Date 2018/12/3 * @Param [v, w] * @return boolean **/ public boolean connected(int v,int w){ return id[v]==id[w]; //在同一分量即连通 } /** * @Author haien * @Description 查找v所在连通分量 * @Date 2018/12/3 * @Param [v] * @return int **/ public int id(int v){ return id[v]; } /** * @Author haien * @Description 返回连通分量数 * @Date 2018/12/3 * @Param [] * @return int **/ public int count(){ return count; } } 应用二：找路径。找到从s到v的一条路径。 public class DepthFirstPaths { //顶点是否已被访问 private boolean[] marked; //索引：当前路径的最后一个顶点；值：上一个顶点 private int[] lastVertex; //起点 private final int s; public DepthFirstPaths(Graph G,int s) { marked=new boolean[G.V()]; lastVertex=new int[G.V()]; this.s = s; dfs(G,s); } /** * @Author haien * @Description 查找出一条包含所有顶点的路径:只需要调用此函数一次，就可以找到s到其他所有顶点的一条路径 * @Date 2018/11/27 * @Param [G, v] * @return void **/ public void dfs(Graph G,int v){ marked[v]=true; for(int w : G.adj(v)){ if(!marked[w]) { lastVertex[w]=v; dfs(G, w); } } } /** * @Author haien * @Description 是否存在从s到v的路径 * @Date 2018/11/27 * @Param [v] * @return boolean **/ public boolean hasPathto(int v){ return marked[v]; //初始化图时会调用dfs，它会把所有和s连通的顶点打上标记 } /** * @Author haien * @Description 找到s到v的一条路径 * @Date 2018/11/27 * @Param [v] * @return java.lang.Iterable&lt;java.lang.Integer&gt; **/ public Iterable&lt;Integer&gt; pathTo(int v){ if(!hasPathto(v)) return null; Stack&lt;Integer&gt; path=new Stack&lt;&gt;(); //从终点反追踪回起点 for(int x=v;x!=s;x=lastVertex[x]){ path.push(x); } path.push(s); return path; } } 应用三：确定图是为否无环图 /** * @Author haien * @Description 深搜判断图是否为无环图 * @Date 2018/12/3 * @Param * @return **/ public class Cycle { private boolean[] marked; private boolean hasCycle; public Cycle(Graph G) { marked=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++){ if(!marked[v]) dfs(G,s,s); } } private void dfs(Graph G,int v,int u){ marked[v]=true; for(int w:G.adj(v)){ if(!marked[w]) dfs(G,w,v); //w是下一个要搜其邻接点的点，v是它的上一个点 //如果遇到一个已被访问的点，而且它还不是自己的上一个点，那就形成一个环了 else if(w!=u) hasCycle=true; } } public boolean hasCycle() { return hasCycle; } } 应用四：判断图是否为二分图 /** * @Author haien * @Description 深搜判断图是否为二分图 * @Date 2018/12/3 **/ public class BipartiteGraph { private boolean[] marked; //如果是的话应该可以用两种不同的颜色标记顶点，使得同色顶点之间没有边相连 private boolean[] color; private boolean isBipartite=true; public BipartiteGraph(Graph G) { marked=new boolean[G.V()]; color=new boolean[G.V()]; for(int v=0;v&lt;G.V();v++){ if(!marked[v]) dfs(G,v); } } private void dfs(Graph G,int v){ marked[v]=true; for(int w:G.adj(v)){ if(!marked[w]){ color[w]=!color[v]; dfs(G,w); } //只要出现相连两点同色，则非二分图 else if(color[w]==color[v]) isBipartite=false; } } public boolean isBipartite() { return isBipartite; } } 代码实例 DataStructure/graph广度优先搜索 应用-最短路径：找出点s到点v的最短路径 实现：从s开始，在所有由一条边就可以到达的点中寻找v，如果找不到就继续在距离s两条边的点中寻找。 /** * @Author haien * @Description 使用广度优先搜索查找图中起点到任一顶点的最短路径 * @Date 2018/12/3 **/ public class BreadthFirstPaths { private boolean[] marked; //索引的上一个顶点 private int[] lastVertex; //起点 private final int s; public BreadthFirstPaths(Graph G,int s) { marked=new boolean[G.V()]; lastVertex=new int[G.V()]; this.s = s; bfs(G,s); } /** * @Author haien * @Description 广度优先搜索：查找当前顶点的邻接点，存入队列中，一个个拿出来接着找邻接点，同样存入队列中 * 保证上一层的邻接点全部遍历完后才轮到下一层 * @Date 2018/12/3 * @Param [G, s] * @return void **/ private void bfs(Graph G,int s){ Queue&lt;Integer&gt; queue=new Queue&lt;&gt;(); marked[s]=true; queue.enQueue(s); while (!queue.isEmpty()){ //取出队头 int v=queue.deQueue(); //遍历队头顶点邻接点 for(int w:G.adj(v)){ if(!marked[w]){ lastVertex[w]=v; //想找到s到任一顶点的最短路径，则找到该顶点对应的值即可一路找下去 marked[w]=true; //加到队尾 queue.enQueue(w); } } } } /** * @Author haien * @Description s到v是否存在一条最短路径 * @Date 2018/12/3 * @Param [v] * @return boolean **/ public boolean hasPathTo(int v) { return marked[v]; } /* public Iterable&lt;Integer&gt; pathTo(int v){ //和深度优先搜索的实现相同 } */ } 在同个项目下dataStructure/UF中实现了union-find算法，我们在完成只需要判断连通性或是需要完成大量连通性查询和插入操作混合等类似的任务时，更倾向使用union-find算法；而深度优先搜索则更适合实现图的抽象数据类型，因为它能更有效地利用已有的数据结构。符号图 在典型应用中，图都是通过文件或者网页定义的，使用的是字符串而非整数来指代顶点 比如有一个测试文件，每一行列出一个电影名及其演员名单。那么电影和演员都是顶点，而邻接表中的每一条边都将电影它的表演者联系起来，这是一幅二分图。 测试文件也可以是机场的代码和能从该机场直达的城市。 我们只要建立一个符号图，把字符串转为int型来操作，要显示的时候也能通过此int想找回原来的字符串即可 /** * @Author haien * @Description 建立字符串和int型的一一对应 * @Date 2018/12/3 **/ public class SymbolGraph { //键：字符串；值：int型 private ST&lt;String,Integer&gt; st; //索引：int型；值：字符串 private String[] keys; private Graph G; public SymbolGraph(String stream,String sp) { //stream: 测试文件名；sp: 顶点间的分隔符 //把测试文件搞成输入流，是一行一行、每行几个的演员名 In in=new In(stream); st=new ST&lt;&gt;(); //第一遍读取:顶点转型与存储 while(in.hasNextLine()){ String[] a=in.readLine().split(sp); //为每个不同的字符串关联一个int型索引 for(int i=0;i&lt;a.length;i++){ if(!st.contains(a[i])) st.put(a[i],st.size()); } } //为每个int型索引反向关联一个字符串 keys=new String[st.size()]; for(String name:st.keys()){ keys[st.get(name)]=name; } G=new Graph(st.size()); //第二遍读取：顶点间建立联系 in=new In(stream); while (in.hasNextLine()){ String[] a=in.readLine().split(sp); //将每一行的第一个顶点和其他顶点相连 int v=st.get(a[0]); for(int i=1;1&lt;a.length;i++){ G.addEdge(v,st.get(a[i])); } } } /** * @Author haien * @Description 返回字符串的索引 * @Date 2018/12/3 * @Param [s] * @return boolean **/ public int index(String s) { return st.get(s); } /** * @Author haien * @Description 返回索引的字符串 * @Date 2018/12/3 * @Param [v] * @return java.lang.String **/ public String name(int v){ return keys[v]; } /** * @Author haien * @Description 返回根据输入初始化好长度的图 * @Date 2018/12/3 * @Param [] * @return com.haien.graph.Graph **/ public Graph G(){ return G; } public static void main(String[] args) { //文件输入 String filename=args[0]; //文件名分隔符 String delim=args[1]; SymbolGraph sg=new SymbolGraph(filename,delim); //获得初始化的图 Graph G=sg.G(); //标准输入 while (StdIn.hasNextLine()){ //一行一个电影名 String source = StdIn.readLine(); //找出每部电影的演员表 for(int w:G.adj(sg.index(source))){ //字符串转int StdOut.println(&quot; &quot;+sg.name(w)); //int转字符串 } } } }","categories":[],"tags":[]},{"title":"","slug":"Java数据结构之排序","date":"2019-04-30T08:25:45.233Z","updated":"2019-01-02T12:23:53.911Z","comments":true,"path":"2019/04/30/Java数据结构之排序/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java数据结构之排序/","excerpt":"","text":"Comparable接口 源码： public interface Comparable&lt;T&gt;{ int compareTo(T other); } 主要用于比较 基本类型的包装类、String、File和URL类都实现了这个接口，所以写排序方法时入参可以定义为Comparable[]数组，这样可以接收多个类型的数组 其中浮点数的比较技巧是扩大为长度一致的整型再进行比较，但是无法避免数据为NaN或无穷的情况，建议自定义比较方法选择排序 不具有稳定性：假设倒数四个元素是3332，当擂台是第一个3时，2会被换到它的位置上，擂轮到后面另外两个3来当时，数组都不会动了，那么第一个3变成了最后一个，稳定性就被破坏了。 /** * @Author haien * @Description 选择排序:每趟都比较剩余未排序元素，记住最小的那个的下标，与擂台互换位置 * 时间复杂度：N^2 * 缺点：运行时间和输入无关，一个有序的数组和无序的数组所需排序时间相同 * 优点：数据移动是最少的，最多交换N次，这是其他算法不具备的 * @Date 2018/10/16 * @Param [a] * @return void **/ public static void selectSort(Comparable[] a){ for (int i=0;i&lt;a.length-1;i++){ int min=i; for(int j=i+1;j&lt;a.length;j++){ if(less(a[j],a[min])){ min=j; } } exch(a,i,min); //每趟只需交换一次；如果令剩余未排序元素和擂台比较，只要比擂台小则交换的话，那至多交换剩余元素那么多次 } } 插入排序 具有稳定性，即相等的元素，原来a1在a2前，排序后a1还在a2前 /** * @Author haien * @Description 插入排序：每一个都跟前面所有元素比较，比人小的话就跟人互换位置，互换一次即退出内层循环 * 优点：运行时间跟输入有关，如果数组已接近有序则排序时间大大缩短 * 缺点：对于元素都一样的数组排序时间和完全无序的相同 * 时间复杂度：原始数组有序时为N，无序为N^2；比选择排序快1.2倍 * @Date 2018/10/17 * @Param [a] * @return void **/ public static void insertSort(Comparable[] a){ for(int i=0;i&lt;a.length-1;i++){ for(int j=i+1;j&gt;0&amp;&amp;!less(a[j-1],a[j]);j--){ exch(a,j-1,j); } } } 插入排序对于某些部分有序的数组效率很高 数组中每个元素距离它的最终位置都不远 一个有序的大数组接一个小数组 数组中只有几个元素的位置不正确 这些情况下插入排序很可能比任何排序算法都要快快速排序 /** * @Author haien * @Description 快速排序：随机选一个基数，比它大的调到右边，小的调到左边，然后对左右两边都* 递归进行这个操作 * 时间复杂度：O(nlogn),logn次递归，每次递归n次比较 * @Date 2018/10/21 * @Param [a] * @return void **/ public static void quickSort(Comparable[]a,int lo,int hi){ if(lo&lt;hi){ int mid=partition(a,lo,hi); //获取基数位置 quickSort(a,lo,mid-1); //基数左边全是小的 quickSort(a,mid+1,hi); //基数右边全是大的 } } /** * @Author haien * @Description 以lo（排头元素）为基数，i从头扫描，发现比lo的元素停下，调动j从尾开始扫描，发现小的即与i交换位置 * 直到两指针相遇结束 * @Date 2018/10/21 * @Param [a, lo, hi] * @return int **/ public static int partition(Comparable[]a,int lo,int hi){ int i=lo,j=hi+1; while(true){ while (less(a[++i],a[lo])) //i从头开始扫描，发现大于基数的元素停下 if(i&gt;=hi) break; //扫到尾结束 while (less(a[lo],a[--j])) //j从尾开始扫，发现小于基数的元素停下 if(j&lt;=lo) break; //扫到头结束 if(i&gt;=j) break; //跳出循环的原因如果是因为扫到头、尾或相遇则结束 exch(a,i,j); //否则就是该交换元素了 } exch(a,lo,j); //算法没写好可能lo会被换到j所指的末尾上去 return j; //把相遇点返回去 } /** * @Author haien * @Description 三向切分的快速排序：把数组分为小于、等于、大于三组；三个指针，一个跟着基数，一个从头扫描，一个从尾 * 优点：重复元素较多的数组适用，大大节省时间 * 缺点： * @Date 2018/10/22 * @Param [a, lo, hi] * @return void **/ public static void quick3way(Comparable[] a,int lo,int hi){ if(lo&lt;hi){ int lt=lo,i=lo+1,j=hi,cmp; Comparable v=a[lo]; //先把基数lo取出来，若放在循环里会变 while (i&lt;=j) { cmp = v.compareTo(a[i]); if (cmp &gt; 0) //小于基数则跟基数交换位置，相当于放在了基数的左边 exch(a, lt++, i++); //lt++，跟上基数 else if (cmp &lt; 0) exch(a, i, j--); else i++; //等于则不用移动元素 } quick3way(a,lo,lt-1); //左边全是比基数小但无序的数 quick3way(a,i,hi); //右边全是比基数大但无序的数 } } 希尔排序 前面我们说插入排序针对部分有序数组效率特别高，所以我们可以在进行选择排序前先把数组排成部分有序的。 首先设想一个完全逆序的数组，想要把最小的元素排到首位要经过多次交换，这是由于插入排序每次交换只移动一位的缘故，那我们可不可以每次都把元素移动得远一点呢？ 希尔排序的思路就是这样的，比如有16个数据，那我们从第13位开始，让它跟第0位比较，第14位跟第1位交换，……，一直到最后一位，这样一来比较小的元素自然都到了前面去（当然可能后面这几位原本都是些大数，但是这样做却能有效应对逆序等极端情况）。这次比较的距离是13，接下来我们控制比较距离为4，第4位跟第0位，第5位跟第1位，……，一直到最后一位，这样数组进一步有序，被分为了4个各自有序的数组（0，4,8,12组成一个有序数组，…）。 最后比较距离设为1，即应用插入排序，由于数组基本有序，最小值一定是这4个小数组首位的其中一个，所以比较次数大大减少，性能提高。 数组越大，希尔排序的优势越大。 /** * @Author haien * @Description 希尔排序：前面我们说插入排序针对部分有序数组效率特别高， * 所以我们可以在进行选择排序前先把数组排成部分有序的 * 思路即是比较时不要邻位比较而是隔一段距离比较 * 优点：适用于大数组、无序数组 * 时间复杂度：N^3/2（无法推算） * * @Date 2018/10/17 * @Param [a] * @return void **/ public static void shellSort(Comparable[] a){ int h=1; int n=a.length; while(h&lt;n/3) h=h*3+1; //保证第一次排序时距离足够远,h=1,4,13,40,121,364,1093,…… //当n=16时，h=13,4,1 while(h&gt;=1) { for (int i = h; i &lt; n; i++) { for (int j = i; j &gt;= h &amp;&amp; !less(a[j - h], a[j]); j -= h) { exch(a, j, j - h); } } h/=3; //逐渐缩小距离 } } 归并排序 具有稳定性 /** * @Author haien * @Description 归并排序：将两个有序数组合并为一个；所以要另写一个算法将数组分到只剩一个元素，保证有序 * 优点：处理数百万甚至更大规模的数组 * 缺点：辅助数组所需空间和N成正比 * 时间复杂度：NlogN * @Date 2018/10/21 * @Param [a, lo, mid, hi] * @return void **/ public static void mergeSort(Comparable[] a,int lo,int mid,int hi){ int i=lo,j=mid+1,n=lo; //原数组要排的是哪一段就放到预备数组的对应位置，这样复制回去的时候才不会把空元素也复制回去 while(i&lt;=mid&amp;&amp;j&lt;=hi){ if(less(a[j],a[i])){ aux[n++]=a[j++]; } else{ aux[n++]=a[i++]; } } while(i&lt;=mid){ aux[n++]=a[i++]; } while(j&lt;=hi){ aux[n++]=a[j++]; } //注意：复制回去的时候一定不能把空位置也复制回去 for(i=lo;i&lt;=hi;i++){ a[i]=aux[i]; } } /** * @Author haien * @Description 分治 * @Date 2018/10/21 * @Param [a, lo, hi] * @return void **/ public static void split(Comparable[] a,int lo,int hi){ int mid; if(lo&lt;hi){ mid=(lo+hi)/2; split(a,lo,mid); split(a,mid+1,hi); mergeSort(a,lo,mid,hi); } } 应用：2-sum问题——找到一个数组中所有和为0的整数对（假设所有元素均不相同）。这个问题很容易用平方级别解决，但是如果先把数组排序然后用二分查找的话就能降为线性对数级别。 /** * @Author haien * @Description 统计 * @Date 2018/10/30 * @Param [a] * @return int **/ public static int count(int[] a){ //归并排序（为二分查找做准备） //Arrays.sort(a); split(a,0,a.length-1); int j=0,count=0; for(int i=0;i&lt;a.length-1;i++){ //找到返回索引，否则返回-1 j=binarySearch(-a[i],a,i+1,a.length-1); //i+1：从哪里开始找起；a.length-1：到哪里结束 if(j!=-1) count++; } return count; } 在2-sum外面套个循环就可以构建平方对数级别的3-sum解决方案 public static int count(int[] a){ //归并排序（为二分查找做准备） //Arrays.sort(a); split(a,0,a.length-1); int k=0,count=0; for(int i=0;i&lt;a.length-2;i++){ for(int j=i+1;j&lt;a.length-1;j++) { //找到返回索引，否则返回-1 k = binarySearch(-a[i] - a[j], a, j + 1, a.length - 1); if (k != -1) count++; } } return count; } 代码实例：DataStructure/sort/TwoSum、ThreeSum堆排序优先队列 首先介绍优先队列：有的时候不要求元素一定要全部有序，或是不一定要一次就将它们排好序。很多情况下是要收集当前集合的最大几个元素。 例如，一台电脑总是处理正在等待的程序中优先级最高的一个。 优先队列是一种数据结构 /** * @Author haien * @Description 优先队列：找出数组中最大的M个元素 * 定义一个固定容量的队列，把数组的元素装进去，多了就删掉最小的那个，最后剩下的就是最大的那几个 * 时间复杂度：NM * @Date 2018/10/22 * @Param * @return **/ public class PriorityQueue { public static void main(String[] args) { //打印输入流中最大的M行 int M=Integer.parseInt(args[0]); //新建一个大小为M+,容量必须比M大 MinPQ&lt;Transaction&gt; pq=new MinPQ&lt;&gt;(M+1); //输5行进来 for(int i=0;i&lt;5;i++){ //为下一行创建一个元素并放入优先队列 Scanner in=new Scanner(System.in); pq.insert(new Transaction(in.nextLine())); //超过容量了 if(pq.size()&gt;M) pq.delMin(); //如果优先队列中的元素超过M+1个则删除其中最小的元素 } //新建一个栈 Stack&lt;Transaction&gt; stack=new Stack&lt;&gt;(); while (!pq.isEmpty()) stack.push(pq.delMin()); //每次都弹出最小的元素进栈 //输出倒序的事务 for(Transaction t:stack) StdOut.println(t); } } 基于二叉堆的优先队列 二叉堆：在二叉堆的数组中，每个元素要保证大于等于另两个特定位置的元素。 最大堆：父结点大于子结点，根结点是其最大结点，每一层都比下一层所有元素大 最小堆：父结点小于子结点，根结点是其最小结点，每一层都比下一层元素小 基于二叉堆实现的优先队列就是内置数组是按照最大堆的排序形式存放元素的 /** * @Author haien * @Description 基于二叉堆的优先队列 * 优点：对于需要大量混杂的插入和删除最大元素的用例来说，能保证在对数时间内完成 * @Date 2018/10/23 **/ public class BinaryHeap { //泛型数组 private Comparable[] pq; //容量 private int N; /** * @Author haien * @Description 构造指定容量的优先队列 * @Date 2018/10/23 * @Param [maxN] * @return **/ public BinaryHeap(int maxN) { pq=new Comparable[maxN+1]; //泛型数组，取元素时必须强转 } public BinaryHeap(Comparable[] pq){ N=pq.length; this.pq=(Comparable[])new Object[N+1]; for(int i=0;i&lt;N;i++){ this.pq[i+1]=pq[i]; } /*N是最后一个结点的序号，N/2是其父结点，也就是说叶结点都是不用管的， 因为前面的元素如果是最小的自然会下沉到最底下代替叶结点， 都不是最小的则说明叶结点已经是最小的几个元素了*/ for(int k=N/2;k&gt;=1;k--){ sink(k); } assert isMaxHeap(); } /** * @Author haien * @Description 判断队列是否最大堆（即父结点都比子结点大） * @Date 2018/10/24 * @Param [] * @return boolean **/ private boolean isMaxHeap(){ return isMaxHeap(1); } /** * @Author haien * @Description 判断以k号元素为首的子树是否为最大堆 * @Date 2018/10/24 * @Param [k] * @return boolean **/ private boolean isMaxHeap(int k){ //溢出则不存在，不存在判断为是最大堆 if(k&gt;N) return true; int left=k*2; int right=k*2+1; if(left&lt;=N &amp;&amp; less(k,left)) return false; if(right&lt;=N &amp;&amp; less(k,right)) return false; return isMaxHeap(left) &amp;&amp; isMaxHeap(right); } public int size(){ return N; } /** * @Author haien * @Description 数组扩容：重开一个数组，把原数组的元素复制过去，再把该数组的引用赋给原数组 * @Date 2018/10/24 * @Param [capacity] * @return void **/ private void resize(int capacity){ assert capacity&gt;N; Comparable[] temp=new Comparable[capacity]; for(int i=1;i&lt;=N;i++){ temp[i]=pq[i]; } pq=temp; } public boolean isEmpty(){ return N==0; } public boolean isFull(){ return N+1==pq.length; } private boolean less(int i, int j){ return pq[i].compareTo(pq[j])&lt;0; } private void exch(int i,int j){ Comparable t=pq[i]; pq[i]=pq[j]; pq[j]=t; } /** * @Author haien * @Description 上浮：堆中出现比父结点大的子结点，令其与父结点交换直到遇到比它大的父结点为止 * @Date 2018/10/23 * @Param [k] * @return void **/ private void swim(int k){ while(k&gt;1&amp;&amp;less(k/2,k)){ exch(k/2,k); k/=2; } } /** * @Author haien * @Description 下沉：出现比子结点小的父结点，把两子结点中最大者跟它互换直到没有比它大的子结点为止 * @Date 2018/10/23 * @Param [k] * @return void **/ private void sink(int k){ int j=k*2; while (k &lt; N) { //跟最大的子结点交换 if(j&lt;N&amp;&amp;less(j,j+1)) { j++; } if(less(k,j)){ exch(k,j); k=j; } } } public void insert(Comparable v){ //已满，扩容 if(isFull()) resize(2*pq.length); pq[++N]=v; swim(N); } public Comparable delMax(){ if(isEmpty()) throw new NoSuchElementException(&quot;Priority queue underflow&quot;); Comparable v=pq[1]; exch(1,N); //防止对象游离 pq[N--]=null; //其实元素如果是int的话可能不行，不过元素不可能是int，因为int不是类，它不可能实现了Comparable接口 sink(1); return v; } } 索引优先队列 为了方便找到已经存入队列的元素，我们可以在存储的时候顺便传入一个键值作为其索引，要获取该元素的时候依据索引来获取 /** * @Author haien * @Description 索引优先队列：存放进来的元素都带了个键，方便获取元素；做比较的是元素，实际排序的是键 * 开一个数组作为队列存放键，开一个数组存放这些键在队列中的位置，开一个数组存放元素本身 * @Date 2018/10/24 **/ public class IndexPriorityQueue { //容量 private int N; /**存放键，这才是优先队列主要维护的数组； * 按照最大堆排序的是键而不是元素本身， * 元素怎么排都可以，只要键有序了找出来的元素就是有序的*/ private int[] pq; //由于设为了int数组，所以键被限死了是int //存放键在pq中的索引，可以根据键找到键在队列中的位置 private int[] qp; //存放元素:键是几就把元素放在第几位 private Comparable[] value; public IndexPriorityQueue(int maxN){ pq=new int[maxN+1]; qp=new int[maxN+1]; //所以k为0~N闭区间，至于为什么容量要定为maxN+1就不得而知了 value=new Comparable[maxN+1]; for(int i=0;i&lt;=maxN;i++) qp[i]=-1; } private boolean less(int i,int j){ //比较的是元素的值而不是元素的键 return value[qp[i]].compareTo(value[qp[j]])&lt;0; } private void exch(int i,int j){ int t=pq[i]; pq[i]=pq[j]; pq[j]=t; t=qp[pq[i]]; qp[pq[i]]=qp[pq[j]]; qp[pq[j]]=t; } public boolean isEmpty(){ return N==0; } public boolean isFull(){ return N==pq.length-1; } public boolean contains(int k){ return qp[k]!=-1; } private void swim(int k){ while(k&gt;1&amp;&amp;less(k/2,k)){ exch(k,k/2); k/=2; } } public void sink(int k){ while(k*2&lt;=N){ int j=k*2; if(j&lt;N&amp;&amp;less(j,j+1)) j++; if(less(j,k)) break; exch(k,j); k=j; } } public void insert(int k,Comparable v){ if(contains(k)||isFull()) throw new IllegalArgumentException(); N++; pq[N]=k; qp[k]=N; value[k]=v; swim(N); } public int delMax(){ if(isEmpty()) throw new NoSuchElementException(); int min=pq[1]; exch(1,N--); sink(1); qp[min]=-1; value[min]=null; pq[N+1]=-1; //返回最小元素的键 return min; } } 应用：实现多向归并排序——将多个有序的小数组归并为有序的数组。从命令行读入文件名，将对应文件搞成输入流，每个文件都包含一个字符串，这几个字符串就是有序的小数组了，其中每个字符都是一个元素单位。把它们排成一个有序的字符串并打印。 /** * @Author haien * @Description 多向归并：用索引优先队列实现；输入多个有序数组，归并为一个有序的大数组 * @Date 2018/10/25 **/ public class MultiwayMerge { /** * @Author haien * @Description 多向归并：入参为多个输入流组成的数组，每个输入流都是一个字符串（升序），每个字符串包含的字符是一个元素单位 * @Date 2018/10/25 * @Param [streams] * @return void **/ public static void merge(In[] streams){ int N=streams.length; //创建一个索引优先队列，它跟IndexPriorityQueue的区别就是顺序相反而已 IndexMinPQ&lt;String&gt; pq=new IndexMinPQ&lt;&gt;(N); //先读取每一个字符串的第一个字符，因为最小的肯定在这里面 for(int i=0;i&lt;N;i++){ if(!streams[i].isEmpty()) //把它在数组中的索引作为键插入队列 pq.insert(i,streams[i].readString()); //读取下一个单词，以空格为分隔符 } while(!pq.isEmpty()){ //把目前最小的输出 StdOut.println(pq.minKey()); //删掉最小元素并返回其键 int i=pq.delMin(); //把最小元素原本所在的字符串的下一个字符插入队列，因为它最可能是第二小的元素，即使不是加入了队列也没事，元素出队的时候队列自然会找最小的那个出来 if(!streams[i].isEmpty()) pq.insert(i,streams[i].readString()); } } public static void main(String[] args) { int N=args.length; In[] streams=new In[N]; for(int i=0;i&lt;N;i++){ streams[i]=new In(args[i]); //args为文件名数组；输入指定文件 } /** * 输入文件m1.txt:A B C F G I I Z * m2.txt:B D H P Q Q * m3.txt:A B E F J N **/ merge(streams); } } 堆排序/** * @Author haien * @Description 堆排序：先把数组排成最大堆，然后把根结点不断跟最后第1,2，……，n交换，最终排成升序数组 * 优点：是目前同时能够最优地节省空间和时间的排序方式 * 时间复杂度：NlgN * @Date 2018/10/25 * @Param [a] * @return void **/ public static void heapSort(Comparable[] a){ int n=a.length; //将原数组排成最大堆 for(int k=n/2;k&gt;=1;k--) sink(a,k,n); /** * 将最大堆排成升序数组：让根结点与最后一个结点交换，把交换上来的结点下沉； * 让新的根结点跟倒数第二个结点交换，然后下沉；……； * 最大的结点不断被交换到最后，最终排序完毕 **/ while(n&gt;1){ exch(a,1,n); sink(a,1,n); } } /** * @Author haien * @Description 下沉：出现比子结点小的父结点，把两子结点中最大者跟它互换直到没有比它大的子结点为止 * @Date 2018/10/23 * @Param [k] * @return void **/ private static void sink(Comparable[] a,int k,int N){ int j=k*2; while (k &lt; N) { //跟最大的子结点交换 if(j&lt;N&amp;&amp;less(a[j],a[j+1])) { j++; } if(less(k,j)){ exch(a,k,j); k=j; } } } 总结 稳定性：除了插入排序和归并排序（因为它们都是从左往右依次排的），其他算法都不具有稳定性。但是稳定性只是针对那些需要相同元素保持相对顺序的应用才另外考虑的，大部分时候都可以忽略。 实践证明，快速排序是最快的、最佳的选择。 但如果稳定性很重要而空间又不是问题，那么归并排序是最好的。 有了SortCompare这样的工具，能够更仔细地比较 以上排序算法不能排列基本数据，基本数据应该实现属于自己的只操作某种数据类型的排序算法，而不能装箱之后继续用上面的算法，因为使用引用来访问和交换数据比直接操作数据本身要耗费很多时间。应用 java.util.Arrays.sort()对基本数据采用（三向切分）快速排序，对引用类型采用保证稳定性的归并排序 找出重复元素：小数组的话，用平方级别的算法将左右元素互相比较一遍；大数组，先排序，再记录连续出现的元素即可。 查找中位数 /** * @Author haien * @Description 找到数组中排行第K的元素 * @Date 2018/10/25 * @Param [a] * @return java.lang.Comparable **/ public Comparable findRankK(Comparable[] a,int k){ //将数组重新排序，可避免最坏情况 StdRandom.shuffle(a); int lo=0,hi=a.length-1,j; while(lo&lt;hi){ j=partition(a,lo,hi); if(j==k) return a[j]; if(j&lt;k) hi=j-1; if(j&gt;k) lo=j+1; } return a[k]; } /** * @Author haien * @Description 以lo（排头元素）为基数，i从头扫描，发现比lo的元素停下，调动j从尾开始扫描，发现小的即与i交换位置 * 直到两指针相遇结束 * @Date 2018/10/21 * @Param [a, lo, hi] * @return int **/ public static int partition(Comparable[]a,int lo,int hi){ int i=lo,j=hi+1; while(true){ while (less(a[++i],a[lo])) //i从头开始扫描，发现大于基数的元素停下 if(i&gt;=hi) break; //扫到尾结束 while (less(a[lo],a[--j])) //j从尾开始扫，发现小于基数的元素停下 if(j&lt;=lo) break; //扫到头结束 if(i&gt;=j) break; //跳出循环的原因如果是因为扫到头、尾或相遇则结束 exch(a,i,j); //否则就是该交换元素了 } exch(a,lo,j); //算法没写好可能lo会被换到j所指的末尾上去 return j; //把相遇点返回去 } 代码实例 DataStructure/sort/MySort","categories":[],"tags":[]},{"title":"","slug":"Java数据结构之带权图","date":"2019-04-30T08:25:45.229Z","updated":"2018-12-08T08:42:30.090Z","comments":true,"path":"2019/04/30/Java数据结构之带权图/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java数据结构之带权图/","excerpt":"","text":"最小生成树 假设要在n个城市之间架设通信网络，如何实现成本最小化？显然可用连通带权图建模，其中顶点表示城市，百年表示线路，权值表示成本。找到最小生成树即找到成本最小化方案，因为它们满足的条件一样，包含所有的顶点，虽然不包含所有的边但是所有的顶点之间都有边相连。Prim普里姆算法 从第一个顶点开始找它的邻接点，要求是权值最小的那个，然后对这个邻接点接着找邻接点，直到所有的点都找遍了。","categories":[],"tags":[]},{"title":"","slug":"Java数据结构之查找","date":"2019-04-30T08:25:45.225Z","updated":"2018-11-13T08:56:37.926Z","comments":true,"path":"2019/04/30/Java数据结构之查找/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java数据结构之查找/","excerpt":"","text":"二分查找 前提是数组必须有序，比如升序，不断与中点值比较，相等则返回中点值索引，中点值较大则往左边查找，较小则往右边查找；找不到返回-1 时间复杂度：对数级别 private static int binary(int K,int[] array,int left,int right){ //left=0；right=a.length-1 int mid=(right+left)/2; //找到首元素和末尾元素都不是K的情况 if(left&gt;right){ return -1; } if(array[mid]==K){ return mid; } //找左半边 else if(array[mid]&gt;K){ return binary(K,array,0,mid-1); //用return的方式调用函数也就是说函数到这一步结束，出栈后不会执行后面代码 } //找右半边 else{ return binary(K,array,mid+1,right); } } 代码实例：DataStructure/binarySearch/FindK二叉查找树 二分查找基于数组实现，因此要找任意子数组的中点元素都十分简单，但是如果找到后下一步就是要插入一个元素的话，那么需要线性级别的时间。便于插入的数据结构应该是链表，而为了方便查找，我们应该让每个结点都指向下一个结点 二叉查找树很好的结合了插入的灵活性和查找的高效性。 在二叉查找树中，每个结点都指向它的左右结点，左结点比父结点小，右结点比父结点大。 构建二叉查找树用的即是插入方法，新元素进来时发现树为空，它即成为根结点，如果比根结点小，它就去到左子树跟那些结点比较，否则去到右子树。根结点的左儿子的右儿子不会比根结点大，因为如果比它大的话插入的时候就会被分到右子树去了，不会来左子树这边，所以左子树全部比父结点小，右子树全部比父结点大。 所以如果第一个进来的元素太大或者太小，构成的树都会失去平衡。 最小的元素永远在最最左边，最大的则在最最右边。 将树的所有结点投影到一条直线上，可以得到一条升序的排列。 public class BST&lt;Key extends Comparable,Value&gt; { //根结点 private Node root; private class Node{ //键 private Key key; //值 private Value value; //左右儿子 private Node left,right; //子树的结点数 private int size; //构造器：生成一个新的结点 public Node(Key key,Value value,int size){ this.key=key; this.value=value; //此结点所在子树的结点数目 this.size=size; } } public BST() { } public boolean isEmpty(){ return size()==0; } public int size(){ return size(root); } /** * @Author haien * @Description 以x为根结点的子树所含结点数目 * @Date 2018/11/6 * @Param [x] * @return int **/ public int size(Node x){ if(x==null) return 0; return x.size; } public boolean contains(Key key){ if(key==null) throw new IllegalArgumentException(&quot;Argument to contains() is null!&quot;); return get(key)!=null; } public Value get(Key key){ return get(root,key); } /** * @Author haien * @Description 以某个结点为根结点开始查找某个元素 * @Date 2018/11/6 * @Param [node, key] * @return Value **/ private Value get(Node x,Key key){ if(key==null) throw new IllegalArgumentException(&quot;Calls get() with a null key!&quot;); if(x==null) return null; int cmp=key.compareTo(x.key); if(cmp==0) return x.value; else if(cmp&lt;0) return get(x.left,key); else return get(x.right,key); } public void put(Key key,Value value){ if(key==null) throw new IllegalArgumentException(&quot;Calls put() with a null key!&quot;); //若值为空则删去此结点 if(value==null){ delete(key); return; } root=put(root,key,value); } private Node put(Node x, Key key,Value value){ //树为空，将结点设置为根结点 if(x==null) return new Node(key,value,1); int cmp=key.compareTo(x.key); if(cmp&lt;0) x.left=put(x.left,key,value); else if(cmp&gt;0) x.right=put(x.right,key,value); //若key已存在则更新其值 else x.value=value; x.size=size(x.right)+size(x.left)+1; return x; } public void deleteMin(){ if(isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow!&quot;); deleteMin(root); } /** * @Author haien * @Description 以最小结点的右结点覆盖之（没有右结点的话就是null了） * @Date 2018/11/6 * @Param [x] * @return com.haien.search.BST&lt;Key,Value&gt;.Node **/ private Node deleteMin(Node x){ //最小结点一定在最左边；若左边没有元素，说明已经找到了最小结点 if(x.left==null) return x.right; //当前结点的左结点的左结点为空，则当前结点的左结点为最小结点，返回当前结点的左结点的右结点，覆盖当前结点的左结点 x.left=deleteMin(x.left); x.size=size(x.left)+size(x.right)+1; //最终返回一开始传进来的赋给根结点，因为如果根结点就是最小结点，那么根结点就要改成原根结点的右结点 return x; } public void deleteMax(){ if(isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow!&quot;); root=deleteMax(root); } private Node deleteMax(Node x){ if(x.right==null) return x.left; x.right=deleteMax(x.right); x.size=size(x.left)+size(x.right)+1; return x; } public void delete(Key key){ if(key==null) throw new IllegalArgumentException(&quot;Calls delete() with a null key!&quot;); root=delete(root,key); } private Node delete(Node x,Key key){ if(x==null) return null; int cmp=key.compareTo(x.key); if(cmp&lt;0) x.left=delete(x.left,key); else if(cmp&gt;0) x.right=delete(x.right,key); /** * 找到目标结点，如果它只有一边的子树则直接把子树的根结点赋给要目标结点 * 如果它两边都有，由于覆盖上来的结点必须大于左子树，小于右子树， * 直接把左子树的根结点提上来是符合，但是它的左右子树也已接好了，那目标结点原来的右子树该接到它哪里 ？ * 所以我们要选一个叶结点放上来，那当然就是右子树中最小的一个啦（左子树的最大结点应该也可以） **/ else{ if(x.right==null) return x.left; if(x.left==null) return x.right; Node t=x; //把右子树中最小的结点放到x处 x=min(t.right); //删除右子树中最小结点，并把右子树接到x上 x.right=deleteMin(t.right); //左子树还是原来的左子树 x.left=t.left; } x.size=size(x.left)+size(x.right)+1; return x; } public Key min(){ if (isEmpty()) throw new NoSuchElementException(&quot;Call min() with empty symbol table!&quot;); return min(root).key; } private Node min(Node x){ if(x.left==null) return x; else return min(x.left); } /** * @Author haien * @Description 小于等于key的最大结点 * @Date 2018/11/6 * @Param [key] * @return Key **/ public Key floor(Key key){ if(key==null) throw new IllegalArgumentException(&quot;Argument to floor() is null!&quot;); if(isEmpty()) throw new NoSuchElementException(&quot;Calls floor() with empty symbol table!&quot;); Node x=floor(root,key); if(x==null) return null; return x.key; } private Node floor(Node x,Key key){ if(x==null) return null; int cmp=key.compareTo(key); if(cmp&lt;0) return floor(x.left, key); //父结点比key大，往左边找 Node t = floor(x.right,key); if(t!=null) return t; else return x; } /** * @Author haien * @Description 查找排名为第k位的结点（排名从0开始） * @Date 2018/11/6 * @Param [k] * @return Key **/ public Key select(int k){ if(k&lt;0||k&gt;=size()){ throw new IllegalArgumentException(&quot;Argument to select() is invalid: &quot;+k); } Node x=select(root,k); return x.key; } private Node select(Node x,int k){ if(x==null) return null; int t=size(x.left); if(k&lt;t) return select(x.left,k); else if(t&lt;k) return select(x.right,k-t-1); else return x; } /** * @Author haien * @Description 计算元素的排名（从0开始） * @Date 2018/11/6 * @Param [key] * @return int **/ public int rank(Key key){ if(key==null) throw new IllegalArgumentException(&quot;Argument to rank() is null!&quot;); return rank(key,root); } private int rank(Key key,Node x){ if(x==null) return 0; int cmp=key.compareTo(x.key); if(cmp&lt;0) return rank(key,x.left); else if(cmp&gt;0) return 1+size(x.left)+rank(key,x.right); else return size(x.left); } /** * @Author haien * @Description 把左右键集合按顺序收集到一个队列中 * @Date 2018/11/6 * @Param [lo, hi] 最小、最大结点 * @return java.lang.Iterable&lt;Key&gt; **/ public Iterable&lt;Key&gt; keys(Key lo,Key hi){ if(lo==null) throw new IllegalArgumentException(&quot;First argument to keys() is null!&quot;); if(hi==null) throw new IllegalArgumentException(&quot;Second argument to keys() is null!&quot;); Queue&lt;Key&gt; queue=new Queue&lt;&gt;(); keys(root,queue,lo,hi); return queue; } //其实就是中序遍历 private void keys(Node x, Queue&lt;Key&gt; queue,Key lo,Key hi){ //查到了最后一个结点的下一个结点null了，出栈 if(x==null) return; keys(x.left,queue,lo,hi); //往左边找，找到最左边的元素才可以出栈 queue.enQueue(x.key); //发现左结点是null，出栈，打印这个结点 keys(x.right,queue,lo,hi); //往右边找 } /** * @Author haien * @Description 计算树的高度 * @Date 2018/11/7 * @Param [] * @return int **/ public int height(){ return height(root); } private int height(Node x){ if(x==null) return 0; //结点为空，高度为0 return 1+Math.max(height(x.left),height(x.right)); //最终树的高度=当前结点高度1+左子树高度+右子树高度 } /** * @Author haien * @Description 按层级顺序把结点收集到队列keys中 * @Date 2018/11/7 * @Param [] * @return java.lang.Iterable&lt;Key&gt; **/ public Iterable&lt;Key&gt; levelOrder(){ Queue&lt;Key&gt; keys=new Queue&lt;&gt;(); Queue&lt;Node&gt; queue=new Queue&lt;&gt;(); queue.enQueue(root); while(!queue.isEmpty()){ Node x=queue.deQueue(); if(x!=null){ keys.enQueue(x.key); queue.enQueue(x.left); queue.enQueue(x.right); } } return keys; } } 代码实例：DataStructure/search/BST红黑树 如果能保持树的平衡性，那么即使在最坏情况下也能保证在对数时间内找到元素。 为了平衡，我们需要一些灵活性，因此我们允许一个结点可以保存多个键。因为这样我们在新插入键的时候就可以把它插到最后的叶结点里，而不是生成一个新的结点增加树的高度。 3-结点：含有2个键和3个链接。左链接指向比它小的结点，中链接指向大小位于本身的俩键的结点，右链接指向比它大的结点。 我们将3-结点定义为由一条红色链接相连的两个2-接结点，且统一为左链接，右链接只能是黑色的，这样它就还是一棵二叉树。 红黑树：包含2-结点和3-结点，红是指3-结点中的俩键实际是通过红色链接相连的2结点，黑是指其他普通的链接。 插入的时候我们把新结点插到最后一层的结点x上，并用红色的链接与它相连，如果x原本是个2-结点，也就是它还没有过红色链接，那么检查这个链接是否左链接，不是的话就把两个结点层次调换一下；如果x原本是个3-结点，那么现在就变成了4-结点，我们可以把中键提上去，拆成3个2-结点。 public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;,Value&gt; { //表示Key可以是任何继承自Comparable的类型，并且这个Comparable必须是指定类型为Key的；写Key extends Comparable没什么问题，就相当于Key extends Comparable&lt;Object&gt;，但是 指定一下Key会更明确 private static final boolean RED=true; private static final boolean BLACK=false; private Node root; private class Node{ private Key key; private Value val; private Node left,right; private boolean color; //由其父结点指向它的链接的颜色 private int size; //子树中的结点总数 public Node(Key key, Value val, boolean color, int size) { this.key = key; this.val = val; this.color = color; this.size = size; } } private boolean isRed(Node x){ if(x==null) return false; return x.color; } public int size(){ return size(root); } private int size(Node x){ if(x==null) return 0; return x.size; } /** * @Author haien * @Description 出现红色右连接，把它旋转到左边 * h原本揽着x的肩膀，x两手提着东西，现在h松手去提x左手的东西，x腾出手去揽h，变成了x在上 * @Date 2018/11/13 * @Param [h] * @return com.haien.search.RedBlackBST&lt;Key,Value&gt;.Node **/ private Node rotateLeft(Node h){ Node x=h.right; h.right=x.left; x.left=h; x.color=h.color; h.color=RED; x.size=h.size; h.size=1+size(h.left)+size(h.right); return x; } /** * @Author haien * @Description 出现错误的红色左链接，错误的情况就是这个结点及其左结点的左链接都是红色的，形成了4-结点， * 需要把这个结点和它的左结点互换，这样新的父结点左右链接就都是红色的，再通过flipColors来调整好 * @Date 2018/11/13 * @Param [h] * @return com.haien.search.RedBlackBST&lt;Key,Value&gt;.Node **/ private Node rotateRight(Node h){ Node x=h.left; h.left=x.right; x.right=h; x.color=h.color; h.color=RED; x.size=h.size; h.size=1+size(h.left)+size(h.right); return x; } /** * @Author haien * @Description 把一个左右链接都是红色的结点变成左右链接都是黑色的，但由父结点指向它的链接是红色的 * 即，把一个4-结点的中建挤到父结点的键区；由于父结点也可能已经是3-结点，所以调用者需要递归调用此法 * @Date 2018/11/13 * @Param [x] * @return void **/ private void flipColors(Node x){ x.color=RED; x.left.color=BLACK; x.right.color=BLACK; } public void put(Key key,Value val){ //查找key，找到则更新其值，否则创建新结点；返回root，当原树为空时就有用 root=put(root,key,val); root.color=BLACK; //当原树为空时，root就是刚创建的结点了，它的颜色是red，应该改成black } private Node put(Node x,Key key,Value val){ if(x==null) return new Node(key,val,RED,1); int cmp=key.compareTo(x.key); if(cmp&lt;0) x.left=put(x.left,key,val); else if(cmp&gt;0) x.right=put(x.right,key,val); else x.val=val; if(isRed(x.right)&amp;&amp;!isRed(x.left)) x=rotateLeft(x); //新插入的键比父结点大，出现了红色的右链接 if(isRed(x.left)&amp;&amp;isRed(x.left.left)) x=rotateRight(x); //未命中查找终止于一个3-结点，并且新结点比它小，出现了连续两个左链接，形成了4-结点 if(isRed(x.left)&amp;&amp;isRed(x.right)) flipColors(x);//出现两链接都是红色的结点 x.size=1+size(x.left)+size(x.right); return x; } } Key extends Comparable: 表示Key可以是任何继承自Comparable的类型，并且这个Comparable必须是指定类型为Key的；写Key extends Comparable没什么问题，就相当于Key extends Comparable，但是 指定一下Key会更明确 《算法》269页 代码实例：DataStructure/search/RedBlackBST","categories":[],"tags":[]},{"title":"","slug":"Java数据结构之背包、队列和栈","date":"2019-04-30T08:25:45.213Z","updated":"2018-10-30T07:21:20.488Z","comments":true,"path":"2019/04/30/Java数据结构之背包、队列和栈/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java数据结构之背包、队列和栈/","excerpt":"","text":"栈 先进后出 为栈中的每一个元素定义一个结点Node，这个结点包括元素本身和下一个结点的引用，栈底结点的下一个为null。 只有一个栈顶指针 实现出栈、入栈和迭代等操作。 public class Stack&lt;T&gt; implements Iterable&lt;T&gt; { //栈顶元素 private Node&lt;T&gt; first; //栈长度 private int n; //栈的存储单位：一个存放当前元素和下一个结点的结点 private static class Node&lt;T&gt;{ private T item; private Node&lt;T&gt; next; } /** * @Author haien * @Description 初始化一个空栈 * @Date 19:56 2018/10/25 **/ public Stack(){ first = null; n=0; } public boolean isEmpty(){ return first==null; } public int size(){ return n; } public void push(T item){ Node&lt;T&gt; oldfirst=first; first=new Node&lt;T&gt;(); first.item=item; first.next=oldfirst; n++; } public T pop(){ if(isEmpty()) throw new NoSuchElementException(); T item=first.item; first=first.next; n--; return item; } /** * @Author haien * @Description 出栈但不删除元素 * @Date 2018/10/25 * @Param [] * @return void **/ public T peek(){ if(isEmpty()) throw new NoSuchElementException(); return first.item; } /** * @Author haien * @Description 把所有元素都连成一个字符串 * @Date 2018/10/25 * @Param [] * @return java.lang.String **/ @Override public String toString() { StringBuilder s=new StringBuilder(); //适用于处理大量字符串 for(T item:this){ s.append(item); s.append(&apos; &apos;); } return s.toString(); } @Override public Iterator&lt;T&gt; iterator(){ return new ListIterator&lt;T&gt;(first); } private class ListIterator&lt;T&gt; implements Iterator&lt;T&gt;{ private Node&lt;T&gt; current; public ListIterator(Node&lt;T&gt; current) { this.current = current; } @Override public boolean hasNext() { return current!=null; } @Override public T next() { if(!hasNext()) throw new NoSuchElementException(); T item=current.item; current=current.next; return item; } @Override public void remove(){ throw new UnsupportedOperationException(); } } } 应用：用两个栈实现四则运算 /** * @Author haien * @Description 用栈实现四则运算 * @Date 2018/10/29 **/ public class Evaluate { //设置优先级 public static int priority(String s) throws ValidationException { switch(s){ case &quot;(&quot;: return 4; case &quot;*&quot;: case &quot;/&quot;: return 3; case &quot;+&quot;: case &quot;-&quot;: return 2; case &quot;)&quot;: return 1; default: throw new ValidationException(&quot;算术表达式格式错误!&quot;); } } public static void main(String[] args) throws ValidationException { //数字栈 Stack&lt;Double&gt; s1=new Stack&lt;&gt;(); //符号栈 Stack&lt;String&gt; s2=new Stack&lt;&gt;(); StringBuilder num=new StringBuilder(&quot;&quot;); int i=0; double a=0.0; System.out.println(&quot;请输入表达式：&quot;); //读取表达式 while(!StdIn.isEmpty()){ //获取表达式 String s=StdIn.readLine().replaceAll(&quot;\\\\s*&quot;,&quot;&quot;); //获取一行字符串；去空白符 //遍历表达式 while(i&lt;=s.length()){ //数字（支持多位数、小数） if(i&lt;s.length()&amp;&amp;(s.charAt(i)&gt;=&apos;0&apos;&amp;&amp;s.charAt(i)&lt;=&apos;9&apos;||s.charAt(i)==&apos;.&apos;)){ num.append(s.charAt(i)); i++; if(i==s.length()||((s.charAt(i)&lt;&apos;0&apos;||s.charAt(i)&gt;&apos;9&apos;)&amp;&amp;s.charAt(i)!=&apos;.&apos;)){ if(!ValidatorUtil.isNumeric(num)){ //是否整数或小数 throw new ValidationException(&quot;算术表达式格式错误!&quot;); } s1.push(Double.parseDouble(num.toString())); num=new StringBuilder(&quot;&quot;); } } //运算符 //无效括号 else if(i&lt;s.length()&amp;&amp;s.charAt(i)==&apos;)&apos;&amp;&amp;!s2.isEmpty()&amp;&amp;s2.peek().equals(&quot;(&quot;)) { s2.pop(); //记得把栈里没用的左括号弹掉 i++; } //进栈(栈为空||运算符优先级大于栈顶||栈顶为左括号) else if(i&lt;s.length() &amp;&amp;(s2.isEmpty() ||priority(String.valueOf(s.charAt(i))) &gt; priority(s2.peek()) ||s2.peek().equals(&quot;(&quot;)) ){ s2.push(String.valueOf(s.charAt(i))); i++; } //表达式只有一个数字 else if(s1.size()==1) break; //弹栈（i&gt;=字符串长度时就已经读取完了，但是符号栈还有就还要进行运算||符号优先级低于栈顶） else if((i&gt;=s.length() &amp;&amp; !s2.isEmpty()) || (priority(String.valueOf(s.charAt(i))) &lt;= priority(s2.peek()))){ //- / 记得颠倒过来 switch (s2.pop()){ case &quot;+&quot;: s1.push(s1.pop()+s1.pop()); break; case &quot;-&quot;: a=s1.pop();s1.push(s1.pop()-a); break; case &quot;*&quot;: s1.push(s1.pop()*s1.pop()); break; case &quot;/&quot;: a=s1.pop();s1.push(s1.pop()/a); break; } } else{ throw new ValidationException(&quot;算术表达式格式错误!&quot;); } } System.out.println(&quot;结果为：&quot;+s1.pop()); System.out.println(&quot;请输入表达式：&quot;); i=0; } } } 队列 先进先出 相当于在栈的基础上加上一个队头指针，指向最早加入的成员，别新成员一来老成员就不见了 如果是数组的话很少用循环数组，而是超出容量重新创建一个新数组并把旧元素移过去 /** * @Author haien * @Description 基于链表的队列 * @Date 2018/10/26 **/ public class Queue&lt;T&gt; implements Iterable&lt;T&gt;{ //队头，用于出队 private Node first; //队尾，用于入队 private Node last; //长度 private int n; //结点 private class Node{ private T item; private Node next; } public boolean isEmpty(){ return first==null; } public int size(){ return n; } public void enQueue(T item){ Node oldlast=last; last=new Node(); //必须要new，防止栈为空时下一行出现NPE last.item=item; //为什么私有属性也能访问？？？ last.next=null; if(isEmpty()) first=last; else oldlast.next=last; n++; //放最后，方便前面判空 } public T deQueue(){ if(isEmpty()) throw new NoSuchElementException(); n--; T item=first.item; first=first.next; //防止游离，否则last还指着已经出队的那个元素 if(isEmpty()) last=null; return item; } public T peek(){ if(isEmpty()) throw new NoSuchElementException(); return first.item; } @Override public String toString() { StringBuilder s=new StringBuilder(); for(T item:this){ //调用的是this的迭代器 s.append(item); s.append(&apos; &apos;); } return s.toString(); } @Override public Iterator&lt;T&gt; iterator() { return new ListIterator(); } private class ListIterator implements Iterator{ //不能定义为MyIterator&lt;T&gt;，此T与外部类的T会被视为另一类 private Node currrent; public ListIterator() { this.currrent = first; } @Override public boolean hasNext() { return currrent!=null; } @Override public T next() { if(!hasNext()) throw new NoSuchElementException(); T item=currrent.item; currrent=currrent.next; return item; } @Override public void remove() { throw new UnsupportedOperationException(); } } public static void main(String[] args) { Queue&lt;String&gt; queue=new Queue&lt;&gt;(); //输入字符串，回车,进栈，输入-，回车,出栈 while (!StdIn.isEmpty()){ //底层是scanner.hasNext()，请求输入并获取输入流判断是否为空 //底层是scanner.next()，从输入流中读取字符串，遇到空格结束一次读取，直到读到输入流末尾再重新请求输入 String item=StdIn.readString(); if(!item.equals(&quot;-&quot;)) queue.enQueue(item); else if(!queue.isEmpty()) StdOut.print(queue.deQueue()+&quot; &quot;); } StdOut.println(&quot;(&quot;+queue.size()+&quot; left on queue)&quot;); } } 背包 其实就是不能出栈的栈，只能往里add元素代码实例 DataStructure/dataStructure","categories":[],"tags":[]},{"title":"","slug":"java生成验证码图片","date":"2019-04-30T08:25:45.186Z","updated":"2019-02-10T02:43:51.346Z","comments":true,"path":"2019/04/30/java生成验证码图片/","link":"","permalink":"http://47.107.237.149/2019/04/30/java生成验证码图片/","excerpt":"","text":"参考文章 要求： 生成随机四位验证码 生成尺寸合适、四方形的图片 打印上验证码，画干扰线和脏点（噪点），图片扭曲 返回图片给controller，输出到客户端 util层生成图片型随机验证码 /** * @Author haien * @Description 生成图片型随机验证码 * @Date 2019/2/9 **/ public class RandomValidateCodeUtil { //随机验证码原材料 private static String randString=&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;; //图片宽 private static int width=95; //高 private static int height=40; //干扰线数量 private static int interLine=6; //随机数生成器（整个类共用，避免数据相同） private static Random random = new Random(); /** * @Author haien * @Description 绘制图片验证码，返回BufferedImage对象 * @Date 2019/2/9 * @Param [backColor] * @return java.awt.image.BufferedImage **/ public static BufferedImage getImageFromCode(String randCode){ //创建不透明BufferedImage对象 BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画布 Graphics g=image.getGraphics(); Random random=new Random(); //画着色矩形 g.setColor(Color.WHITE); g.fillRect(0,0,width,height); //绘制干扰线 int x= random.nextInt(4),y=0; int x1=width-random.nextInt(4),y1=0; for(int i=0;i&lt;interLine;i++){ g.setColor(getRandomColor(100,200)); //比较浅色 y=random.nextInt(height- random.nextInt(4)); y1= random.nextInt(height-random.nextInt(4)); g.drawLine(x,y,x1,y1); } //写上验证码 int fsize=(int)(height*0.8); //字体大小为图片高度的80% int fx=10,fy=fsize; g.setFont(new Font(Font.SANS_SERIF, Font.PLAIN,fsize)); for(int i=0;i&lt;randCode.length();i++){ //一个一个字符写 fy=(int)(Math.random()*0.8+0.8*height); //字符高低随机 g.setColor(getRandomColor(40,90)); //比较深色 g.drawString(randCode.charAt(i)+&quot; &quot;,fx,fy); fx+=(width/randCode.length())*(Math.random()*0.3+0.8); //依据宽度浮动 } //扭曲图片 shearX(g,width,height); shearY(g,width,height); //添加噪点 float yawpRate = 0.05f;// 噪声率 int area = (int) (yawpRate * width * height);//噪点数量 for (int i = 0; i &lt; area; i++) { int xxx = random.nextInt(width); int yyy = random.nextInt(height); int rgb = random.nextInt(interLine); image.setRGB(xxx, yyy, rgb); } //封笔 g.dispose(); return image; } /** * @Author haien * @Description 获取四位随机验证码 * @Date 2019/2/9 * @Param [random] * @return java.lang.String **/ public static String getRandomCode(){ Random random=new Random(); StringBuilder stringBuilder=new StringBuilder(); for(int i=0;i&lt;4;i++) stringBuilder.append(String.valueOf(randString.charAt( random.nextInt(randString.length())))); return stringBuilder.toString(); } /** * @Author haien * @Description 根据自费颜色和背景颜色计算随机颜色 * @Date 2019/2/9 * @Param [fc, bc] * @return java.awt.Color **/ private static Color getRandomColor(int fc,int bc){ if (fc &gt; 255){ fc = 255; } if (bc &gt; 255){ bc = 255; } int r = fc + random.nextInt(bc - fc - 16); int g = fc + random.nextInt(bc - fc - 14); int b = fc + random.nextInt(bc - fc - 18); return new Color(r, g, b); } /** * @Author haien * @Description 扭曲图片 * @Date 2019/2/9 * @Param [g, w, h, color] * @return void **/ private static void shearX(Graphics g,int w,int h){ //水平平移 Random random=new Random(); int period=5; boolean borderGap=true; int frames=1; int phase=random.nextInt(2); //一小块一小块平移实现扭曲 for(int i=0;i&lt;h;i++){ double dx=(double) (period &gt;&gt; 1)* Math.sin((double) i / (double) period + (2.2831853071795862D * (double) phase)/ (double) frames); g.copyArea(0,i,w,1,(int)dx,0); if(borderGap){ g.setColor(getRandomColor(90,156)); g.drawLine((int)dx,i,0,i); g.drawLine((int)dx+w,i,w,i); } } } private static void shearY(Graphics g, int w1, int h1) { int period = 10; boolean borderGap = true; int frames = 20; int phase = random.nextInt(2); for (int i = 0; i &lt; w1; i++) { double dy = (double) (period &gt;&gt; 1) * Math.sin((double) i / (double) period + (2.2831853071795862D * (double) phase) / (double) frames); g.copyArea(i, 0, 1, h1, 0, (int) dy); if (borderGap) { g.setColor(getRandomColor(80,99)); g.drawLine(i, (int) dy, i, 0); g.drawLine(i, (int) dy + h1, i, h1); } } } } 图片效果 controller层获取图片 /** * @Author haien * @Description 获取图片验证码 * @Date 2019/2/9 * @Param [request, response] * @return void **/ @RequestMapping(&quot;/getVerifyCode&quot;) public void getVerifyCode(HttpServletRequest request,HttpServletResponse response) throws IOException { response.setContentType(&quot;image/jpeg&quot;); response.setHeader(&quot;Pragma&quot;,&quot;No-cache&quot;); response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;,0); String randCode=RandomValidateCodeUtil.getRandomCode(); //获取4位验证码 HttpSession session=request.getSession(); session.removeAttribute(&quot;RANDOMVALIDATECODEKEY&quot;); session.setAttribute(&quot;RANDOMVALIDATECODEKEY&quot;,randCode); BufferedImage image=RandomValidateCodeUtil.getImageFromCode(randCode); //生成图片 logger.info(&quot;----获取图片验证码--RANDOMVALIDATECODEKEY={}----&quot;,randCode); try { ImageIO.write(image,&quot;JPEG&quot;,response.getOutputStream()); } catch (IOException e) { throw new IOException(&quot;获取客户端输出流失败&quot;); } } test测试：将图片保存到本地 public static void main(String[] args) { String randomCode = RandomValidateCodeUtil.getRandomCode(); System.out.println(randomCode); BufferedImage imageFromCode = RandomValidateCodeUtil.getImageFromCode(randomCode); try { Path path=Paths.get(&quot;d:/test01.jpg&quot;); if(Files.exists(path)) Files.delete(path); File file = path.toFile(); ImageIO.write(imageFromCode,&quot;jpg&quot;,file); System.out.println(&quot;成功保存到：&quot;+file.getAbsolutePath()); } catch (IOException e) { System.out.println(&quot;保存失败&quot;); e.printStackTrace(); } } 代码实例：github/image_verifyCode分支/thz-parent/thz-manager-web/WebPageController、thz-common/tool/RandomValidateCodeUtil、RandomValidateCodeUtilTest","categories":[],"tags":[]},{"title":"","slug":"Java上传图片到阿里云OSS","date":"2019-04-30T08:25:45.176Z","updated":"2018-11-18T03:24:50.127Z","comments":true,"path":"2019/04/30/Java上传图片到阿里云OSS/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java上传图片到阿里云OSS/","excerpt":"","text":"简介 OSS：阿里云对象存储服务（Object Storage Service），是阿里云提供的海里、安全、低成本、高可靠的云存储服务。您可以通过调用API上传和下载数据，也可以通过web控制台对数据进行简单的管路。它将数据文件以对象的形式上传到存储空间（bucket）中。开通OSS服务 登录阿里云官网，注册账号，首页点击产品，在下拉菜单点击对象存储OSS，点击立即开通，开通后创建空间，然后就可以开始上传文件了。 上传方式有多种，可以通过OSS控制台直接上传、通过代码上传、通过图形化管理工具ossbrowser等上传 图形化管理工具 Ossutil：命令行管理工具，提供简介方便的object管理命令。简单来讲就是通过简单的命令行，即可实现往OSS上传输的功能，当然也包括其他的功能。 文件总量小于30T时适用，大于30T建议使用ossimport类的工具代码方式 OSSClient:OSS服务的Java客户端，它为调用者提供了一系列的方法，用于和OSS服务进行交互。 引入依赖： &lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; OSS配置文件 ossclient.endpoint:https://xxx.aliyuncs.com #ossutil的基本endpoint配置，必须为一个二级域名，表示OSS对外服务的访问域名 ossclient.accessKeyId:xxx #访问OSS使用的AccessKeyID ossclient.accessKeySecret:xxx #访问OSS使用的AccessKeySecret（密钥） ossclient.bucketName:xxx #存储空间，所有要存储的对象都必须隶属某个存储空间 OSS通过使用AccessKeyId和AccessKeySecret对称加密的方法来验证某个请求的发送者身份。AccessKeyId用于标识用户；AccessKeySecret是用户用于加密签名字符串和OSS用来验证签名字符串的密钥，必须保密。 新建OSSClient： String key = &quot;&lt;key&gt;&quot;; String secret = &quot;&lt;secret&gt;&quot;; OSSClient client = new OSSClient(key, secret); 上面的方式使用默认域名作为OSS的服务地址。如果你想自己制定域名，可以传入endpoint参数来指定做法解析 一般做法是用户在浏览器上传到应用服务器，然后应用服务器再把文件上传到OSS 这种方法有三个缺点： 上传慢，中间需要经过应用服务器，网络传送多了一倍，而且OSS是采用BGP带宽，能保证各地运营商的速度。 扩展性不好，如果后续用户多了，应用服务器就会成为瓶颈。 费用高，因为OSS上传流量是免费的。如果数据直接传到OSS，不走应用服务器，那么将能省下几台应用服务器 BGP带宽：边界网关协议，运行于TCP上的一种自治系统（AS）的路由协议。通俗来讲，就是电信、移动、联通和一些拥有AS自治域的运营商可以通过BGP来实现多线互联。打个比喻，出差去伤害（网站），可以选择公路（电信）、飞机（联通）、高铁（移动）等多种方式，BGP就好比一个只能App，可以帮助用户选择最佳的交通形式，并且可以在出现临时问题时，自动帮用户选择最佳的交通方式 改进方法，由于技术问题，暂不列出","categories":[],"tags":[]},{"title":"","slug":"Java枚举类enum","date":"2019-04-30T08:25:45.169Z","updated":"2019-03-15T08:27:05.938Z","comments":true,"path":"2019/04/30/Java枚举类enum/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java枚举类enum/","excerpt":"","text":"简介 先看一个简单的枚举类型 public enum SeasonEnum { SPRING,SUMMER,FALL,WINTER; } enum其实和class地位一样。 枚举类默认继承java.lang.Enum而非Object类。 枚举类可以继承一个或多个接口。 上面的四个季节其实就是SeasonEnum的四个实例，自动被添加public static final修饰，默认调用构造器。不可以再创建新的实例 由于枚举类的实例在类内创建，构造器只允许在类内调用，因此必须声明为private。 非抽象的枚举类默认被final修饰，不可以被继承。 枚举类也可以有自定义属性和方法（静态与否无妨）。 public enum SeasonEnum { //创建实例，调用构造器（这里要求传入字符串）；必须写在第一行 SPRING(&quot;春天&quot;),SUMMER(&quot;夏天&quot;),FALL(&quot;秋天&quot;),WINTER(&quot;冬天&quot;); //自定义属性；枚举类通常应该设计成不可变类，它的field不应该被改变，这样会更安全 private final String name; //构造器 private SeasonEnum(String name) { this.name = name; } public String getName() { return name; } } 常用方法 toString(): 继承自Enum类，返回枚举常量（枚举值）名。 SeasonEnum.SPRING.toString() //返回SPRING valueOf(): 静态方法，toString()的逆方法，将字符串包装成枚举类。 SeasonEnum season=(SeasonEnum)Enum.valueOf(SeasonEnum.class,&quot;SPRING&quot;); //将season包装为SeasonEnum.SPRING values(): 每个枚举类型都包含的静态方法，返回一个包含全部枚举值的数组 SeasonEnum[] values=SeasonEnum.values(); 枚举类实现接口 与普通类一样，枚举类实现接口的时候如果没有重写所有方法，那这个枚举类就是抽象的，只是不需要显式加上abstract修饰。 public enum Operation { //枚举值实现抽象方法 PLUS{ @Override public double eval(double x, double y) { return x + y; } }, TIMES{ @Override public double eval(double x, double y) { return x * y; } }, /** * 抽象方法，由不同的枚举值提供不同的实现。 */ public abstract double eval(double x, double y); public static void main(String[] args) { System.out.println(Operation.PLUS.eval(10, 2)); System.out.println(Operation.TIMES.eval(10, 2)); } } switch语句里的表达式可以是枚举值 case表达式可以直接写枚举值，而不需加入枚举类作为限定。 public class SeasonTest { public void judge(SeasonEnum s) { switch(s) { case SPRING: System.out.println(&quot;春天适合踏青。&quot;); break; case SUMMER: System.out.println(&quot;夏天要去游泳啦。&quot;); break; case FALL: System.out.println(&quot;秋天一定要去旅游哦。&quot;); break; case WINTER: System.out.println(&quot;冬天要是下雪就好啦。&quot;); break; } }","categories":[],"tags":[]},{"title":"","slug":"Java基础知识点","date":"2019-04-30T08:25:45.150Z","updated":"2019-04-07T03:07:48.713Z","comments":true,"path":"2019/04/30/Java基础知识点/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java基础知识点/","excerpt":"","text":"基本类型 byte 8位整数，-128~127 short 16位整数，-32768~32767 int 32位 long 64位，为了标识，建议跟个后缀L或l。 float 32位浮点小数，有一个后缀F/f，没有后缀的浮点数默认为double类型。 double 64位浮点小数，后缀D/d。 char 字符型 boolean 布尔型 只有很少的情况适用float，例如，需要快速地处理单精度数据，或者需要存储海量数据。否则都是使用double。 Java整型和浮点数都是有符号数，不存在有符号数和无符号数比较或运算时出错的情况。 限定符 对类、接口及其成员进行声明时，public表示可以被任何人访问 protected只能被本包的本类和位于任何包的子类访问 default只能被本包访问 private只能被本类访问 重载可以改变方法的访问范围，但只能变大。 final 一个final类不能有子类，一个final的field表示它是一个常量。 一个final域需要在对象调用构造器后就被初始化，不接受默认初始化，因此定义了final常量后要么顺便赋个值给它，要么在构造器里给它赋值。 把方法的入参定义为final的话，该参数不可以被重新赋值。可以防止在方法里面不小心改变了不能变的参数，造成一些不必要的麻烦。 public static void printAll(final Curry temp){ //实参传进来给形参，就相当于初始化完成 temp.setSmallName(&quot;fk do it&quot;); System.out.println(temp.getSmallName()); temp = new Curry(); 传送进来的Curry引用是final，不可以再赋值了，这里一定会报错哦！ } static 一个static的field表明它是属于类的，而不是每一个对象都单独拥有一份的。 类加载的时候将static变量初始化（接受默认初始化）并加载到方法区，因此它是随着类的加载而加载的 一个static的final常量由于不能被默认初始化，所以类加载的时候若它还未人为初始化则编译报错。因此静态常量需要定义即赋值或在静态代码块中赋值（构造器不随类加载而执行，而是随着对象创建而被调用的），或者像笔记：hibernate学习之Crud-&gt;封装Util获取session工厂一样，让final常量=一个静态方法的返回值，强制类加载时也把静态方法执行了。反正必须让它在类加载时完成初始化。 静态方法则不会随着类的加载而执行，但静态代码块是随着项目的开始而执行的。native native修饰某个方法表明该方法实现的文件是由其他语言（C/C++等)写的。 Array.length 数组的求长度（总容量）属性length是java.lang.reflect.Array中的一个属性，该属性由getLength(Object array)方法赋值，但这个方法是由其他语言来实现的，因为要接触到底层，而java语言本身是不接触 及其底层的。数组 声明一个父类数组，其中可以放子类对象，但是这些对象就被隐转成父类，只有父类的成员了。 用instanceof能检测出元素的原类型 定义基本类型数组，声明后即可放入元素 int[] a=new int[5]; a[0]=0; 定义元素为类的数组，声明后还要对每个元素都new一遍，否则元素全部为空指针 Bag&lt;Integer&gt;[] adj=(Bag&lt;Integer&gt;[])new Bag[V]; //不能创建泛型指定类型的泛型数组，只能先创建泛型数组再强转 //这一步不能省略，必须一个个分配Bag，否则adj数组中每个元素都是空指针 for(int i=0;i&lt;V;i++){ adj[i]=new Bag&lt;Integer&gt;(); adj[i].add(i); //不经过上一行的话报空指针异常 } 父类强转为子类 可以的，但此父类对象必须原本就是由子类对象转来的。 例如，Father father=new Son()或Father father=(Father)son; 转换前可以先用instanceof检查 if(father instanceof Son){ Son son=(Son)father; } 其实子类转为父类（隐式或强制），比父类多的成员只是暂时不能访问，被隐藏了而已，被转回来之后又能访问了。 构造方法不能继承 如果父类中有无参构造函数，创建子类时，必须在构造函数第一行调用父类的无参构造函数；如果父类只定义了有参构造函数，那么编译器无法隐式加上无参构造函数，而子类又需要调用无参构造函数，故编译报错。当然，如果子类需要的只是父类的有参构造函数，那么调用即可。编译器不会因为父类缺少无参构造函数而报错。 同父类强转在编辑时检测不到异常 编译时才能发现类型不能强制的错误，并且抛异常，所以不要以为强转时没飘红就是可以了，只是检测不出来而已。 collection.toArray() list.toArray(): 将list(或其他集合如Set)转为Object[]。 String[] array= (String[]) list.toArray(); 以上代码运行报错：Exception in thread “main” java.lang.ClassCastException:[Ljava.lang.Object; cannot be cast to [Ljava.lang.String;原因是不能将Object[]直接转为String[]，只能遍历每一个元素进行转化。 Java中的强制类型转换只针对单个对象，不能将整个数组转换为另一类型，这和数组初始化时需要一个个来是类似的。 正解： Object[] arr = list.toArray(); for (int i = 0; i &lt; arr.length; i++) { String e = (String) arr[i]; } list.toArray(T[] a): 转化为指定类型数组，比上个方法更好用。 predicates.toArray(new Predicate[0]); // toArray(数组)：将调用方法的对象转换为数组， // 并存储到传入的数组中；若数组空间不足则重新创造一个数组并返回 predicates.toArray( new Predicate[predicates.size()] ); 参考文章 线程 synchronized：Java 关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 //该方法是产生一个double型的Gaussian随机数 public synchronized double nextGaussian(){ } 获取当前类名 this.getClass().getName() Thread.currentThread().getStackTrace()[1].getClassName()System.currentTimeMillis()获取当前时间 获取当前的时间，new Date()底层调用的也是这个 long startTime= System.currentTimeMillis();//返回一个long型，保存到数据库转为date展示（Date原本也是用秒数表示的） 获取文件后缀名File file = new File(&quot;HelloWorld.java&quot;); String fileName = file.getName(); String suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1); 测试程序运行时间 在程序开始前记录一次当前时间，程序结束时再记录一次，两者相减即可 long startTime = System.currentTimeMillis(); ---待测试程序--- long endTime = System.currentTimeMillis(); System.out.println(&quot;运行时间:&quot; + (endTime - startTime) + &quot;ms&quot;); System.nanoTime() 返回纳秒（即当前与某个时间基准的时间差），1ms=1ns10001000,中间还隔了个微秒。 long time1=System.nanoTime(); 只用于计算时间差，不要用于计算距离现在的时间差，因为纳秒太小了 //计算程序运行时间 long time1=System.nanoTime(); for(int i=0;i&lt;200;i++){ System.out.print(&quot;.&quot;); } long time2=System.nanoTime(); System.out.println(time2-time1); 参数类型后加… test(ObjectA… objectAs)可变长度参数列表，表示这个类型的入参可以有0个或多个ObjectA或ObjectA[]，传参时可以是一个个并列地传，也可以是直接一个数组。 方法内对它们的遍历： public void correlationRoles(Long... roleIds) { for(Long roleId : roleIds) { } //or for(int i=0;i&lt;roleIds.length;i++){ } } 如果调用时什么也没传，那么该参数的长度为0。 必须放在最后一个形参的位置上，否则报错。 假如已有一个方法test(String… strings)，那么还可以写方法test()，而当我们调用test()时，编译器优先匹配test()方法，没有test()时才会匹配test(String… strings)； 但是不能写test(String[] strings),编译出错，系统提示出现重复方法。 Clazz 为什么很多程序员喜欢用Clazz命名？ 它表示类的意思，因为Class已经被作为关键字，人们不能再使用，因此用clazz作为代替。 Deque类 即double ended queue，双端队列，继承自Queue，是一种具有队列和栈的性质的数据结构。元素可以从两端弹出，插入和删除都可以在两端进行。 push(): 向队头插入元素。 pop(): 弹出队头元素。 removeFirst(): 弹出首元素，如果是作为栈来使用则应该是最后一个进去的元素。 removeLast(): 弹出尾元素。 参考文章 代码示例：ideaProjects/shiro-chapter18/web/shiro/filterKickoutSessionControllerFilter；不知道为什么在这里removeFirst()弹出的是队尾元素，removeLast()反而是队头。 StringUtils hasText(str): 字符串判空，如果字符串为null、””或” “，那么返回false。","categories":[],"tags":[]},{"title":"","slug":"Java获取客户ip","date":"2019-04-30T08:25:45.139Z","updated":"2019-02-05T03:03:40.803Z","comments":true,"path":"2019/04/30/Java获取客户ip/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java获取客户ip/","excerpt":"","text":"在开发工作中，我们常常需要获取客户端的ip。一般获取客户端ip的方法是request.getRemoteAddr(),但是在通过了Apache、squid等反向代理软件后，这样不能获取到客户端的真实ip地址了。 如果使用了反向代理软件，将http://192.168.1.110.2046的url反向代理为http://www.abc.com/，当我们访问http://www.abc.com/index.jsp时，其实浏览器并不是真正访问到了服务器上的index.jsp文件，而是先由反向代理服务器去访问http://192.168.1.110:2046/index.jsp，反向代理服务器再将访问到的结果返回给浏览器。由于是反向代理服务器去访问index.jsp的，所以index.jsp中通过request.getRemoteAddr()的方法获取到的实际上是反向代理服务器的地址，并不是客户端的地址。 图示为不通过代理上网（其中resin服务器为一种web服务器） 这种通过remoteip可以直接获取 下面是通过代理上网的图例（其中代理服务器也可以是nginx） 其中X-Forwarded-For和X-Real-IP都不是http的正式协议头，而是squid等反向代理软件最早引入的。如果连XFF第一个都不是客户ip，那么第二个就更不靠谱了。XFF就会按照代理链将一系列的ip地址存储起来。 由图可得，在程序服务器中拿最原始的ip逻辑： 如果XFF不为空，拿第一个 为空，拿XRI 如果XRI为空，拿remoteAddr，即只能拿最直接发给他的机器的ip 代码 public static String getIp(HttpServletRequest request) { String ip = request.getHeader(&quot;x-forwarded-for&quot;); if (ip != null &amp;&amp; ip.length() != 0 &amp;&amp; !&quot;unknown&quot;.equalsIgnoreCase(ip)) { if( ip.indexOf(&quot;,&quot;)!=-1 ){ ip = ip.split(&quot;,&quot;)[0]; } } if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) { ip = request.getHeader(&quot;Proxy-Client-IP&quot;); } if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) { ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); } if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) { ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;); } if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) { ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;); } if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) { ip = request.getHeader(&quot;X-Real-IP&quot;); } if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) { ip = request.getRemoteAddr(); if(ip.equals(&quot;127.0.0.1&quot;) || ip.equals(&quot;0:0:0:0:0:0:0:1&quot;)){ //根据网卡取本机配置的IP InetAddress inet=null; try { inet = InetAddress.getLocalHost(); } catch (UnknownHostException e) { e.printStackTrace(); } ip= inet.getHostAddress(); } } return ip; } 参考文章 参考文章 代码示例：D:/dieaprojects/thz/thz-parent/thz-common/IPUtil","categories":[],"tags":[]},{"title":"","slug":"java公有类","date":"2019-04-30T08:25:45.128Z","updated":"2018-09-03T05:38:56.173Z","comments":true,"path":"2019/04/30/java公有类/","link":"","permalink":"http://47.107.237.149/2019/04/30/java公有类/","excerpt":"","text":"一个文件中只能有一个public类，除此之外可以有其他类，这些类主要用来为public类提供支持。在包之外的世界是无法看见这些类的。 如果没有public类，文件名可以与任一类名一致。 当编写一个java源文件时，此文件通常被称为编译单元。","categories":[],"tags":[]},{"title":"","slug":"Java发送短信验证码","date":"2019-04-30T08:25:45.121Z","updated":"2019-02-10T12:03:09.719Z","comments":true,"path":"2019/04/30/Java发送短信验证码/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java发送短信验证码/","excerpt":"","text":"要求 生成6位随机验证码 向第三方接口发送手机号和验证码，由第三方接口发送验证码到指定手机 将验证码和发送时间存入session，供controller层比对验证码是否正确和有效简介 发送短信需要借助第三方接口，目前提供短信服务的第三方平台有很多，首选秒嘀科技，注册即送10元约200条免费试用优惠，但需要企业认证才能发送短信。阿里云也提供短信服务，但必须充值才能使用。注册秒嘀科技 访问秒嘀科技：http://www.miaodiyun.com/，注册账号 登录，点击用户中心-&gt;账户管理，获取ACCOUNT_SID和AUTH_TOKEN（后者需要验证）。 点击配置管理-&gt;验证码短信模板-&gt;新建模板,填写信息后提交审核，很快能好术语 SMS：Short Message Service，短信服务 sig: 一种有效的数字签名，以便在手机设备上运行。 sid：Security Identifiers,是用户、组合计算机账户的唯一身份标识。MessageDigest类 为应用程序提供信息摘要算法，如MD5或SHA算法。信息摘要是安全的单向哈希函数，它接收任意大小的数据，并输出固定长度的哈希值。 MessageDigest.getInstance(String algorithm):返回实现指定摘要算法的MessageDigest对象。 update(byte[]):指定要生成摘要的信息，返回值为void。 digest():返回计算出来的哈希摘要，是byte[]，通常与update方法同用。 digest(byte[]):可以不用update方法。 isEqual(byte[],byte[]):两个摘要是否相同，做简单的字节比较。代码 短信发送方面不需要导什么包，因为我们是用网络访问的方式调用第三方接口，只需要程序发起请求，不需要额外引入依赖。 发送短信工具类 /** * @Author haien * @Description 发送短信服务工具类 * @Date 2019/2/10 * @Param * @return **/ public class SmsUtil { //第三方平台接口 private static final String QUERY_PATH= &quot;https://api.miaodiyun.com/20150822/industrySMS/sendSMS&quot;; //我的账号认证 private static final String ACCOUNT_SID=&quot;78789aaee2d54938adb96d01f96dae79&quot;; private static final String AUTH_TOKEN=&quot;1834bbf37ebc457e8141d290127a431d&quot;; public static int sendCode(String phone,String code) throws NoSuchAlgorithmException, IOException { //定义该次请求 URL url=new URL(QUERY_PATH); HttpURLConnection connection=(HttpURLConnection)url.openConnection(); connection.setRequestMethod(&quot;POST&quot;); connection.setDoInput(true); //是否允许数据写入 connection.setDoOutput(true); //是否允许数据输出 connection.setConnectTimeout(5000); //链接响应时间 connection.setReadTimeout(10000); //参数读取时间 connection.setRequestProperty(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //提交请求 String timestamp=new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;) .format(new Date());//时间戳 String sig=getMD5(ACCOUNT_SID,AUTH_TOKEN,timestamp); //签名（用于手机设备认证） String tamp=&quot;您的验证码为&quot;+code +&quot;，请于5分钟内正确输入，如非本人操作，请忽略此短信。&quot;; //短信内容 String args=getQueryArgs(ACCOUNT_SID,tamp,phone ,timestamp,sig,&quot;JSON&quot;); //请求参数拼接 OutputStreamWriter out=new OutputStreamWriter(connection.getOutputStream() ,&quot;UTF-8&quot;); out.write(args); //发起请求 out.flush(); //读取返回参数 BufferedReader br=new BufferedReader(new InputStreamReader(connection.getInputStream() ,&quot;UTF-8&quot;)); //br：{&quot;respCode&quot;:&quot;00179&quot;,&quot;respDesc&quot;:&quot;发送短信需要先认证&quot;} String temp=&quot;&quot;; StringBuilder result=new StringBuilder(); while((temp=br.readLine())!=null){ //其实也就一行 result.append(temp); } //解析参数，判断成功与否 JSONObject json=JSONObject.parseObject(result.toString()); //转为json String respCode=json.getString(&quot;respCode&quot;); //获取respCode对应的值 String successRespCode=&quot;00000&quot;; //成功情况：respCode=00000 if(successRespCode.equals(respCode)) return 1; //成功 else return 0; //失败 } /** * @Author haien * @Description 获得sign(签名) * @Date 2019/2/10 * @Param [sid, token, timestamp] * @return java.lang.String **/ private static String getMD5(String sid,String token,String timestamp) throws NoSuchAlgorithmException { StringBuilder result=new StringBuilder(); String source=sid+token+timestamp; //MessageDigest:生成信息摘要，即加密 MessageDigest digest=MessageDigest.getInstance(&quot;MD5&quot;); //指定用MD5算法 byte[] bytes=digest.digest(source.getBytes()); //要进行加密的信息 for(byte b : bytes){ String hex=Integer.toHexString(b &amp; 0xff); //将一个整型转为十六进制 if(hex.length()==1) result.append(&quot;0&quot;+hex); else result.append(hex); } return result.toString(); } /** * @Author haien * @Description 拼接请求参数 * @Date 2019/2/10 * @Param [accountSid, smsContent, to, timestamp, sig, respDataType] * @return java.lang.String **/ public static String getQueryArgs(String accountSid,String smsContent,String to, String timestamp, String sig,String respDataType){ return &quot;accountSid=&quot;+accountSid+&quot;&amp;smsContent=&quot;+smsContent+&quot;&amp;to=&quot;+to+&quot;×tamp=&quot; +timestamp+&quot;&amp;timestamp=&quot;+timestamp+&quot;&amp;sig=&quot;+sig+&quot;&amp;respDataType=&quot; +respDataType; //tamp前面是乘号;有的例子没加timestamp参数，会报错的 } } 发送结果分析 发送错误： result==&gt;{&quot;respCode&quot;:&quot;00134&quot;,&quot;respDesc&quot;:&quot;没有和内容匹配的模板&quot;} 发送正确: result==&gt;{&quot;respCode&quot;:&quot;00000&quot;,&quot;respDesc&quot;:&quot;请求成功。&quot;, &quot;failCount&quot;:&quot;0&quot;,&quot;failList&quot;:[],&quot;smsId&quot;:&quot;f5d6ec80a8bc4291af8f6d9b7c6555fb&quot;} 产生随机验证码工具类 /** * @Author haien * @Description 生成随机验证码 * @Date 2019/2/9 **/ public class RandomValidateCodeUtil { /** * @Author haien * @Description 生成6位数字随机验证码 * @Date 2019/2/10 * @Param [] * @return java.lang.String **/ public static String getVerifyCode(){ return String.valueOf(new Random().nextInt(899999)+100000); } } controller层发送短信 /** * @return void * @Author haien * @Description 发送短信验证码 * @Date 2019/2/9 * @Param [request, response] **/ @RequestMapping(&quot;/getVerifyCode&quot;) public Map&lt;String, String&gt; getVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException { Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); String phone = request.getParameter(&quot;phone&quot;); if (StringUtil.isNull(phone)) { result.put(&quot;message&quot;, &quot;请填写手机号&quot;); return result; } if (!ValidatorUtil.isMobile(phone)) { result.put(&quot;message&quot;, &quot;手机格式错误&quot;); return result; } if (userService.findUserByPhone(phone) != null) { result.put(&quot;message&quot;, &quot;手机已绑定&quot;); return result; } String code = RandomValidateCodeUtil.getVerifyCode(); logger.info(&quot;----请求验证码--code={}----&quot;, code); try { int success = SmsUtil.sendCode(phone, code); } catch (NoSuchAlgorithmException e) { logger.info(&quot;----短信发送失败----&quot;); throw new NoSuchFieldError(&quot;生成信息摘要异常：不存在指定的加密算法&quot;); } logger.info(&quot;----短信发送成功----&quot;); JSONObject json = new JSONObject(); json.put(VERIFYCODEKEY, code); json.put(CODECREATETIMEKEY, System.currentTimeMillis()); request.getSession().setAttribute(VERIFYMSG, json); result.put(&quot;message&quot;, &quot;短信发送成功&quot;); return result; } controller层比对验证码 /** * @Author haien * @Description 比对验证码是否正确 * @Date 2019/2/10 * @Param [verifyCode] * @return boolean **/ @RequestMapping(value = &quot;/isVrfCodeRigth&quot;, method = RequestMethod.GET) public Map&lt;String,String&gt; isVrfCodeRigth(@RequestParam(&quot;verifyCode&quot;)String verifyCode ,HttpServletRequest request){ Map&lt;String,String&gt; result=new HashMap&lt;&gt;(); JSONObject verifyMsg=(JSONObject)request.getSession().getAttribute(VERIFYMSG); if(!verifyMsg.getString(VERIFYCODEKEY).equals(verifyCode)) result.put(&quot;message&quot;,&quot;验证码错误&quot;); if((System.currentTimeMillis()-verifyMsg.getLong(CODECREATETIMEKEY))&gt;1000*60*5) //5分钟 result.put(&quot;message&quot;,&quot;验证码过期&quot;); return result; } 参考文章 秒嘀科技注册说明与发送短信代码参考 验证码和有效时间在session中的存取操作代码实例 D:/thz/thz-parent/thz-common/SmsUtil、thz-manager-web/WebPageController","categories":[],"tags":[]},{"title":"","slug":"Java比较两个浮点数","date":"2019-04-30T08:25:45.112Z","updated":"2018-10-16T08:52:14.952Z","comments":true,"path":"2019/04/30/Java比较两个浮点数/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java比较两个浮点数/","excerpt":"","text":"类型升级 规则是低的往高转 如果运算符（通常是比较运算符）两边的数值类型不同，则会先进行类型转换： 出现double则全转换为double 出现float则全转换为float 出现long则全转换为long 否则全转换为int 混合运算时，必须先把所有的数据都转换成同一数据类型： 字符必须先转换成int型，short转换成int型，float转换成double。浮点数的二进制表示 float和double存在计算机中分别是这样的： 第一部分为符号位，第二部分为指数位，第三部分为基数位。这是科学计数法的二进制表示。 由于位数是固定的，所以对无限小数不能精确表示，但实际上，对于一些有限小数也不能精确表示，比如0.1。 科学计数法的十进制表示：2.5410^2；二进制表示：1.12^-4（跟前面表示的不是同一个数）。 我们来查看一下浮点数在内存中的样子： System.out.println(Integer.toBinaryString(Float.floatToIntBits(0.1f))); System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.1d))); System.out.println(Long.toBinaryString(Double.doubleToLongBits(0.1f))); xxxToXxxBits()是把某类型转换为长度相同的另一类型，底层可能是把浮点数扩大一定倍数吧。 toBinaryString()则是获取某个数值的字节码 第三行首先要把float转为double然后再被doubleToLongBits()作用 怎么比较呢 直接用==肯定不行，比如： Double a = Double.valueOf(&quot;0.0&quot;); Double b = Double.valueOf(&quot;-0.0&quot;); System.out.println(a.equals(b)); //false 用equals也不行： Double a = Math.sqrt(-1.0); //NaN Double b = 0.0d / 0.0d; //NaN Double c = a + 200.0d; //NaN Double d = b + 1.0d; //NaN System.out.println(a.equals(b)); //true，equals只是比较两个对象的引用是否相同 System.out.println(b.equals(c)); //true System.out.println(c.equals(d)); //true 最好也不要用compare To() Float.compareTo()和Double.compareto()虽说是先将数值转换成整型再进行比较的，但实际由于舍入误差，还是可能会导致经过一些计算后得到的待比较浮点数有略微不同；而且无法避免NaN和0.0、-0.0的错误。 自定义阙值进行比较 要考虑NaN、无穷和舍入误差，可能出现的场景如下： 算法 public boolean isEqual(double a, double b) { if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) { return false; } return Math.abs(a - b) &lt; 1e-6d; }","categories":[],"tags":[]},{"title":"","slug":"Javabean","date":"2019-04-30T08:25:45.104Z","updated":"2018-07-12T00:24:13.051Z","comments":true,"path":"2019/04/30/Javabean/","link":"","permalink":"http://47.107.237.149/2019/04/30/Javabean/","excerpt":"","text":"代码实例：HeadFirstJspServletChap04-javabean02.jsp开始","categories":[],"tags":[]},{"title":"","slug":"Java8已定义的函数式接口","date":"2019-04-30T08:25:45.093Z","updated":"2018-10-25T08:26:08.894Z","comments":true,"path":"2019/04/30/Java8已定义的函数式接口/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java8已定义的函数式接口/","excerpt":"","text":"Predicate 主要功能是验证数据 //源码 public interface Predicate&lt;T&gt; { /** * 制定检查模板 */ boolean test(T t); /** * 得到相反结果 */ default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); //相当于new了一个Predicate对象并重写了其test方法，如此可以进行链式书写 } …… } //调用 Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0; //重写test predicate.test(&quot;foo&quot;); // true predicate.negate().test(&quot;foo&quot;); // negate返回一个Predicate对象，调用这个对象的test方法；false Predicate&lt;Boolean&gt; nonNull = Objects::nonNull; //重写test Predicate&lt;Boolean&gt; isNull = Objects::isNull; Predicate&lt;String&gt; isEmpty = String::isEmpty; Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Consumer 主要功能是更改输入参数的内部状态 //源码 public interface Consumer&lt;T&gt; { void accept(T t); /** * 检测入参是否为空并返回一个实现了方法的Consumer对象 * 用于链式书写：consumer.andThen().accept() */ default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; { accept(t); after.accept(t); }; //既对调用andThen的对象应用accept方法，也对传入andThen的参数应用accept方法 } } //调用 User user=new User(&quot;zm&quot;); //接收一个参数 Consumer&lt;User&gt; userConsumer=User1 -&gt; User1.setName(&quot;zmChange&quot;); userConsumer.accpet(user); System.out.println(user.getName()); Predicate和Consumer综合应用 通过一个学生例子：Student类包含姓名、分数和费用，每个学生科根据分数获得不同程度的费用折扣 Student类： public class Student { String firstName; String lastName; Double grade; Double feeDiscount = 0.0; Double baseFee = 2000.0; public Student(String firstName, String lastName, Double grade) { this.firstName = firstName; this.lastName = lastName; this.grade = grade; } public void printFee(){ Double newFee = baseFee - ((baseFee * feeDiscount)/100); System.out.println(&quot;The fee after discount: &quot; + newFee); } } 用一个Predicate接口判断输入的Student对象是否拥有费用打折的资格，然后使用Consumer接口更新Student对象的折扣： public class PredicateConsumerDemo{ public static Student updateStudentFee(Student student, Predicate&lt;Student&gt; predicate, Consumer&lt;Student&gt; consumer){ if(predicate.test(student)){ consumer.accept(student); } return student; } } 调用updateStudentFee() Stream stream=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); //构造stream String[] strArray=new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; stream=Arrays.stream(strArray); //底层也是构造stream List&lt;String&gt; list=Arrays.asList(strArray); //底层是new ArrayList&lt;&gt;(strArray); stream=list.stream(); //底层也是stream IntStream.of(new int[]{1,2,3}).forEach(System.out::println); Student student=new Student(&quot;Ashok&quot;,&quot;Kumar&quot;,9.5); student=PredicateConsumerDemo.updateStudentFee(student, stu -&gt; stu.grade &gt; 8.5, stu -&gt; stu.feeDiscount = 30.0); student.printFee(); //The fee after discount:1400.0 Supplier 主要是返回一个实例，相当于工厂 //实例化一个String对象，值为hello world Supplier&lt;String&gt; supplier=() -&gt; &quot;hello world&quot;; System.out.println(supplier.get()); //实例化一个对象 Supplier&lt;Student&gt; student=() -&gt; new Student(); student.get(); //获取此对象 Function 主要功能是对输入的参数进行计算并返回结果 源码： public interface Function&lt;T, R&gt; { //指定入参、返回值的类型 /** * 对输入的参数进行某种计算并返回定义接口时指定的类型 */ R apply(T t); /** * 返回一个Function对象，重写其apply方法为：先执行before的apply方法再执行调用者的apply方法 */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } /** * 先执行调用者的apply方法再执行after的apply方法 */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } /** * static：静态方法；&lt;T&gt;：泛型方法； * Function&lt;T,T&gt;：返回值为一个Function对象， * 此对象被重写的apply方法入参和返回值类型均为T * 功能：返回一个Function对象，其apply方法为传入什么返回什么 */ static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; } } 调用 Function&lt;Integer,Integer&gt; name=e -&gt; e*2; Function&lt;Integer,Integer&gt; square=e -&gt; e*e; int value=name.andThen(square).apply(3); System.out.println(value); //36 value=name.compose(square).apply(3); //18 System.out.println(value); String identity=(String)Function.identity().apply(&quot;hello&quot;); System.out.println(identity); //hello BiFunction BiFunction与Function的区别就是传入两个参数，依旧返回一个参数（比如传入两个字符串连接成一个返回） 调用 Function&lt;String,Integer&gt; myFunction=str -&gt; str.length(); BiFunction&lt;String,String,String&gt; myBiFunction=(str1,str2) -&gt; str1+str2; int len=myFunction.apply(&quot;hello&quot;); System.out.println(len); //5 String str=myBiFunction.apply(&quot;hello&quot;,&quot;world&quot;); System.out.println(str); //hello world Comparator 主要功能是比较任意类型数据，多用于排序、分组 源码：（不是很懂为什么可以有两个抽象方法，但是要实现Comparator接必须实现compare()，equals()随意 public interface Comparator&lt;T&gt; { /** * 比较两个参数，数字一般相减，字符串一般用compareTo() * 返回1，0，-1，以该接口为入参之一的Collection.sort()分别进行升序、不处理、降序处理 */ int compare(T o1, T o2); /** * 判断调用者是否和入参相等，同Object.equals() */ boolean equals(Object obj); /** * 还有一些默认函数，不常用 */ } 排序应用 public class FormulaImpl{ //首先定义一个狗狗的类 class Dog{ public int age; public String name; public Dog(int age,String name){ super(); this.age=age; this.name=name; } @Override public String toString() { return &quot;Dog{&quot; + &quot;age=&quot; + age + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &apos;}&apos;; } } //然后用Comparator来排序 public static void main(String[] args) { //这里注意静态方法里不能有非静态的成员，一定要先实例外部类再实例内部类 List&lt;Dog&gt; list=new ArrayList&lt;&gt;(); list.add(new FormulaImpl().new Dog(1,&quot;a&quot;)); list.add(new FormulaImpl().new Dog(2,&quot;b&quot;)); list.add(new FormulaImpl().new Dog(3,&quot;c&quot;)); //按照年龄降序 Comparator&lt;Dog&gt; comparator=(obj1,obj2) -&gt; obj2.age-obj1.age; //升序：obj1.age-obj2.age Collections.sort(list,comparator); System.out.println(&quot;按照年龄降序：&quot;+list); //[Dog{age=3, name=&apos;c&apos;}, Dog{age=2, name=&apos;b&apos;}, Dog{age=1, name=&apos;a&apos;}] //按照字母顺序升序 comparator=(obj1,obj2) -&gt; obj1.name.compareTo(obj2.name); //[Dog{age=1, name=&apos;a&apos;}, Dog{age=2, name=&apos;b&apos;}, Dog{age=3, name=&apos;c&apos;}] Collections.sort(list,comparator); System.out.println(&quot;按照字母顺序升序：&quot;+list); } } 分组应用 public class FormulaImpl{ //首先定义一个苹果类 class Apple { public String color; public int weight; public Apple(String color, int weight) { super(); this.color = color; this.weight = weight; } @Override public String toString() { return &quot;Apple [color=&quot; + color + &quot;, weight=&quot; + weight + &quot;]&quot;; } } /** * 分组：入参为数据源和比较规则，比如吧相同颜色或者同一重量级的分到一组 * 返回组别的集合 */ public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; divider(Collection&lt;T&gt; datas, Comparator&lt;? super T&gt; c) { //result是所有组的集合，每个组又单独是一个集合 List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;(); //result.size()=0 //开始分组：遍历每个苹果 for (T t : datas) { //设置flag boolean isSameGroup = false; //同已有组的任一成员比较，相等即进组；第一个苹果肯定是不用进此循环直接到下一步的 for (int j = 0; j &lt; result.size(); j++) { if (c.compare(t, result.get(j).get(0)) == 0) { isSameGroup = true; result.get(j).add(t); break; } } //不是前面任何组的，单独开组 if (!isSameGroup) { List&lt;T&gt; innerList = new ArrayList&lt;T&gt;(); //以下两行看起来好像是开了新组但是却没把苹果放进去，其实到了遍历集合的时候自然就进去了 result.add(innerList); innerList.add(t); } } return result; } //调用 public static void main(String[] args) { List&lt;Apple&gt; list=new ArrayList&lt;&gt;(); list.add(new FormulaImpl().new Apple(&quot;红&quot;,200)); list.add(new FormulaImpl().new Apple(&quot;红&quot;,100)); list.add(new FormulaImpl().new Apple(&quot;绿&quot;,201)); list.add(new FormulaImpl().new Apple(&quot;绿&quot;,101)); list.add(new FormulaImpl().new Apple(&quot;黄&quot;,102)); list.add(new FormulaImpl().new Apple(&quot;黄&quot;,202)); Comparator&lt;Apple&gt; comparator=(obj1,obj2) -&gt; obj1.color.compareTo(obj2.color); List&lt;List&lt;Apple&gt;&gt; byColor=divider(list,comparator); System.out.println(&quot;按照颜色分组：&quot;+byColor); comparator=(obj1,obj2) -&gt; (obj1.weight/100 == obj2.weight/100) ? 0 : -1; List&lt;List&lt;Apple&gt;&gt; byWeight=divider(list,comparator); System.out.println(&quot;按照重量分组：&quot;+byWeight); } } 从这个例子中我们可以看出，当一个数组需要按照不同的规则排序的时候，我们可以定义不同的比较器传入排序方法中。Stream 主要功能是对集合转换成的数据流进行过滤、转换、计算等操作 除了Stream，平行的还有IntStream、LongStream、DoubleStream三种数值型Stream，当然我们也可以用Stream来代替，但是boxing和unboxing会很耗时。 Map接口不支持Stream 源码： public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; { /** * 返回符合判断条件的流对象 */ Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); /** * 返回经过计算的流对象 */ &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); /** * 返回经过计算的流对象（该计算的结果为int型） */ IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); /** * 返回经过计算的流对象，这个流对象的每一个元素都是流 */ &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); /** * 返回经过计算的int型流对象，这个流对象的每一个元素都是int型的流 */ IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper); /** * 去重 */ Stream&lt;T&gt; distinct(); /** * 元素有得比较则按默认规则排序，否则抛异常 */ Stream&lt;T&gt; sorted(); /** * 按指定规则排序 */ Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator); /** * 对流的所有元素进行同一个操作 */ void forEach(Consumer&lt;? super T&gt; action); /** * 遍历流的元素，与forEach的区别是它返回的是Stream对象，可以继续进行链式操作 */ Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action); /** * 提供一个起始值identity，然后依照运算规则BinaryOperator和所有的元素组合 * 字符串的拼接、数值的sum、min、max、average都是特殊的reduce * 例如：Stream的sum就相当于 * Integer sum=integers.reduce(0,(a,b) -&gt; a+b); * 或Integer sum=integers.reduce(0,Integer::sum); */ T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); /** * 还有很多方法 */ } 流的构造： //用数组构造 Stream stream=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); //构造stream String[] strArray=new String[]{&quot;a&quot;,&quot;b&quot;,&quot;c&quot;}; stream=Arrays.stream(strArray); //底层也是构造stream //用集合构造 List&lt;String&gt; list=Arrays.asList(strArray); //底层是new ArrayList&lt;&gt;(strArray); stream=list.stream(); //底层也是构造stream 数值流的构造 IntStream.of(new int[]{1,2,3}); 流转换为其他数据结构 //转换成数组 Stream stream=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); String[] strArray= (String[]) stream.toArray(String[]::new); //a,b,c //转换成集合 stream=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); //Stream只能使用一次，用完即关闭，需重开 List&lt;String&gt; list1= (List&lt;String&gt;) stream.collect(Collectors.toList()); //a,b,c stream=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); List&lt;String&gt; list2= (List&lt;String&gt;) stream.collect(Collectors.toCollection(ArrayList::new)); //a,b,c //转换成String stream=Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); String str=stream.collect(Collectors.joining()).toString(); //abc 调用map() //转换大写 List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); List&lt;String&gt; output=list.stream() .map(String::toUpperCase) .collect(Collectors.toList()); System.out.println(output); //平方数 List&lt;Integer&gt; nums=Arrays.asList(1,2,3,4); List&lt;Integer&gt; squareNums=nums.stream() .map(n -&gt; n*n) .collect(Collectors.toList()); System.out.println(squareNums); flapMap() //flatMap把Stream中的层级结构扁平化，直接将最底层元素抽取出来构成Stream Stream&lt;List&lt;Integer&gt;&gt; inputStream=Stream.of(Arrays.asList(1), Arrays.asList(2,3), Arrays.asList(4,5,6)); Stream&lt;Integer&gt; outputStream=inputStream.flatMap(midList -&gt; midList.stream()); List&lt;Integer&gt; list2=outputStream.collect(Collectors.toList()); //Stream不能直接打印，打印出来是一串看不懂的类标志 System.out.println(list2); //[1, 2, 3, 4, 5, 6] peek() List&lt;String&gt;list=Stream.of(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;).filter(e -&gt; e.length()&gt;3).peek(e -&gt; System.out.println(&quot;Filter value:&quot;+e)) .map(String::toUpperCase).peek(e -&gt; System.out.println(&quot;Mapped value:&quot;+e)) .collect(Collectors.toList()); //一定要转换成List才会打印内容出来 reduce():有起始值的话一定返回确定的类型，否则可能由于元素不够而判断不出类型返回Optional //字符串连接 String concat=Stream.of(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;).reduce(&quot;&quot;,String::concat); //ABCD //求最小值 double min=Stream.of(-1.5,1.0,-3.0,-2.0).reduce(Double.MAX_VALUE,Double::min); //-3.0 //求和 int sum=Stream.of(1,2,3,4).reduce(0,Integer::sum); //10 //过滤+字符串连接 concat=Stream.of(&quot;a&quot;,&quot;B&quot;,&quot;c&quot;,&quot;D&quot;,&quot;e&quot;,&quot;f&quot;).filter(x -&gt; x.compareTo(&quot;Z&quot;)&gt;0) .reduce(&quot;&quot;,String::concat); limit()&amp;skip() //Person类 class Person{ public int no; //序号 private String name; public Person(int no, String name) { this.no = no; this.name = name; } //注意：getName方法有打印操作 public String getName(){ System.out.println(name); return name; } } //塞数据 List&lt;Person&gt; persons=new ArrayList&lt;&gt;(); for (int i=0;i&lt;11;i++){ //塞11个 Person person=new FormulaImpl().new Person(i,&quot;name&quot;+i); persons.add(person); } //调用方法 List&lt;String&gt; personList=persons.stream() .map(Person::getName) .limit(10) //map管道被限制到只打印前10个 .skip(3) //personList先被限制到前十又被跳过前三 .collect(Collectors.toList()); //第一次打印：输出0~10 //第二次打印 System.out.println(personList); //输出3~10 limit()&amp;skip()对sorted()无作用 List&lt;Person&gt; persons=new ArrayList&lt;&gt;(); for (int i=0;i&lt;5;i++){ Person person=new FormulaImpl().new Person(i,&quot;name&quot;+i); persons.add(person); } List&lt;Person&gt; personList=persons.stream() .sorted((p1,p2) -&gt; p1.getName().compareTo(p2.getName())) //不受限制，打印5个 .limit(2) .collect(Collectors.toList()); System.out.println(personList); //输出2个 打印结果： name1 name0 name2 name1 name3 name2 name4 name3 [com.java1234.tool.FormulaImpl$Person@18769467, com.java1234.tool.FormulaImpl$Person@46ee7fe8] 上面的打印结果说明sorted的底层是两个两个元素拿出来比较的 max()&amp;min() //找出最长一行的长度 BufferedReader br = new BufferedReader(new FileReader(&quot;c:\\\\SUService.log&quot;)); int longest = br.lines(). //br.lines()得到的是一个Stream对象 mapToInt(String::length). max(). getAsInt(); br.close(); distinct() //找出全文的单词，转小写，去重，并排序 BufferedReader br=new BufferedReader(new FileReader(&quot;d:\\\\test.txt&quot;)); List&lt;String&gt; words=br.lines().flatMap(line -&gt; Stream.of(line.split(&quot; &quot;))) .filter(word -&gt; word.length()&gt;0) .map(String::toLowerCase) .distinct() .sorted() .collect(Collectors.toList()); br.close(); allMatch()&amp;anyMatch()&amp;noneMatch():Stream中全部、任一、无一元素符合传入的Predicate，返回true 在Person类中加个年龄属性和获取年龄的方法，做以下测试 List&lt;Person&gt; persons = new ArrayList(); persons.add(new Person(1, &quot;name&quot; + 1, 10)); persons.add(new Person(2, &quot;name&quot; + 2, 21)); persons.add(new Person(3, &quot;name&quot; + 3, 34)); persons.add(new Person(4, &quot;name&quot; + 4, 6)); persons.add(new Person(5, &quot;name&quot; + 5, 55)); boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18); //false boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12); //true count()：计数，返回Stream中元素的个数，返回值类型是long；是一个最终操作 long startsWithB = stringCollection.stream() .filter((s) -&gt; s.startsWith(&quot;b&quot;)) .count(); 并行Stream Stream有串行和并行两种，串行是在一个线程中依次完成，而并行则是在多个线程上同时执行，可提高效率。 下面我们来创建一个无重复的大容量List int max=1000000; List&lt;String&gt; list=new ArrayList&lt;&gt;(max); for (int i=0;i&lt;max;i++){ UUID uuid=UUID.randomUUID(); list.add(uuid.toString()); } 串行排序 long t0=System.nanoTime(); list.stream().sorted(); long t1=System.nanoTime(); long millis=TimeUnit.NANOSECONDS.toMillis(t1-t0); System.out.println(String.format(&quot;Sequential sort took: %d ms&quot;,millis)); //899mx 并行排序，效率提高一倍 t0=System.nanoTime(); list.parallelStream().sorted(); t1=System.nanoTime(); millis=TimeUnit.NANOSECONDS.toMillis(t1-t0); System.out.println(String.format(&quot;Parallel sort took: %d ms&quot;,millis)); //472ms 参考文章","categories":[],"tags":[]},{"title":"","slug":"Java8 Map新方法","date":"2019-04-30T08:25:45.085Z","updated":"2018-10-02T03:54:36.878Z","comments":true,"path":"2019/04/30/Java8 Map新方法/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java8 Map新方法/","excerpt":"","text":"putIfAbsent(key,value):不存在则添加键值对 forEach((key,value) -&gt; System.out.println(key+value)):接收一个Consumer来遍历键值对 以下列举了其他有用的方法： map.computeIfPresent(3,(num,val) -&gt; val+num); //传入key和操作，其中num=3,val=val3 map.get(3); //val33 map.computeIfPresent(9,(num,val) -&gt; null); map.containsKey(9); //false map.computeIfAbsent(23,num -&gt; &quot;val&quot;+num); //没有23key元素的 map.containsKey(23); //true //修改值 map.merge(9,&quot;concat&quot;,(value,newValue) -&gt; value.concat(newValue)); //key不存在则生成新键值对，否则连接 map.get(9); //val9concat remove(key,value):删除元素 getOrDefault(key,defaultValue):找不到就返回指定的默认值","categories":[],"tags":[]},{"title":"","slug":"Java web","date":"2019-04-30T08:25:45.081Z","updated":"2018-04-16T15:50:53.538Z","comments":true,"path":"2019/04/30/Java web/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java web/","excerpt":"","text":"WEB-INF无法用tomcat打开的 使用eclipse写Java web的话必须先关闭tomcat否则报错","categories":[],"tags":[]},{"title":"","slug":"Java URI、URL类","date":"2019-04-30T08:25:45.076Z","updated":"2018-11-10T07:54:19.249Z","comments":true,"path":"2019/04/30/Java URI、URL类/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java URI、URL类/","excerpt":"","text":"简介 URI：Uniform Resource Identifier，统一资源标识符，URI的范畴位于顶层，URL和URN只是子范畴。 URL： Uniform Resource Locator，代表资源的地址信息 URN：Uniform Resource Name，代表某个资源独一无二的名称。 对于程序员来说，URI和URL都是一个意思。 它们的主要格式为：一串以scheme开头的字符串，语法如下： [scheme:] scheme-specific-part //&lt;协议&gt;:&lt;特定协议部分&gt; //特定协议部分的格式 //&lt;用户&gt;:&lt;密码&gt;@&lt;主机&gt;:&lt;端口号&gt;/&lt;路径&gt; 举个栗子 若主机名为openhome.cc，要获取Gossip中的index.html,端口号是8080.则必须使用以下URL： http://openhome.cc:8080/Gossip/index.html 又假设想获取本地计算机文件系统中C://workspace下的jdbc.pdf，则为： file://C://workspace/jsbc.pdf 协议指定了以何种方式获取资源。一些协议名的例子： ftp(File Transfer Protocol)文件传输协议 http(Hypertext Tranfer Protocol)超文本传输协议 mailto 电子邮件 file 特定主机文件名 相对URL如：articles/articels.html，是依赖于标识符出现的环境而言的。用法 URI类只能解析路径，不包含任何用于访问资源的方法。 URL类则可以打开一个到达资源的流，访问资源。 用String构建URI对象 URI uri=new URI(&quot;http://www.cnn.com&quot;); //URI会把String分解为组件存于各个属性中，String不合法则抛URISyntaxException异常 //效果同上 URI uri=URI.create(&quot;http://www.cnn.com&quot;); URL类：可以用URI的toURL()获取URL对象，也可以直接new URL url=new URL(&quot;http://www.cnn.com&quot;); openstream()：获取流，读取资源 URL url = new URL (args [0]); InputStream is = url.openStream (); int ch; while ((ch = is.read ()) != -1) { System.out.print ((char) ch); } 如果是html形式的文本，则打印： &lt;html&gt; … &lt;/html&gt; getContent()：返回资源对应的对象，调用instanceof方法检查是否为预期对象之后可以针对性地采用处理流来读取资源 URL url = new URL (args [0]); Object o = url.getContent (); if (o instanceof ImageProducer) { //如果资源是JPEG资源的话，获取到的对象应该实现了ImageProducer接口 ImageProducer ip = (ImageProducer) o; // ... } openConnection()：返回URLConnection对象，封装了与资源连接的信息，有点像发起了一个请求，连接到资源后得到了响应。 public static void main (String[] args) throws IOException { URL url = new URL (&quot;http://www.javajeff.com&quot;); //http://www.javajeff.com // 返回代表某个资源的连接的新的特定协议对象的引用 URLConnection uc = url.openConnection (); // 进行连接 uc.connect (); // 打印header的内容 Map m = uc.getHeaderFields (); //获取header报头中的键值对 Iterator i = m.entrySet ().iterator (); while (i.hasNext ()) { System.out.println (i.next()); //自动按键=值的形式输出 } // 检查是否资源允许输入和输出操作 System.out.println (&quot;Input allowed = &quot; +uc.getDoInput ()); System.out.println (&quot;Output allowed = &quot; +uc.getDoOutput ()); } 打印 Date=[Sun, 17 Feb 2002 17:49:32 GMT] Connection=[Keep-Alive] Content-Type=[text/html; charset=iso-8859-1] Accept-Ranges=[bytes] Content-Length=[7214] null=[HTTP/1.1 200 OK] ETag=[&quot;4470e-1c2e-3bf29d5a&quot;] Keep-Alive=[timeout=15, max=100] Server=[Apache/1.3.19 (Unix) Debian/GNU] Last-Modified=[Wed, 14 Nov 2001 16:35:38 GMT] Input allowed = true Output allowed = false 其中ContentType和input/output allowed比较有用 可以用java代码而不是form表单向url提交请求，数据必须是键值对形式，而且按照编码规则来 String result = URLEncoder.encode (&quot;a b&quot;); //将把空格转换为+号 把数据发送给某个资源 class URLDemo3 { public static void main (String [] args) throws IOException { URL url = new URL(&quot;http://banshee.cs.uow.edu.au:2000/~nabg/echo.cgi&quot;); URLConnection uc = url.openConnection (); // 验证连接的类型，必须是HttpURLConnection的 if (!(uc instanceof HttpURLConnection)) { System.err.println (&quot;Wrong connection type&quot;); return; } //默认不支持发送数据，这里改为支持 uc.setDoOutput (true); // 不使用cache uc.setUseCaches (false); //设置Content-Type指示指定MIME类型 uc.setRequestProperty (&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //单纯键值对的话就必须是这种类型 // 建立名/值对内容发送给服务器 String content = buildContent (args); //设置Content-Length uc.setRequestProperty (&quot;Content-Length&quot;, &quot;&quot; + content.length ()); // 连接的适当类型 HttpURLConnection hc = (HttpURLConnection) uc; // 把HTTP请求方法设置为POST（默认的是GET） hc.setRequestMethod (&quot;POST&quot;); // 输出内容 OutputStream os = uc.getOutputStream (); DataOutputStream dos = new DataOutputStream (os); dos.writeBytes (content); dos.flush (); dos.close (); // 从服务器程序资源输入和显示内容 InputStream is = uc.getInputStream (); int ch; while ((ch = is.read ()) != -1) System.out.print ((char) ch); is.close (); } static String buildContent (String [] args) { //参数：name value name value name value StringBuffer sb = new StringBuffer (); for (int i = 0; i &lt; args.length; i++) { // 对参数编码 String encodedItem = URLEncoder.encode (args [i]); sb.append (encodedItem); if (i % 2 == 0) sb.append (&quot;=&quot;); // 分离名称和值 else sb.append (&quot;&amp;&quot;); // 分离名称/值对 } // 删除最后的 &amp; 间隔符 sb.setLength (sb.length () - 1); return sb.toString (); } } 输出 &lt;html&gt; &lt;head&gt; &lt;title&gt;Echoing your name value pairs&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ol&gt; &lt;li&gt;name1 : value1 &lt;li&gt;name2 : value2 &lt;li&gt;name3 : value3 &lt;/ol&gt; &lt;hr&gt; Mon Feb 18 08:58:45 2002 &lt;/body&gt; &lt;/html&gt; URI的作用之一：解析标识符并将它分解为各种不同的部分，可以用一下方法读取各个部分： getScheme getSchemeSpecificPart getAuthority getUserInfo getHost getPort getPath getQuery getFragment 另一个作用：处理绝对标识符和相对标识符","categories":[],"tags":[]},{"title":"","slug":"Java assert断言","date":"2019-04-30T08:25:45.072Z","updated":"2018-10-23T11:46:14.672Z","comments":true,"path":"2019/04/30/Java assert断言/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java assert断言/","excerpt":"","text":"格式 assert+返回boolean的语句、方法 如果boolean为true，程序继续执行，否则抛出AssertionError(继承于Error而非Exception，表达系统级运行错误)，终止程序。 因此assert可以定位bug assert+boolean:message 冒号后面跟着一个提示信息，断言失败后将被打印 举例： assert false; assert s!=null?true:false; assert StringUtil.isNull(str):&quot;str为null！&quot;; 正常发布的代码中断言是无效的，因此不能把功能代码放在断言中使用 assert比较多使用于Junit测试中","categories":[],"tags":[]},{"title":"","slug":"Java Annotation注解","date":"2019-04-30T08:25:45.067Z","updated":"2019-03-23T09:22:35.697Z","comments":true,"path":"2019/04/30/Java Annotation注解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Java Annotation注解/","excerpt":"","text":"简介 annotation是Java5引入的新特征，它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）关联。 通俗来讲，就是为程序的元素加上更直观明了的说明，这些说明信息是与程序的业务逻辑无关，提供给指定的工具或框架使用的。 annotation实际是一种接口，通过Java反射机制来访问annotation信息，并根据这些信息来决定如何使用被注解的程序元素或改变其行为。 annotation类型使用关键字@interface定义，表示继承了java.lang.annotation.Annotation接口，并声明它也是一个接口。 annotation与接口相似，可以定义常量、静态成员类型（如枚举类）。 annotation类型的方法必须是、声明为无参数、无异常抛出的。 成员方法即为成员属性，方法名为属性名，方法返回值为属性类型。 方法返回值类型必须为primitive类型、Class类型、枚举类型、annotation类型或由这些类型之一作为元素的数组。方法后面可以使用default和一个默认值来声明成员的默认值（null除外）。 元注解 作用：注解其他注解。 Java5定义了4个标准的meta-annotation类型，用于对其他annotation作说明。 @Target @Retention @Documented @Inherited @Target 说明了Annotation所修饰的对象范围，也即是注解的使用范围。annotation可悲用于packages、types（类、接口、枚举、annotation类型）、类型成员（方法、属性、枚举值）、方法参数和本地变量（如循环变量、catch参数），使用target可明确其修饰的目标。 取值（ElementType）： CONSTRUCTOR：注解在构造器上。 FIELD：成员属性。 LOCAL_VARIABLE：局部变量。 METHOD：方法。 PACKAGE：包。 PARAMETER：参数。 TYPE：type。 实例： //数据表名注解 @Target(ElementType.TYPE) public @interface Table { /** * 表名，默认值为被注解类名 * @return */ public String tableName() default &quot;className&quot;; } //不映射字段注解 @Target(ElementType.FIELD) public @interface NoDBColumn { } @Retention 作用：定义了注解被保留的时间长短。某些注解只出现在源代码中，不被编译，一些则被编译到class文件中，但它们可能会被虚拟机忽略，另一些则在加载Class时被读取。使用此元注解可对注解的生命周期进行限制，指明需要在什么级别保存该注解。 取值（RetentionPolicy）： SOURCE: 在源文件中有效（即保留在源文件） CLASS：在class文件中有效。 RUNTIME：在运行时有效。 实例： @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface Column { public String name() default &quot;fieldName&quot;; public String setFuncName() default &quot;setField&quot;; public String getFuncName() default &quot;getField&quot;; public boolean defaultDBValue() default false; } RetentionPolicy取值为RUNTIME，这样注解处理器可以通过反射，获取该注解的属性值，从而去做一些运行时的逻辑处理。 @Documented 作用：使annotation被javadoc类的工具文档化。 没有取值可选，直接加在annotation上即可。 @Inherited 作用：表示被annotation注解的类其子类也继承了此annotation，但实现了带此annotation的接口的实现类并不会继承该annotation，方法也不会从它重载的方法继承annotation。 无取值可选。 自定义注解 使用@interface自定义注解，注意不能继承其他的注解或接口。 其中的每一个方法实际上是声明了一个配置参数，方法的名称就是参数的名称，返回值类型就是参数类型。 annotation里面的参数要求： 只能用public或default修饰，如String value()即为default。 类型只能是基本数据类型、String、Enum、Class、Annotation和它们之一的数组。 如果只有一个参数成员，最好命名为value，则可以直接注入值。 实例： /** * 水果名称注解 * @author wangsheng * */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FruitName { String value() default &quot;&quot;; } /** * 水果颜色注解 * @author peida * */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FruitColor { //颜色枚举 public enum Color{BULE,RED,GREEN}; //颜色属性 Color fruitColor() default Color.GREEN; } //使用注解 public class Apple { @FruitName(&quot;Apple&quot;) //直接注入值而不用指明属性 private String appleName; @FruitColor(fruitColor=Color.RED) private String appleColor; } 非基本类型的注解属性的值不可为null，因此，使用空字符串和0作为默认值是一种常用的做法。也正是因为不能为null，处理器很难判断一个属性是否缺失，所以我们只能定义一些特殊的默认值，例如空字符串或负数来表示某个属性不存在。 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface FruitProvider { /** * 供应商编号 * @return */ public int id() default -1; /** * 供应商名称 * @return */ public String name() default &quot;&quot;; } 实例：最后还模拟了一下反射机制对注解的解析。 /** * 定义作者信息的注解，name和group */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Documented public @interface Author { String name(); String group(); } /** * 定义描述信息的注解，value */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Documented public @interface Description { String value(); } /** * 使用注解 */ @Description(value=&quot;这是一个有用的工具类&quot;) // value可以省略 public class Utility { @Author(name=&quot;wangsheng&quot;, group=&quot;developer team&quot;) public String work() { return &quot;work over!&quot;; } } /** *在运行时分析处理annotation类型的信息 */ public class AnalysisAnnotation { public static void main(String[] args) { try { // 通过运行时反射API获得annotation信息 Class&lt;?&gt; rtClass = Class.forName(&quot;com.wsheng.aggregator.annotation.Utility&quot;); Method[] methods = rtClass.getMethods(); //判断Description注解是否存在 boolean descriptionExist = rtClass.isAnnotationPresent(Description.class); if (descriptionExist) { //从类中获取注解Description Description description = (Description)rtClass.getAnnotation(Description.class); //Utility&apos;s Description --- &gt; 这是一个有用的工具类 System.out.println(&quot;Utility&apos;s Description --- &gt; &quot; + description.value()); //从方法中获取Author注解 for (Method method : methods) { if (method.isAnnotationPresent(Author.class)) { Author author = (Author)method.getAnnotation(Author.class); //Utility&apos;s Author ---&gt; wangsheng from developer team System.out.println(&quot;Utility&apos;s Author ---&gt; &quot; + author.name() + &quot; from &quot; + author.group()); } } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 自定义的注解使用其他已定义注解 有的时候要在自定义的注解上使用其他定义好的注解，比如： @Caching( put = { @CachePut(value = &quot;user&quot;, key = &quot;#user.id&quot;), @CachePut(value = &quot;user&quot;, key = &quot;#user.username&quot;), @CachePut(value = &quot;user&quot;, key = &quot;#user.email&quot;) } ) @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface UserSaveCache { } 把要用的注解取好值加在自定义注解上，然后这个自定义注解加在方法上自然就会拥有@Caching的功能，不过属性就不能改了。 详见笔记：Spring Cache 参考文章","categories":[],"tags":[]},{"title":"","slug":"IO流","date":"2019-04-30T08:25:45.050Z","updated":"2019-04-02T08:43:08.913Z","comments":true,"path":"2019/04/30/IO流/","link":"","permalink":"http://47.107.237.149/2019/04/30/IO流/","excerpt":"","text":"概念 流：从一端移动到另一端，有源头与目的地。源头即数据源：文件、数组、数据库、网络连接目的地：程序分类 按流向：输入流与输出流 按处理数据：字节类：二进制，可以处理一切文件（纯文 本、doc、音频、视频等）字符流：文本文件，只能处理纯文本(.txt、.htm、.java) 按功能分类：1. 节点流（最接近源头的；以下都是四个（不包括括号的话）都是抽象类，不可以new对象）：包裹源头 字节流的节点流:(File)InputStream、(File)OutputStream InputStream类是所有字节输入流的父类 - OutputStream类是所有字节输出流的父类 字符流的节点流：(File)Reader、(File)Writer Reader类是所有字节输出流的父类 - Writer类是所有字节输出流的父类 2. 处理流（提高性能）： （1）缓冲流（带缓冲区的输入输出流，减少访问磁盘次数，速度更快），是io处理大文件一般要用到的： 字节缓冲流：BufferedInputStream、BufferedOutputStream； 字符缓冲流：BufferedReader、BufferedWriter 缓冲思想 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多。这是加入了数组这样的缓冲区效果。java本身在设计的时候，也考虑到了这样的设计思想，所以提供了字节缓冲区流 比如BufferedInputStream BufferedInputStream内置了一个缓冲区(数组)，BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 并返回给程序。程序再次读取时, 就不用找文件了, 直接从缓冲区中获取。直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个。 比如BufferedOutputStream BufferedOutputStream也内置了一个缓冲区(数组)，程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中。直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里 用缓冲流拷贝文件 public class FileTest { public static void main(String[] args) throws Exception{ FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;); BufferedInputStream bis=new BufferedInputStream(fis); //使用装饰模式，把fis装饰进去bis中。使用缓冲读取速度变快 BufferedOutputStream bos=new BufferedOutputStream(fos); int b; //如果自定义了缓冲数组并传入的话就会用自定义的 while((b=bis.read())!=-1){ //数目随机地读到内置缓冲数组中，即使是很小的文本也要跑十几遍循环，一次几十~100个字节地读 bos.write(b); } bis.close(); bos.close(); } } （2）转换流：字节流转为字符流（处理乱码 编码集与解码集之间的关系）（要知道字节流的编码集才能解回来）读字节文件的基本操作流程 建立联系（封装File对象） 选择流 操作：用缓冲数组多次读取 -&gt; byte[] car = new byte10+read+循环读取 关闭资源 public static void main(String[] args) { //1.建立联系 File src = new File(&quot;e:/xp/test/a.txt&quot;); //读取纯文本，应该会出现乱码，因为是用字节流来读取的，无妨，真实操作下文件应该是从源文件到目标文件的，像这样中途打印出来的不是主要目标 //2.选择流 InputStream is = null; //3.操作 byte[] car = new byte[10]; //定长一点中文乱码概率小一点 int len = 0;//实际读取长度（最后一次可能不到10个） try { is = new BufferedInputStream(new FileInputStream(src)); //循环读取 while(-1 != (len = is.read(car))) { //read(byte[] car)方法，将文件分批读入字节数组，返回实际读取个数，最后一次读取后，再读取一次并返回-1;除了最后一次，每次都是准确10个字节 //字节数组转字符串 String info = new String(car,0,len); //从car数组第0个开始读取并转换len长度个字节 System.out.print(info); //要想恢复文件原样就不要用println } } catch (FileNotFoundException e) { e.printStackTrace(); System.out.println(&quot;文件不存在&quot;); } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;读取文件失败&quot;); }finally { //4.释放资源 if(null != is) { //占了资源才需要释放 try { is.close(); //close()实际就是释放is的内存资源，相当于断开引用 } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;释放资源失败&quot;); } } } } 写字节文件的基本操作流程 建立联系：将目的地封装成File对象 选择流： OutputStream-&gt;FileOutputStream 操作：write()(方法而非Write字符输出流)+flush 关闭资源 public static void main(String[] args) { //1.建立联系 File dest = new File(&quot;e:/xp/test/a.txt&quot;); OutputStream os = null; try { //2.选择流（追加一层缓冲流提高性能） os = new BufferedOutputStream(new FileOutputStream(dest,true)); //true表示目标文件已有内容时追加，默认为false覆盖 //3.写出 String car = &quot;DuDu i love you!\\r\\n&quot;;//写出内容 byte[] car2 = car.getBytes();//转为字节数组才能写入文件 os.write(car2, 0, car2.length); //从0位写出car2.length位出去 os.flush();//强制刷出，否则最后一次不满可能会残留在流中 } catch (FileNotFoundException e) { e.printStackTrace(); System.out.println(&quot;文件不存在&quot;); } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;写入文件失败&quot;) }finally { //4.释放引用的内存 if(null != os) { try { os.close(); //实际上执行close方法也会先flush刷出 } catch (IOException e) { e.printStackTrace(); System.out.println(&quot;关闭资源失败&quot;) } } } } 拷贝文件（读+写） public static void main(String[] args) throws Exception{ //1,建立联系 File src=new File(&quot;E:/xp/test/1.jpg&quot;); File dest=new File(&quot;E:/xp/test/100.jpg&quot;); //2.选择流 InputStream is=new FileInputStream(src); OutputStream os=new FileOutputStream(dest); //3.文件拷贝（循环读取+写出） byte[] flush=new byte[1024]; int len=0; while(-1!=(len=is.read(flush))) { //读取 os.write(flush, 0, len); //写出 } os.flush(); //4.关闭资源(先开的后关） os.close(); is.close(); } 读字符文件的基本操作流程 建立联系（封装File对象） 选择流 操作：用缓冲数组多次读取 -&gt; char[] flush = new char[20]+read+循环读取 关闭资源 public static void main(String[] args) { //1.建立联系 File src = new File(&quot;e:/xp/test/test.txt&quot;); //2.选择流 Reader reader = null; char[] flush = new char[20]; int len = 0; try { reader = new FileReader(src); //3.操作 while(-1!=(len=reader.read(flush))) { //这一步报编码错误可能是文本不是用notepad写的 /* 可以这样打印 （不过println自己会断行，再加上原文也有换行符，所以断行可能会乱）*/ //String flush1 = new String(flush,0,len); //字符数组转字符串 //System.out.println(flush1); /* 也可以这样 */ for(int i=0;i&lt;len;i++) { System.out.print(flush[i]); //遇到换行符自动换行，断行不会乱 } } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { //4.关闭资源 if(null!=reader) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } } } 写字符文件的基本操作流程 建立联系：将目的地封装成File对象 选择流： Writer-&gt;FileWriter 操作：write()/append()+flush 关闭资源 public static void main(String[] args) { File dest = new File(&quot;e:/xp/test/test1.txt&quot;); Writer wr = null; String car = &quot;PigPig i love you!\\r\\n&quot;; try { wr = new FileWriter(dest,true);//true则文件已有内容时追加 wr.write(car); wr.append(&quot;PigPig love me,too\\r\\n&quot;);//同write() wr.flush(); } catch(FileNotFoundException e) { e.printStackTrace(); }catch (IOException e) { e.printStackTrace(); }finally { if(null!=wr) { try { wr.close(); } catch (IOException e) { e.printStackTrace(); } } } } 其他流一、 节点流 字节数组节点流：流的来源或目的地不一定是文件，也可以是内存中的一块空间，例如一个字节数组。字节数组节点流就是将数组当作输入来源、输出目的地的类。这种流用于支持内存虚拟文件或内存映像文件创建，对于要创建临时文件的程序以及网络数据的传输、数据压缩后的传输等都可以提高效率，避免访问磁盘。输入流（以io流的方式读取字节数组）：ByteArrayInputStream read(byte[] b,int off,int len)+close输出流（以io流的方式写入字节数组）：ByteArrayOutputStream write(byte[] b,int off,int len)+toByteArray()（新增方法，把文件写入到字节数组里，不能使用多态）操作：文件到字节数组（内存） 目的地 byte[] dest = null; 选择流 将文件包装成输入流&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;开辟字节数组输出流bos 读取 边读到自定义字节数组作为缓冲 new byte[1024]&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;边写入字节数组输出流 强制刷出 获取数据 dest = bos.toByteArray() 释放资源 读字节数组 public void readByteArray() throws IOException { /** * 准备字节数组：把这个想象成是我们要从服务器上读取的内容 * 那为什么服务器不直接把这句话传给我们我们直接打印不就好了吗？ * 因为直接传字符串涉及到编码问题，所以中间的传输部分还是用字节数组来的准确 */ String meg=&quot;操作与文件输入流一致&quot;; byte[] src=meg.getBytes(); /** * 选择流 * ByteArrayInputStream: 把字节数组包装成输入流 * BufferedInputStream：再加个缓冲区调优 * 这里不会抛异常（FileNotFoundException之类），不是跟外部资源建立联系就不会抛异常 */ InputStream is=new BufferedInputStream(new ByteArrayInputStream(src)); //缓冲数组 byte[] flush=new byte[1024]; int len=0; while((len=is.read(flush))!=-1){ System.out.println(new String(flush,0,len)); } //释不释放资源都无所谓了 } 写字节数组 public byte[] writeToByteArray(){ //准备字节数组 String msg=&quot;操作与文件输出流不一致&quot;; byte[] info=msg.getBytes(); //目的地 byte[] dest; //不知道多大，先搁着 ByteArrayOutputStream bos=new ByteArrayOutputStream(); //不能直接把字节数组dest丢进来；不要使用多态，因为等下要使用新增方法toByteArray() //写入 bos.write(info,0,info.length); //只是写到了管道里，没有写到目标字节数组中 dest=bos.toByteArray(); return dest; } 拷贝文件 /** * 利用字节数组为桥梁实现文件拷贝（任意文件形式均可） * 1、文件（文件）-&gt;字节数组（其实也是文件） * 文件输入流 * 字节数组输出流 * 2、字节数组-&gt;文件 * 字节数组输入流 * 文件输出流 * @author 14103 */ public class ByteArrayDemo02 { public static void main(String[] args) throws IOException { byte[] dest = getBytesFromFile(&quot;e:/xp/test/CalendarTest.java&quot;); toFileFromByteArray(dest,&quot;e:/xp/test/test3.java&quot;); } /** * 1、文件-&gt;字节数组 * 文件输入流 * 字节数组输出流 * @param srcPath * @return * @throws IOException */ public static byte[] getBytesFromFile(String srcPath) throws IOException { //数据源 File src = new File(srcPath); //目的地 byte[] dest = null; //选择流 InputStream is = new BufferedInputStream(new FileInputStream(src));/ ByteArrayOutputStream bos = new ByteArrayOutputStream();//ByteArrayOutputStream是没有包装对象的，因为根本就不能通过它直接写入字节数组（内存） //缓冲数组 byte[] flush = new byte[1024]; int len = 0; while(-1!=(len=is.read(flush))) { //写入通道 bos.write(flush,0,len); } bos.flush(); //写入字节数组 dest = bos.toByteArray(); //可以不关，因为操作的是内存，会自动关闭，执行close实际是无效的 bos.close(); return dest; } /** * 2、字节数组（内存）-&gt;文件 * 字节数组输入流 * 文件输出流 * @param src * @throws IOException */ public static void toFileFromByteArray(byte[] src,String destPath) throws IOException { //目的地 File dest = new File(destPath); //选择流 InputStream is = new BufferedInputStream(new ByteArrayInputStream(src)); //把字节数组包装成流 OutputStream os = new BufferedOutputStream(new FileOutputStream(dest)); byte[] flush = new byte[1024]; int len = 0; //这里不能直接写os.write(src,0,src.length)，因为通常都是另一台计算机上的内存传进来，比较大 while(-1!=(len=is.read(flush))) { os.write(flush, 0, len); } //强制刷出 os.flush(); //释放资源 os.close(); } } 有的时候我们需要对同一个InputStream对象使用多次，比如，客户端从服务器获取数据，利用HttpURLConnection的getInputStream()方法获得Stream对象，我们希望把数据显示到前台（第一次读取），同时写进文件缓存到本地。 然而第一次读取后，已经走到Stream的结尾或者Stream已经关闭了，此时我们可以把InputStream转化成ByteArrayOutputStream，下次再从ByteArrayOutputStream转化回来就好 public void byteArrayStreamApp() throws IOException { //目的地 byte[] dest=null; //源 InputStream is=httpconn.getInputStream(); ByteArrayOutputStream bos=new ByteArrayOutputStream(); byte[] buffer=new byte[1024]; int len; while((len=is.read(buffer))!=-1){ bos.write(buffer,0,len); } bos.flush(); dest=bos.toByteArray(); //第一次访问 InputStream is1=new ByteArrayInputStream(dest); //do something to print the stream... //第二次访问 InputStream is2=new ByteArrayInputStream(dest); //do something to save in local... } 二、处理流 数据类型处理流 处理基本类型+String（能保留数据及其类型）输入流：DataInputStream readXxx()输出流：DataOutputsStream writeXxx() 引用类型（对象）处理流（保留数据+类型）序列化 输入流：ObjectInputStream readObject()反序列化 输出流：ObjectOutputStream writeObject()注意：先序列化再反序列化；反序列化必须与序列化顺序一致&emsp;&emsp;&emsp;不是所有的对象都可以序列化，java.io.Serializable &emsp;&emsp;&emsp;不是所有的属性都需要序列化，transient 打印流PrintStream 释放资源 手动关 流.close() 写工具类关 close(is,os) 新特性自动关 try/with/resouce 合并流SequenceInputStreamsequence 队列将输入源合并成一个或统一写出操作： 创建容器Vector vi = new Vector(); 装入 for(int i=0;i&lt;this.blockName.size();i++){ bis=new BufferedInputStream(new FileInputStream(new File(blockName.get(i)))); vi.add(bis); } 3.选择流 for(int i=0;i&lt;blockName.size();i++) { sis = new SequenceInputStream(vi.elements());//返回一个元素；有序的、一个一个被返回 ... while(-1!=(len=sis.read(flush))) ... sis.close(); } IOException 文件不存在、文件拒绝访问、读着读着突然被删了","categories":[],"tags":[]},{"title":"","slug":"int型为null问题","date":"2019-04-30T08:25:45.041Z","updated":"2018-09-16T10:13:09.324Z","comments":true,"path":"2019/04/30/int型为null问题/","link":"","permalink":"http://47.107.237.149/2019/04/30/int型为null问题/","excerpt":"","text":"调用jpa框架的findById()可能会出现Null value was assigned to a property of……错误，就是null值被赋予某个属性错误。 经检查，获取到的这条记录由于存在一个int型字段的值为null（主要是插入时该字段为空所以默认设为了null），而基本类型不能被赋值为null(编译器将会报错)。 null既不是对象也不是类型，它仅是一种特殊的值，可以将其赋值给任何引用类型（它们的默认值也都是null），但不能赋值给基本类型（int的默认值为0，boolean的默认值为false）。 Java将值为null的包装类拆箱为基本类型时会抛出空指针异常，如： Integer isNull = null; int i = isNull; //编译时不会报错 因此，数据库中记得要给int型设置默认值为0或不为null，get/set之前也先进行验证：if(i&gt;=0||i!=null);","categories":[],"tags":[]},{"title":"","slug":"idea添加方法注释","date":"2019-04-30T08:25:45.037Z","updated":"2018-07-21T10:02:55.992Z","comments":true,"path":"2019/04/30/idea添加方法注释/","link":"","permalink":"http://47.107.237.149/2019/04/30/idea添加方法注释/","excerpt":"","text":"setting-live template","categories":[],"tags":[]},{"title":"","slug":"idea断点调试","date":"2019-04-30T08:25:45.022Z","updated":"2018-07-29T08:22:55.817Z","comments":true,"path":"2019/04/30/idea断点调试/","link":"","permalink":"http://47.107.237.149/2019/04/30/idea断点调试/","excerpt":"","text":"参考文章跨断点调试 点击下面按钮跳到下一个断点，若没有下一个则直接执行完程序。 单步调试step over 程序向下执行一行（如果当前行有方法调用，这个方法将被执行完毕返回，然后到下一行）step into 程序向下执行一行。如果该行有自定义方法，则运行进入自定义方法force step into 该按钮在调试的时候能进入任何方法(包含java类库)step out 如果在调试的时候你进入了一个方法(如f2())，并觉得该方法没有问题，你就可以使用stepout跳出该方法，返回到该方法被调用处的下一行语句。值得注意的是，该方法已执行完毕。drop frame 点击该按钮后，你将返回到当前方法的调用处重新执行，并且所有上下文变量的值也回到那个时候。只要调用链中还有上级方法，可以跳到其中的任何一个方法。","categories":[],"tags":[]},{"title":"","slug":"idea安装","date":"2019-04-30T08:25:45.020Z","updated":"2018-08-30T11:55:58.426Z","comments":true,"path":"2019/04/30/idea安装/","link":"","permalink":"http://47.107.237.149/2019/04/30/idea安装/","excerpt":"","text":"参考文章","categories":[],"tags":[]},{"title":"","slug":"Idea","date":"2019-04-30T08:25:45.014Z","updated":"2019-04-28T05:53:30.105Z","comments":true,"path":"2019/04/30/Idea/","link":"","permalink":"http://47.107.237.149/2019/04/30/Idea/","excerpt":"","text":"启用快捷键 启用eclipse的键盘模式 关闭vim编辑模式 control+各种的快捷方式就都回来啦手动导包鼠标停在这个类上，alt+enter导入相应的包抛出异常alt+enter可以选择抛出或try/catch生成代码Alt+Insert代码自动补全输入首字母即可获取完整方法名提示，如，输入psvm提示main方法全名，for循环则是fori,打印是sout移除无用包ctrl+shift+o快捷键汇总添加jar包idea建立maven项目 额先设置吧，不然生成maven骨架贼慢 idea里的project相当于eclipse的workplace，model相当于project 在线翻译选中单词按下快捷键ALT+1 修改主题及字体大小 换背景图：setting-&gt;apperence-&gt;backgroud image工作空间和项目的区别 project相当于工作空间，module相当于项目 不过目前还是先把工作空间当工程来使用吧idea导入maven项目 打开idea点击import project，找到项目目录 部分勾选框选择参见教程显示空的中间包 project那里有一个小齿轮，取消hide……选项，取消flatten packages选项。断点调试 运行到哪个断点，哪一行就是下一步要执行的以tab形式展示窗口运行项目提示workplace not exist 选择Run下Edit Configuration，将1、2两处重新设置一遍即可 自动注释 ctrl+/：多行代码分行，取消也是这个快捷键 ctrl+shift+/：多行代码注释在一个块里，取消也是这个快捷键格式化代码 Ctrl+Alt+L添加jar包 点击project structure 选择左侧的modules 选择dependencies 点击最右侧的加号，选择jars… 在弹出的目录里选择自己的jar包即可idea发布maven项目使子项目可以互相引用 点击view-&gt;Tool windows-&gt;maven projects 选中子项目的lifecycle下的install，点击三角形运行 然后就可以在另一个子项目中引入该项目的依赖了xml中一些url是红色的、找不到 未注册，要把这些url给注册了,这样才可以不联网就获取到 Ctrl+shift+s，按照下面1、2、3步点击把url加进去就对了 idea执行maven命令控制台日志乱码 settings-&gt;maven-&gt;runner-&gt;VMOptions添加如下内容 如果原本就有内容则用空格分开热部署 idea目前的情况是，前端脚本支持热部署，后台代码不行。 创建maven web项目 选择maven-archetype-webapp 填写组织和项目名 Maven home directory选择自己的maven安装令；User settings file选择自己的maven仓库。 一路next，然后finish。 等一会就出项目结构了。 参考文章 类下标变成J 主要时因为根包没有Mark As资源文件夹 参考文章 .iml和.idea文件 .iml是idea自动创建的模块文件，是项目的标识文件，缺少该文件，则idea无法识别项目。用于java应用开发，存储模块开发相关的信息，比如java组件、插件组件和maven组件，还可能存储模块路径信息、依赖信息和别的一些设置。 .idea是idea对module的配置信息。","categories":[],"tags":[]},{"title":"","slug":"http请求与响应、URL编码、域名","date":"2019-04-30T08:25:45.010Z","updated":"2019-04-25T08:01:53.117Z","comments":true,"path":"2019/04/30/http请求与响应、URL编码、域名/","link":"","permalink":"http://47.107.237.149/2019/04/30/http请求与响应、URL编码、域名/","excerpt":"","text":"http请求报文 http请求信息由三部分组成 请求方法 URI协议 http版本 请求头（Request Header） 请求正文 例子： GET /sample.jsp HTTP/1.1 Accept:image/gif.image/jpeg,*/* Accept-Language:zh-cn //客户端所用的语言 Connection:Keep-Alive Host:localhost //主机名 User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) //浏览器版本 Accept-Encoding:gzip,deflate 其中URI：URI为/sample.jsp；URI完整地指定了要访问的网络资源，通常只要给出相对于服务器根目录的相对目录即可，因此以“/”开头。 另外URL：统一资源定位符；&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;？&lt;参数&gt; 其中请求头：请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器的版本、所用的语言、请求正文的长度等。 Accept：客户端可识别的内容类型列表 Content-Type: 标识向服务器发送的数据的格式。格式：type/subtype(;parameter:type). Content-Type:text/html;charset:utf-8 在html页面中可以通过下面的方式指定 这种方式可以指定很多种媒体类型，但是不能指定application/x-www-form-urlencoded和multipart/form-data这两种类型 这种方式可以指定两种类型 Cookie：通知服务器当前页面的域生效中的Cookie 请求正文：get没有请求正文。请求正文与请求头之间是一个空行，请求正文中包含客户端提交的字符串信息 username=jinqiao&amp;password=1234 get、post的选择 get请求纯粹取得资源，例如查询数据库的数据。 post请求可能会影响服务器上的数据或状态，例如增删改。http响应 http响应也由三个部分构成： 状态行 响应头（Response Header） 响应正文 状态行 状态行由协议版本、状态码和相应的状态描述组成，各元素之间以空格分开 HTTP/1.1 200 OK 1xx: 指示信息——表示信息已接收，继续处理 2xx：成功——表示请求已被成功接收、理解并接受 3xx: 重定向 4xx: 客户端错误——请求有语法错误或请求无法实现 5xx: 服务器端错误——服务器未能实现合法的请求 比如： 200：OK，客户端请求成功 400：Bad Request，由于客户端请求有语法错误，不能被服务器所理解 401：Unauthonzed，请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用。 403：Forbidden，服务器接收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。 404：Not Found，请求的资源不存在 500：Internal Server Error，服务器发生不可预期的错误，导致无法完成客户端的请求。 503：Service Unavailable，服务器当前不能够处理客户端的请求，在一段时间后可能会恢复正常。 响应头可能包括： Location响应报头域：当我们在jsp中使用重定向语句的时候，响应报头中就会有Location Server响应报头域：包含了服务器用来处理请求的软件信息，和User-Agent是相对应的。 WWW-Authenticate响应报头域：必须被包含在401响应消息中。当客户端收到401响应消息，就要决定是否请求服务器对其进行验证。如果要求服务器对其进行验证，就可以发送一个包含了Authorization报头域的请求，小面是WWW-Authenticate响应报头域的一个例子：可知服务器对我们所请求的资源采用的是基本验证机制。 WWW-Authenticate: Basic realm=&quot;Basic Auth Test!&quot; Content-Encoding实体报头域：媒体类型的修饰符，它的值指示了被应用到实体正文的附加内容编码，因为要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制 Content-Type：gzip Content-Type实体报头域：指明发送给接收者的实体正文的媒体类型。 Content-Type: text/html;charset=ISO-8859-1 Expires实体报头域：响应过期的日期和时间。通常，代理服务器或浏览器会缓存一些页面，当用户档次访问这些页面时，直接从缓存中加载并显示给用户，这样缩短了响应时间，减少服务器的负载。为了让代理服务器或浏览器在一段时间后更新页面，我们可以使用Expires指定页面过期的时间。当用户又一次访问页面时，如果Expires给出的日期比Date普通报头域给出的日期要早或相同的话，那么代理服务器或浏览器就不会再使用缓存的页面而是从服务器上请求更新的页面。HTTP1.1的客户端和缓存必须将除RFC 1123之外的日期格式和0看做已过期。例如，为了让浏览器不要缓存页面，我们设置Expires设置为0：response.setDateHeader(“Expires”,0); Cache-Control实体报头域：指定请求和相应遵循的缓存机制。请求时的缓存指令包括：no-cache,no-store,max-age,max-stale,min-fresh,only-if-cached;响应时的指令包括: Public指示响应可被任何缓存区缓存。 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。 no-cache指示请求或响应消息不能缓存 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 禁用缓存 response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;); response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; ); //作用与上一句相同，不过通常两者合用 response.setDateHeader(&quot;Expires&quot;, 0); //好像可以单独使用，不过通常也与上两句合用 Set-Cookie：通知客户端保存如下cookie 请求和响应步骤 Cookie Cookie总是保存在客户端中，按在客户端中的位置可以分为： 内存Cookie：由浏览器维护，保存在内存中，浏览器关闭之后就消失，属于非持久Cookie 硬盘Cookie：保存在硬盘中，有一个过期时间，除非用户手动清理或到了过期时间，否则不会被删除，属于持久Cookie 用途：因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式web应用程序的实现。Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。 应用场景：当登录一个网站时，如果用户勾选“下次自动登录”，那么本次登录时，服务器就会发送包含登录凭据（用户名和密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，浏览器会发送该Cookie到服务器，于是不必再输入用户名和密码就让用户登录了。 识别功能：如果在一台计算机中安装多个浏览器，每个浏览器都会以独立的空间存放Cookie。Cookie中不但可以确认用户信息，还包含计算机和浏览器的信息，所以一个用户使用不同的浏览器登录或不同的浏览器登录，都会得到不同的Cookie信息。 一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入set-cookie字段，然后下次再发请求的时候，浏览器会自动将cooker附加在请求的头字段cookie中，服务端就能知道这个用户已经登录过了。 url、域名 uniform resource locator，统一资源定位符，俗称网址。 格式：&lt;&gt;://&lt;ip或域名&gt;:/&lt;路径&gt;,其中，port和路径可以省略，这样的路径映射默认首页，如，https://www.baidu.com/。 域名 Domain Name，网域名称，简称域名，是以文字形式记录的ip地址，理由是好记。 网域名称系统，DNS，用于将域名翻译成ip地址的系统。 一个ip地址可以对应多个域名，但是一个域名只有一个ip地址。 url编码 如果请求参数本身包括“=”等特殊字符怎么办？又或者你想发送的请求参数值时http://openhome.cc这个值呢？假设是get请求，则不能在地址栏上输入 http://openhome.cc/addBookmar.do?url=http://openhome.cc. URI中定义了一些保留字符，如，：/ ？&amp; = @ %等。如果要在请求上表达这些字符，必须在%字符之后以十六进制数值表示方式，来表示该字符的八个位数值。这就是URI规范中的百分比编码，也即是URI编码或URL编码。 例如，字符“:”真正存储时的八位为00111010，必须使用%3A来表示；所以若发送的请求参数值是http://openhome.cc，则必须使用以下格式 http://openhome.cc/addBookmar.do?url=http%3A%2F%2Fopenhome.cc 如果想知道某个字符的URL编码是什么，在Java中可以使用java.net.URLEncoder类的静态方法encode()。；要译码则使用decode() String text=URLEncoder.encode(&quot;http://openhome.cc&quot;, &quot;utf-8&quot;); 不过在URI之前，HTTP也规定了请求中的保留字，这与URI规范有所差别。其中一个就是URI规范空格符为%20，而HTTP规范为“+”，上面java方法产生的字符串，空格的编码就为“+”。 由于中文不在ASCⅡ字符之中，所以不能直接出现在地址栏而应该写其编码。在URI规范的URL编码中，针对的是utf-8编码的八位数。在utf-8编码下，一个中文字符有三个编码。而在HTTP规范下的URL编码，并不限使用utf-8，比如使用big5编码，一个中文的编码为两个。 但其实在浏览器中我们是可以直接输入中文的，这是因为我们输入的中文被浏览器隐式转为编码了，只是表面上显示为中文而已","categories":[],"tags":[]},{"title":"","slug":"https、SSL和TLS，使用KeyTool生成自签名证书","date":"2019-04-30T08:25:45.006Z","updated":"2019-03-08T09:35:18.710Z","comments":true,"path":"2019/04/30/https、SSL和TLS，使用KeyTool生成自签名证书/","link":"","permalink":"http://47.107.237.149/2019/04/30/https、SSL和TLS，使用KeyTool生成自签名证书/","excerpt":"","text":"简介 超文本传输协议HTTP被用于在web浏览器和网站服务器之间传递信息，以明文方式发送内容，如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此不适合传输一些敏感信息。即使post提交的数据放在报体里看不到，但是利用抓包工具还是会被窃取到。 安全套接字层超文本传输协议HTTPS，在HTTP的基础上加入了SSL（Secure Sockets Layer）协议，SSL是基于HTTP之下TCP之上的一个协议层，所以HTTPS是HTTP+SSL/TCP的简称。 ssl依靠证书来验证服务器之间的身份，并为浏览器和服务器之间的通信加密。简单来讲是HTTP的安全版，既保证数据传输的安全，又能确认网站的真实性。 TLS：Transport Layer Security，安全传输层协议，SSL的新版本3.1。 https协议需要到CA（Certificate Authority证书机构）申请证书，一般免费证书较少，因而需要一定费用。 数字证书 目的：起初是为了保证互联网上电子交易及支出的安全性、保密性，在网上建立的一种信任机制。这就不要求买卖双方都必须拥有合法的身份，并且在网上能够被有效无误地验证。 数字证书是一种权威性的电子文档，它提供了一种在Internet上验证您身份的方式，类似于身份证。 由权威机构CA证书授权中心发行，并由该机构负责检验和管理证书。 颁发流程： 首先，用户生成自己的密钥对，并将公钥即部分个人身份信息传送给认证中心。 认证中心核实身份后，将发给用户一个数字证书，即对身份信息和公钥进行数字签名、ca机构本身的数字签名。 用户使用该证书进行相关的各种活动。 原理 （1）客户访问一个需要https的网站，如，https://www.domain.xom。 （2）开始握手，以完成身份验证和密钥交换，此过程采用非对称加密。服务器收到客户端请求后，会将网站的证书信息（包含公钥）传送一份给客户端。这里要特别说一下客户端到底如何校验对方发来的数字证书是否有效： 1. 首先在本地电脑寻找是否有该服务器证书上的ca机构的根证书（本地电脑和浏览器都会内置许多可信的根证书），有则进入下一步，否则弹出警告。 2. 客户端从ca获取公钥，对证书中ca机构本身的数字签名进行解密，因为原本就是用ca自己的私钥加密生成的，所以如果能解密成功就说明该证书是权威的。 3. 然后证书中包含的公钥还要进行一层一层的解密、与ca的比对，最终才能确定证书的真实性。 （3）校验成功后，客户端会生成会话密钥（随机串）并用服务器证书的公钥加密后发送回去。 （4）服务器利用自己的私钥解密出会话密钥，会话密钥交换完毕，握手结束。 （6）客户端和服务器开始用此会话密钥对信息进行对称加密，开始通信。 为什么不一致使用非对称加密进行通信，因为其耗时远比对称加密要大。 参考文章 优点 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 （4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 缺点 虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的： （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 HTTP切换到https 需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com 这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。 自签名证书 自签名证书：自己生成的证书，因为官方生成的证书要钱，所以除非是很正式的项目，否则使用自己签发的证书足矣。 使用jdk自带公管局KeyTool生成自签发证书 命令行输入：keytool -genkey -keystore “D:\\localhost.keystore” -alias localhost -keyalg RSA 输入密钥库口令:123456 再次输入新口令:123456 您的名字与姓氏是什么? [Unknown]: localhost 您的组织单位名称是什么? [Unknown]: sishuok.com 您的组织名称是什么? [Unknown]: sishuok.com 您所在的城市或区域名称是什么? [Unknown]: beijing 您所在的省/市/自治区名称是什么? [Unknown]: beijing 该单位的双字母国家/地区代码是什么? [Unknown]: cn CN=localhost, OU=sishuok.com, O=sishuok.com, L=beijing, ST=beijing, C=cn是否正确 ? [否]: y 输入 &lt;localhost&gt; 的密钥口令 (如果和密钥库口令相同, 按回车):回车 再次输入新口令: 虽然最后报warning，但依然生成了证书。 然后，让客户端信任此服务器证书，即将服务器证书加入到受信任的根证书颁发机构中。 先把服务器证书导出为.cer文件 keytool -keystore D:/keys/localhost.keystore -export -alias localhost -file D:/keys/server.cer //localhost是刚才为证书起的别名","categories":[],"tags":[]},{"title":"","slug":"html设置背景及使内容居中","date":"2019-04-30T08:25:45.003Z","updated":"2018-05-07T12:05:05.249Z","comments":true,"path":"2019/04/30/html设置背景及使内容居中/","link":"","permalink":"http://47.107.237.149/2019/04/30/html设置背景及使内容居中/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"HTML","date":"2019-04-30T08:25:44.998Z","updated":"2018-09-07T06:39:07.833Z","comments":true,"path":"2019/04/30/HTML/","link":"","permalink":"http://47.107.237.149/2019/04/30/HTML/","excerpt":"","text":"margin 外边距，和padding（内边距）用法一样。 设一个有两个div，一大一小，小的div在大的div里面，而小的div和大div直接的距离就叫外边距，用margin、margin-left、margin-right、margin-top、margin-bottom来设置距离，如margin:10px。而div里面的文字之间的距离就叫内边距，用padding来设置，如同margin一样。 标签不能写在表单里面 check 在…上打勾 javac#php 把爱好打包成名为hobby的数组 lable标签 指定光标焦点定位之处 //聚焦在for属性指定的id上（注意是id而不是name） &lt;label for=&quot;basketball&quot;&gt;篮球&lt;/label&gt; &lt;input type=&apos;checkbox&apos; name=&apos;basket&apos; id=&apos;basketball&apos;&gt; &lt;label for=&quot;football&quot;&gt;足球&lt;/label&gt; &lt;input type=&apos;checkbox&apos; name=&apos;football&apos; id=&apos;football&apos;&gt; 效果如下： 点击文字，勾选框也会被选中 不用for属性的话可以有另一种指定方式：直接将表单控件放到label标签内，这种情况下，label标签只能包含一个表单元素，包含多个只对第一个有效 &lt;label&gt;点击我可以使文本框获得焦点 &lt;input type=&apos;text&apos; name=&apos;theinput&apos; id=&apos;theinput&apos;&gt; &lt;/label&gt; 效果如下：","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之映射继承","date":"2019-04-30T08:25:44.993Z","updated":"2018-08-18T02:39:16.246Z","comments":true,"path":"2019/04/30/hibernate学习之映射继承/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之映射继承/","excerpt":"","text":"每个具体类对应一个表 写一个虚拟父类，用具体类来继承这个虚拟父类，有多少个具体类就建多少张表，父表的外键关联全部的这些具体表 由于根类是虚拟的，在父表这里也不必配置集合映射了，直接在具体类的映射文件中配置多对一的映射即可。 通过外键来获取这些具体类时比较麻烦，要一个一个地去获取，然后再集成一个大集合 下面举了一个例子，是学生拥有多张生活照和工作照的例子 //学生父表 public class Student { private long id; private String name; private Set&lt;String&gt; images; } //照片虚拟类 public abstract class Image { private int id; private String imageName; private Student student; } //生活照和工作照分别为其子类 public class LifeImage extends Image{} public class WorkImage extends Image{} //配置学生映射文件 &lt;class name=&quot;Student&quot; table=&quot;t_student&quot;&gt; &lt;id name=&quot;id&quot; column=&quot;stuId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot;&gt;&lt;/property&gt; &lt;!-- Image类是抽象类，主要是两个实现类在起作用，所以这里配置了Image的映射也没什么用 --&gt; &lt;/class&gt; //配置照片具体类映射文件（重点是都要加上下面这条） &lt;many-to-one name=&quot;student&quot; column=&quot;stuId&quot; class=&quot;com.java1234.model.Student&quot;&gt;&lt;/many-to-one&gt; 数据库 //配置简单，但是获取复杂，假如有很多子类那么获取难度很大 @Test public void testGetAllImages() { List&lt;Image&gt; imageList=new ArrayList&lt;Image&gt;(); int stuId=1; //多态 List&lt;Image&gt; lifeImageList=(List&lt;Image&gt;)session.createQuery(&quot;from LifeImage l where l.student.id=&quot;+stuId).list(); imageList.addAll(lifeImageList); List&lt;Image&gt; workImageList=(List&lt;Image&gt;)session.createQuery(&quot;from WorkImage w where w.student.id=&quot;+stuId).list(); imageList.addAll(workImageList); Iterator iterator=imageList.iterator(); while(iterator.hasNext()) { Image image=(Image) iterator.next(); System.out.println(image.getImageName()); } } 根类对应一个表 创建一个图片的根类（非虚拟类），加上类型属性来区别具体类； 让两个具体类来继承它，但是真正起作用的还是根类 在学生配置文件中加入根类的集合映射 在根类的映射文件中则要加入解释器和子类来区别图片具体类型 获取的话直接一次获取根类即可 //学生父表 public class Student2 { private int id; private String name; private Set&lt;Image2&gt; images; } //照片类 public class Image2 { private int id; private String imageName; private String imageType; //用来区别照片类型 private Student2 student; } //生活照和工作照分别为其子类 public class LifeImage2 extends Image2{} public class WorkImage2 extends Image2{} //学生映射文件 &lt;set name=&quot;images&quot;&gt; &lt;key column=&quot;stuId&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.java1234.model.Image2&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; //照片映射文件 &lt;many-to-one name=&quot;student&quot; column=&quot;stuId&quot; class=&quot;com.java1234.model.Student2&quot;&gt;&lt;/many-to-one&gt; &lt;!--解释器，主要是作为标识的--&gt; &lt;discriminator column=&quot;imageType&quot; type=&quot;string&quot;&gt;&lt;/discriminator&gt; &lt;!--默认是string--&gt; &lt;!--子类--&gt; &lt;subclass name=&quot;com.java1234.model.LifeImage2&quot; discriminator-value=&quot;li&quot;&gt;&lt;/subclass&gt; &lt;!--假如imageType是li这个值那就是LifeImage2类--&gt; &lt;subclass name=&quot;com.java1234.model.WorkImage2&quot; discriminator-value=&quot;wi&quot;&gt;&lt;/subclass&gt; 数据库 //配置略复杂（要配置subclass），但获取简单，直接获取根类即可 @Test public void testGetAllImages2() { Student2 student2=(Student2)session.get(Student2.class, 1); //int的话可以直接放数字 Set&lt;Image2&gt; images=student2.getImages(); Iterator iterator=images.iterator(); while(iterator.hasNext()) { Image2 image2=(Image2)iterator.next(); System.out.println(image2.getImageName()); } } 每个类对应一个表 前两种要么只有根表，要么只有具体表，这种既有根表又有具体表。 跟第二种一样，先创建具体的根类，再创建两个具体类继承根类 学生映射文件中配置根类的集合映射，根类的映射文件中配置一个外键同时关联两张具体类的子表 获取的时候统一获取 //学生父表 public class Student3 { private int id; private String name; private Set&lt;Image3&gt; images; } //根类 public class Image3 { private int id; private String imageName; private Student3 student; } //具体类 public class LifeImage3 extends Image3{} public class WorkImage3 extends Image3{} //学生映射文件 &lt;set name=&quot;images&quot;&gt; &lt;key column=&quot;stuId&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.java1234.model.Image3&quot;&gt;&lt;/one-to-many&gt; &lt;/set&gt; //根类映射文件 &lt;many-to-one name=&quot;student&quot; column=&quot;stuId&quot; class=&quot;com.java1234.model.Student3&quot;&gt;&lt;/many-to-one&gt; &lt;!-- 创建两张关联表 --&gt; &lt;joined-subclass name=&quot;com.java1234.model.LifeImage3&quot; table=&quot;t_lifeImage3&quot;&gt; &lt;key column=&quot;lifeImageId&quot;&gt;&lt;/key&gt; &lt;!-- 主键，将会关联本表（总图片表）的主键，也即是三张图片表的主键同时都是外键 --&gt; &lt;/joined-subclass&gt; &lt;joined-subclass name=&quot;com.java1234.model.WorkImage3&quot; table=&quot;t_workImage3&quot;&gt; &lt;key column=&quot;workImageId&quot;&gt;&lt;/key&gt; &lt;/joined-subclass&gt; 数据库 因为两张具体表的主键都跟根表的主键关联，因此两张具体表的主键不能相同，生活表有1的主键，工作表就不能出现1的主键 //直接获取即可 @Test public void testGetAllImages3() { Student3 student3=(Student3)session.get(Student3.class, 1); //int的话可以直接放数字 Set&lt;Image3&gt; images=student3.getImages(); Iterator iterator=images.iterator(); while(iterator.hasNext()) { Image3 image3=(Image3)iterator.next(); System.out.println(image3.getImageName()); } } 代码实例 HibernateExtends","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之一对一映射","date":"2019-04-30T08:25:44.983Z","updated":"2018-08-18T06:26:04.518Z","comments":true,"path":"2019/04/30/hibernate学习之一对一映射/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之一对一映射/","excerpt":"","text":"通过共享主键映射 举例，用户和地址的一对一关系。用共享主键来关联的话，就是两张表的主键之一作为外键，关系限定为一对一。 //用户类（包含地址） public class User { private int id; private String name; private Address address; } //地址类（包含用户） public class Address { private int id; private String address; private String zipcode; //邮编 private User user; } //用户映射文件 &lt;class name=&quot;User&quot; table=&quot;t_user&quot;&gt; &lt;id name=&quot;id&quot; column=&quot;userId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; column=&quot;UserName&quot;&gt;&lt;/property&gt; &lt;!--可以去掉，但每次获取到的user对象将不带其对应address--&gt; &lt;one-to-one name=&quot;address&quot; class=&quot;com.java1234.model.Address&quot; cascade=&quot;all&quot;&gt;&lt;/one-to-one&gt; &lt;!--all：级联删除、更新都有了--&gt; &lt;/class&gt; //地址映射文件 &lt;class name=&quot;Address&quot; table=&quot;t_address&quot;&gt; &lt;!-- 主键也作为外键与user属性关联 --&gt; &lt;id name=&quot;id&quot; column=&quot;addressId&quot;&gt; &lt;generator class=&quot;foreign&quot;&gt; &lt;!--addressId作为外键关联userId--&gt; &lt;param name=&quot;property&quot;&gt;user&lt;/param&gt; &lt;!--关联user属性--&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/property&gt; &lt;property name=&quot;zipcode&quot; column=&quot;zipcode&quot;&gt;&lt;/property&gt; &lt;!--可以去掉，两张表已然有关联，但获取address不带其对应user--&gt; &lt;one-to-one name=&quot;user&quot; class=&quot;com.java1234.model.User&quot; constrained=&quot;true&quot;&gt;&lt;/one-to-one&gt; &lt;!--constrained：共享主键--&gt; &lt;/class&gt; 数据库 两张表的主键相关联 添加外键进行映射 在用户表中添加一个外键与地址表相关联，并且将外键设置为唯一外键，相当于一对一的效果 //用户类和地址类同上 //用户表增加外键 &lt;!--一对多外键，但是加了unique（不允许重复）之后又变成一对一--&gt; &lt;many-to-one name=&quot;address&quot; class=&quot;com.java1234.model.Address2&quot; column=&quot;addressId&quot; cascade=&quot;all&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; &lt;!--all：级联删除、更新都有了--&gt; //地址映射文件说明一对一关系 &lt;class name=&quot;Address2&quot; table=&quot;t_address2&quot;&gt; &lt;!-- 主键也作为外键与user属性关联 --&gt; &lt;id name=&quot;id&quot; column=&quot;addressId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/property&gt; &lt;property name=&quot;zipcode&quot; column=&quot;zipcode&quot;&gt;&lt;/property&gt; &lt;!-- user属性与User2类的address属性一对一 --&gt; &lt;one-to-one name=&quot;user&quot; class=&quot;com.java1234.model.User2&quot; property-ref=&quot;address&quot;&gt;&lt;/one-to-one&gt; &lt;!--constrained：共享主键--&gt; &lt;/class&gt; 数据库 代码实例HibernateOneToOne","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之实体类状态","date":"2019-04-30T08:25:44.979Z","updated":"2018-08-24T03:58:21.930Z","comments":true,"path":"2019/04/30/hibernate学习之实体类状态/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之实体类状态/","excerpt":"","text":"瞬时态：new一个对象后即处于瞬时态。这个对象所保存的数据域数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()或merge()把瞬时态对象跟数据库关联，这个对象才会转换为持久态对象。 持久态：该对象再数据库中有对应的记录，并拥有一个持久化标识（id）。对持久态对象进行delete操作后，数据库中对应记录将被删除。那么持久态对象与数据库不再存在对应关系，从而变成移除态（可以视为瞬时态）。持久态对象被修改后，不会马上同步到数据库，除非事务提交。 游离态（托管态）：当Session进行了close()、clear()、evict()或flush()后，实体对象将从持久态变为游离态对象虽然拥有和数据库一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理中，所以处于游离态。游离态与瞬时态十分相似，只是它有持久化标识。","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之类型映射","date":"2019-04-30T08:25:44.975Z","updated":"2018-08-18T05:43:18.081Z","comments":true,"path":"2019/04/30/hibernate学习之类型映射/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之类型映射/","excerpt":"","text":"基本类型映射 左边为映射文件中指定类型时使用的，右边为映射到数据库时的字段类型 比如下面几种类型映 //实体类 public class Book { private int id; private String bookName; private float price; private boolean specialPrice; //是否特价 private Date publishDate; //发布日期 private String author; private String introdution; //简介 private Blob bookPic; //图书图片 } //映射文件 &lt;id name=&quot;id&quot; column=&quot;bookId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;bookName&quot; column=&quot;bookName&quot; length=&quot;40&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; column=&quot;price&quot; type=&quot;float&quot;&gt;&lt;/property&gt; &lt;property name=&quot;specialPrice&quot; column=&quot;specialPrice&quot; type=&quot;boolean&quot;&gt;&lt;/property&gt; &lt;property name=&quot;publishDate&quot; column=&quot;publishDate&quot; type=&quot;date&quot;&gt;&lt;/property&gt; &lt;property name=&quot;author&quot; column=&quot;author&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;introdution&quot; column=&quot;introduction&quot; type=&quot;text&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bookPic&quot; column=&quot;bookPic&quot; type=&quot;blob&quot;&gt;&lt;/property&gt; //设置值时将二进制文件转换为Blog类型，用hibernate的方法 LobHelper lobHelper=session.getLobHelper(); InputStream in=new FileInputStream(&quot;D://puchijun.jpg&quot;); Blob bookPic=lobHelper.createBlob(in, in.available()); book.setBookPic(bookPic); Boolean类型对应数据库bit类型，是1/0，sqlyog显示不出其为0时，可以用select语句将要查询的字段+0即可变成1展示出来。集合类型映射 要两边都能互相获取的话就必须在两边的映射文件都配置和对方的关联，参见笔记：hibernate学习之表关联和级联中class映射文件的set集合。 Set：无序不重复 //类 public class Student { private long id; private String name; private Set&lt;String&gt; images; } //映射文件 &lt;!--set映射的是对方表--&gt; &lt;set name=&quot;images&quot; table=&quot;t_image&quot;&gt; &lt;!--待会会自动创建一张t_image表--&gt; &lt;key column=&quot;studentId&quot;&gt;&lt;/key&gt; &lt;!--t_image表的外键是studentId，关联的是本表主键--&gt; &lt;element column=&quot;imageName&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;!--元素,image表中另一字段--&gt; &lt;/set&gt; //测试用例 /** * 保存一学生的几张照片 */ @Test public void testSetSave() { Set&lt;String&gt; imageSet=new HashSet&lt;String&gt;(); imageSet.add(&quot;image1.png&quot;); imageSet.add(&quot;image2.png&quot;); imageSet.add(&quot;image3.png&quot;); imageSet.add(&quot;image3.png&quot;); //加不进去，不可重复 Student s1=new Student(); s1.setImages(imageSet); session.save(s1); } 数据库 List：有序可重复 //映射文件 &lt;list name=&quot;images&quot; table=&quot;t_image2&quot;&gt; &lt;key column=&quot;studentId&quot;&gt;&lt;/key&gt; &lt;list-index column=&quot;imageIndex&quot;&gt;&lt;/list-index&gt; &lt;!-- 多一个索引字段，因为list是有序的 --&gt; &lt;element column=&quot;imageName&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/list&gt; 数据库 Bag：无序可重复 //映射文件 &lt;idbag name=&quot;images&quot; table=&quot;t_image3&quot;&gt; &lt;collection-id type=&quot;long&quot; column=&quot;imageId&quot;&gt; &lt;!-- 加个主键区分相同的两条记录 --&gt; &lt;generator class=&quot;increment&quot;&gt;&lt;/generator&gt; &lt;/collection-id&gt; &lt;key column=&quot;studentId&quot;&gt;&lt;/key&gt; &lt;element column=&quot;imageName&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/idbag&gt; 数据库 Map：键值对，键不可重复 //映射文件 &lt;map name=&quot;images&quot; table=&quot;t_image4&quot;&gt; &lt;key column=&quot;stuId&quot;&gt;&lt;/key&gt; &lt;!--既是外键也是本表主键--&gt; &lt;map-key column=&quot;imageKey&quot; type=&quot;string&quot;&gt;&lt;/map-key&gt; &lt;!--key，也被搞成主键，联合主键，没什么用但是一定要有--&gt; &lt;element column=&quot;imageName&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;/map&gt; 数据库 获取Map public void testMapFecth() { Student4 student4=(Student4)session.get(Student4.class, Long.valueOf(1)); Map&lt;String, String&gt; imageMap=student4.getImages(); //首先获取keys Set keys=imageMap.keySet(); Iterator iterator=keys.iterator(); while(iterator.hasNext()) { String key=(String)iterator.next(); System.out.println(key+&quot;:&quot;+imageMap.get(key)); //集合.get(key):获取值 } } 代码实例 eclipse-&gt;HibernateTypeMapping","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之检索策略","date":"2019-04-30T08:25:44.972Z","updated":"2018-08-24T02:33:53.076Z","comments":true,"path":"2019/04/30/hibernate学习之检索策略/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之检索策略/","excerpt":"","text":"lazy：true （默认）延迟检索，get时只查本表数据不查关联表数据,用到时再查 lazy：false 立即检索 lazy：extra 增强延迟检索，get时获得的是对象的代号，访问属性时再查一遍查出具体对象信息 lazy：no_proxy 无代理延迟检索，get时获得的是null，访问属性时再查一遍 batch-size 批量检索 //获取三个班级极其学生 public void testBatch1(){ List&lt;Class&gt; classList=session.createQuery(&quot;from Class&quot;); Iterator it=(Class)it.next(); Class c1=(Class)it.next(); Class c2=(Class)it.next(); Class c3=(Class)it.next(); c1.getStudents().iterator(); c2.getStudents().iterator(); c3.getStudents().iterator(); } 上面例子，配置batch-size=3时，一跳hql可以同时查询三个班的学生，否则需要三条hql来查询学生 fetch：select 默认查询方式 fetch：subselect 子查询，数据量大时能提高性能 fetch：join 外连接查询，比如上面的例子默认是先查询班级再查询学生，配置了join之后只用一条hql即可作为一条hql查询，数据量很大时能提高性能，很少时优化了反而越慢了。 代码实例：e:/wuli数据组/一头扎进Hibernate/第十四讲源码","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之缓存","date":"2019-04-30T08:25:44.966Z","updated":"2018-08-18T09:17:02.448Z","comments":true,"path":"2019/04/30/hibernate学习之缓存/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之缓存/","excerpt":"","text":"缓存介于物理数据源于应用程序之间，是对数据库中的数据复制一份临时存在内存或者硬盘中的容器，其作用是为了减少应用程序对物理数据源的访问次数，从而提高了应用程序的运行性能。 hibernate在进行读取数据的时候，根据缓存机制在相应的缓存中查询，如果在缓存中找到则把这称为缓存命中。这避免了大量发送sql语句到数据库查询的性能损耗。 session缓存，事务缓存：hibernate内置的，不能卸除。只能被当前session对象访问。缓存的生命周期依赖于session的生命周期。当session被关闭后，缓存也就结束生命周期。配置EHCache（二级缓存提供商） 默认配置文件名：ehcache.xml，分别要配置默认的缓存设置和具体的缓存设置 在hibernate.cfg.xml中开启二级缓存 在要开启二级缓存的类的映射文件中开启二级缓存 测试：用同一个工厂开两个session，第一个查询到的对象将存放在sessionFactory，即使第一个session关闭了，该对象已然存在于sessionFactory中，第二个session可以直接在缓存中获取到。 public void testCache2(){ //第一次用sql Session session1=sessionFactory.openSession(); session1.beginTransaction(); Class c=(Class)session1.get(Class.class, Long.valueOf(1)); System.out.println(c.getName()); session1.getTransaction().commit(); session1.close(); //第二次查询时使用到了二级缓存，直接从SessionFactory里拿 Session session2=sessionFactory.openSession(); session2.beginTransaction(); Class c2=(Class)session2.get(Class.class, Long.valueOf(1)); System.out.println(c2.getName()); session2.getTransaction().commit(); session2.close(); System.out.println(c==c2); } 代码实例：hibernateEHCache 什么数据适合放二级缓存中 经常被访问 改动不大 数量有限 不是很重要的数据，允许出现偶尔并发的数据 只读的数据 比如组织机构代码、列表信息等","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之多对多映射","date":"2019-04-30T08:25:44.951Z","updated":"2018-08-15T09:22:06.018Z","comments":true,"path":"2019/04/30/hibernate学习之多对多映射/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之多对多映射/","excerpt":"","text":"单向关联 学生和课程是多对多的关系，一个学生能选多门课程，一门课程也可能被多人选中。 单向关联指只有学生类中包含课程类，只在学生映射文件中配置一张中间表的映射 获取时只能从根据学生信息获取课程表，不能反过来 //学生类 public class Student { private int id; private String name; private Set&lt;Course&gt; courses=new HashSet&lt;Course&gt;(); } //课程类 public class Course { private int id; private String name; } //学生映射文件 &lt;set name=&quot;courses&quot; table=&quot;student_course&quot; cascade=&quot;save-update&quot;&gt; &lt;key column=&quot;student_id&quot;&gt;&lt;/key&gt; &lt;!--这个主键关联t_student的主键--&gt; &lt;many-to-many class=&quot;com.java1234.model.Course&quot; column=&quot;course_id&quot;&gt;&lt;/many-to-many&gt; &lt;!--这个主键course_id关联的是Course这张表的主键--&gt; &lt;/set&gt; //课程映射表 &lt;class name=&quot;Course&quot; table=&quot;t_course&quot;&gt; &lt;id name=&quot;id&quot; column=&quot;courseId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; column=&quot;courseName&quot;&gt;&lt;/property&gt; &lt;!--学生表与课程表的关联是单向的，所以课程表不需要映射学生表，也无法通过课程来获取学生信息--&gt; &lt;/class&gt; 数据库 /** 只在学生映射文件中配置课程映射，只能通过学生表获取课程表，不能反向*/@Testpublic void testLoad1(){ Student student=(Student)session.get(Student.class, 1); Set courses=(Set)student.getCourses(); Iterator it=courses.iterator(); while(it.hasNext()){Course c=(Course)it.next(); System.out.println(c.getName()); }}双向关联 学生类中包含课程集合，课程类中也包含学生集合 同时在学生和课程映射文件中配置中间数据库 可以反向获取 //学生类 public class Student2 { private int id; private String name; private Set&lt;Course2&gt; courses=new HashSet&lt;Course2&gt;(); } //课程类 public class Course2 { private int id; private String name; private Set&lt;Student2&gt; students=new HashSet&lt;Student2&gt;(); } //学生映射文件 &lt;set name=&quot;courses&quot; table=&quot;student_course2&quot; cascade=&quot;save-update&quot;&gt; &lt;key column=&quot;student_id&quot;&gt;&lt;/key&gt; &lt;!--这个主键关联t_student的主键--&gt; &lt;many-to-many class=&quot;com.java1234.model.Course2&quot; column=&quot;course_id&quot;&gt;&lt;/many-to-many&gt; &lt;!--这个主键course_id关联的是Course这张表的主键--&gt; &lt;/set&gt; //课程映射文件 &lt;set name=&quot;students&quot; table=&quot;student_course2&quot; inverse=&quot;true&quot;&gt; &lt;key column=&quot;course_id&quot;&gt;&lt;/key&gt; &lt;many-to-many class=&quot;com.java1234.model.Student2&quot; column=&quot;student_id&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; 数据库同上 /** * 双向关联，可以反向获取 */ @Test public void testLoad2(){ Course2 course=(Course2)session.get(Course2.class, 1); Set&lt;Student2&gt; students=(Set&lt;Student2&gt;)course.getStudents(); Iterator it=students.iterator(); while(it.hasNext()){ Student2 s=(Student2)it.next(); System.out.println(s.getName()); } } 代码实例 HibernateManyToMany","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之常用方法重点是merge","date":"2019-04-30T08:25:44.939Z","updated":"2018-08-24T03:56:22.251Z","comments":true,"path":"2019/04/30/hibernate学习之常用方法重点是merge/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之常用方法重点是merge/","excerpt":"","text":"load方法VSget方法 假如数据库不存在该对象，load会抛异常而get会返回null load方法默认采用延迟加载策略，只获取对象引用，访问到属性时才会加载对象属性。因此删除对象时多采用load方法，访问对象时多采用get。saveOrUpdate方法 对象存在时采用update，否则采用savemerge方法 合并对象，解决对象不唯一问题 /** * 把主键为1的班级改名为08计本4 */ @Test public void testMergeClass() { Session session1=sessionFactory.openSession(); session1.beginTransaction(); Class c1=(Class)session1.get(Class.class, Long.valueOf(1)); session1.getTransaction().commit(); session1.close(); Session session2=sessionFactory.openSession(); session2.beginTransaction(); Class c2=(Class)session2.get(Class.class, Long.valueOf(1)); c1.setName(&quot;08计本4&quot;); //如果用session.update(c1)的话，会报错：对象不唯一，缓存中存在不止一个该对象-&gt;org.hibernate.NonUniqueObjectException: A different object with the same identifier value was already associated with the session : [com.java1234.model.Class#1] //因为上面session2.get之后session2中就有了一个主键为1的对象，而引用这个对象的是c2，c1就相当于另外一个主键为1的对象，但是它已不在会话中，要用它来更新c2关联的数据就错乱了。如果c2的管理的不是id为1的对象那就可以update(c1)，但是现在同时有两个对象的主键是1，用merge就意味着这两个对象的更新操作都会被合并到同一条记录上。 //换成save的话则是新建一条记录，因为c1的事务已经关了，再保存c1就相当于保存一个新对象，若没关的话那就是修改一个存在的对象，就变成更新原有记录了 session2.merge(c1); session2.getTransaction().commit(); session2.close(); } 代码实例 eclipse-&gt;HibernateFunction","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之表关联和级联","date":"2019-04-30T08:25:44.933Z","updated":"2018-08-18T05:40:19.034Z","comments":true,"path":"2019/04/30/hibernate学习之表关联和级联/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之表关联和级联/","excerpt":"","text":"班级学生一对多表关联 建立关联关系的话首先至少要有两个表，那就要有两个实体类，通常是一对多的关系，比如学生和班级，可以在其中一个类加入另一个类的实例，比如在学生中包含班级这个类（如果是班级中包含学生的话那应该是一个班级包含一个学生集合） public class Student { private long id; private String name; private Class c; //学生只有一个班级，多对一 } 映射文件中加入外键声明，多的这个表一定要加 &lt;!--在学生表中插入一个外键--&gt; &lt;many-to-one name=&quot;c&quot; column=&quot;classId&quot; class=&quot;com.java1234.model.Class&quot; cascade=&quot;save-update&quot;&gt;&lt;/many-to-one&gt; 一的这边也可以声明和多的之间的关联（不是必要） //类 public class Class { private long id; private String name; private Set&lt;Student&gt; students=new HashSet&lt;Student&gt;(); } //映射文件 &lt;!-- 因为是一对多，所以class表不会多出下面字段，只是建立一种关联而已，不写也可以(写了的话获取班级的同时会自动获取学生集合)，但学生表那边一定要写 --&gt; &lt;set name=&quot;students&quot; cascade=&quot;save-update&quot; inverse=&quot;true&quot;&gt; &lt;!-- 加上save-update可以在只保存class的情况下顺便保存student;加上inverse就能在多的一端维护外键;加上cascade=&quot;delete&quot;可以进行级联删除 --&gt; &lt;key column=&quot;classId&quot;&gt;&lt;/key&gt; &lt;!-- 外键名 --&gt; &lt;one-to-many class=&quot;com.java1234.model.Student&quot;/&gt; &lt;/set&gt; 比如上面这个set集合如果不设置的话，那么下面打印的将是0，因为班级获取不到学生 public void testInversse() { Class c=(Class)session.get(Class.class, Long.valueOf(1)); Set&lt;Student&gt; students=c.getStudents(); System.out.println(students.size()); } 最后插入数据的时候要在学生中设置好班级 Class c=new Class(); c.setName(&quot;08计本&quot;); session.save(c); Student s1=new Student(); s1.setName(&quot;张三&quot;); s1.setC(c); Student s2=new Student(); s2.setName(&quot;李四&quot;); s2.setC(c); session.save(s1); session.save(s2); 经过上面学生类和学生映射文件这两步，学生这个表就会自动关联到班级表的主键。 级联 学生映射文件中，在标签里面，cascade默认是“none”，假如我们希望在持久化多的一端时自动级联保存和更新一的一端，我们可以把cascade设置成“save-update”。那么这个class自己不保存也可以跟着引用了它的student保存下来。反过来，在班级映射文件中加入该标签，则可以使student随着class保存而保存。 Class c=new Class(); c.setName(&quot;08计本&quot;); // session.save(c); 不保存，在&lt;many-to-one&gt;标签中加个属性cascade属性即可随多的一方（Student）保存 Student s1=new Student(); s1.setName(&quot;张三&quot;); s1.setC(c); Student s2=new Student(); s2.setName(&quot;李四&quot;); s2.setC(c); session.save(s1); session.save(s2); inverse属性 剪除多余hql，提高性能 &lt;set name=&quot;students&quot; cascade=&quot;save-update&quot; inverse=&quot;true&quot;&gt; &lt;!-- 加上save-update可以在只保存class的情况下顺便保存student;加上inverse就能在多的一端维护外键;加上cascade=&quot;delete&quot;可以进行级联删除 --&gt; &lt;key column=&quot;classId&quot;&gt;&lt;/key&gt; &lt;!-- 外键名 --&gt; &lt;one-to-many class=&quot;com.java1234.model.Student&quot;/&gt; &lt;/set&gt; 比如上面班级配置文件中的inverse属性，加上之后可以提高以下程序的性能 //先添加两条没有关联的数据 @Test public void testAdd() { Class c=new Class(); c.setName(&quot;09计本&quot;); Student s1=new Student(); s1.setName(&quot;王五&quot;); session.save(c); session.save(s1); } //把这两条数据查出来之后再建立联系 @Test public void testInversse() { Class c=(Class)session.get(Class.class, Long.valueOf(1)); Student s=(Student)session.get(Student.class, Long.valueOf(1)); //加了inverse之后可以使第二行不生效（因为它本来就没用，除了多一句多余的hql拖慢性能）提高性能，一般都是在多的一端保存即可 s.setC(c); //在学生中添加班级，会在学生表中增加班级外键 c.getStudents().add(s); //在班级中添加学生，会在学生表中增加学生外键 //这样就会生成hql，在这个学生中加入这个班级的外键 } 级联删除 删除被关联的表时顺便删除父表 /* * 这样运行应该是报错的，因为class表被关联，加上属性cascade=&quot;delete&quot;后才能进行级联删除，将学生表记录一并删掉 */ @Test public void testDeleteClassCascade() { Class c=(Class)session.get(Class.class, Long.valueOf(1)); session.delete(c); } 自身关联 自身字段关联自身字段，比如下面一个菜单的例子 数据库 //类 public class Node { private long id; private String name; private Node parentNode; //父节点 private Set&lt;Node&gt; childNodes=new HashSet&lt;Node&gt;(); //子节点 } //映射文件 //保存数据 @Test public void testSaveMenu() { Node node=new Node(); node.setName(&quot;根结点&quot;); Node subNode1=new Node(); subNode1.setName(&quot;子结点1&quot;); Node subNode2=new Node(); subNode2.setName(&quot;子结点2&quot;); subNode1.setParentNode(node); subNode2.setParentNode(node); session.save(subNode1); session.save(subNode2); } 代码实例：eclipse-&gt;HibernateCrud","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之sql与hql","date":"2019-04-30T08:25:44.921Z","updated":"2018-08-16T04:13:46.624Z","comments":true,"path":"2019/04/30/hibernate学习之sql与hql/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之sql与hql/","excerpt":"","text":"sql 面向过程，用到的关键字都是字段，查询结果对象不明，需要绑定对象以获取数据 public void testSQLQuery() { String sql=&quot;select * from t_student&quot;; Query query=session.createSQLQuery(sql).addEntity(Student.class); //由于返回的是Object类型，所以要绑定一个实体类，不然遍历时数据查不出来 List studentList=query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } public void testSQLQuery2() { String sql=&quot;select * from t_student where stuName like :stuName and stuAge=:stuAge&quot;; //where后面带字段名 Query query=session.createSQLQuery(sql).addEntity(Student.class); query.setString(&quot;stuName&quot;, &quot;张%&quot;); query.setInteger(&quot;stuAge&quot;, 10); List studentList=query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } hql 面向对象，关键字是对象属性，返回结果对象确定，不用绑定对象，直接强转 public void testHQLQuery() { String hql=&quot;from Student&quot;; Query query=session.createQuery(hql); //不用绑定，可以直接强转 List&lt;Student&gt; studentList=(List&lt;Student&gt;)query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } public void testHQLQuery2() { String hql=&quot;from Student where name like :stuName and age=:stuAge&quot;; //where后面带属性名 Query query=session.createQuery(hql); query.setString(&quot;stuName&quot;, &quot;张%&quot;); query.setInteger(&quot;stuAge&quot;, 10); List&lt;Student&gt; studentList=(List&lt;Student&gt;)query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } /** 使用别名 */ public void testHQLQuery3() { String hql=&quot;from Student as s where s.name like :stuName and s.age=:stuAge&quot;; //where后面接对象.属性，like跟=后面接随意命名 Query query=session.createQuery(hql); query.setString(&quot;stuName&quot;, &quot;张%&quot;); query.setInteger(&quot;stuAge&quot;, 10); List&lt;Student&gt; studentList=(List&lt;Student&gt;)query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } /** 按年龄排序 */ @Test public void testHQLQuery4() { String hql=&quot;from Student order by age desc&quot;; //降序 Query query=session.createQuery(hql); List&lt;Student&gt; studentList=(List&lt;Student&gt;)query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } /** 分页 */ @Test public void testHQLQuery5() { String hql=&quot;from Student&quot;; Query query=session.createQuery(hql); query.setFirstResult(0); //从第1条查起 query.setMaxResults(2); //查询两条 List&lt;Student&gt; studentList=(List&lt;Student&gt;)query.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } /** 查询单个对象 */ @Test public void testHQLQuery6() { String hql=&quot;from Student&quot;; Query query=session.createQuery(hql); query.setFirstResult(1); query.setMaxResults(1); //就只查一条 Student student=(Student)query.uniqueResult(); //直接强转成对象而非集合 System.out.println(student); } /** 链式写法 */ @Test public void testHQLQuery7() { String hql=&quot;from Student as s where s.name like :stuName and s.age=:stuAge&quot;; Query query=session.createQuery(hql); //就是把查询语句连接成一条 List&lt;Student&gt; studentList=(List&lt;Student&gt;)query //因为返回的是Query所以可以接着. .setString(&quot;stuName&quot;, &quot;张%&quot;) //返回的还是 Query .setInteger(&quot;stuAge&quot;, 10) //还是Query .list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } }","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之QBC查询","date":"2019-04-30T08:25:44.917Z","updated":"2018-08-18T09:12:26.375Z","comments":true,"path":"2019/04/30/hibernate学习之QBC查询/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之QBC查询/","excerpt":"","text":"借助hibernate提供的接口的一种查询方式 比hql更面向对象的查询方式 普通查询 public void testQBCQuery1(){ Criteria sriteria=session.createCriteria(Student.class); List&lt;Student&gt; studentList=criteria.list(); Iterator it=studentList.iterator(); while(it.hasNext){ Student s=(Student)it.next; System.out.println(s); } } 条件查询 public void testQBCQuery2(){ Criteria criteria=session.createCriteria(Student.class); Criterion c1=Restriction.like(&quot;name&quot;,&quot;张%&quot;); //添加限制条件；关键字用属性名 Criterion c2=Restrictions.eq(&quot;age&quot;,10); criteria.add(c1); criteria.add(c2); List&lt;Student&gt; studentList=criteria.list(); Iterator it=studentList.iterator(); while(it.hasNext){ Student s=(Student)it.next(); System.out.println(s); } } 排序查找 public void testQBCQuery3(){ Criteria criteria=session.createCriteria(Student.class); criteria.addOrder(Order.desc(&quot;age&quot;); List&lt;Student&gt; studentList==criteria.list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)itt.next(); System.out.println(s); } } 分页查询 public void testQBCQuery4(){ Criteria criteria=session.createCriteria(Student.class); criteria.setFirstResult(0); //从第一条开始查询 criteria.setMaxResults(2); List&lt;Student&gt; studentList=criteria.list(); Iterator it=studentList.iterator(); while(it,hasNext()){ Student s=(Student)it.next(); System.out.println(s); } } 查询单个对象 public void testQBCQuery5(){ Criteria criteria=session.createCriteria(Student.class); criteria.setMaxRresult(2); criteria.setMaxResults(1); Student student=(Student)criteria.uniqueResult(); System.out.println(student); } 链式写法 public void testQBCQuery6(){ Criteria criteria=session.createCriteria(Student.class); List&lt;Student&gt; studentList=criteria .setFirstResult(2) .setMaxResults(2) .list(); Iterator it=studentList.iterator(); while(it.hasNext()){ Student s=(Student)it.next(); System.out.println(s); } }","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之DDL","date":"2019-04-30T08:25:44.910Z","updated":"2018-08-17T07:11:41.993Z","comments":true,"path":"2019/04/30/hibernate学习之DDL/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之DDL/","excerpt":"","text":"hibernate配置文件 将对象映射为数据库的关系可以采用注解或配置文件，我们先接触配置文件 配置文件默认命名为hibernate.cfg.xml，改名的话需要另外指定；默认位置为src下。 先在以上命名文件中配置好数据库连接、方言设置，指定是否打印sql语句、更新表结构方式的方法和映射文件 &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 数据库连接设置 --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/hibernate&lt;/property&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;123456&lt;/property&gt; &lt;!-- 方言 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hiberate.dialect.MySQL5Dialect&lt;/property&gt; &lt;!-- 控制台显示sql --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 自动更新表结构 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- validate【每次运行会校验数据与数据库的字段类型是否相同，不同则报错】、 create【每次运行程序，没有表格会新建，表内有数据会清空】、 create-drop【每次程序结束时会清空表】、 update【每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新表结构，但是原有的字段不会删掉，就算是把该字段改名了也还是会保存原有这个字段，所以易出现相同意义字段重复情况；即使表结构改变了但原有的记录不会删除】、） --&gt; &lt;!-- 指定文件进行对象关系映射 --&gt; &lt;mapping resource=&quot;com/java1234/model/Student.hbm.xml&quot;/&gt; &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 配置映射文件 命名、位置随意，将pojo和表对应。 一个pojo对应一个映射文件 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping package=&quot;com.java1234.model&quot;&gt; &lt;class name=&quot;Student&quot; table=&quot;t_student&quot;&gt; &lt;!-- 要映射的对象为Student，表为t_student --&gt; &lt;!-- 主键配置用标签id --&gt; &lt;id name=&quot;id&quot; column=&quot;stuId&quot;&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;!-- 生成策略为按照本地，这里是自增 --&gt; &lt;/id&gt; &lt;!-- 其他字段配置用property标签 --&gt; &lt;property name=&quot;name&quot;&gt;&lt;/property&gt; &lt;!-- 省略column表示字段和属性名相同 --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 主键生成策略：- increment：由hibernate自动以递增的方式生成主键（插入数据前查询最大主键并自动加一） - identity：由底层数据库自动生成标识符（MySQL是自增） - native：根据底层数据库自动选择以上方式（sql是identity） 代码实例 eclipse-&gt;HibernateDDL","categories":[],"tags":[]},{"title":"","slug":"hibernate学习之Crud","date":"2019-04-30T08:25:44.895Z","updated":"2018-10-27T03:06:18.928Z","comments":true,"path":"2019/04/30/hibernate学习之Crud/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate学习之Crud/","excerpt":"","text":"封装Util获取session工厂 采用单例模式（保证外部调用的方法中不包含new操作，new操作只执行一次，比如让它随着类的加载而执行） public class HibernateUtil { //静态域，随着类的加载而加载；类的所有实例共享一个sqlSessionFactory，一个对象对其修改则所有对象的该域都被修改。常量，调用对象构造器初始化后不能更改 private static final SessionFactory sessionFactory=buildSessionFactory(); private static SessionFactory buildSessionFactory() { Configuration configuration=new Configuration().configure(); ServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build(); return configuration.buildSessionFactory(serviceRegistry); } //这样获取的就都是单例了 public static SessionFactory getSessionFactory() { return sessionFactory; } } Crudpublic class StudentTest { private SessionFactory sessionFactory=HibernateUtil.getSessionFactory(); private void add() { Session session=sessionFactory.openSession(); session.beginTransaction(); Student s=new Student(); s.setName(&quot;李四&quot;); session.save(s); session.getTransaction().commit(); session.close(); } private void delete() { Session session=sessionFactory.openSession(); session.beginTransaction(); Student s=(Student)session.get(Student.class, Long.valueOf(1)); session.delete(s); session.getTransaction().commit(); session.close(); } private void update() { Session session=sessionFactory.openSession(); session.beginTransaction(); Student s=(Student)session.get(Student.class, Long.valueOf(1)); s.setName(&quot;张三2&quot;); session.save(s); session.getTransaction().commit(); session.close(); } private void getAllStudent() { Session session=sessionFactory.openSession(); session.beginTransaction(); String hql=&quot;from Student&quot;; Query query=session.createQuery(hql); List&lt;Student&gt; studentList=query.list(); for(Student s:studentList) { System.out.println(s); } session.getTransaction().commit(); session.close(); } public static void main(String[] args) { StudentTest studentTest=new StudentTest(); //studentTest.add(); //studentTest.delete(); //studentTest.update(); studentTest.getAllStudent(); } } session缓存 查询某条数据都是先到session缓存中查看是否存在，存在即引用，不存在再去数据库查询 Student s1=(Student)session.get(Student.class, Long.valueOf(1)); //select语句查询 Student s2=(Student)session.get(Student.class, Long.valueOf(2)); Student s3=(Student)session.get(Student.class, Long.valueOf(1)); //在session缓存中获取 System.out.println(s1==s2); //false System.out.println(s1==s3); //true 代码实例 eclipse-&gt;HibernateCrud","categories":[],"tags":[]},{"title":"","slug":"hibernate","date":"2019-04-30T08:25:44.890Z","updated":"2018-09-21T03:17:41.499Z","comments":true,"path":"2019/04/30/hibernate/","link":"","permalink":"http://47.107.237.149/2019/04/30/hibernate/","excerpt":"","text":"参考文章主键生成策略简介 Hibernate是一个开放源代码的对象关系映射框架，它对jdbc进行了非常轻量级的对象封装，它将pojo与数据库表建立映关系，是一个全自动的orm（对象关系记录）框架。 也就是说，我们可以用Hibernate来完成原来我们使用jdbc完成的操作。hibernate方言 hibernate方言是为了实现HQL（面向对象查询，是hibernate的数据库查询语言，对应于面向数据库查询的sql）语句向不同数据库的sql语句转换时，解决不同数据库之间的差异而制定的一套规范。@Entity和@Table注解 将pojo映射到数据库，使得创建该pojo对象数据库即即新建一条记录，删除则数据库跟着删除一条记录，修改则数据库会根据此pojo对象的状态同步。 @Entity：被标注的类，其类名即为数据库中的表名，它的属性即为表中的字段。 @Table：标注在类前。属性： name：表示映射的表名，不指定的话默认和类同名，但一般我们不希望表名以大写字母开头 @Column：标注在属性或其getter方法前。属性： name：表示属性映射的字段名 nullable：true或false决定字段支不支持null值。 columnDefinition：指定类型；很多java类型都有默认的sql类型，但是Date类对应的sql类型有Datetime（精确到秒）和Date（精确到日），columnDefinition=”DATE”可以指定类型为Date @Basic：即使不写也是属性的默认注解，作用是将没有加@Column注解的属性也映射到数据库。一般不需要加上用到，默认就好。 fetch：值为FetchType.LAZY或FetchType.EAGER，延迟加载或者及时加载，前者获取数据时不获取该字段，用时再获取；后者直接获取，默认值 optional：boolean，定义字段值是否允许为null，默认true @Transient：该字段不映射 @ManyToOne：表示一个多对一的映射，被标注的属性通常是数据库表的外键 optional：是否允许为null，默认为true fetch：表示抓取策略，默认为FetchType.EAGER cascade：级联策略。 CascadeType.PRESIST:级联持久化，持久保存实体时，也会持久保存该实体的所有关联数据； CascadeType.REMOVE：级联删除，删除一个实体时也会删除该实体的关联数据； CascadeType.MERGE：级联更新，Merge对实体进行操作时,会区分这个实体的状态,假如这个实体处于托管状态,就应该使用merge,否则会报异常..同样,做级联的时候执行merge操作,CasCadeType.Merge也会对关联实体生效。额不是很懂； CascadeType.REFRESH：级联刷新，假如A、B两对象同时引用同一条数据，B修改某属性后提交，之后A修改另一属性后要提交时，entityManager中的持久化实体没有更新为B修改后的样子，此时执行一次Refresh操作，就会将该实体更新为数据库中的最新记录，最后再进行提交。那么加了CascadeType.REFRESH就会在执行Refresh时也对关联的实体类进行刷新操作。 CascadeType.ALL：包含以上所有级联操作。 具体使用方法参见笔记：@JoinColumn建立外键 @MappedSuperclass：要映射的类继承自不需映射的超类，需要在超类加上此注解，在要映射的类加上@Entity注解。 @MappedSuperclass //指定映射超类（映射超类不会生成单独的表，它的映射信息作用于继承它的实体类） public class Resource { @Id @GeneratedValue private int id; //会议名称 private String title; //搜索日期 @Column(columnDefinition = &quot;DATE&quot;) private Date createDate; //会议类型 private String type; //组别 private String model; //上传者 private String author; //上传者id private int authorId; } @Entity @Table(name=&quot;image&quot;) public class Image extends Resource{ //继承映射超类的属性 } 数据库 子类可以通过@AttributeOverride和@AssociationOverride注解来覆盖映射超类的属性。 代码实例：SpringMvc02/Resource、Image更多属性、被注解类的要求、一个类映射多张表 实体类必须拥有一个public或protected的无参构造函数。 实体类必须是一个顶级类，枚举或者接口不能被注解为一个实体。 实体类不能是final类型的，也不能有final类型的方法@GeneratedValue 用于标注主键的生成策略，通过strategy属性指定。默认情况下，jpa自动选择一个最适合数据库库的主键生成策略：sql对应identity（像MySQL的identity是auto increment）。 @GenericGenerator(name=&quot;_native&quot;,strategy=&quot;native&quot;) //定义生成策略，native对应自增长 @GeneriateValue(generator=&quot;_native&quot;) //使用生成策略 一般都是直接加个@GeneratedValue这样就好了，默认native 主键生成策略： increment：由hibernate自动以递增的方式生成主键（插入数据前查询最大主键并自动加一） identity：由底层数据库自动生成标识符（MySQL是自增） native：根据底层数据库自动选择以上方式（sql是identity）@Embedded 当一个类存在属性为另一个类时，可以用这个注解来标注该属性 @Entity @Table(name=&quot;paople&quot;) //命名，否则为大写 public class People { @Id @GeneratedValue private int id; private String name; @Embedded private Address address; } 被引用的类用@Embeddable注释 @Embeddable public class Address { private String city; private String street; private String zip; } 如此，数据库建立的people表address字段会被替换成Address类的三个属性","categories":[],"tags":[]},{"title":"","slug":"hexo博客搭后感","date":"2019-04-30T08:25:44.876Z","updated":"2018-06-03T12:33:39.858Z","comments":true,"path":"2019/04/30/hexo博客搭后感/","link":"","permalink":"http://47.107.237.149/2019/04/30/hexo博客搭后感/","excerpt":"","text":"工具使用 node.js git github仓库 hexo框架错误历史node.js版本问题 一定要下载node.js最新版，这个是木有向后兼容性滴~所以不是最新版的话，安装hexo时会比别人多出一个版本的warn，直接后面安不了hexo。表示被这第一步坑了三次左右！下载hexo出错 多出来的那个warn绝对不是让你骄傲的，因为后面一串的err才真是够你吹一年了。。。起初很傻地跟着教程做，结果在cmd里执行安装hexo的命令。因为这个小错误，我把node.js卸载重装了七八次。 我认为最后能装上完全靠的是信念。因为就在第七次/第八次的时候，我偶然发现在hexo目录下git bash,然后执行一系列安装命令，居然能跟教程匹配上了！老泪纵横，于是一口气把一系列的块都下好了。更换主题滞后 博客给人第一眼感觉就是“长得怎么样”，下面一起来换主题吧！查了下网，比较火的主题是next、indigo等，我选择后者。那么就要修改一哈根目录以及theme目录下的_config.yml，把一些个性化配置修改为个人相关信息。 然后问题来了，乱码加修改不生效。我是修改后保存并运行hexo d。看上去没毛病，但其实我故意修改了一个关键项之后，重复上述操作，博客并没有丝毫改变……后来在hexo d命令之前加上hexo clean清理缓存即可，可能是前面操作太多了！一些命令","categories":[],"tags":[]},{"title":"","slug":"hexo博客部署到服务器","date":"2019-04-30T08:25:44.872Z","updated":"2019-04-30T07:52:33.120Z","comments":true,"path":"2019/04/30/hexo博客部署到服务器/","link":"","permalink":"http://47.107.237.149/2019/04/30/hexo博客部署到服务器/","excerpt":"","text":"部署到github或者部署到服务器上才能让别人也看到你的博客，而部署到github上的缺点是访问速度比较慢，而且.io不被百度认证。 原先的部署https://eliyser.github.io/，现在把博客部署到云服务器上，但也没有撤销在github上的托管，所以访问之前或者部署之后的地址都可以。 首先理解一下部署和托管都是怎么个流程 右边那个既可以是服务器也可以是github 左边我之前就已经在本地弄好了，包括安装node.js，hexo(e盘下的hexo2就是了)，以及博客的初始美化和文章撰写。 接下来是服务器的环境搭建 服务器端安装git 思路：在阿里云服务器上搭建git仓库，本地博客目录下运行hexo g -d生成静态文件,并提交到git仓库 yum install git 检查安装信息 git --version 创建git用户 adduser git chmod 740 /etc/sudoers //好像是开写权限 vim /etc/sudoers 找到以下内容 ## Allow root to run any commands anywhere root ALL=(ALL) ALL 在下面添加一行 git ALL=(ALL) ALL 保存后退出改回权限 chmod 400 /etc/sudoers 设置git的密码 sudo passwd git 生成一对ssh认证密钥(这个应该是为了git push之类的时候免密吧) su git cd /home/git mkdir /blog/.ssh cd blog/.ssh ssh-keygen -t rsa 下面是本地端的操作，主要是为了ssh连接远程服务器的时候可以免密 在本地生成公钥和密钥 ssh-keygen -t rsa //因为本地已经有了所以应该会提示已存在，那其实也可以直接跳过这一步 将本机生成的公钥发送到服务器上建立信任关系，目的是ssh连接的时候可以不输入密码 ssh-copy-id -i C:/Users/14103/.ssh/id_rsa.pub git@47.107.237.149 测试ssh远程登录是否成功，必须免密才算成功 ssh git@47.107.237.149 把上一步、上上一步的git换成root就可以实现ssh连接root用户免密了 然后回到服务端 新建git仓库 mkdir -p /home/git/blog/hexo.git #准备成为Git仓库 mkdir /home/git/blog/hexo #存储网站文件（文章啦渲染之类的） git init --bare /home/git/blog/hexo.git #设为git仓库，--bare代表这是裸库，裸库没有工作区，我们不会在裸库上进行操作，它只为共享而存在 cd /home/git/blog/hexo.git/hooks //进入该仓库 vim /home/git/blog/hexo.git/hooks/post-update.sample //配置post-update.sample 追加一行 git --work-tree=/home/git/blog/hexo --git-dir=/home/git/blog/hexo.git checkout -f 保存之后更改文件名为post-update 赋予可执行权限（这一步好像需要root用户，前面也是，有的需要root用户，那就切换用户再切换回来就是了，或者直接在命令前面加个sudo更好） chmod +x post-update 安装Nginx nginx就是我们的web服务器了 首先进行服务端的系统更新，时间可能有点久 yum update -y 切换git用户，直接使用root用户是不符合安全规范的 su git 安装nginx yum install nginx 修改配置文件 vim /etc/nginx/nginx.conf 有两个user，都要改成root server_name改成服务器ip地址 root改成hexo网站文件存储路径 location里面要不要加都随便 看到上面的默认端口是80了吧，我们来看看服务器上有没有这个端口，没有的话选择新建。PS:之前是直接把配置文件的默认端口改成服务器已有的22，但不知道为什么访问直接响应网页走丢 PS：下载nano 一种文本编辑器,其实用vim也一样 yum install nano //下载好之后直接 nano 文件名 //即可创建文件，然后Ctrl+O保存，Ctrl+X退出 修改了Nginx的配置文件nginx.conf后要重启Nginx：nginx -s reload出现错误： nginx: [error] open() &quot;/run/nginx.pid&quot; failed (2: No such file or directory) 执行其他命令：nginx或nginx -s stop也报错： 这是因为重启nginx后丢失nginx.pid，我们要先停止nginx，首先查询nginx的进程号 ps -ef | grep nginx 其中9011就是进程号了 从容停止nginx kill -QUIT 9011 在重启之前，我们先检查一下刚才的修改是否正确 nginx -t -c /etc/nginx/nginx.conf 正确的话再执行 nginx -c /etc/nginx/nginx.conf 最后重启 nginx -s reload 浏览器输入ip地址：47.107.237.149 出现这个页面就算成功，不过我们刚才在location下配置类index.html,那个实际是我们自己写在/home/git/blog/hexo下面的一个代替此页面的网页，所以看到那个网页也算对 本地 C://用户/14103/.ssh下Git Bash vim config 新建config文件并编辑 Host hexo #SSH主机配置的识别名，配置好后直接&quot;ssh 识别名&quot;即可快速连接 HostName 47.107.237.149 #SSH主机的地址 Port 22 #SSH主机端口 User git #用户，本例是Git IdentityFile ~/.ssh/id_rsa #私钥文件的存放地址，建议复制到~/.ssh下统一管理 然后修改E://hexo2/_config.yml deploy: type: git #用户名 repo: git@hexo:/home/git/blog/hexo.git #Git仓库地址，:符号后为Git仓库服务器路径；hexo可以换成服务器ip地址 branch: master #分支，由于我们只用Git进行发布，master即可 进入E://hexe2，执行 hexo clean &amp; hexo deploy -g //清除工作区加部署到git 浏览器访问 47.107.237.149:80 即可出现我的博客啦~","categories":[],"tags":[]},{"title":"","slug":"Hadoop（一）：Hadoop概述","date":"2019-04-30T08:25:44.867Z","updated":"2018-12-24T11:46:22.260Z","comments":true,"path":"2019/04/30/Hadoop（一）：Hadoop概述/","link":"","permalink":"http://47.107.237.149/2019/04/30/Hadoop（一）：Hadoop概述/","excerpt":"","text":"简介 Hadoop是Apache基金会开发的一个分布式系统基础架构。用户可以在不了解分布式底层细节的情况下开发分布式程序，充分利用集群的威力进行告诉运算和存储。 得名由来：开发者的女儿给一头黄色大象起的名字。 Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS，它有着高容错性的特性，并且设计用来部署在低廉的硬件上，提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集的应用程序。 Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，MapReduce为海量的数据提供了计算。 Hadoop是适合海量数据的分布式存储和分布式计算平台。 为什么HDFS不适合存储小文件？假如有一个100m的文件和100个1m的文件，在数据存储上面完全没有差异，但是在管理节点和元数据上面，一个100m的文件只有一份元数据信息，而后者却有100份，这会对管理节点造成非常大的压力，所以不适合存储大量的小文件。数据体积 bit、byte、kb、mb、gb、tb、…… 1byte=8bit 1kb=1024byte 1mb=1024kb存储方式 集中式存储：一个完整的数据都存储在一个存储介质中，数据的物理结构没有破坏，是完整的，比如一个100mb的数据存放在一块1t的硬盘中。 分布式存储：一个完整的数据存储在不同的存储介质中，数据的物理结构被破坏了，从逻辑上看同样是完整，比如一个100mb的数据，50mb存在A机器，30mb存在B机器，20mb存在C机器。为了保证数据的健壮性，需要对数据做冗余存储（备份）。而在分布式存储系统中，分散在不同节点中的数据可能属于同一个文件，为了组织众多的文件，可以把文件放在不同的文件夹中，文件夹可以一级一级包含。我们把这种组织形式成为命名空间(namespace)。命名空间管理着整个服务器集群中的所有文件。###计算方式 集中式计算：计算和数据在同一台机器的同一个进程中完成。1+…+1000=50500,需要10分钟。 分布式计算：机器A:1+…+100=A 1分钟 机器B:101+…+200=B 1分钟 …… 最终将所有机器的计算结果汇总到其中一台机器上，得到最终结果。四大模块 Hadoop Common：支持其他模块的公共组件。 Hadoop Distributed File System Hadoop TARN：任务调度和集群资源管理的框架 Hadoop MapResource：以YARN为基础的大数据并发处理系统。","categories":[],"tags":[]},{"title":"","slug":"Gson注解","date":"2019-04-30T08:25:44.861Z","updated":"2018-07-26T06:46:48.064Z","comments":true,"path":"2019/04/30/Gson注解/","link":"","permalink":"http://47.107.237.149/2019/04/30/Gson注解/","excerpt":"","text":"@SerializedName 主要应用在Gson解析json字符串时。Gson能直接将json字符串解析成java对象或者集合，也能将java对象转换为json字符串表示。例如有json数据如下： { &quot;id&quot;:&quot;1&quot; &quot;n&quot;:&quot;zhangsan&quot; &quot;p&quot;:&quot;123456&quot; &quot;s&quot;:&quot;0&quot; } 它能被解析到下面这个对象 public class User{ private String id; private String n; private String p; private string s; } 默认在字段名相同的字段间解析，所以User类必须要这样写才能直接使用Gson解析出来，但是java对象里的属性名和json里的字段名有时会不一样。Gson提供注解的方法来解决这个问题。 public class User{ private String id; @SerializedName(&quot;n&quot;) private String userName; @SerializedName(&quot;p&quot;) private String password; @SerializedName(&quot;s&quot;) private String sex; } Expose 通常与@SerializedName连用，当我们不想把某个属性包含到json中时可以用。 public class UserSimple { @Expose() String name; // equals serialize &amp; deserialize @Expose(serialize = false, deserialize = false) String email; @Expose(serialize = false) int age; @Expose(deserialize = false) boolean isDeveloper; // equals only serialize } 序列化的结果将只有name和isDeveloper出现在json中，因为serialize都是false。反序列化时，java对象将只会拥有json中的name和age，因为diserialze是true。","categories":[],"tags":[]},{"title":"","slug":"Gradle","date":"2019-04-30T08:25:44.846Z","updated":"2019-03-10T08:41:39.842Z","comments":true,"path":"2019/04/30/Gradle/","link":"","permalink":"http://47.107.237.149/2019/04/30/Gradle/","excerpt":"","text":"简介 Gradle是一个构建工具，用来帮助我们编译、打包App。 在代码师姐有三大构建工具，Ant、Maven和Gradle。 目前来说maven更成熟，资源更丰富；gradle灵活但资源少，实战经验不足。 maven使用基于xml的配置gradle采用了领域特定语言Groovy的配置。 在maven中要引入一个依赖，示例如下： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; 而在gradle在引入依赖： dependencies { compile(&apos;org.springframework:spring-core:2.5.6&apos;) compile(&apos;org.springframework:spring-beans:2.5.6&apos;) compile(&apos;org.springframework:spring-context:2.5.6&apos;) compile(&apos;com.google.code.kaptcha:kaptcha:2.3:jdk15&apos;) testCompile(&apos;junit:junit:4.7&apos;) } 安装 官网点击Install Gradle后选择最新版的Complete即可。 安装教程 目前是安装5.2.1版，目录为E:/gradle-5.2.1。","categories":[],"tags":[]},{"title":"","slug":"git协同开发","date":"2019-04-30T08:25:44.831Z","updated":"2018-08-25T02:56:47.132Z","comments":true,"path":"2019/04/30/git协同开发/","link":"","permalink":"http://47.107.237.149/2019/04/30/git协同开发/","excerpt":"","text":"仓库 在项目的开始到结束，我们会有两种仓库。一种是源仓库（origin），一种是开发者仓库。开发者仓库围绕着源仓库。源仓库 在项目的开始，项目的发起者构建起一个项目的最原始的仓库，我们把它称为origin。源仓库有两个作用： 汇总参与该项目的各个开发者的代码 存放趋于稳定和可发布的代码 源仓库应该是受保护的，开发者不应该直接对其进行开发工作。只有项目管理者（通常是项目发起人）能对其进行较高权限的操作。开发者仓库 上面说过，任何开发者都不会对源仓库进行直接的操作，源仓库建立以后，每个开发者需要做的事情就是把源仓库“复制”一份，作为自己日常开发的仓库。这个复制，也就是github上面的fork。 开发者在这个仓库中编码，提交到自己的仓库中。开发工作完成后，可以向源仓库发送pull request，请求源仓库把自己的代码合并进去。合并永久性分支 永久性分支是寿命无限的分支，存在于整个项目的开始、开发、迭代、终止过程中。永久性分支只有两个master和develop。 master：主分支从项目一开始便存在，它用于存放经过测试，已经完全稳定代码；在项目开发以后的任何时刻当中，master存放的代码应该是可作为产品供用户使用的代码。所以，应该随时保持master仓库代码的清洁和稳定，确保入库之前是通过完全测试和代码reivew的。master分支是所有分支中最不活跃的，大概每个月或每两个月更新一次，每一次master更新的时候都应该用git打上tag，说明你的产品有新版本发布了。 主分支从项目一开始便存在，它用于存放经过测试，已经完全稳定代码；在项目开发以后的任何时刻当中，master存放的代码应该是可作为产品供用户使用的代码。所以，应该随时保持master仓库代码的清洁和稳定，确保入库之前是通过完全测试和代码reivew的。master分支是所有分支中最不活跃的，大概每个月或每两个月更新一次，每一次master更新的时候都应该用git打上tag，说明你的产品有新版本发布了。 所有开发者开发好的功能会在源仓库的develop分支中进行汇总，当develop中的代码经过不断的测试，已经逐渐趋于稳定了，接近产品目标了。这时候，我们就可以把develop分支合并到master分支中，发布一个新版本。所以，一个产品不断完善和发布过程就正如下图： 注意，任何人不应该向master直接进行无意义的合并、提交操作。正常情况下，master只应该接受develop的合并，也就是说，master所有代码更新应该源于合并develop的代码。暂时性分支 feature：功能性分支，开发者的主要阵地。开发者从本地仓库的develop分支中分出此分支，开发完后再合并到develop上，然后删除此分支。 举例：我是一名开发者，已经把源仓库fork了，并且clone到了本地，现在要开发一个新功能discuss，我在本地仓库中可以这样做： 切换到develop分支 git checkout develop 分出一个功能性分支 git checkout -b feature-discuss 在功能性分支上进行开发之后，多次commit、测试之后…… 合并到develop git checkout develop git merge --no-ff feature-discuss #合并结果为Already up to date的话那说明两个分支内容要么一样要么合并失败，可以换到功能分支上合并develop分支，结果是Fast-forward就肯定成功 #把feature分支合并到develop git branch -d feature-discuss #删除功能性分支 git push origin develop #把develop提交到自己的远程仓库中 release：预发布分支，当产品即将发布的时候，要进行最后的调整和测试，这时候就可以分出一个预发布分支，进行最后的bug fix。测试完全以后，发布新版本，就可以把预发布分支删除。 hotfix：修复bug分支，当产品已经发布了，突然出现了重大的bug。这时候就要新建一个hotfix分支，继续紧急的bug修复工作，当bug修复完以后，把该分支合并到master和develop以后，就可以把该分支删除。 pull request 同步源仓库完整工作流","categories":[],"tags":[]},{"title":"","slug":"git安装","date":"2019-04-30T08:25:44.828Z","updated":"2018-08-30T11:55:58.366Z","comments":true,"path":"2019/04/30/git安装/","link":"","permalink":"http://47.107.237.149/2019/04/30/git安装/","excerpt":"","text":"参考文章，看安装部分就行了，安装完就直接能建工作空间了，什么ssh秘钥在GitHub已经设置好了","categories":[],"tags":[]},{"title":"","slug":"GitHub查看仓库SSH地址","date":"2019-04-30T08:25:44.824Z","updated":"2018-06-03T09:26:06.534Z","comments":true,"path":"2019/04/30/GitHub查看仓库SSH地址/","link":"","permalink":"http://47.107.237.149/2019/04/30/GitHub查看仓库SSH地址/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"git","date":"2019-04-30T08:25:44.816Z","updated":"2019-03-10T07:36:58.652Z","comments":true,"path":"2019/04/30/git/","link":"","permalink":"http://47.107.237.149/2019/04/30/git/","excerpt":"","text":"集中式版本控制系统 版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊 分布式版本控制系统 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统 创建版本库 版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 具体教程可以从廖雪峰网站-Git简介-创建版本库 所有的版本控制系统，其实只能跟踪文本文件的改动。不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可 创建本地版本库 //进入learngit git init 关联远程仓库 git remote add origin git@github.com:owenr/repository.git //origin：给仓库起名，后面是ssh地址，可在github仓库点击clone or dowmload获取 解除关联 git remote rm origin //origin是远程仓库在本地git中的名称 新建文件 touch filename //新建文件 vi filename //新建文件并编辑（文件已存在则直接编辑） 上传文件到仓库步骤(网站讲解章节：时光机穿梭) 编写文件（文本文件，不能是图片之类二进制文件）比如readme.txt 保存到仓库下（比如learngit） 告诉git你保存了这么个东西到仓库里面了： 在learngit文件夹里右键git bash here 在git bash here里面git add file,也就是说git add file的这个file必须是learngit里面有的 修改了文件并保存之后，用git diff readme.txt查看修改细节： git log只能查看commit的历史 执行git log 命令无法退出,按q退出历史记录列表即可重新输入其他命令 版本回退也可以是git reset –hard head(后面跟几个^)回到历史版本，前提是记得目标版本是要加几个^ 撤销修改其实有点类似于版本回退，只是版本回退是已经提交之后回退到分支里某个历史版本，而撤销修改是把工作区恢复到和版本库相同。 有时你git add之后又在工作区对文件进行了多次修改（但是都没有git add），这时执行git checkout – file就可以撤销在工作区做的所有修改 工作区和暂存区 git diff的比较 删除文件 新建一个文件并add+commit到版本库的分支里面 要删除的话，先将文件从工作区手动删除或rm file用命令行删除；这样，文件就从工作区被删除，但是版本库中还是有该文件 发现删错了，git checkout – file，撤销修改（这里是撤销删除操作） 要连版本库都删除的话，git rm file+commit;删错还可以版本回退，但是会丢失最近一次commit后的修改 cat file查看的是工作区或暂存区最新的版本 关联远程仓库 仓库最好同名，同名可以直接git push 一个本地仓库最好只关联一个远程仓库，不然同时向两个仓库push有难度 新建分支 git checkout 分支名（新建并切换到一个分支） 创建分支 创建并切换到新分支：git checkout -b 分支名称 之后add、commit等所有操作都是保存在新分支中的 未合并分支前切换回主分支的话，查看在新建分支修改过的文件，它仍然是未修改的模样，因为修改这个操作是在其他分支上，而且还为合并。 合并分支：git merge 其他分支 切换分支：git checkout 其他分支,切换到其他分支,切换后电脑上的文件也会跟着变成所在分支的样子 删除分支：git branch -d 分支合并冲突 两个分支都对同一个（注意是同一个）文件进行了修改，合并的时候就会出现冲突 解决冲突：手动修改文件（也就是选择保留一种修改），再提交，然后就可以合并了 出现冲突的文件片段： &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD public ModelAndView record1(@RequestParam(&quot;model&quot;)String model){ ======= public ModelAndView record1(@RequestParam(&quot;editor&quot;)String editor, @RequestParam(&quot;model&quot;)String model, @RequestParam(&quot;year&quot;)String year1){ int year=Integer.parseInt(year1); &gt;&gt;&gt;&gt;&gt;&gt;&gt; add_year 冲突标记&lt;&lt;&lt;&lt;&lt;&lt;&lt; （7个&lt;）与=======之间的内容是我的修改；=======与&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是别人的修改 修改完之后，git status会发现有未提交的修改，提交即大功告成 git commit -m &quot;……&quot; 用git log可以看到分支合并图 克隆远程仓库 在一个合适的目录下（不用新建文件夹，clone项目后会自动生成一个以项目名命名的文件夹来存放该项目）：git clone git@github.com:Eliyser/仓库.git 目前无法实现只复制指定目录的git功能。 不用再关联，直接git push -u origin master就把本地做的修改推送上去了（首次推需要-u）pull request 从别人那里fork来的仓库里点pull request，然后一路按按钮就可以请求把自己的仓库合并到别人的仓库里了，别人的仓库会自动提示主人我修改了什么东西，合并的时候也只合并修改的部分补充一个从创建版本库到push项目全过程创建版本库 手动或利用一下git命令创建一个新的文件夹,如learngit mkdir learngit cd learngit 新建的文件夹里只有feature分支 进入该文件夹后，将其变为版本库 git init git init之后只有master分支克隆项目进来 在learngit里面 git clone url 一般这个url都是自己的github仓库，然后这个github仓库一般是从别人（老大）的仓库fork来的，相信我，没人会直接让你动他的源仓库的！而且直接从别人的仓库clone项目下来，到最后开发完要把代码合并上去的时候，你没有人家的公钥，根本合并不上去，你开发了等于没开发。所以还是乖乖fork源仓库，clone项目下来，开发完合并回去，再pull request到源仓库等待审核吧。PS：pull request只能发起一次，而且只能在有fork关系的仓库之间发起开发 创建并切换到新分支上，如add_year git checkout -b add_year 可以每天关机前将改动add、commit到该分支 查看所有分支的话 git branch 开发完成后，切换回主分支,下来远程分支到master上 git checkout master git pull(结果是Already up-to-date) //和源仓库同步（可能出现合并冲突，如果合并功能分支的冲突可能较少的话建议先合并功能分支），未添加源仓库为本地远程仓库见“本地仓库同步到远程仓库”步骤 本地仓库同步到源仓库 先查询本地远程仓库 添加源仓库 再查看远程仓库目录 下面这三步相当于git pull upstream master 抓取源仓库的修改文件（应该可以指定分支，不指定的话抓取全部分支） git fecth upstream master 切换到另一个要同步的分支，比如master git checkout master 合并修改 放心吧，合并完了自己写的东西还在 此时本地仓库和源仓库已同步，但是远程仓库尚未同步，要同步需将master分支git push到远程仓库 合并分支，有冲突的话就把冲突文件改改 git merge add_year(结果是Fast-forward，有的时候好像up-to-date还是什么的也是对的，可以到github上查看master分支看文件是否已更新) 改完了再commit 推送到远程仓库 git push origin master 删除add_year分支 git branch -d add_year git常用命令 详细开发流程可以参见笔记：git协同开发异常 git push后出现rejected non-fast-forward错误 括号里也可能是你的commit信息，总之这些都表示git仓库中已经有一部分代码（好像readme.txt也算），所以它不允许你直接把你的代码覆盖上去。于是你有两种选择： 强制覆盖（有的时候真的不知道到底为什么就是push不上去就直接强推了）： git push -f origin master 先把git的东西fetch到本地来merge后再push git fetch git merge //等价于 git pull 上面这三行代码应该还会报错：你没有指定仓库和分支，那么我们可以指定默认的仓库和分支 git config branch.master.remote origin git config branch.master.merge refs/heads/master .gitignore 需要忽略什么文件都可以写到这个文件里面，这个文件用编辑器都建不出来，只能在Git Bash里建，建在根目录或者和src包同级都可以 格式： # 忽略的文件夹 target out # 忽略的文件，前面加！的话表示不要忽略 *.idea *.iml 如果忽略规则创建于代码提交之后，那么不会影响到已经提交的文件，需要删除的话执行以下命令 把远程项目拉下来 git pull 查看文件夹 dir 删除文件（夹）git rm -r –cached filename //cached应该是只删除远程库不删除本地库的意思 提交修改 git commit 推到远程库 git push 以上操作要在与远程库分支名相同的分支下操作，如过要删除develop分支下的文件夹，却在本地feature分支做了以上操作，那么要merge到develop分支并由它push。 参考文章 不然就把文件先搬到别的地方，加好忽略规则之后push一遍，最后把文件搬回来，这样本地的某些文件就不会出现在远程了。","categories":[],"tags":[]},{"title":"","slug":"forEach","date":"2019-04-30T08:25:44.812Z","updated":"2018-08-05T08:08:26.887Z","comments":true,"path":"2019/04/30/forEach/","link":"","permalink":"http://47.107.237.149/2019/04/30/forEach/","excerpt":"","text":"for(Student student:studentList){ System.out.println(student); }","categories":[],"tags":[]},{"title":"","slug":"Font类","date":"2019-04-30T08:25:44.797Z","updated":"2019-02-25T04:21:51.544Z","comments":true,"path":"2019/04/30/Font类/","link":"","permalink":"http://47.107.237.149/2019/04/30/Font类/","excerpt":"","text":"Font类 Font(Font font):由已知Font创建新font，就像复制黏贴一样 Font(String name,int style,int size):指定字体、样式和大小创建Font对象。其中name为字体名称，例如“Times New Roman”，“Arial Italic”,”宋体”等。 字体名称也可以加入字体样式。当字体名称中加入字体样式时，应当注意和参数字体样式组合的结果。当两者不互相矛盾时，最终显示效果为两者叠加的效果，例如 name = “Arial Italic”和 style = “Font.BOLD” 组合的显示效果为即是斜体又是粗体的效果，与 name = “Arial Bold Italic” 或者 style = “Font.BOLD + Font.ITALIC” 的效果相同。当两者相同时，例如 “Arial BOLD” 和 “Font.BOLD” 的组合效果并不会双倍加粗字体，斜体同理。当两者相互矛盾时，即 “Arial Bold” 和 “Font.PLAIN” 同时使用时，显示效果为加粗。 如果无法找到所要求的字体的样式，则字体系统可以通过相应的算法实现所要求的样式，例如要求倾斜，但相应字体没有可用的斜体外观，则会调用相关算法使字体倾斜。 如果无法找到要求的字体名称，则会使用默认字体，并且通过 getFontName() 得到的字体名称为 “Dialog.plain/Dialog.bold/Dialog.italic/Dialog.bolditalic”, 通过 getFamily() 得到的是 “Dialog”。 style：字体样式。常用的值为 Font.PLAIN, Font.BOLD, Font.ITALIC 三者的任意结合，用运算符连接，通常为加号，三者的值分别为 0, 1, 2, 组合后按运算出的值对应显示效果，结果为 3 时则是加粗加斜的字体，也可以直接给出字体样式相应的数字值对字体样式进行设置，当数值没有对应的字体样式时，显示效果为普通样式，即 Font.PLAIN. 常用字体样式： public static final int PLAIN = 0; public static final int BOLD = 1; public static final int ITALIC = 2 public static final int ROMAN_BASELINE = 0; //罗马字体的基线 public static final int CENTER_BASELINE = 1; //印度字的基线 public static final int HANGING_BASELINE = 2; //中文、日文等表意文字的基线 public static final int TRUETYPE_FONT = 0; public static final int TYPE1_FONT = 1; 常用方法 String getFamily() - 返回此字体系列的名称。 String getFontName() - 返回此字体外观的名称。 String getName() - 返回此字体的逻辑名称，注意此名称为字体的逻辑名称，即新建字体时第一个参数，即使计算机中无法找到此字体，该函数返回的依然是参数中指定的字体名称，也就是说，该函数返回的是新建字体时第一个参数的字符串值，即使字体名称中指定了字体系列的样式时，也会原封不动地返回。 int getSize() - 整数型式返回该字体磅值的大小。 float getSize2D() - 浮点数形式返回该字体磅值的大小。 int getStyle() - 返回此字体的样式，返回的整数与字体样式的对应关系见上文。 boolean isBold() - 返回此字体的样式是否为粗体，粗斜体时为真。 boolean isItalic() - 返回此字体的样式是狗为斜体，粗斜体时为真。 boolean isPlain() - 返回此字体的样式是否为普通。 String toString() - 将此 Font 对象转换为字符串（应该只打印其中不为null的属性。","categories":[],"tags":[]},{"title":"","slug":"File从创建到操作","date":"2019-04-30T08:25:44.786Z","updated":"2018-11-24T02:33:04.785Z","comments":true,"path":"2019/04/30/File从创建到操作/","link":"","permalink":"http://47.107.237.149/2019/04/30/File从创建到操作/","excerpt":"","text":"父路径+文件名 File(String parentPath,String child) File(File parentPath,String child) //在File对象中传入File对象，便于底层操作 绝对路径 File(String path) 没有路径（默认当前项目） File(String filename) 以当前项目构建 File(“./filename”) 以当前项目所在盘构建 File(/filename); 代码实例：myproject-&gt;src-&gt;cn.haien.io.File-&gt;testPath public static void main(String[] args) { String parentPath=&quot;E:/xp/test&quot;; String name=&quot;2.jpg&quot;; //1.父路径+文件名 File src=new File(parentPath,name); //文件路径+文件名 src=new File(new File(parentPath),name); //输出 System.out.println(src.getName()); //获取文件名 2.jpg System.out.println(src.getPath()); //获取文件路径 E:\\xp\\test\\2.jpg //2.绝对路径 src=new File(&quot;E:xp/test/2.jpg&quot;); System.out.println(src.getName()); // 2.jpg System.out.println(src.getPath()); // E:\\xp\\test\\2.jpg //3.没有路径（当前项目）直接构建 src=new File(&quot;test.txt&quot;); System.out.println(src.getName()); // test.txt System.out.println(src.getPath()); // test.txt，未传入路径构建则获取不到完整路径 System.out.println(src.getAbsolutePath()); // D:\\Eclipse\\myprojects\\myproject\\test.txt //以当前项目下文件夹“.”下文件构建 src=new File(&quot;./test.txt&quot;); System.out.println(src.getName()); // test.txt System.out.println(src.getPath()); // .\\test.txt System.out.println(src.getAbsolutePath()); // D:\\Eclipse\\myprojects\\myproject\\.\\test.txt //以项目所在盘构建 src=new File(&quot;/test.txt&quot;); System.out.println(src.getName()); // test.txt System.out.println(src.getPath()); // \\test.txt System.out.println(src.getAbsolutePath()); // D:\\test.txt } mkdir() 创建目录，若父目录不存在则创建失败 mkdirs() 创建目录，目录链不存在则一并创建 path=&quot;E:/xp/test/parent/new&quot;; src=new File(path); //src.mkdir(); src.mkdirs(); 查询目录下文件 path=&quot;E://xp/test&quot;; src=new File(path); if(src.isDirectory()) { System.out.println(&quot;该目录下文件名：&quot;); String[] subNames=src.list(); //获得文件夹下各文件名 for(String temp:subNames) { System.out.println(temp); } System.out.println(&quot;该目录下文件File对象：&quot;); File[] subFiles=src.listFiles(); for(File temp:subFiles) { System.out.println(temp.getAbsolutePath()); } System.out.println(&quot;打印子目录下java文件名：&quot;); //模板设计模式 subFiles=src.listFiles(new FilenameFilter() { /** * 重写了文件过滤器，返回为真时才将文件挑选出来，否则将剔除出listFiles * dir 代表src */ @Override public boolean accept(File dir, String name) { // TODO 自动生成的方法存根 return new File(dir,name).isFile()&amp;&amp;name.endsWith(&quot;.java&quot;); } }); for(File temp:subFiles) { System.out.println(temp.getAbsolutePath()); } } 递归输出子孙级目录（详述递归步骤） public static void printName(File src) { //所谓递归，就要先把第一层写出来--递归体 if(null==src||!src.exists()) { return; } System.out.println(src.getAbsolutePath()); //然后写递归头--递归条件 if(src.isDirectory()) { for(File sub:src.listFiles()) { printName(sub); //里面就是自己调用自己 } } } file.renameto(file): 重命名，但这个几乎不会成功，因为它是不能跨平台的，它无法将一个文件在不同文件系统之间移动，而即使在同一台计算机上文件系统也可能不同，新的文件名也可能代表着不同的文件系统，即使文件类型相同，所以最好不要用这个方法，可以使用Files.move(srcPath,desPath).","categories":[],"tags":[]},{"title":"","slug":"File","date":"2019-04-30T08:25:44.773Z","updated":"2018-04-06T13:21:04.501Z","comments":true,"path":"2019/04/30/File/","link":"","permalink":"http://47.107.237.149/2019/04/30/File/","excerpt":"","text":"概念 路径分隔符pathSparator就是个分号，名称分隔符separator就是个斜杠，但是在不同的系统上它表示为不同的方向，具有更好的移植性。 上面的推荐方式其实就是利用编译器将写好的斜杠转换为系统适配的（注意上面的斜杠不是写出来的，而是用编译器转换过来的）。 常用方法创建临时文件 文件存在10秒后执行deleteOnExit删除 判断文件方法 判断是文件还是文件夹 有三种情况，文件、文件夹、文件不存在 创建文件 mkdirs() 不管有几层父文件夹不存在，它都会一一创建出来 creatNewFile() 文件可能创建失败，所以会抛出异常，如：con是系统关键字，如果要创建名为con的文件则会失败；若文件已存在也会创建失败；创建失败返回false 删除文件 文件在使用中会删除失败 重命名 获取文件信息 length() 返回的是字节数，不能读取文件夹的长度","categories":[],"tags":[]},{"title":"","slug":"fastjson之toJSONString、parseObject和SerializerFeature类","date":"2019-04-30T08:25:44.758Z","updated":"2019-04-02T08:43:51.461Z","comments":true,"path":"2019/04/30/fastjson之toJSONString、parseObject和SerializerFeature类/","link":"","permalink":"http://47.107.237.149/2019/04/30/fastjson之toJSONString、parseObject和SerializerFeature类/","excerpt":"","text":"简介 fastjson是一个java编写的JSON处理器 依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;/dependency&gt; 常用的方法都是静态方法 public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArray public static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObject public static final &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz); // 把JSON文本parse为JavaBean public static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArray public static final &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz); //把JSON文本parse成JavaBean集合 public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本（即json格式的String） public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本 public static final Object toJSON(Object javaObject); 将JavaBean转换为JSONObject或者JSONArray。 JSONObject：就是常说的json，是一种重要的数据传输对象。 JSONObject可以转为Object，但是Object却不能转为JSONObject，只能转为json格式的String类型 格式：{“key”:”value”,”key”:”value”}；key必须是字符串，value是基本类型的话就不带引号 返回方式：一般是通过response.getWriter()获取PrintWriter printWriter，然后printWriter.print(json),如果没有设置好内容类型：response.setContentType(“application/json;charset=utf-8”);就要自己到js中再进行解析。 response.setContentType(&quot;application/json; charset=utf-8&quot;); PrintWriter pw = response.getWriter(); Student s = new Student(。。。);//反正就是构造一个对象，有没有数据无所谓 JSONObjet json = JSONObjet .from(s);//将s转化成json对象。 pw .print(json); pw .flush(); pw .close(); 这样这个json对象就传到你发送请求的那个jsp上面。 而$.post(url,datas.function(data){})这里的data就是后台返回的值，也就是这里的json 只需要 var json = data;//就获取到了。 再取得原来Student的属性 var name = json.name(student 的name 属性); JSONArray：由JSONObject构成的数组 格式：[{“key”:”value”,”key”:”value”},{“key”:”value”,”key”:”value”}];注意，最外面是中括号而不是花括号toJSONString()、parseObject() JSON.parseObject()：将json字符串转为相应的对象 JSON.toJSONString()：将对象转为json字符串，可同时传入一个SerializerFeature对象指定格式 JSONObject.getString(String key):根据key获取对应的值（任何类型都转为String），key不存在时抛NPE；以下为源码 public String getString( String key ) { verifyIsNull(); //应该是判断key是否为null Object o = get( key ); //获取key对应的值，不知道是什么类型，所以用Object接收 //如果值不为null if( o != null ){ return o.toString();//不管什么类型都转为String } //为null则抛异常 throw new JSONException( &quot;JSONObject[&quot; + JSONUtils.quote( key ) + &quot;] not found.&quot; ); } getInt(String key):获取对应值并转为int型，值为int型或“123”这样的字符串都可以，否则抛非数字异常。 public int getInt(String key) { verifyIsNull(); Object o = get(key); if (o != null) { //这里非数字的话会报非数字错误 return o instanceof Number ? ((Number) o).intValue() : (int) getDouble(key); } //无对应值的话 throw new JSONException(&quot;JSONObject[&quot; + JSONUtils.quote(key) + &quot;] is not a number.&quot;); } 首先引入fastjson的依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;${fastjson_version}&lt;/version&gt; &lt;/dependency&gt; 定义一个实体类 public class Staff { private String name; private Integer age; private String sex; private Date birthday; } 测试两个方法 public class jsonTest { public static void main(String[] args) { /** * json字符串转化为对象 */ String jsonString = &quot;{name:&apos;Antony&apos;,age:&apos;12&apos;,sex:&apos;male&apos;,telephone:&apos;88888&apos;}&quot;; //telephone是Staff没有的属性；另外还差个birthday属性 Staff staff = JSON.parseObject(jsonString, Staff.class); System.out.println(staff.toString()); //Staff{name=&apos;Antony&apos;, age=12, sex=&apos;male&apos;, birthday=null} /** * 对象转化为json字符串 */ String jsonStr = JSON.toJSONString(staff); System.out.println(jsonStr); //{&quot;age&quot;:12,&quot;name&quot;:&quot;Antony&quot;,&quot;sex&quot;:&quot;male&quot;}；age是基本类型，无双引号；为null的属性不显示 } } SerializerFeature类 主要用于将fastjson的格式进行调整，如是否要输出为null的字段、Date类型的显示格式等 属性 用法：直接加到toJSONString()的参数里就行，不加就用默认值，默认开就是开，不开就是不开 JSON.toJSONString(staff, SerializerFeature.PrettyFormat, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.DisableCircularReferenceDetect, SerializerFeature.WriteNullListAsEmpty) 参考文章:里面有更多属性的用法，靠后的黑图展示了多种属性的输出格式SerializeConfig类 对序列化过程做一些特殊配置，其实也就类似SerializerFeature类的补充 用法 public static SerializeConfig mapping=new SerializeConfig(); mapping.put(Date.class,new SimpleDateFormatSerialzer(&quot;yyyy-MM-dd&quot;); JOSN.toJSONString(staff,mapping); //假设staff有日期类属性那将会输出2018-11-3 SerialzeFilter接口 对每个属性定制序列化，比如当这个属性大于多少的时候才序列化，否则不用写到json里面了 它有多个子接口 PropertyPreFilter 根据PropertyName判断是否序列化； PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化； NameFilter 修改Key，如果需要修改Key，process返回值则可； ValueFilter 修改Value； BeforeFilter 序列化时在最前添加内容； AfterFilter 序列化时在最后添加内容。 PropertyFilter的源码 public interface PropertyFilter extends SerializeFilter { boolean apply(Object object, String propertyName, Object propertyValue); //true则序列化，否则不 } 用法 public static void main(String[] args) { PropertyFilter filter = new PropertyFilter() { @Override public boolean apply(Object source, String name, Object value) { // 属性是id并且大于等于100时进行序列化 if (name.equals(&quot;id&quot;)) { long id = ((Long) value).longValue(); return id &gt;= 100; } return false; } }; User user = new User(); user.setId(9L); user.setName(&quot;挖坑埋你&quot;); String jsonString = JSON.toJSONString(user, filter); // 序列化的时候传入filter System.out.println(&quot;序列化,id=9：&quot; + jsonString + &quot;\\n&quot;); // {} user.setId(200L); jsonString = JSON.toJSONString(user, filter); // 序列化的时候传入filter System.out.println(&quot;序列化,id=200：&quot; + jsonString); // {&quot;id&quot;:200} } 参考文章","categories":[],"tags":[]},{"title":"","slug":"FastDFS文件服务器","date":"2019-04-30T08:25:44.743Z","updated":"2018-11-18T06:42:40.971Z","comments":true,"path":"2019/04/30/FastDFS文件服务器/","link":"","permalink":"http://47.107.237.149/2019/04/30/FastDFS文件服务器/","excerpt":"","text":"为什么要将文件上传到服务器 对于传统项目来说，所有的静态资源比如文件等，都存储在一个Tomcat服务器上。 访问量较小时问题不大，但是对于互联网项目来说，这样一个Tomcat服务器远远不能满足需求。 既然一个不够，那么就部署Tomcat集群，有集群就需要负载均衡，一般使用Nginx来作为负载均衡服务器。 然而，Tomcat集群的缺点很明显。假如把一张图片上传到Tomcat1的images目录下，第一次用户请求访问这张图片时，Nginx把请求分发给Tomcat1处理，它能找到该图片，但如果第二次分发给了Tomcat2去处理，这时就找不到该图片了。作为用户体验，一次访问能看到，刷新一下又看不到，再刷新又看到了，实在很不美好。 为此，我们对集群做下改善，专门做一个图片服务器，将图片上传到该服务器，Tomcat本身并不保存图片。我们采用http的方式来访问图片，能作为http服务器的选择有多种 Tomcat：但是强项不在于处理静态资源，而是servlet&amp;jsp等动态请求。 Apache：但是逐渐式微。 Nginx：因其独特优势而火爆 我们就采用Nginx来统一管理http请求，而图片服务器选择FastDFS。 特别的，FastDFS存储资源的设备是按组来区分的，当存储空间不足时，便可以通过水平增加分组并相应添加设备来达到扩容的目的，成为FastFDS集群，而且无上限。另外一个优势是高可用，FastDFS集群能够做到当提供服务的Nginx发生故障时，自动切换到另一台Nginx上（当然也要有得切换），保障服务的稳定。 前端文件先上传到Tomcat的临时文件夹下 临时文件夹下的文件上传到ftp服务器 删除临时文件夹下的文件 不过作为练习，搭建单机版FastDFS即可。","categories":[],"tags":[]},{"title":"","slug":"executeQuery 、executeUpdate的用法","date":"2019-04-30T08:25:44.739Z","updated":"2018-05-15T05:31:16.145Z","comments":true,"path":"2019/04/30/executeQuery 、executeUpdate的用法/","link":"","permalink":"http://47.107.237.149/2019/04/30/executeQuery 、executeUpdate的用法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"","slug":"el表达式","date":"2019-04-30T08:25:44.727Z","updated":"2018-05-07T06:22:38.888Z","comments":true,"path":"2019/04/30/el表达式/","link":"","permalink":"http://47.107.237.149/2019/04/30/el表达式/","excerpt":"","text":"Expression Language 比如，${error },根据error去找到四大作用域里存放的key为error的值 常用param、cookie，其他直接$；在四大作用域里取值直接用$代替作用域.getAttribute(),更方便，用法${key } 代码示例：HeadFirstJspServletChap06-&gt;jsp文件，先写了个el1.jsp测试下四大作用域存取值，然后info.jsp接收请求参数 el表达式访问4种范围属性，寻找顺序：page-&gt;request-&gt;session-&gt;application，从page开始，page范围没找到就一级一级扩大范围找 提交到el2.jsp 从前台获取数据格式： 姓名：${param.name } 代码示例：el2.jsp 获取对象格式： 姓名：${zhangsan.name }（zhangsan为某个类的对象） 写完在右花括号那里下划线报错先不用理他，没错的 代码示例：el3.jsp 如何取集合？ 代码示例：el4.jsp el表达式运算符操作 算术运算符、关系运算符、逻辑运算符 三目运算符 empty关键字，${empty a }，如果在四个作用域里没有就是true 代码示例：el5.jsp","categories":[],"tags":[]},{"title":"","slug":"eclipse写H5乱码","date":"2019-04-30T08:25:44.724Z","updated":"2018-05-09T15:21:50.511Z","comments":true,"path":"2019/04/30/eclipse写H5乱码/","link":"","permalink":"http://47.107.237.149/2019/04/30/eclipse写H5乱码/","excerpt":"","text":"-文件头部都长这样就好了&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8”%&gt;&lt;!DOCTYPE html&gt;","categories":[],"tags":[]},{"title":"","slug":"eclipse快捷键","date":"2019-04-30T08:25:44.720Z","updated":"2018-04-23T15:05:26.635Z","comments":true,"path":"2019/04/30/eclipse快捷键/","link":"","permalink":"http://47.107.237.149/2019/04/30/eclipse快捷键/","excerpt":"","text":"ctrl+shift+/ 注释 ctrl+a 全选 ctrl+shift+f 格式化 单步调试快捷键被占用，只能使用调试视图下的图标按键","categories":[],"tags":[]},{"title":"","slug":"eclipse导入web项目","date":"2019-04-30T08:25:44.716Z","updated":"2018-07-15T02:34:56.045Z","comments":true,"path":"2019/04/30/eclipse导入web项目/","link":"","permalink":"http://47.107.237.149/2019/04/30/eclipse导入web项目/","excerpt":"","text":"导入项目 出现覆盖问题选择“全部为是” 到此，项目应该会有挺多报错的，下面看配置问题配置问题 检查lib下面的jar包是否都引进来了，然后对lib进行Build Path-&gt;Add to Build Path操作,出现jdk和服务器版本不合问题可选择“编辑”改为合适版本","categories":[],"tags":[]},{"title":"","slug":"DOM","date":"2019-04-30T08:25:44.713Z","updated":"2018-04-26T13:31:32.452Z","comments":true,"path":"2019/04/30/DOM/","link":"","permalink":"http://47.107.237.149/2019/04/30/DOM/","excerpt":"","text":"DOM主要是操作文档对象，文档即整个网页的HTML文档 整个网页其实是由节点组成的 缩进的话能直观的看出父子关系，不过一般只对里的子节点进行缩进 节点分为三类： 元素节点：其实就是标签，如， 文本节点：其实就是标签内的文字 属性节点：其实就是标签的属性，如，id 测试getElementById() 代码示例：E-&gt;js-&gt;dom基础.js 测试getElementsByTagName()-代码示例：E-&gt;js-&gt;dom基础2","categories":[],"tags":[]},{"title":"","slug":"DebugRun跳出Edit Configuration弹窗","date":"2019-04-30T08:25:44.709Z","updated":"2018-08-10T03:06:03.432Z","comments":true,"path":"2019/04/30/DebugRun跳出Edit Configuration弹窗/","link":"","permalink":"http://47.107.237.149/2019/04/30/DebugRun跳出Edit Configuration弹窗/","excerpt":"","text":"修改文件路径：重新选一下文件工作空间即可，这个也可以应付工作空间不存在的情况。 选择模块","categories":[],"tags":[]},{"title":"","slug":"Date时间格式转换","date":"2019-04-30T08:25:44.702Z","updated":"2018-12-01T08:23:04.256Z","comments":true,"path":"2019/04/30/Date时间格式转换/","link":"","permalink":"http://47.107.237.149/2019/04/30/Date时间格式转换/","excerpt":"","text":"参考文章 public static void main(String[] args) { //时间转字符串 Date currentTime=new Date(); DateFormat formatter=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); //模板可以多样 String dateString=formatter.format(currentTime); System.out.println(dateString); //2018-12-01 15:47:10 //字符串转时间 dateString=&quot;2018-12-1&quot;; DateFormat formatter2=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date currentTime2=null; try { //精确到日的时间字符串转为精确到秒的时间，报错 //currentTime=formatter.parse(dateString); currentTime2=formatter2.parse(dateString); } catch (ParseException e) { e.printStackTrace(); } //精确到日的时间字符串转为相同精度的时间再转回相同精度的时间 dateString=formatter2.format(currentTime2); System.out.println(dateString); //2018-12-01 //精确到日的时间字符串转为相同精度的时间再转回精确到秒的时间 dateString=formatter.format(currentTime2); System.out.println(dateString);//2018年12月01日 00:00:00 } 文章里还有获取一个月中的最后一天、单独得到现在的小时、得到两个日期间的间隔天数、把日期前移或后推多少分钟等等方法 代码实例：SpringbootIntegrateMybatis/test/java/DateFormatTest","categories":[],"tags":[]},{"title":"","slug":"C语言数据类型转换","date":"2019-04-30T08:25:44.689Z","updated":"2018-10-16T08:17:13.824Z","comments":true,"path":"2019/04/30/C语言数据类型转换/","link":"","permalink":"http://47.107.237.149/2019/04/30/C语言数据类型转换/","excerpt":"","text":"混合运算时的转换： 字符必须先转换为整数(C语言规定字符类型数据和整型数据之间可以通用) 。 short型转换为int型(同属于整型) 。 float型数据在运算时一律转换为双精度(double)型，以提高运算精度 无符号数和有符号数之间： 首先进行一个实验，分别定义一个signed int型数据和unsigned int型数据，然后进行大小比较： unsigned int a=20; signed int b=-130; a&gt;b?还是b&gt;a？实验证明b&gt;a，也就是说－130&gt;20,为什么会出现这样的结果呢？ 这是因为在C语言操作中，如果遇到无符号数与有符号数之间的操作，编译器会自动转化为无符号数来进行处理，因此a＝20，b＝4294967166，这样比较下去当然b&gt;a了。 再举一个例子： unsigned int a=20; signed int b=-130; std::cout&lt;&lt;a+b&lt;&lt;std::endl; 结果输出为4294967186，同样的道理，在运算之前，a＝20，b被转化为4294967166，所以a＋b＝4294967186 减法和乘法的运算结果类似。 如果作为signed int型数据的b=-130，b与立即数之间操作时不影响b的类型，运算结果仍然为signed int型： signed int b=-130; std::cout&lt;&lt;b+30&lt;&lt;std::endl; 输出为-100。","categories":[],"tags":[]},{"title":"","slug":"contentType","date":"2019-04-30T08:25:44.686Z","updated":"2018-07-31T02:43:47.532Z","comments":true,"path":"2019/04/30/contentType/","link":"","permalink":"http://47.107.237.149/2019/04/30/contentType/","excerpt":"","text":"MockMvc单元测试不设置contentType的话默认是application/x-www-form-urlencoded类型，也就是隐藏在url中那种键=值的形式。","categories":[],"tags":[]},{"title":"","slug":"Comparable和Comparator的区别","date":"2019-04-30T08:25:44.679Z","updated":"2018-10-23T09:38:51.075Z","comments":true,"path":"2019/04/30/Comparable和Comparator的区别/","link":"","permalink":"http://47.107.237.149/2019/04/30/Comparable和Comparator的区别/","excerpt":"","text":"其实都差不多。 基本类型大多都实现了Comparable接口，比较方式compareTo(T t)已经固定下来了。如果我们对原来的比较方式不满意的话，可以另外实现Comparator接口重写compare(T t1,T t2)。 其他类如果要实现自己的比较方式的话，推荐实现Comparable接口，不过由于泛型已经限定下来了，要比较也只能比较两个相同类的对象。比如说比较一下谁的年龄比较大之类的。 Comparator还可以作为一个外比较器，即不需在定义类的时候就实现它并重写compare()，这个比较器不依附于要比较的对象，它可以单独写单独用。详见：Java8已定义的函数式接口","categories":[],"tags":[]},{"title":"","slug":"Collator按照中文名排序","date":"2019-04-30T08:25:44.661Z","updated":"2018-10-02T09:01:04.139Z","comments":true,"path":"2019/04/30/Collator按照中文名排序/","link":"","permalink":"http://47.107.237.149/2019/04/30/Collator按照中文名排序/","excerpt":"","text":"用来排序中文姓名或者各种语言杂糅的对象集合 首先我们来设定数据，这就是待排序集合 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;李方&quot;); list.add(&quot;郭云2&quot;); list.add(&quot;郭云3&quot;); list.add(&quot;赵飞&quot;); list.add(&quot;马路&quot;); list.add(&quot;xxx&quot;); list.add(&quot;xxy&quot;); list.add(&quot;432&quot;); 然后定义一个比较器，实现比较规则 Comparator&lt;String&gt; comparator = new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { //传入两个比较对象 //获取默认的语言环境；也可指定，全是中文的话可以传个中文的类进去 Collator collator = Collator.getInstance(); //返回一个比较值；CollationKey是Collator用来将String元素转换成可以彼此比较位的类 return collator.getCollationKey(o1).compareTo( //小于返回负数，以此类推 collator.getCollationKey(o2)); } }; 调用Collections的sort方法，传入待排序集合和比较规则 Collections.sort(list, comparator); System.out.println(list); //[432, xxx, xxy, 郭云2, 郭云3, 李方, 马路, 赵飞]；默认把数字、字母放在前面 代码实例：SpringMvc02/test/TestCodeSeg","categories":[],"tags":[]},{"title":"","slug":"classpath根目录","date":"2019-04-30T08:25:44.644Z","updated":"2019-04-28T05:40:38.096Z","comments":true,"path":"2019/04/30/classpath根目录/","link":"","permalink":"http://47.107.237.149/2019/04/30/classpath根目录/","excerpt":"","text":"在编程的时候，就是放在src下面，和你自己创建的包同一级 在eclipse编译并发布到服务器端后，src路径对应WEB-INF路径，包中的.java文件对应 WEB-INF下的classes文件夹下即calsses/com/javaweb/environment/test/.class。 classPath即class类文件的根路径，所以发布前根路径是src,对应发布后的WEB-INF/classes/ 用maven构建项目的时候，classpath即src/main/下的resources、java和webapp。若在main下新建一个properties文件，则classpath也指该文件。 项目中文件加载pojo对象、其他文件的默认路径都是classpath，不需要加前缀，直接写包名即可，如： //加载pojo对象 &lt;context: component-scan base-package=&quot;com.taotao.controller&quot; /&gt; //加载其他文件 &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;context:property-placeholder location=&quot;classpath:resource/db.properties&quot; /&gt; 参考文章 编译后，classpath是指WEB-INF文件夹下的classes目录 解释classes含义： 存放各种资源配置文件，eg. init.properties,log4j.properties.struts.xml 存放模板文件，eg. actionerror.ftl 存放class文件，对应的是项目开发时的src目录的编译文件 总结：这是一个定位资源的入口 //加载classpath下以applicationContext开头的配置文件 &lt;param-value&gt;classpath:applicationContext-*.xml&lt;/param-value&gt; //加载其子目录下的文件 &lt;param-value&gt;classpath:context/conf/controller.xml&lt;/param-value&gt; **/：表示任意目录 **/applicationContext-.xml表示任意目录下以applicationContext开头的xml文件。 classpath和classpath*的区别","categories":[],"tags":[]},{"title":"","slug":"Cannot add or update a child row-a foreign key constraint fails","date":"2019-04-30T08:25:44.639Z","updated":"2018-05-19T14:56:55.891Z","comments":true,"path":"2019/04/30/Cannot add or update a child row-a foreign key constraint fails/","link":"","permalink":"http://47.107.237.149/2019/04/30/Cannot add or update a child row-a foreign key constraint fails/","excerpt":"","text":"可能插入了一个主表中并不存在的外键，这时候要检查这个外键在主表中是否存在","categories":[],"tags":[]},{"title":"","slug":"CallableStatement接口","date":"2019-04-30T08:25:44.637Z","updated":"2018-06-15T06:57:00.718Z","comments":true,"path":"2019/04/30/CallableStatement接口/","link":"","permalink":"http://47.107.237.149/2019/04/30/CallableStatement接口/","excerpt":"","text":"CallableStatement是prepareStatement的子接口 如何用程序调用存储过程呢？ 设置输入参数 设置返回参数 获取返回参数 代码实例：ideaProject-&gt;src.main.java.com.haien.MyCallableStatement","categories":[],"tags":[]},{"title":"","slug":"Cache和Buffer的区别","date":"2019-04-30T08:25:44.630Z","updated":"2019-03-20T13:55:52.104Z","comments":true,"path":"2019/04/30/Cache和Buffer的区别/","link":"","permalink":"http://47.107.237.149/2019/04/30/Cache和Buffer的区别/","excerpt":"","text":"Cache 高速缓存。 我们知道各种硬件存在制作工艺上的差别，所以当两种硬件需要交互时，肯定会存在速度上的差异，而且只有交互双方都完成了这一步才能同时解放去处理其他书屋。 假如现在有A、B两个设备，A用来交互的接口速度是1000M/s，B是500M/s，那么以下两种情况： A从B取一个1000M的文件原本需要1s，实际却需要2s，额外的1s是等待B把剩余的500M找出来，而这1s的空闲时间除了等待干不了其他事情。 A给B1000M文件也需要2s，本来也只需要1s,但B 1s内只能拿500M，剩下的500M还得等下一个1sB来取，等待的这1s也是不能干别的事。 解决的办法就是在A和B之间加一层区域ab，它提供了两个接口，a接口的速率接近A，b接口则接近B，然后我们把ab的a和A相连，b和B相连，让A、B把文件通过ab传给对方： A要从B中取1000M文件，它把需求告诉了ab，接下来ab通过b和B进行文件传送，对于第一次传送ab并没起什么作用，但第一次之后ab就背着B偷偷缓存了一个一模一样的文件，而且只要从B取东西，ab都会缓存一个副本下来，下次谁来取都直接把该副本通过a接口给它，由于a的速率相对接近A，所以A觉得节省了时间。说白了ab就是提供了缓存能力，即cache。ab会定期清cache以保证提供的东西是最新的。例如，CPU读取内存数据时，一般都是经过内存的一部分作为缓存来增加系统的读取性能。 A要给B发个1000M的文件，它通过a接口给了ab。站在A的角度上好像它认为已经交到B手上了，但其实ab并不先交给B，而是先缓存下来，等到系统空闲或buffer满了再通过b接口慢慢给B，这样A就不用等了。此时，ab提供的就是缓冲的能力，即Buffer。它存在的目的就是适用于速度快的往速度慢的输出东西，例如，内存的数据要写到磁盘，CPU寄存器里的数据写到内存。","categories":[],"tags":[]},{"title":"","slug":"Cache高速缓冲存储","date":"2019-04-30T08:25:44.622Z","updated":"2019-03-21T12:00:30.911Z","comments":true,"path":"2019/04/30/Cache高速缓冲存储/","link":"","permalink":"http://47.107.237.149/2019/04/30/Cache高速缓冲存储/","excerpt":"","text":"计算机中的缓存 存储器是计算机五大组成部分之一（控制器、运算器、存储器、输入和输出），分为主存储器和辅助存储器。 主存储器又称内存Memory，辅助存储器又称外存。 我们平时使用的程序，如Windows操作系统、打字软件、游戏软件，一般都是安装在硬盘等外存上的，使用时才将其调入内存运行。我们平时输入一段文字，或玩一个游戏，都是在内存中进行的。 就好比在一个书房里，外存相当于存放书籍的书架，内存则是我们工作的书桌。 内存是计算机程序与CPU进行沟通的桥梁，计算机中所有程序的运行都是在内存中进行的，其作用是战术存放CPU中的运算数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中。为了配合CPU的高速，内存和CPU之间还加了一层高速缓存。 通常我们把要永久保存的、大量的数据存储在外存，而把一些临时或少量的数据和程序放在内存。 程序中的缓存 当程序的并发量较高、对实时性的要求较高时，我们的程序就必须使用缓存了，否则，可能显示一个公司的报表、在搜索引擎上搜索资料都要花几分钟的时间。 使用缓存，就是在取出数据结果后，暂时将数据存储在某些可以快速存取的位置，如Nosql、MemoryCache，让这些耗时的数据重复地利用，不必每次重复请求相同的数据，读取时先从缓存中找，节省CPU和io。 缓存的终点在于更新，如果数据没有及时更新和删除，就会成为脏数据。 缓存策略 也就是用一些算法决定什么时候清缓存、清哪一部分。 缓存控制 在Java中，我们一般对方法进行缓存控制。当调用findUserById(long id)时，先从缓存查找有没有结果。没有再调用该方法从数据库加载用户，并添加到缓存中。下次调用前将会从缓存中获取数据。","categories":[],"tags":[]},{"title":"","slug":"c forEach","date":"2019-04-30T08:25:44.619Z","updated":"2018-05-03T12:01:12.494Z","comments":true,"path":"2019/04/30/c forEach/","link":"","permalink":"http://47.107.237.149/2019/04/30/c forEach/","excerpt":"","text":"-&lt;c:forEach var=”pow” items=”${power }”&gt; ${pow } &lt;/c:forEach&gt;在作用域比如request、session里面存了power这个集合，然后这边${power }取一下就可以遍历了","categories":[],"tags":[]},{"title":"","slug":"byte数组本质、0xff、String转byte[]原理","date":"2019-04-30T08:25:44.609Z","updated":"2019-02-23T05:49:46.416Z","comments":true,"path":"2019/04/30/byte数组本质、0xff、String转byte[]原理/","link":"","permalink":"http://47.107.237.149/2019/04/30/byte数组本质、0xff、String转byte[]原理/","excerpt":"","text":"0x（零叉）前缀表示后面的数为十六进制数，0（零）前缀表示八进制。 把number转换为二进制，只取最低的8位，也就是一个字节。而0xff二进制最后8位就是1111 1111，前面全是0。将number &amp; 0xff，只有最后8位被显示出来，前面无论是0是1最后都是0，被遮蔽。 byte的本质就是一个8位的二进制数字，即表示从0~255的一个数字，所以byte数组中存的是数字。比如，byte[] byteArrary = { 0x01, 0x02, 0x03, 34 };其中，int型常量不能超过255，若将34改为340则报错，而int型变量不允许存入，原因是变量是不确定的，它可能超过了255。 String转byte[]，就是先转ASCII码，然后再转成二进制，如，A-&gt;65-&gt;65的二进制表示.","categories":[],"tags":[]},{"title":"","slug":"BufferedImage类、Image类、Graphics类","date":"2019-04-30T08:25:44.600Z","updated":"2019-02-10T02:35:03.455Z","comments":true,"path":"2019/04/30/BufferedImage类、Image类、Graphics类/","link":"","permalink":"http://47.107.237.149/2019/04/30/BufferedImage类、Image类、Graphics类/","excerpt":"","text":"BufferedImage Image是一个抽象类，BufferedImage是其实现类，是一个带缓冲区图像类，主要作用是将一幅图片加载到内存中（BufferedImage生成的图片在内存里有一个图像缓冲区，利用这个缓冲区我们可以很方便地操作这个图片），提供获得绘图对象、图像缩放、选择图像平滑度等功能，通常用来做图片大小变换、图片变灰、设置透明不透明等。 public abstract Graphics getGraphics()； //获得在图像上绘图的Graphics对象 Java将一幅图片加载到内存的方法是： String imgPath = &quot;C://demo.jpg&quot;; BufferedImage image = ImageIO.read(new FileInputStream(imgPath)); 继而可以对图片进行操作,比如，获得图片的宽度：image.getWidth() 图片只有加载到内存中才能进行进一步的处理。 RGB:R（红）G（绿）B（蓝）色彩模式是工业界的一种颜色标准。在Java中每个RGB像素所占的位数为8. 创建： 直接调用构造函数 //指定宽高、图像字节灰度 BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY) //创建一个不带透明色的对象 BufferedImage bimage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //创建一个带透明色的对象 new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB); - 根据已经存在的BufferedImage对象创建一个copy体 public BufferedImage createBufferedImage(BufferedImage src) - 通过创建ColorModel（颜色转换为Java中的像素表示）和Raster（光栅，描述像素的）对象创建BufferedImage对象 public BufferedImage createBufferedImage（int width , int height, byte[] pixels）{ //pixel像素 ColorModel cm = getColorModel(); SampleModel sm = getIndexSampleModel((IndexColorModel)cm, width,height); DataBuffer db = new DataBufferByte(pixels, width*height,0); WritableRaster raster = Raster.creatWritableRaster(sm, db,null); BufferedImage image = new BufferedImage (cm, raster,false, null); return image; } - 读取一个图片文件来转换. BufferedImage image = ImageIo.read(new FileInputStream(filePath)); 保存：找个位置写出去 File outputfile = new File(&quot;save.png&quot;); ImageIO.write(bi,&quot;png&quot;,outputfile); Raster和ColorModel对象、BufferedImage的创建与保存ImageIO 提供read()和write()静态方法，读写图片，比以往的InputStream读写更方便。BufferedImage与byte数组的转换 在传输中，图片是不能直接传的，需要先转为字节数组再传输较为方便；而字节数组再转回BufferedImage则还原图片。 BufferedImage–&gt;byte[] ImageIO.write(BufferedImage image,String format,OutputStream out); //format:图片格式，“gif&quot;等； //out:目标；特别的，如果目标为byte数组，则将其预设为ByteArrayOutputStream即可传入此方法，执行完后，只要toByteArray()即可获得byte[]. byte[]–&gt;bufferedImage ByteArrayInputStream in = new ByteArrayInputStream(byte[]b); //将b作为输入流； BufferedImage image = ImageIO.read(InputStream in); //将in作为输入流，读取图片存入image中，而这里in可以为ByteArrayInputStream(); 参考文章应用 缓存网络图片 //获得图片地址 Url img = new URL(url); //获得图片输入流 InputStream in = img.openStream(); //把输入流转为BufferedImage JPEGImageDecoder decoderFile = JPEGCodec.createJPEGDecoder(in); BufferedImage image = decoderFile.decodeAsBufferedImage(); //获得其byte数组 ImageIO.write(image, &quot;jpg&quot;, bos); //写出 InputStream is = new ByteArrayInputStream(os.toByteArray()); 具体测试与改动 URL url = new URL(&quot;http://www.google.com/intl/en_ALL/images/logo.gif&quot;); BufferedImage image = ImageIO.read(url); ByteArrayOutputStream os = new ByteArrayOutputStream(); ImageIO.write(image, &quot;gif&quot;, os); InputStream is = new ByteArrayInputStream(os.toByteArray()); Graphics 提供基本绘图和显示格式化文字的方法，画图用的坐标系原点在左上角，纵轴向下。主要有画线段、矩形、圆、椭圆、圆弧、多边形等各种颜色的图形、线条。 Graphics2D类提供更强大的绘图能力。 在窗口画一条直线：drawLine(int x1,int y1,int x2,int y2) g.drawLine(3,3,50,50);//在(3,3)与(50,50)之间画一条线段 g.drawLine(100,100,100,100);//画一个点 画折线：drawPolyline(int[],int[],int)，各点的x、y坐标，折线数。 画字符串：drawString(String str,int x,int y)，x、y是开始显示的位置，使用默认字体、大小、黑色。再写下一行要写在什么位置就很难精确定位了。若要精确定位，则需要知道字符串显示的长度和字高，可以通过FontMetrics类来实现。 FontMetrics fm = g.getFontMetrics(font); //从Graphics对象获取FontMetrics对象 int height = fm.getHeight(); //调用其getHeight()获得字高 int width = fm.stringWidth(s1); //获得字符串宽度 应用FontMetrics精确定位 String s1 = &quot;Hello, Java World!&quot;; g.setColor(Color.red); setBackground(new Color(0,255,0)); Font font = new Font(&quot;Arial&quot;, Font.BOLD, 18); g.setFont(font); FontMetrics fm = g.getFontMetrics(font); int height = fm.getHeight(); int width = fm.stringWidth(s1); int posx =50; int posy = 50; g.drawString(s1 ,posx, posy); g.drawString(&quot;I will come in.&quot; ,posx +width, posy+height); 显示效果 设置画笔字体：setFont(Font font)；Java有一个类叫GraphicsEnvironment提供绘图环境，其中getAvailableFontFamilyNames()方法可获取程序所在操作系统的所有字体名（是String不是Font）。 GraphicsEnvironment gv = GraphicsEnvironment.getLocalGraphicsEnvironment(); String[] ftNames = gv.getAvailableFontFamilyNames(); for (int i=0; i&lt;ftNames.length; i++) Font ft = new Font(ftNames[i], Font.BOLD, 14); 设置前景色（画笔颜色）：setColor(Color color)，选择颜色有两种方法，一是直接用颜色值RGB创建Color对象：Color color=new Color(int R,int G,int B),由于是8位，所以不能超过255;二是用颜色常量如Color.red,Color.green等，Color类提供了13中颜色常量。 设置背景色：setBackground(new Color(int,int,int)) 来个写不同字体的小例子 public void paint (Graphics g){ String s1 = &quot;This Font is &quot;; Font font = new Font(&quot;Arial&quot;, Font.BOLD, 18); g.setColor(Color.red); setBackground(new Color(0,255,0)); g.setFont(font); g.drawString(s1 + font.getName() ,20, 60); g.setFont(new Font(&quot;隶书&quot;, Font.BOLD, 28)); g.drawString(&quot;现在是隶书&quot; ,20, 120); g.setColor(new Color(0,0,0)); } 显示效果 画矩形：drawRect(int x,int y,int width,int height),画矩形线框，x,y指定了左上角位置，后两个为矩形宽高；fillRect(iny x.int y,int width,int height),指定填充颜色。 g.drawRect(80,100,40,25);//画线框 g.setColor(Color.yellow);g.fillRect(20,70,20,30);//画着色块 画圆角矩形：drawRoundRect(int x,int y,int width,int height,int arcWidth,int arcHeight),线框，最后两个宽高是圆角弧的横向直径和纵向直径；fillRoundRect(int x,int y,int width,int height,int arcWidth,int arcHeight),颜色填充。 g.drawRoundRect(10,10,150,70,40,25);//画一个圆角矩形 g.setColor(Color.blue); g.fillRoundRect(80,100,100,100,60,40);//涂一个圆角矩形块 g.drawRoundRect(10,150,40,40,40,40);//画圆 g.setColor(Color.red); g.fillRoundRect(80,100,100,100,100,100);//画圆块 画三维矩形: draw3DRect(int x,int y,int width,int height,boolean raised),画一个突出显示的矩形（即3D矩形），raise是突出与否；fill3DRect(int x,int y,int width,int height,boolean raised)，颜色填充。 g.draw3DRect(80,100,40,25,true);//画一个线框 g.setColor(Color.yellow); g.fill3DRect(20,70,20,30,true);//画一个着色块 画椭圆：drawOval(int x,int y,int width,int height),x、y是中心坐标，长轴、短轴；fillOval(int x,int y,int width,int height),填充。 画圆弧：drawArc(int x,int y,int width,int height,int startAngle,int arcAngle),画椭圆一部分的圆弧线，椭圆中心时它的外接矩形的中心，外接矩形左上角坐标为(x,y)，宽width，高height，startAngle单位是度，其实角度0度是指3点钟方向，startAngle和arcAngle表示从startAngle角度开始，逆时针方向画arcAngle度的弧，约定，正值度数是逆时针方向，负数为顺时针，例如-90°是6点钟方向；fillArc(int x,int y,int width, int height, int startAngle, int arcAngle)，着色。 g.drawArc(10,40,90,50,0,180);//画圆弧线 g.drawArc(100,40,90,50,180,180);//画圆弧线 g.setColor(Color.yellow); g.fillArc(10,100,40,40,0,-270);//填充缺右上角的四分之三的椭圆 g.setColor(Color.green); g.fillArc(60,110,110,60,-90,-270);//填充缺左下角的四分之三的椭圆 画多边形：drawPolygon(int xPoints[],int yPoints[],int nPoints),多边形是多条线段首尾连接而成的封笔平面图，多边形线段端点的x,y坐标存储在两个数组中，画多边形就是按给定的坐标点顺序用直线段将它们连起来，nPoints是坐标点个数；fillPolygon(int xPoints[],int yPoints[],int nPoints)，着色。 int px1[]={50,90,10,50};//首末点相重,才能画多边形 int py1[]={10,50,50,10}; int px2[]={140,180,170,180,140,100,110,140}; int py2[]={5,25,35,45,65,35,25,5}; g.setColor(Color.blue); g.fillPolygon(px1,py1,4); g.setColor(Color.red); g.drawPolygon(px2,py2,9); 也可以用多边形对象Polygon画多边形 Polygon()：创建多边形对象，暂时没有坐标点。 Polygon(int xPoints[],int yPoints[],int nPoints)：用指定的坐标点创建多边形对象。 addPoint()：将一个坐标点加入到Polygon对象中。 drawPolygon(Polygon p)：绘制多边形。 fillPolygon(Polygon p)：和指定的颜色填充多边形。 画一个三角形 int x[]={140,180,170,180,140,100,110,100}; //用多边形对象不要求首末点重合 int y[]={5,25,35,45,65,45,35,25}; Polygon ponlygon1=new Polygon(); polygon1.addPoint(50,10); polygon1.addPoint(90,50); polygon1.addPoint(10,50); g.drawPolygon(polygon1); g.setColor(Color.yellow); Polygon polygon2 = new Polygon(x,y,8); g.fillPolygon(polygon2); 画图片：drawImage(Image image,int x,int y) 擦除矩形块：clearREct(int x,int y,int width,int height),当需要在一个着色图形中有一个空缺的矩形时，可用背景色填充一矩形块实现，相当于在该图形上使用了橡皮擦。以下代码实现了在一个圆中擦除了一个矩形块 g.setColor(Color.blue); g.fillOval(50,50,100,100);g.clearRect(70,70,40,55); 限定作图显示区域：clipRect(int x,int y,int width,int height),用一个矩形表示图形的显示区域，超出部分不显示，多个限制区有覆盖时，得到交集区域 g.clipRect(0,0,100,50);g.clipRect(50,25,100,50); 复制图形：copyArea(int x,int y,int width,int height,int dx,int dy),dx和dy表示将图形复制到原位置偏移的像素点数，正值为往右或往下偏移，负值为往左或往上偏移，x、y是要复制矩形区域的左上角坐标。以下代码将一个矩形的部分、另一个矩形的全部分别平移 g.drawRect(10,10,60,90); g.fillRect(90,10,60,90); g.copyArea(40,50,60,70,-20,80); g.copyArea(110,50,60,60,10,80); 对Point、Rectangle类的应用 Point p = new Point(cx / 2, cy / 2); //定义一个点 Rectangle rect = new Rectangle((p.x - 40), (p.y - 40), 80, 40); //定义一个矩形 int[] xP = {(p.x - 40), (p.x + 90), p.x+200, (p.x - 40)}; int[] yP = {(p.y - 40), (p.y +140), (p.y + 60), (p.y-40)}; g.drawArc(rect.x, rect.y, rect.width, rect.height * 2, 270, 90); //画弧 g.drawPolygon(xP, yP,3); //画多边形 g.setColor(Color.red); 画图形方法代码实例 github/image_verifyCode分支/thz-parent/thz-manager-web/WebPageController、thz-common/tool/RandomValidateCodeUtil、RandomValidateCodeUtilTest","categories":[],"tags":[]},{"title":"","slug":"Boot","date":"2019-04-30T08:25:44.597Z","updated":"2019-03-18T09:21:41.585Z","comments":true,"path":"2019/04/30/Boot/","link":"","permalink":"http://47.107.237.149/2019/04/30/Boot/","excerpt":"","text":"boot是系统引导文件。 也解作Build Own Operate Transfer,即创建、拥有、运营和移交。","categories":[],"tags":[]},{"title":"","slug":"BCrypt加密算法","date":"2019-04-30T08:25:44.593Z","updated":"2019-02-06T01:30:40.963Z","comments":true,"path":"2019/04/30/BCrypt加密算法/","link":"","permalink":"http://47.107.237.149/2019/04/30/BCrypt加密算法/","excerpt":"","text":"BCrypt算法与md5、sha算法主要区别为，每次生成的密文（hash）都是不同的，这样暴力猜解起来要更困难一点，而且密文长度较长，为60位。 使用方法： BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String hashedPassword = passwordEncoder.encode(password); //hashedPassword即为密文 参考文章","categories":[],"tags":[]},{"title":"","slug":"a标签添加onclick事件","date":"2019-04-30T08:25:44.589Z","updated":"2018-05-10T10:48:32.279Z","comments":true,"path":"2019/04/30/a标签添加onclick事件/","link":"","permalink":"http://47.107.237.149/2019/04/30/a标签添加onclick事件/","excerpt":"","text":"a href=”javascript:void(0);” onclick=”js_method()” a href=”javascript:;” onclick=”js_method()” a href=”#” onclick=”js_method();return false;” 参考地址","categories":[],"tags":[]},{"title":"","slug":"assert","date":"2019-04-30T08:25:44.586Z","updated":"2018-06-03T01:29:08.013Z","comments":true,"path":"2019/04/30/assert/","link":"","permalink":"http://47.107.237.149/2019/04/30/assert/","excerpt":"","text":"assert()宏是用于保证满足某个特定条件，用法是： assert(表达式); 如果表达式的值为假，整个程序将退出，并输出一条错误信息。如果表达式的值为真则继续执行后面的语句。 使用这个宏前需要包含头文件assert.h 注意： 每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败 不能使用改变环境的语言，因为assert只在debug时生效，如果这么做，会使程序在真正运行时遇到问题。如，assert（i++&lt;100）","categories":[],"tags":[]},{"title":"","slug":"ArrayList.this类名.this何意","date":"2019-04-30T08:25:44.570Z","updated":"2018-10-23T14:04:58.451Z","comments":true,"path":"2019/04/30/ArrayList.this类名.this何意/","link":"","permalink":"http://47.107.237.149/2019/04/30/ArrayList.this类名.this何意/","excerpt":"","text":"ArrayList的源码中，有一个实现了Iterator接口的内部类Itr，其中有两个elementData变量，一个是内部类的属性，一个是外部类的，那么外部类的就必须标识为ArrayList.this.elemtData 注意，不是this.elementData，因为外部类的对象是不能调用内部类的，所以只能用类名.this来区别内部类和外部类的属性。 //内部类 private class Itr implements Iterator&lt;E&gt; { transient Object[] elementData; @SuppressWarnings(&quot;unchecked&quot;) public E next() { //同名变量 Object[] elementData = ArrayList.this.elementData; } }","categories":[],"tags":[]},{"title":"","slug":"Apache POI","date":"2019-04-30T08:25:44.556Z","updated":"2018-09-08T08:30:26.970Z","comments":true,"path":"2019/04/30/Apache POI/","link":"","permalink":"http://47.107.237.149/2019/04/30/Apache POI/","excerpt":"","text":"简介 一种用java代码读写文档（Excel、word、PPT）的方式读写Excel方面 针对不同的Excel版本，要采用不同的工具类。 HSSFWorkbook：操作Excel2003以前的版本，扩展名为.xls XSSFWorkbook：操作2007的版本，扩展名是.xlsx 如果版本匹配错了，会抛出异常： org.apache.poi.openxml4j.exceptions.InvalidOperationException org.apache.poi.poifs.filesystem.OfficeXmlFileException 从POI 3.8版本开始，提供了一种基于XSSF的低内存占用的API—-SXSSF 当数据量超出65536条后，在使用HSSFWorkbook或XSSFWorkbook，程序会报OutOfMemoryError：Javaheap space;内存溢出错误。这时应该用SXSSFworkbook。参考文章读取各种文档的类 HSSF–读写.xls格式文档 XSSF–读写.xlsx格式文档 HWPF–读写.doc格式文档 HSLF–读写PPT工作簿概念 打个比方，工作簿就像一本书或者一本账册，工作表就像其中的一张或一篇。工作簿中包含一个或多个工作表，工作表依托于工作簿存在。 新建Excel文档（.xls)其实就是新建工作簿,然后在里面可以有sheet1、sheet2等等。代码实例 一个较为复杂的例子 public void excel() throws Exception{ String excelName = year+&quot;泛珠赛全国总决赛终评评委打分审核表(&quot;+model+&quot;)&quot;; //工作簿名称 Workbook wb = new HSSFWorkbook(); Map&lt;String, CellStyle&gt; styles = createStyles(wb); //设置各种单元格对应的样式 for (int i = 0; i &lt; pingweiList.size(); i++) { //创建Excel表格 CreatePingweiScore(wb, styles, headers,pingweiList.get(i), model,year); } // 写出 String file = excelName+&quot;.xls&quot;; //文件命名 FileOutputStream out = new FileOutputStream(file); wb.write(out); out.close(); } /* * 设置各种单元格对应的样式 * （基本上样式都是应用于单元格的，没见过应用在行上的顶多设置下行高这样） */ private static Map&lt;String, CellStyle&gt; createStyles(Workbook wb){ Map&lt;String, CellStyle&gt; styles = new HashMap&lt;&gt;(); CellStyle style; /*设置标题格式*/ Font titleFont = wb.createFont(); //字号 titleFont.setFontHeightInPoints((short)18); //加粗 titleFont.setBold(true); //设置单元格样式 style = wb.createCellStyle(); //水平居中 style.setAlignment(HorizontalAlignment.CENTER); //垂直居中 style.setVerticalAlignment(VerticalAlignment.CENTER); //将字体样式加入到样式当中 style.setFont(titleFont); //将样式应用到标题当中 styles.put(&quot;title&quot;, style); /*设置表头格式*/ Font monthFont = wb.createFont(); monthFont.setFontHeightInPoints((short)11); monthFont.setBold(true); //字体颜色 monthFont.setColor(IndexedColors.BLACK.getIndex()); style = wb.createCellStyle(); style.setAlignment(HorizontalAlignment.CENTER); style.setVerticalAlignment(VerticalAlignment.CENTER); style.setFont(monthFont); //自动换行 style.setWrapText(true); //应用到表头 styles.put(&quot;header&quot;, style); /*设置单元格*/ CellStyle cellStyle = wb.createCellStyle(); cellStyle.setAlignment(HorizontalAlignment.CENTER); cellStyle.setWrapText(true); //右边框 cellStyle.setBorderRight(BorderStyle.THIN); //右边框颜色 cellStyle.setRightBorderColor(IndexedColors.BLACK.getIndex()); cellStyle.setBorderLeft(BorderStyle.THIN); cellStyle.setLeftBorderColor(IndexedColors.BLACK.getIndex()); cellStyle.setBorderTop(BorderStyle.THIN); cellStyle.setTopBorderColor(IndexedColors.BLACK.getIndex()); cellStyle.setBorderBottom(BorderStyle.THIN); cellStyle.setBottomBorderColor(IndexedColors.BLACK.getIndex()); //应用到单元格 styles.put(&quot;cell&quot;, cellStyle); return styles;//styles：应用单元-单元属性的Map集合 } /* * 设置Excel表格 */ private int CreatePingweiScore(Workbook wb, Map&lt;String, CellStyle&gt; styles, String[] headers,String pid, String model,int year){ //所有作品的分 List&lt;PingweiScore&gt; pingweiScoreList = pingweiScoreService.selectByPidAndModelAndYear(pid,model,year); String titleName = year+&quot;泛珠赛全国总决赛终评评委打分审核表(&quot;+model+&quot;)&quot;; String pingweiName = &quot;评委&quot;+pid; //打印设置 Sheet sheet = wb.createSheet(pingweiName); //pingweiName为表名 PrintSetup printSetup = sheet.getPrintSetup(); printSetup.setLandscape(true); //true表示页面方向为横向，false为纵向 sheet.setFitToPage(true); sheet.setHorizontallyCenter(true); //title row Row titleRow = sheet.createRow(0); titleRow.setHeightInPoints(45); Cell titleCell = titleRow.createCell(0); titleCell.setCellValue(titleName); titleCell.setCellStyle(styles.get(&quot;title&quot;)); sheet.addMergedRegion(CellRangeAddress.valueOf(&quot;$A$1:$J$1&quot;)); //从A1到J1单元格合并；可以直接CellRangeAddress（起始行，终止行，起始列，终止列） //Second row Row secondRow = sheet.createRow(1); secondRow.setHeightInPoints(40); //行高 Cell secondCell = secondRow.createCell(0); secondCell.setCellValue(&quot;评委编号：&quot;+pid+&quot; 评委签名：&quot;); secondCell.setCellStyle(styles.get(&quot;header&quot;)); //设置单元格样式 sheet.addMergedRegion(CellRangeAddress.valueOf(&quot;$A$2:$J$2&quot;)); //合并单元格，前面设置的样式都应用到了这些单元格上了 //header row Row headerRow = sheet.createRow(2); headerRow.setHeightInPoints(40); Cell headerCell; for (int i = 0; i &lt; headers.length; i++) { headerCell = headerRow.createCell(i); headerCell.setCellValue(headers[i]); headerCell.setCellStyle(styles.get(&quot;header&quot;)); } //评委分数 int rownum = 3; //前三列为固定值先不管 for (int i = 0; i &lt; pingweiScoreList.size(); i++) { Row row = sheet.createRow(rownum++); for (int j = 0; j &lt; headers.length; j++) { Cell cell = row.createCell(j); //逐项分数写入 switch (j){ case 0: cell.setCellValue(pingweiScoreList.get(i).getProId());break; case 1: cell.setCellValue(pingweiScoreList.get(i).getBianHao());break; case 2: cell.setCellValue(pingweiScoreList.get(i).getProName());break; case 3: cell.setCellValue(pingweiScoreList.get(i).getOption1());break; case 4: cell.setCellValue(pingweiScoreList.get(i).getOption2());break; case 5: cell.setCellValue(pingweiScoreList.get(i).getOption3());break; case 6: cell.setCellValue(pingweiScoreList.get(i).getOption4());break; case 7: cell.setCellValue(pingweiScoreList.get(i).getOption5());break; case 8: cell.setCellValue(pingweiScoreList.get(i).getOption6());break; case 9: cell.setCellValue(pingweiScoreList.get(i).getTotalScore());break; } } } //所有行第1~3列的宽度，分别用来填写序号、作品编号和作品名称 sheet.setColumnWidth(0, 10*256); //10 characters wide sheet.setColumnWidth(1, 10*256); //10 characters wide sheet.setColumnWidth(2, 30*256); //30 characters wide //后面列的宽度 for (int i = 3; i &lt; headers.length; i++) { sheet.setColumnWidth(i, 9*256); //9 characters wide } return 0; } 其中write(Outputstream)为HSSFWork唯一写出方法 一些样式设置参考解析Excel保存到数据库public class ResolveExcelServiceImpl implements ResolveExcelService { private static final String SUFFIX_2003=&quot;.xls&quot;; private static final String SUFFIX_2007=&quot;.xlsx&quot;; @Override public List&lt;Works&gt; resolveExcel(MultipartFile file) throws BusinessException { List&lt;Works&gt; list=new ArrayList&lt;Works&gt;(); if(file==null){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;文件不存在！&quot;); } //获取文件名 String originalFilename=file.getOriginalFilename(); Workbook workbook=null; //判断格式 try{ if(originalFilename.endsWith(SUFFIX_2003)){ /* getInputStream()返回InputStream 经测试，全部文件都返回ByteArrayInputStream */ workbook=new HSSFWorkbook(file.getInputStream()); }else if(originalFilename.endsWith(SUFFIX_2007)){ //不知道为什么这种格式会抛异常 workbook=new XSSFWorkbook(file.getInputStream()); } }catch (Exception e){ e.printStackTrace(); throw new BusinessException(ReturnCode.CODE_FAIL,&quot;格式错误！&quot;); } if(null==workbook){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;格式错误！&quot;); }else{ //获取所有工作表的数量 int numOfSheet=workbook.getNumberOfSheets(); //遍历这些表 for(int i=0;i&lt;numOfSheet;i++){ //获取一个sheet Sheet sheet=workbook.getSheetAt(i); int lastRowNum=sheet.getLastRowNum(); //从第三行开始，第1行一般是标题，第二行是表头 for(int j=2;j&lt;=lastRowNum;j++){ Row row=sheet.getRow(j); Works works=new Works(); //获取序号单元格 if(row.getCell(0)!=null){ row.getCell(0).setCellType(Cell.CELL_TYPE_STRING); //获取单元格内容（将内容当做字符串处理） String code=row.getCell(0).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^\\\\d{1,2}$&quot;,code); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;序号错误！&quot;); } works.setCode(code); } //编号 if(row.getCell(1)!=null){ row.getCell(1).setCellType(Cell.CELL_TYPE_STRING); String bianHao=row.getCell(1).getStringCellValue(); //校验编号长度 boolean matche=Pattern.matches(&quot;^\\\\d{6}$&quot;,bianHao); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;序号错误！&quot;); } works.setBianHao(bianHao); } //名称 if(row.getCell(2)!=null){ row.getCell(2).setCellType(Cell.CELL_TYPE_STRING); String name=row.getCell(2).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5\\\\w\\\\-\\\\——]{1,}$&quot;,name); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;作品名称错误！&quot;); } works.setName(name); } //分赛区 if(row.getCell(3)!=null){ row.getCell(3).setCellType(Cell.CELL_TYPE_STRING); String district=row.getCell(3).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5]{1,}$&quot;,district); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;分赛区名称错误！&quot;); } works.setPartName(district); } //学校 if(row.getCell(4)!=null){ row.getCell(4).setCellType(Cell.CELL_TYPE_STRING); String school=row.getCell(4).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5]{1,}$&quot;,school); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;学校名称错误！&quot;); } works.setSchool(school); } //指导老师 if(row.getCell(5)!=null){ row.getCell(5).setCellType(Cell.CELL_TYPE_STRING); String teachers=row.getCell(5).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5\\\\s,，、]{1,}$&quot;,teachers); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;老师姓名格式错误！&quot;); } works.setTeachers(teachers); } //学生 if(row.getCell(6)!=null){ row.getCell(6).setCellType(Cell.CELL_TYPE_STRING); String students=row.getCell(6).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5\\\\s,，、]{1,}$&quot;,students); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;学生姓名格式错误！&quot;); } works.setStudents(students); } //组别 if(row.getCell(7)!=null){ row.getCell(7).setCellType(Cell.CELL_TYPE_STRING); String model=row.getCell(7).getStringCellValue(); //正则对比 boolean matche=Pattern.matches(&quot;^[\\\\u4E00-\\\\u9FA5]{1,}$&quot;,model); if(!matche){ throw new BusinessException(ReturnCode.CODE_FAIL,&quot;组别格式错误！&quot;); } works.setModel(model); } list.add(works); } } } return list; }","categories":[],"tags":[]},{"title":"","slug":"Ant风格","date":"2019-04-30T08:25:44.553Z","updated":"2019-02-28T06:23:03.321Z","comments":true,"path":"2019/04/30/Ant风格/","link":"","permalink":"http://47.107.237.149/2019/04/30/Ant风格/","excerpt":"","text":"Ant风格，为请求路径的一种匹配方式。 Ant通配符 参考文章 支持Ant风格： Spring资源加载————classpath：com/t?st.xml SpringMvc的url映射————@RequestMapping(“/teach”) Spring注释扫描 &lt;context:component-scan base-package=&quot;org.xxx.**.dao, org.xxx.**.service.impl, org.xx.**.webservice&quot;/&gt;","categories":[],"tags":[]},{"title":"","slug":"alibabaJava开发手册之异常处理","date":"2019-04-30T08:25:44.544Z","updated":"2018-09-26T09:45:28.353Z","comments":true,"path":"2019/04/30/alibabaJava开发手册之异常处理/","link":"","permalink":"http://47.107.237.149/2019/04/30/alibabaJava开发手册之异常处理/","excerpt":"","text":"异常不要用来做流程控制、条件控制，因为异常的处理效率比条件分支低。 //正例 if(obj!=null){ ... } //反例 try{ obj.method() }catch(NullPointException e){ ... } 对大段代码进行try/catch,这是不负责任的表现。请分清稳定代码和非稳定代码。 捕获代码是为了处理它，如果不想处理它，请把该异常抛给它的调用者。最外层的业务处理者，必须处理异常，并将其转化为用户可以理解的内容。 避免直接抛出new RuntimeException(),更不允许抛出Exception或者Throwable，应该用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException、ServiceException等。 避免出现重复的代码（Don’t Repeat Youself),即DRY原则。必要时抽取公共方法，或者抽象公共类，甚至是组件化。","categories":[],"tags":[]},{"title":"","slug":"Ajax","date":"2019-04-30T08:25:44.537Z","updated":"2018-10-13T08:36:16.852Z","comments":true,"path":"2019/04/30/Ajax/","link":"","permalink":"http://47.107.237.149/2019/04/30/Ajax/","excerpt":"","text":"创建一个XMLHttpRequest 对象，用于在后台与服务器交换数据。这意味着可以在不重载的整个网页的 情况下，对网页的某部分进行更新。然后使用该对象的open方法来打开一个Http请求。 open(method,url,async): 规定请求的类型（get或post）、URL与是否异步（一般为true） send(String): 发送请求，String仅用于post请求。 function loadName(){ var xmlHttp; if(window.XMLHttpRequest){ //检查浏览器是否存在XMLHttpRequest对象，它用于在后台与服务器交换数据 xmlHttp=new XMLHttpRequest(); }else{ //IE5|IE6不支持 xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //get，请求方式，中间是URL，文件在服务器上的位置，在web.xml中找到URL为getAjaxName的servlet来处理请求；true，启用异步 xmlHttp.open(&quot;get&quot;, &quot;getAjaxName?name=jack&amp;age=11&quot;, true);//直接加参数 //xmlHttp.open(&quot;post&quot;, &quot;getAjaxName&quot;, true);//不带参数 //xmlHttp.open(&quot;post&quot;, &quot;getAjaxName?name=jack&amp;age=11&quot;, true); xmlHttp.send();//记得要加个send才能把数据发送到后台 } 代码实例：HeadFirstAjaxJsonChap02-&gt;ajax.jsp、onreadystatechange.jsp 注意要使用到json.lib的话就要引入很多个jar包 xmlHttp.open:url栏写法：xmlHttp.open(“get”, “login?action=view&amp;userName=”+userName, true);//带action回去，userName不是一个字符串而是一个字符串对象就不要放引号里面了","categories":[],"tags":[]}]}
{"meta":{"title":"never belief any book","subtitle":"love youself,love life","description":"love youself,love life","author":"Haien","url":"http://47.107.237.149"},"pages":[{"title":"categories","date":"2018-06-03T09:56:30.000Z","updated":"2018-06-03T11:50:01.753Z","comments":true,"path":"categories/index.html","permalink":"http://47.107.237.149/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-03T09:54:24.000Z","updated":"2018-06-03T11:49:23.640Z","comments":false,"path":"tags/index.html","permalink":"http://47.107.237.149/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"@JoinColumn表关联和级联","date":"2019-04-30T08:25:44.432Z","updated":"2018-08-30T11:55:58.819Z","comments":true,"path":"2019/04/30/@JoinColumn表关联和级联/","link":"","permalink":"http://47.107.237.149/2019/04/30/@JoinColumn表关联和级联/","excerpt":"","text":"@JoinColumn简介 注释本表或另一张关联表中指向对方表的外键一对一外键关联 假设Person中有一个外键addressID关联Address表，是一对一关系。我们一般认为主控方是Person,所以@JoinColumn写在Person中。 @OneToOne(cascade=CascadeType.ALL,optional=true) @JoinColumn(name=&quot;addressID&quot;) //注释本表中指向另一张表的外键 public Address getAddress() { } 我们也可以不写@JoinColumn,hibernate会自动在Person表生成关联字段，名称是被控方类名_被控方主键，如address_id主键关联 如果两张表是以主键关联的，比如person表的主键是id，address表的主键是addressId,则运用以下注释 @OneToOne(cascade=CascadeTtype.ALL) @PrimaryKeyJoinColumn(name=&quot;id&quot;,referencedColumnNmae=&quot;addressId&quot;) public Address getAddress() { } 一对多 加入现在有person（多）表和country（一）表，那么一定是person表中有country_id外键 由于我们是一对多的关系，所以站在一的角度，也就是country的角度，在Country的角度，在该类中加入@JoinColumn @OneToMany(cascade=CascadeType.ALL) @JoinColumn(name=&quot;country_id&quot;) //注释另一张表指向本表的外键 public List&lt;Person&gt; getPerson() { } 在一对多单向关系表中，多的一方没有注解，一的一方有注解。最终外键会被加到哪一张表完全由@JoinColumn根据几对几注解来适当分配。如果一的一方不加@JoinColumn指定外键字段的话，hibernate会自动生成一张中间表Country_Person来对Person和Country进行绑定。 自定义中间表的注解（应该是写在哪个类都可以,比如下面写在Person类） @JoinTable(name=&quot;Person_Country&quot;, joinColumns={@JoinColumn(name=&quot;person_id&quot;))}, //指定关联本表id的字段 inverseJoinColumns={@JoinColumn(name=&quot;country_id&quot;)}) //指定关联对方表id的字段 多对一 还是沿用一对多的例子，只是反过来要把注释加到Person类里 @ManyToOne @JoinColumn(name=&quot;country_id&quot;) public Country getCountry() { } 此时如果不用@JoinColumn指定外键的话，会在person表中生成一个指向country的外键而不是中间表。双向关联 前面一对多和多对一的例子一般都是同时配置，因为只配置一或多的一方会导致另一方无法获取对方信息多对多 多对多关系一般都是用中间表维护的，只需要在一个类中注释一张中间表即可，比如现在有person、project表，在Person类中建立person_project表 @ManyToMany(cascade = CascadeType.ALL) @JoinTable(name = &quot;Person_Project&quot;, joinColumns = {@JoinColumn(name = &quot;person_id&quot;)}, inverseJoinColumns = {@JoinColumn(name = &quot;project_id&quot;)}) //关联另一张表 public List&lt;Project&gt; getProjects() { return project; } 级联 举例：学生与学校的一对多关系 //学生类 @Entity @Table(name = &quot;student&quot;) public class Student { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; //在表中建立外键 &quot;school_fk&quot; @ManyToOne @JoinColumn(name=&quot;school_fk&quot;) private School school; } //学校类 @Entity @Table(name = &quot;school&quot;) public class School { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @OneToMany(mappedBy=&quot;shcool&quot;) /* * 设置 ：级联保存/新建操作。 * 那么新建学校和学生的时候，保存新建的学校新建的学生也同时被保存 @Column(cascade={CascadeType.PERSIST}) private List&lt;Student&gt; students; } //级联保存，测试方法 public void testPersistCreateSchool(){ School school = new School(); school.setName(&quot;学校&quot;); Student st1 = new Student(); st1.setName(&quot;学弟&quot;); st1.setSchool(school); //不需要显示保存学生st1 //studnetDAO.save(st1); Student st2 = new Student(); st2.setName(&quot;学长&quot;); st2.setSchool(school); //不需要显示保存学生st2 //studnetDAO.save(st2); //添加学生 school.addStudent(st1); school.addStudent(st2); schoolDAO.save(school);//保存学校，学校内新建的学生也[st1、st2]被保存了 }","categories":[],"tags":[]}]}